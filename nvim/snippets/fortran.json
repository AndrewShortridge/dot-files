{
  "Program Skeleton": {
    "prefix": ["program", "PROGRAM"],
    "body": ["program ${1:name}", "\timplicit none", "\t${0}", "end program ${1:name}"],
    "description": "Program Skeleton"
  },
  "Module Skeleton": {
    "prefix": ["module", "MODULE"],
    "body": [
      "module ${1:name}",
      "\timplicit none",
      "\t${2}",
      "contains",
      "\t${0}",
      "end module ${1:name}"
    ],
    "description": "Create a new module"
  },
  "Submodule": {
    "prefix": ["submodule", "SUBMODULE"],
    "body": [
      "submodule (${1:parent}) ${2:name}",
      "\timplicit none",
      "\t${0}",
      "end submodule ${2:name}"
    ],
    "description": "Create a submodule"
  },
  "Do Loop": {
    "prefix": ["do", "DO"],
    "body": ["do ${1:i} = ${2:1}, ${3:n}", "\t${0}", "end do"],
    "description": "Create a do loop"
  },
  "Do While Loop": {
    "prefix": ["dowhile", "DOWHILE"],
    "body": ["do while (${1:condition})", "\t${0}", "end do"],
    "description": "Create a do while loop"
  },
  "Do Concurrent": {
    "prefix": ["doconcurrent", "DOCONCURRENT"],
    "body": ["do concurrent (${1:i} = ${2:1}:${3:n})", "\t${0}", "end do"],
    "description": "Create a do concurrent loop"
  },
  "Function": {
    "prefix": ["function", "FUNCTION"],
    "body": [
      "function ${1:func}(${2:arg}) result(${3:retval})",
      "\t${4:integer}, intent(in) :: ${2:arg}",
      "\t${5:integer} :: ${3:retval}",
      "",
      "\t${0}",
      "end function ${1:func}"
    ],
    "description": "Create a function"
  },
  "Pure Function": {
    "prefix": ["purefunction", "PUREFUNCTION"],
    "body": [
      "pure function ${1:func}(${2:arg}) result(${3:retval})",
      "\t${4:integer}, intent(in) :: ${2:arg}",
      "\t${5:integer} :: ${3:retval}",
      "",
      "\t${0}",
      "end function ${1:func}"
    ],
    "description": "Create a pure function"
  },
  "Elemental Function": {
    "prefix": ["elemental", "ELEMENTAL"],
    "body": [
      "elemental function ${1:func}(${2:arg}) result(${3:retval})",
      "\t${4:real}, intent(in) :: ${2:arg}",
      "\t${5:real} :: ${3:retval}",
      "",
      "\t${0}",
      "end function ${1:func}"
    ],
    "description": "Create an elemental function"
  },
  "Subroutine": {
    "prefix": ["subroutine", "SUBROUTINE"],
    "body": [
      "subroutine ${1:name}(${2:arg1}, ${3:arg2})",
      "\t${4:type1}, intent(${5:in}) :: ${2:arg1}",
      "\t${6:type2}, intent(${7:out}) :: ${3:arg2}",
      "",
      "\t${0}",
      "end subroutine ${1:name}"
    ],
    "description": "Create a subroutine"
  },
  "Pure Subroutine": {
    "prefix": ["puresub", "PURESUB"],
    "body": [
      "pure subroutine ${1:name}(${2:arg})",
      "\t${3:type}, intent(${4:inout}) :: ${2:arg}",
      "",
      "\t${0}",
      "end subroutine ${1:name}"
    ],
    "description": "Create a pure subroutine"
  },
  "Type Definition": {
    "prefix": ["type", "TYPE"],
    "body": [
      "type :: ${1:type_name}",
      "\t${2:integer} :: ${3:var}",
      "\t${0}",
      "end type ${1:type_name}"
    ],
    "description": "Create a derived type"
  },
  "Type with Procedures": {
    "prefix": ["typeproc", "TYPEPROC"],
    "body": [
      "type, public :: ${1:type_name}",
      "\t${2:integer} :: ${3:var}",
      "contains",
      "\tprocedure :: ${4:method}",
      "\t${0}",
      "end type ${1:type_name}"
    ],
    "description": "Create a type with type-bound procedures"
  },
  "Interface": {
    "prefix": ["interface", "INTERFACE"],
    "body": [
      "interface ${1:name}",
      "\tmodule procedure ${2:proc1}",
      "\t${0}",
      "end interface ${1:name}"
    ],
    "description": "Create an interface block"
  },
  "Abstract Interface": {
    "prefix": ["abstractinterface", "ABSTRACTINTERFACE"],
    "body": [
      "abstract interface",
      "\t${0}",
      "end interface"
    ],
    "description": "Create an abstract interface"
  },
  "If Then": {
    "prefix": ["if", "IF"],
    "body": ["if (${1:condition}) then", "\t${0}", "end if"],
    "description": "if then block"
  },
  "If Then Else": {
    "prefix": ["ifelse", "IFELSE"],
    "body": ["if (${1:condition}) then", "\t${2}", "else", "\t${0}", "end if"],
    "description": "if then else block"
  },
  "Else If": {
    "prefix": ["elseif", "ELSEIF"],
    "body": ["else if (${1:condition}) then", "\t${0}"],
    "description": "else if clause"
  },
  "Select Case": {
    "prefix": ["select", "SELECT", "selectcase"],
    "body": [
      "select case (${1:expr})",
      "case (${2:value})",
      "\t${3}",
      "case default",
      "\t${0}",
      "end select"
    ],
    "description": "select case block"
  },
  "Select Type": {
    "prefix": ["selecttype", "SELECTTYPE"],
    "body": [
      "select type (${1:var})",
      "type is (${2:type})",
      "\t${3}",
      "class default",
      "\t${0}",
      "end select"
    ],
    "description": "select type block"
  },
  "Where": {
    "prefix": ["where", "WHERE"],
    "body": ["where (${1:mask})", "\t${0}", "end where"],
    "description": "where construct"
  },
  "Forall": {
    "prefix": ["forall", "FORALL"],
    "body": ["forall (${1:i} = ${2:1}:${3:n})", "\t${0}", "end forall"],
    "description": "forall construct"
  },
  "Block": {
    "prefix": ["block", "BLOCK"],
    "body": ["block", "\t${0}", "end block"],
    "description": "block construct"
  },
  "Associate": {
    "prefix": ["associate", "ASSOCIATE"],
    "body": ["associate (${1:alias} => ${2:expr})", "\t${0}", "end associate"],
    "description": "associate construct"
  },
  "Allocate": {
    "prefix": ["allocate", "ALLOCATE"],
    "body": [
      "allocate(${1:array}(${2:n}), stat=${3:ierr})",
      "if (${3:ierr} /= 0) error stop 'Allocation failed'"
    ],
    "description": "allocate with error check"
  },
  "Deallocate": {
    "prefix": ["deallocate", "DEALLOCATE"],
    "body": [
      "if (allocated(${1:array})) deallocate(${1:array})"
    ],
    "description": "deallocate with check"
  },
  "Implicit None": {
    "prefix": ["implicit", "IMPLICIT"],
    "body": ["implicit none"],
    "description": "implicit none"
  },
  "Use Module": {
    "prefix": ["use", "USE"],
    "body": ["use ${1:module_name}, only: ${0}"],
    "description": "use module with only clause"
  },
  "Use ISO_C_BINDING": {
    "prefix": ["useiso", "isoc"],
    "body": ["use, intrinsic :: iso_c_binding, only: ${0:c_int, c_double, c_ptr}"],
    "description": "use iso_c_binding"
  },
  "Use ISO_FORTRAN_ENV": {
    "prefix": ["usefortranenv", "isofortran"],
    "body": ["use, intrinsic :: iso_fortran_env, only: ${0:real64, int32, stderr => error_unit}"],
    "description": "use iso_fortran_env"
  },
  "Intent In": {
    "prefix": ["intentin", "INTENTIN"],
    "body": ["${1:type}, intent(in) :: ${0:var}"],
    "description": "intent(in) declaration"
  },
  "Intent Out": {
    "prefix": ["intentout", "INTENTOUT"],
    "body": ["${1:type}, intent(out) :: ${0:var}"],
    "description": "intent(out) declaration"
  },
  "Intent InOut": {
    "prefix": ["intentinout", "INTENTINOUT"],
    "body": ["${1:type}, intent(inout) :: ${0:var}"],
    "description": "intent(inout) declaration"
  },
  "Real Declaration": {
    "prefix": ["real", "REAL"],
    "body": ["real(${1:real64}) :: ${0:var}"],
    "description": "real variable declaration"
  },
  "Integer Declaration": {
    "prefix": ["integer", "INTEGER"],
    "body": ["integer(${1:int32}) :: ${0:var}"],
    "description": "integer variable declaration"
  },
  "Character Declaration": {
    "prefix": ["character", "CHARACTER"],
    "body": ["character(len=${1:*}) :: ${0:var}"],
    "description": "character variable declaration"
  },
  "Logical Declaration": {
    "prefix": ["logical", "LOGICAL"],
    "body": ["logical :: ${0:var}"],
    "description": "logical variable declaration"
  },
  "Array Declaration": {
    "prefix": ["array", "ARRAY"],
    "body": ["${1:real}(${2:real64}), dimension(${3::}), allocatable :: ${0:arr}"],
    "description": "allocatable array declaration"
  },
  "Open File": {
    "prefix": ["open", "OPEN"],
    "body": [
      "open(newunit=${1:unit}, file='${2:filename}', status='${3:unknown}', &",
      "     action='${4:readwrite}', iostat=${5:ierr})",
      "if (${5:ierr} /= 0) error stop 'Failed to open file'"
    ],
    "description": "open file with error check"
  },
  "Close File": {
    "prefix": ["close", "CLOSE"],
    "body": ["close(${1:unit})"],
    "description": "close file"
  },
  "Read": {
    "prefix": ["read", "READ"],
    "body": ["read(${1:unit}, ${2:*}) ${0:var}"],
    "description": "read statement"
  },
  "Write": {
    "prefix": ["write", "WRITE"],
    "body": ["write(${1:*}, ${2:*}) ${0:var}"],
    "description": "write statement"
  },
  "Print": {
    "prefix": ["print", "PRINT"],
    "body": ["print '(${1:A})', ${0:var}"],
    "description": "print with format"
  },
  "Error Stop": {
    "prefix": ["errorstop", "ERRORSTOP"],
    "body": ["error stop '${0:message}'"],
    "description": "error stop with message"
  },
  "Contains": {
    "prefix": ["contains", "CONTAINS"],
    "body": ["contains", "", "${0}"],
    "description": "contains statement"
  },
  "Private": {
    "prefix": ["private", "PRIVATE"],
    "body": ["private"],
    "description": "private statement"
  },
  "Public": {
    "prefix": ["public", "PUBLIC"],
    "body": ["public :: ${0}"],
    "description": "public statement"
  },
  "Module Documentation Header": {
    "prefix": ["modoc", "MODOC"],
    "body": [
      "!------------------------------------------------------------------------------",
      "! ${1:Institution}",
      "!------------------------------------------------------------------------------",
      "!",
      "! MODULE: ${2:module_name}",
      "!",
      "!> @author ${3:Author Name}",
      "!",
      "!> @brief ${4:Short description}",
      "!",
      "! REVISION HISTORY:",
      "! ${5:date} - Initial Version",
      "!------------------------------------------------------------------------------"
    ],
    "description": "Module documentation header"
  }
}
