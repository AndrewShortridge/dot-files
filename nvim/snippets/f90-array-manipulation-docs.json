{
  "cshift": "## cshift\n\n### **Name**\n\n**cshift** - \\[ARRAY:MANIPULATION\\] Perform circular shift of array elements\n\n### **Synopsis**\n```fortran\n    result = cshift(array, shift [, dim])\n```\n```fortran\n     function cshift(array, shift, dim) result(res)\n\n      type(any_type), intent(in) :: array(..)\n      integer, intent(in)        :: shift\n      integer, intent(in), optional :: dim\n      type(same_as_array)        :: res(same_shape_as_array)\n```\n\n### **Characteristics**\n\n - **array** can be any array of any intrinsic or derived type with any rank.\n - **shift** must be of type integer. If **array** has rank one, **shift** must be a scalar. If **array** has rank greater than one, **shift** can be a scalar or an array of rank n-1 conformable with the shape of **array** with dimension **dim** removed.\n - **dim** must be a scalar integer with a value in the range 1 <= dim <= n, where n is the rank of **array**. If absent, it defaults to 1.\n - The result has the same type, type parameters, and shape as **array**.\n\n### **Description**\n\n **cshift** performs a circular shift on elements of **array** along the dimension\n specified by **dim**. Elements shifted out one end of each rank-one section are\n shifted back in at the other end. A positive **shift** causes a shift to the left\n (toward lower indices), while a negative **shift** causes a shift to the right\n (toward higher indices). A zero **shift** leaves the array unchanged.\n\n If **array** has rank one, then all elements are shifted by **shift** places.\n If **array** has rank greater than one, each complete rank-one section along\n dimension **dim** is shifted independently.\n\n### **Options**\n\n- **array**\n  : The array to be shifted. It can be of any intrinsic or derived type and\n  any rank from 1 to 15.\n\n- **shift**\n  : The number of positions to shift. Positive values shift toward lower\n  indices (left for rows, up for columns). Negative values shift toward\n  higher indices (right for rows, down for columns). For multi-dimensional\n  arrays, **shift** can be an array specifying different shift amounts for\n  different sections.\n\n- **dim**\n  : (Optional) The dimension along which to shift. Must be a positive integer\n  not exceeding the rank of **array**. Default is 1.\n\n### **Result**\n\n The result is an array with the same shape, type, and type parameters as\n **array**. Each rank-one section along dimension **dim** contains the elements\n of the corresponding section of **array**, circularly shifted by the\n corresponding element of **shift**.\n\n### **Examples**\n\n Sample program:\n\n```fortran\nprogram demo_cshift\n  implicit none\n  integer :: i\n  integer :: v(6)\n  integer :: a(3, 4)\n\n  ! One-dimensional circular shift\n  v = [1, 2, 3, 4, 5, 6]\n  print '(a,6i3)', 'Original:     ', v\n  print '(a,6i3)', 'Shift left 2: ', cshift(v, shift=2)\n  print '(a,6i3)', 'Shift right 2:', cshift(v, shift=-2)\n\n  ! Two-dimensional array\n  a = reshape([(i, i=1,12)], [3, 4])\n  print *\n  print '(a)', 'Original 3x4 array:'\n  do i = 1, 3\n    print '(4i4)', a(i, :)\n  end do\n\n  ! Shift along dimension 1 (columns shift down/up)\n  print *\n  print '(a)', 'After cshift(a, shift=1, dim=1):'\n  do i = 1, 3\n    print '(4i4)', cshift(a, shift=1, dim=1)(i, :)\n  end do\n\n  ! Shift along dimension 2 (rows shift left/right)\n  print *\n  print '(a)', 'After cshift(a, shift=1, dim=2):'\n  do i = 1, 3\n    print '(4i4)', cshift(a, shift=1, dim=2)(i, :)\n  end do\n\n  ! Different shifts for each row\n  print *\n  print '(a)', 'After cshift(a, shift=[1,2,3], dim=2):'\n  do i = 1, 3\n    print '(4i4)', cshift(a, shift=[1, 2, 3], dim=2)(i, :)\n  end do\n\nend program demo_cshift\n```\n\n Results:\n\n```text\nOriginal:       1  2  3  4  5  6\nShift left 2:   3  4  5  6  1  2\nShift right 2:  5  6  1  2  3  4\n\nOriginal 3x4 array:\n   1   4   7  10\n   2   5   8  11\n   3   6   9  12\n\nAfter cshift(a, shift=1, dim=1):\n   2   5   8  11\n   3   6   9  12\n   1   4   7  10\n\nAfter cshift(a, shift=1, dim=2):\n   4   7  10   1\n   5   8  11   2\n   6   9  12   3\n\nAfter cshift(a, shift=[1,2,3], dim=2):\n   4   7  10   1\n   8  11   2   5\n  12   3   6   9\n```\n\n### **Standard**\n\n Fortran 90\n\n### **See Also**\n\n - [**eoshift**](#eoshift) - End-off shift elements of an array\n - [**transpose**](#transpose) - Transpose a rank-two array\n - [**reshape**](#reshape) - Reshape an array",

  "eoshift": "## eoshift\n\n### **Name**\n\n**eoshift** - \\[ARRAY:MANIPULATION\\] Perform end-off shift of array elements\n\n### **Synopsis**\n```fortran\n    result = eoshift(array, shift [, boundary] [, dim])\n```\n```fortran\n     function eoshift(array, shift, boundary, dim) result(res)\n\n      type(any_type), intent(in) :: array(..)\n      integer, intent(in)        :: shift\n      type(same_as_array), intent(in), optional :: boundary\n      integer, intent(in), optional :: dim\n      type(same_as_array)        :: res(same_shape_as_array)\n```\n\n### **Characteristics**\n\n - **array** can be any array of any intrinsic or derived type with any rank.\n - **shift** must be of type integer. If **array** has rank one, **shift** must be a scalar. If **array** has rank greater than one, **shift** can be a scalar or an array of rank n-1.\n - **boundary** must have the same type and type parameters as **array**. It can be a scalar or an array of rank n-1. If absent, default values are used.\n - **dim** must be a scalar integer with a value in the range 1 <= dim <= n. If absent, defaults to 1.\n - The result has the same type, type parameters, and shape as **array**.\n\n### **Description**\n\n **eoshift** performs an end-off shift on elements of **array** along the dimension\n specified by **dim**. Elements shifted out one end are lost, and vacated positions\n are filled with values from **boundary** (or a default value if **boundary** is\n absent). A positive **shift** shifts toward lower indices (left), and a negative\n **shift** shifts toward higher indices (right).\n\n Unlike **cshift**, elements shifted out are discarded rather than wrapped around.\n\n### **Options**\n\n- **array**\n  : The array to be shifted. It can be of any intrinsic or derived type.\n\n- **shift**\n  : The number of positions to shift. Positive values shift toward lower\n  indices, negative values shift toward higher indices. Can be an array\n  for multi-dimensional shifting.\n\n- **boundary**\n  : (Optional) The value used to fill vacated positions. Must have the same\n  type as **array**. If absent, the following defaults are used:\n  - INTEGER: 0\n  - REAL: 0.0\n  - COMPLEX: (0.0, 0.0)\n  - LOGICAL: .false.\n  - CHARACTER: blanks\n\n- **dim**\n  : (Optional) The dimension along which to shift. Must be a positive integer\n  not exceeding the rank of **array**. Default is 1.\n\n### **Result**\n\n The result is an array with the same shape, type, and type parameters as\n **array**. Each rank-one section along dimension **dim** contains the elements\n shifted by the specified amount, with vacated positions filled by **boundary**\n values.\n\n### **Examples**\n\n Sample program:\n\n```fortran\nprogram demo_eoshift\n  implicit none\n  integer :: i\n  integer :: v(6)\n  integer :: a(3, 4)\n  character(len=3) :: c(4)\n\n  ! One-dimensional end-off shift\n  v = [1, 2, 3, 4, 5, 6]\n  print '(a,6i3)', 'Original:        ', v\n  print '(a,6i3)', 'Shift left 2:    ', eoshift(v, shift=2)\n  print '(a,6i3)', 'Shift right 2:   ', eoshift(v, shift=-2)\n  print '(a,6i3)', 'With boundary=9: ', eoshift(v, shift=2, boundary=9)\n\n  ! Character array shift\n  c = ['abc', 'def', 'ghi', 'jkl']\n  print *\n  print '(a,4(a4))', 'Char original: ', c\n  print '(a,4(a4))', 'Char shifted:  ', eoshift(c, shift=1)\n\n  ! Two-dimensional array\n  a = reshape([(i, i=1,12)], [3, 4])\n  print *\n  print '(a)', 'Original 3x4 array:'\n  do i = 1, 3\n    print '(4i4)', a(i, :)\n  end do\n\n  ! Shift along dimension 1 with default boundary (0)\n  print *\n  print '(a)', 'After eoshift(a, shift=1, dim=1):'\n  do i = 1, 3\n    print '(4i4)', eoshift(a, shift=1, dim=1)(i, :)\n  end do\n\n  ! Shift along dimension 2 with custom boundary\n  print *\n  print '(a)', 'After eoshift(a, shift=2, boundary=-1, dim=2):'\n  do i = 1, 3\n    print '(4i4)', eoshift(a, shift=2, boundary=-1, dim=2)(i, :)\n  end do\n\nend program demo_eoshift\n```\n\n Results:\n\n```text\nOriginal:         1  2  3  4  5  6\nShift left 2:     3  4  5  6  0  0\nShift right 2:    0  0  1  2  3  4\nWith boundary=9:  3  4  5  6  9  9\n\nChar original:  abc def ghi jkl\nChar shifted:   def ghi jkl    \n\nOriginal 3x4 array:\n   1   4   7  10\n   2   5   8  11\n   3   6   9  12\n\nAfter eoshift(a, shift=1, dim=1):\n   2   5   8  11\n   3   6   9  12\n   0   0   0   0\n\nAfter eoshift(a, shift=2, boundary=-1, dim=2):\n   7  10  -1  -1\n   8  11  -1  -1\n   9  12  -1  -1\n```\n\n### **Standard**\n\n Fortran 90\n\n### **See Also**\n\n - [**cshift**](#cshift) - Circular shift elements of an array\n - [**transpose**](#transpose) - Transpose a rank-two array\n - [**reshape**](#reshape) - Reshape an array",

  "merge": "## merge\n\n### **Name**\n\n**merge** - \\[ARRAY:MANIPULATION\\] Merge two arrays under mask control\n\n### **Synopsis**\n```fortran\n    result = merge(tsource, fsource, mask)\n```\n```fortran\n     elemental function merge(tsource, fsource, mask) result(res)\n\n      type(any_type), intent(in) :: tsource\n      type(same_as_tsource), intent(in) :: fsource\n      logical, intent(in) :: mask\n      type(same_as_tsource) :: res\n```\n\n### **Characteristics**\n\n - **tsource** can be of any type (intrinsic or derived).\n - **fsource** must have the same type and type parameters as **tsource**.\n - **mask** must be of type logical.\n - All three arguments must be conformable (same shape or scalar).\n - The result has the same type and type parameters as **tsource**.\n - This is an elemental function operating element-by-element.\n\n### **Description**\n\n **merge** selects values from two sources based on a logical mask. Where **mask**\n is .true., the result comes from **tsource** (\"true source\"); where **mask** is\n .false., the result comes from **fsource** (\"false source\"). This provides a\n compact way to perform conditional selection without explicit loops or\n if-then-else constructs.\n\n The function is elemental, meaning it operates element-by-element when given\n array arguments, making it highly efficient for array operations.\n\n### **Options**\n\n- **tsource**\n  : The value(s) to use where **mask** is .true. Can be any intrinsic or\n  derived type. May be a scalar or array.\n\n- **fsource**\n  : The value(s) to use where **mask** is .false. Must have the same type\n  and type parameters as **tsource**. May be a scalar or array.\n\n- **mask**\n  : A logical value or array that determines the selection. Where .true.,\n  **tsource** is selected; where .false., **fsource** is selected.\n\n### **Result**\n\n The result has the same type, type parameters, and shape as **tsource** and\n **fsource** (after broadcasting). Element (i,j,...) of the result equals\n tsource(i,j,...) if mask(i,j,...) is .true., and fsource(i,j,...) otherwise.\n\n### **Examples**\n\n Sample program:\n\n```fortran\nprogram demo_merge\n  implicit none\n  integer :: i\n  integer :: a(5), b(5), c(5)\n  real :: x(4), y(4)\n  logical :: mask(5)\n\n  ! Basic scalar merge\n  print *, 'Scalar merge:'\n  print *, 'merge(10, 20, .true.)  = ', merge(10, 20, .true.)\n  print *, 'merge(10, 20, .false.) = ', merge(10, 20, .false.)\n\n  ! Array merge with mask\n  a = [1, 2, 3, 4, 5]\n  b = [10, 20, 30, 40, 50]\n  mask = [.true., .false., .true., .false., .true.]\n\n  c = merge(a, b, mask)\n  print *\n  print '(a,5i4)', 'Array a:    ', a\n  print '(a,5i4)', 'Array b:    ', b\n  print '(a,5l4)', 'Mask:       ', mask\n  print '(a,5i4)', 'merge(a,b): ', c\n\n  ! Using expression as mask - select positive values\n  x = [-1.5, 2.0, -3.5, 4.0]\n  y = merge(x, 0.0, x > 0.0)\n  print *\n  print '(a,4f6.1)', 'Original x:          ', x\n  print '(a,4f6.1)', 'Positive only:       ', y\n\n  ! Clamp values to range [0, 10]\n  a = [-5, 3, 15, 7, 12]\n  c = merge(0, a, a < 0)       ! Replace negatives with 0\n  c = merge(10, c, c > 10)     ! Replace values > 10 with 10\n  print *\n  print '(a,5i4)', 'Before clamp:', a\n  print '(a,5i4)', 'After clamp: ', c\n\n  ! Absolute value using merge\n  a = [-3, 2, -5, 4, -1]\n  c = merge(-a, a, a < 0)\n  print *\n  print '(a,5i4)', 'Values:   ', a\n  print '(a,5i4)', 'Absolute: ', c\n\nend program demo_merge\n```\n\n Results:\n\n```text\n Scalar merge:\n merge(10, 20, .true.)  =           10\n merge(10, 20, .false.) =           20\n\nArray a:       1   2   3   4   5\nArray b:      10  20  30  40  50\nMask:          T   F   T   F   T\nmerge(a,b):    1  20   3  40   5\n\nOriginal x:            -1.5   2.0  -3.5   4.0\nPositive only:          0.0   2.0   0.0   4.0\n\nBefore clamp:  -5   3  15   7  12\nAfter clamp:    0   3  10   7  10\n\nValues:       -3   2  -5   4  -1\nAbsolute:      3   2   5   4   1\n```\n\n### **Standard**\n\n Fortran 90\n\n### **See Also**\n\n - [**pack**](#pack) - Pack array elements into a vector under mask control\n - [**unpack**](#unpack) - Unpack a vector into an array under mask control\n - [**where**](#where) - Masked array assignment construct",

  "pack": "## pack\n\n### **Name**\n\n**pack** - \\[ARRAY:MANIPULATION\\] Pack array elements into a rank-one array under mask control\n\n### **Synopsis**\n```fortran\n    result = pack(array, mask [, vector])\n```\n```fortran\n     function pack(array, mask, vector) result(res)\n\n      type(any_type), intent(in) :: array(..)\n      logical, intent(in)        :: mask(..)\n      type(same_as_array), intent(in), optional :: vector(:)\n      type(same_as_array)        :: res(:)\n```\n\n### **Characteristics**\n\n - **array** can be any array of any intrinsic or derived type.\n - **mask** must be of type logical and conformable with **array** (same shape or scalar).\n - **vector** must be a rank-one array of the same type and type parameters as **array**. If present, its size must be at least the number of .true. elements in **mask**.\n - The result is a rank-one array of the same type and type parameters as **array**.\n\n### **Description**\n\n **pack** gathers elements of **array** into a rank-one (vector) result based on\n a logical **mask**. Elements corresponding to .true. values in **mask** are\n collected in array element order (column-major for multi-dimensional arrays).\n\n If **vector** is present, it determines the size of the result, with elements\n beyond those selected by **mask** filled from **vector**.\n\n### **Options**\n\n- **array**\n  : The source array from which elements are selected. Can be of any type\n  and any rank.\n\n- **mask**\n  : A logical array conformable with **array**, or a scalar logical.\n  Elements of **array** are selected where **mask** is .true.\n  If **mask** is scalar .true., all elements are selected.\n\n- **vector**\n  : (Optional) A rank-one array of the same type as **array** that determines\n  the size of the result. Elements beyond those selected by **mask** are\n  taken from **vector**. Its size must be >= count(mask).\n\n### **Result**\n\n If **vector** is absent, the result is a rank-one array containing the\n elements of **array** corresponding to .true. elements of **mask**, in\n array element order. The size equals count(mask).\n\n If **vector** is present, the result has the same size as **vector**.\n The first count(mask) elements come from **array** (where mask is .true.),\n and the remaining elements come from the corresponding positions in **vector**.\n\n### **Examples**\n\n Sample program:\n\n```fortran\nprogram demo_pack\n  implicit none\n  integer :: i\n  integer :: a(6), b(2, 3)\n  integer, allocatable :: packed(:)\n  logical :: mask(6)\n  real :: values(5), positives(5)\n\n  ! Pack elements matching a condition\n  a = [1, 0, 3, 0, 5, 0]\n  packed = pack(a, a /= 0)\n  print '(a,6i3)',   'Original array:  ', a\n  print '(a,*(i3))', 'Packed nonzeros: ', packed\n\n  ! Pack with explicit mask\n  mask = [.true., .false., .true., .false., .true., .false.]\n  packed = pack(a, mask)\n  print *\n  print '(a,6l3)', 'Mask:            ', mask\n  print '(a,*(i3))', 'Packed by mask:  ', packed\n\n  ! Pack from 2D array (column-major order)\n  b = reshape([1, 2, 3, 4, 5, 6], [2, 3])\n  print *\n  print '(a)', '2D array (2x3):'\n  do i = 1, 2\n    print '(3i4)', b(i, :)\n  end do\n  packed = pack(b, b > 2)\n  print '(a,*(i3))', 'Elements > 2:    ', packed\n\n  ! Using vector argument for fixed-size result\n  a = [10, 0, 30, 0, 50, 0]\n  packed = pack(a, a /= 0, vector=[0, 0, 0, 0, 0])\n  print *\n  print '(a,6i4)', 'Array:               ', a\n  print '(a,5i4)', 'With vector fill:    ', packed\n\n  ! Pack all elements (scalar mask .true.)\n  packed = pack(a, .true.)\n  print '(a,*(i4))', 'Pack all:            ', packed\n\n  ! Practical: gather positive values\n  values = [-1.0, 2.5, -3.0, 4.5, 0.0]\n  print *\n  print '(a,5f6.1)', 'Values:     ', values\n  print '(a,*(f6.1))', 'Positives:  ', pack(values, values > 0.0)\n\nend program demo_pack\n```\n\n Results:\n\n```text\nOriginal array:     1  0  3  0  5  0\nPacked nonzeros:    1  3  5\n\nMask:              T  F  T  F  T  F\nPacked by mask:     1  3  5\n\n2D array (2x3):\n   1   3   5\n   2   4   6\nElements > 2:       3  4  5  6\n\nArray:                10   0  30   0  50   0\nWith vector fill:     10  30  50   0   0\nPack all:              10   0  30   0  50   0\n\nValues:        -1.0   2.5  -3.0   4.5   0.0\nPositives:        2.5   4.5\n```\n\n### **Standard**\n\n Fortran 90\n\n### **See Also**\n\n - [**unpack**](#unpack) - Unpack a vector into an array under mask control\n - [**merge**](#merge) - Merge two arrays under mask control\n - [**spread**](#spread) - Replicate an array by adding a dimension",

  "reshape": "## reshape\n\n### **Name**\n\n**reshape** - \\[ARRAY:MANIPULATION\\] Construct an array with a specified shape from source elements\n\n### **Synopsis**\n```fortran\n    result = reshape(source, shape [, pad] [, order])\n```\n```fortran\n     function reshape(source, shape, pad, order) result(res)\n\n      type(any_type), intent(in) :: source(..)\n      integer, intent(in)        :: shape(:)\n      type(same_as_source), intent(in), optional :: pad(..)\n      integer, intent(in), optional :: order(:)\n      type(same_as_source)       :: res(shape(1), shape(2), ...)\n```\n\n### **Characteristics**\n\n - **source** can be any array of any intrinsic or derived type.\n - **shape** must be a rank-one integer array with size <= 15 and all positive values.\n - **pad** must have the same type and type parameters as **source**.\n - **order** must be a rank-one integer array with the same size as **shape**, containing a permutation of (1, 2, ..., n).\n - The result has the type and type parameters of **source** and shape specified by **shape**.\n\n### **Description**\n\n **reshape** constructs an array with a different shape from an existing array.\n Elements from **source** are placed into the result in array element order\n (column-major, unless modified by **order**). If **source** does not have\n enough elements, **pad** provides additional elements.\n\n This is one of the most versatile array manipulation functions, enabling\n conversion between different array dimensions and layouts.\n\n### **Options**\n\n- **source**\n  : The array supplying elements for the result. Its size must be >=\n  product(shape) if **pad** is absent or has size zero.\n\n- **shape**\n  : A rank-one integer array defining the shape of the result. The product\n  of shape values determines the total number of elements. Maximum rank is 15.\n\n- **pad**\n  : (Optional) An array of the same type as **source** used to fill the\n  result if **source** has insufficient elements. Elements are used\n  repeatedly if necessary.\n\n- **order**\n  : (Optional) A permutation of (1, 2, ..., n) specifying the order in\n  which dimensions are filled. Default is (1, 2, ..., n), meaning\n  column-major order. With order=[2,1], elements fill row-major.\n\n### **Result**\n\n The result is an array of shape **shape** with the same type as **source**.\n Elements are taken from **source** in array element order, followed by\n elements from **pad** (repeated as necessary) if more elements are needed.\n The **order** argument can change the dimension fill order.\n\n### **Examples**\n\n Sample program:\n\n```fortran\nprogram demo_reshape\n  implicit none\n  integer :: i\n  integer :: v(6), a(2, 3), b(3, 2), c(2, 4)\n  integer :: d(3, 3)\n\n  ! Basic reshape: vector to 2x3 matrix\n  v = [1, 2, 3, 4, 5, 6]\n  a = reshape(v, [2, 3])\n  print '(a)', 'Vector to 2x3 (column-major):'\n  do i = 1, 2\n    print '(3i4)', a(i, :)\n  end do\n\n  ! Reshape to different dimensions\n  b = reshape(v, [3, 2])\n  print *\n  print '(a)', 'Vector to 3x2 (column-major):'\n  do i = 1, 3\n    print '(2i4)', b(i, :)\n  end do\n\n  ! Using order for row-major layout\n  a = reshape(v, [2, 3], order=[2, 1])\n  print *\n  print '(a)', 'Vector to 2x3 (row-major via order=[2,1]):'\n  do i = 1, 2\n    print '(3i4)', a(i, :)\n  end do\n\n  ! Using pad when source is too small\n  c = reshape(v, [2, 4], pad=[0, 0])\n  print *\n  print '(a)', '6 elements to 2x4 with pad=0:'\n  do i = 1, 2\n    print '(4i4)', c(i, :)\n  end do\n\n  ! Create identity-like matrix using reshape and pad\n  d = reshape([1, 0, 0, 0, 1, 0, 0, 0, 1], [3, 3])\n  print *\n  print '(a)', '3x3 identity matrix:'\n  do i = 1, 3\n    print '(3i4)', d(i, :)\n  end do\n\n  ! Flatten a 2D array to 1D\n  print *\n  print '(a,6i3)', 'Flattened 2x3 array: ', reshape(a, [6])\n\n  ! Transpose-like operation using reshape + order\n  a = reshape([1, 2, 3, 4, 5, 6], [2, 3])\n  b = reshape(a, [3, 2], order=[2, 1])\n  print *\n  print '(a)', 'Original 2x3:'\n  do i = 1, 2\n    print '(3i4)', a(i, :)\n  end do\n  print '(a)', 'Reshaped to 3x2 with order=[2,1]:'\n  do i = 1, 3\n    print '(2i4)', b(i, :)\n  end do\n\nend program demo_reshape\n```\n\n Results:\n\n```text\nVector to 2x3 (column-major):\n   1   3   5\n   2   4   6\n\nVector to 3x2 (column-major):\n   1   4\n   2   5\n   3   6\n\nVector to 2x3 (row-major via order=[2,1]):\n   1   2   3\n   4   5   6\n\n6 elements to 2x4 with pad=0:\n   1   3   5   0\n   2   4   6   0\n\n3x3 identity matrix:\n   1   0   0\n   0   1   0\n   0   0   1\n\nFlattened 2x3 array:   1  4  2  5  3  6\n\nOriginal 2x3:\n   1   3   5\n   2   4   6\nReshaped to 3x2 with order=[2,1]:\n   1   2\n   3   4\n   5   6\n```\n\n### **Standard**\n\n Fortran 90\n\n### **See Also**\n\n - [**shape**](#shape) - Get the shape of an array\n - [**size**](#size) - Get the total size or extent of an array\n - [**transpose**](#transpose) - Transpose a rank-two array\n - [**spread**](#spread) - Replicate an array by adding a dimension",

  "spread": "## spread\n\n### **Name**\n\n**spread** - \\[ARRAY:MANIPULATION\\] Replicate an array by adding a dimension\n\n### **Synopsis**\n```fortran\n    result = spread(source, dim, ncopies)\n```\n```fortran\n     function spread(source, dim, ncopies) result(res)\n\n      type(any_type), intent(in) :: source(..)\n      integer, intent(in)        :: dim\n      integer, intent(in)        :: ncopies\n      type(same_as_source)       :: res(..)\n```\n\n### **Characteristics**\n\n - **source** can be a scalar or array of any intrinsic or derived type with rank < 15.\n - **dim** must be a scalar integer with value in range 1 <= dim <= n+1, where n is the rank of **source**.\n - **ncopies** must be a scalar integer specifying the extent of the new dimension.\n - The result has rank n+1 (one more than **source**) and the same type as **source**.\n\n### **Description**\n\n **spread** replicates **source** by adding a new dimension at position **dim**\n with extent **ncopies**. Each element along the new dimension contains a copy\n of **source**. This is useful for broadcasting operations where you need to\n expand an array to match another array's shape.\n\n For a scalar **source**, the result is a rank-one array of **ncopies** copies.\n For an array **source** of rank n, the result has rank n+1 with the new\n dimension inserted at position **dim**.\n\n### **Options**\n\n- **source**\n  : The scalar or array to replicate. Can be of any type. Maximum rank is 14\n  (since result has rank n+1 and maximum rank is 15).\n\n- **dim**\n  : The position for the new dimension in the result. Must satisfy\n  1 <= dim <= rank(source) + 1. DIM=1 inserts at the front, DIM=n+1 at the end.\n\n- **ncopies**\n  : The number of copies (extent of the new dimension). If ncopies <= 0,\n  the result has zero size along that dimension.\n\n### **Result**\n\n The result has rank n+1 where n is the rank of **source**. The shape is\n the shape of **source** with **ncopies** inserted at position **dim**.\n Each section along dimension **dim** is a copy of **source**.\n\n### **Examples**\n\n Sample program:\n\n```fortran\nprogram demo_spread\n  implicit none\n  integer :: i\n  integer :: a, v(3), m(2, 3)\n  integer :: spread_scalar(4), spread_v1(4, 3), spread_v2(3, 4)\n  integer :: spread_m(2, 3, 2)\n\n  ! Spread a scalar to create a vector\n  a = 5\n  spread_scalar = spread(a, dim=1, ncopies=4)\n  print '(a,4i3)', 'Spread scalar 5, ncopies=4: ', spread_scalar\n\n  ! Spread a vector along dim=1 (add rows)\n  v = [1, 2, 3]\n  spread_v1 = spread(v, dim=1, ncopies=4)\n  print *\n  print '(a)', 'Spread vector [1,2,3] along dim=1, ncopies=4:'\n  print '(a)', '(Result is 4x3 - vector becomes columns, repeated 4 times)'\n  do i = 1, 4\n    print '(3i4)', spread_v1(i, :)\n  end do\n\n  ! Spread a vector along dim=2 (add columns)\n  spread_v2 = spread(v, dim=2, ncopies=4)\n  print *\n  print '(a)', 'Spread vector [1,2,3] along dim=2, ncopies=4:'\n  print '(a)', '(Result is 3x4 - vector becomes rows, repeated 4 times)'\n  do i = 1, 3\n    print '(4i4)', spread_v2(i, :)\n  end do\n\n  ! Spread a 2D array along dim=3\n  m = reshape([1, 2, 3, 4, 5, 6], [2, 3])\n  print *\n  print '(a)', 'Original 2x3 matrix:'\n  do i = 1, 2\n    print '(3i4)', m(i, :)\n  end do\n\n  spread_m = spread(m, dim=3, ncopies=2)\n  print *\n  print '(a)', 'Spread matrix along dim=3, ncopies=2:'\n  print '(a)', 'Layer 1:'\n  do i = 1, 2\n    print '(3i4)', spread_m(i, :, 1)\n  end do\n  print '(a)', 'Layer 2:'\n  do i = 1, 2\n    print '(3i4)', spread_m(i, :, 2)\n  end do\n\n  ! Practical use: outer product via spread\n  print *\n  print '(a)', 'Outer product of [1,2,3] and [10,20] using spread:'\n  v = [1, 2, 3]\n  m(1:3, 1:2) = spread(v, dim=2, ncopies=2) * spread([10, 20], dim=1, ncopies=3)\n  do i = 1, 3\n    print '(2i6)', m(i, 1:2)\n  end do\n\nend program demo_spread\n```\n\n Results:\n\n```text\nSpread scalar 5, ncopies=4:   5  5  5  5\n\nSpread vector [1,2,3] along dim=1, ncopies=4:\n(Result is 4x3 - vector becomes columns, repeated 4 times)\n   1   2   3\n   1   2   3\n   1   2   3\n   1   2   3\n\nSpread vector [1,2,3] along dim=2, ncopies=4:\n(Result is 3x4 - vector becomes rows, repeated 4 times)\n   1   1   1   1\n   2   2   2   2\n   3   3   3   3\n\nOriginal 2x3 matrix:\n   1   3   5\n   2   4   6\n\nSpread matrix along dim=3, ncopies=2:\nLayer 1:\n   1   3   5\n   2   4   6\nLayer 2:\n   1   3   5\n   2   4   6\n\nOuter product of [1,2,3] and [10,20] using spread:\n    10    20\n    20    40\n    30    60\n```\n\n### **Standard**\n\n Fortran 90\n\n### **See Also**\n\n - [**reshape**](#reshape) - Construct an array with a specified shape\n - [**pack**](#pack) - Pack array elements into a rank-one array\n - [**unpack**](#unpack) - Unpack a vector into an array\n - [**merge**](#merge) - Merge two arrays under mask control",

  "transpose": "## transpose\n\n### **Name**\n\n**transpose** - \\[ARRAY:MANIPULATION\\] Transpose a rank-two array\n\n### **Synopsis**\n```fortran\n    result = transpose(matrix)\n```\n```fortran\n     function transpose(matrix) result(res)\n\n      type(any_type), intent(in) :: matrix(:,:)\n      type(same_as_matrix)       :: res(size(matrix,2), size(matrix,1))\n```\n\n### **Characteristics**\n\n - **matrix** must be an array of rank two (a matrix) of any type.\n - The result has the same type and type parameters as **matrix**.\n - If **matrix** has shape (n, m), the result has shape (m, n).\n\n### **Description**\n\n **transpose** returns the transpose of **matrix**. Element (i, j) of the result\n equals element (j, i) of **matrix** for all valid (i, j). This interchanges\n rows and columns: the first row of the result is the first column of **matrix**,\n and so on.\n\n Transposition is a fundamental matrix operation used in linear algebra,\n data manipulation, and converting between row-major and column-major layouts.\n\n### **Options**\n\n- **matrix**\n  : A rank-two array of any intrinsic or derived type to be transposed.\n\n### **Result**\n\n The result is an array of rank two with the same type as **matrix**.\n If **matrix** has shape (n, m), the result has shape (m, n).\n Element (i, j) of the result has the value matrix(j, i).\n\n### **Examples**\n\n Sample program:\n\n```fortran\nprogram demo_transpose\n  implicit none\n  integer :: i\n  integer :: a(2, 3), at(3, 2)\n  real :: b(3, 4), bt(4, 3)\n  character(len=1) :: c(2, 3), ct(3, 2)\n\n  ! Integer matrix transpose\n  a = reshape([1, 2, 3, 4, 5, 6], [2, 3])\n  at = transpose(a)\n\n  print '(a)', 'Original 2x3 integer matrix:'\n  do i = 1, 2\n    print '(3i4)', a(i, :)\n  end do\n\n  print *\n  print '(a)', 'Transposed 3x2 matrix:'\n  do i = 1, 3\n    print '(2i4)', at(i, :)\n  end do\n\n  ! Real matrix transpose\n  b = reshape([(real(i)/10.0, i=1,12)], [3, 4])\n  bt = transpose(b)\n\n  print *\n  print '(a)', 'Original 3x4 real matrix:'\n  do i = 1, 3\n    print '(4f6.1)', b(i, :)\n  end do\n\n  print *\n  print '(a)', 'Transposed 4x3 matrix:'\n  do i = 1, 4\n    print '(3f6.1)', bt(i, :)\n  end do\n\n  ! Character matrix transpose\n  c = reshape(['a', 'b', 'c', 'd', 'e', 'f'], [2, 3])\n  ct = transpose(c)\n\n  print *\n  print '(a)', 'Original 2x3 character matrix:'\n  do i = 1, 2\n    print '(3(a2))', c(i, :)\n  end do\n\n  print *\n  print '(a)', 'Transposed 3x2 matrix:'\n  do i = 1, 3\n    print '(2(a2))', ct(i, :)\n  end do\n\n  ! Verify transpose property: transpose(transpose(A)) = A\n  print *\n  print '(a,l)', 'transpose(transpose(a)) equals a: ', &\n    all(transpose(transpose(a)) == a)\n\n  ! Square matrix transpose\n  print *\n  print '(a)', 'Square 3x3 matrix and its transpose:'\n  block\n    integer :: s(3, 3), st(3, 3)\n    s = reshape([(i, i=1,9)], [3, 3])\n    st = transpose(s)\n    print '(a)', 'Original:'\n    do i = 1, 3\n      print '(3i4)', s(i, :)\n    end do\n    print '(a)', 'Transposed:'\n    do i = 1, 3\n      print '(3i4)', st(i, :)\n    end do\n  end block\n\nend program demo_transpose\n```\n\n Results:\n\n```text\nOriginal 2x3 integer matrix:\n   1   3   5\n   2   4   6\n\nTransposed 3x2 matrix:\n   1   2\n   3   4\n   5   6\n\nOriginal 3x4 real matrix:\n   0.1   0.4   0.7   1.0\n   0.2   0.5   0.8   1.1\n   0.3   0.6   0.9   1.2\n\nTransposed 4x3 matrix:\n   0.1   0.2   0.3\n   0.4   0.5   0.6\n   0.7   0.8   0.9\n   1.0   1.1   1.2\n\nOriginal 2x3 character matrix:\n a c e\n b d f\n\nTransposed 3x2 matrix:\n a b\n c d\n e f\n\ntranspose(transpose(a)) equals a:  T\n\nSquare 3x3 matrix and its transpose:\nOriginal:\n   1   4   7\n   2   5   8\n   3   6   9\nTransposed:\n   1   2   3\n   4   5   6\n   7   8   9\n```\n\n### **Standard**\n\n Fortran 90\n\n### **See Also**\n\n - [**reshape**](#reshape) - Construct an array with a specified shape\n - [**matmul**](#matmul) - Matrix multiplication\n - [**cshift**](#cshift) - Circular shift of array elements\n - [**eoshift**](#eoshift) - End-off shift of array elements",

  "unpack": "## unpack\n\n### **Name**\n\n**unpack** - \\[ARRAY:MANIPULATION\\] Scatter vector elements into an array under mask control\n\n### **Synopsis**\n```fortran\n    result = unpack(vector, mask, field)\n```\n```fortran\n     function unpack(vector, mask, field) result(res)\n\n      type(any_type), intent(in) :: vector(:)\n      logical, intent(in)        :: mask(..)\n      type(same_as_vector), intent(in) :: field(..)\n      type(same_as_vector)       :: res(shape_of_mask)\n```\n\n### **Characteristics**\n\n - **vector** must be a rank-one array of any intrinsic or derived type with size >= count(mask).\n - **mask** must be a logical array of any shape.\n - **field** must have the same type as **vector** and be conformable with **mask** (same shape or scalar).\n - The result has the same type as **vector** and the same shape as **mask**.\n\n### **Description**\n\n **unpack** scatters elements from a rank-one **vector** into an array with\n the shape of **mask**. Elements of **vector** are placed at positions where\n **mask** is .true., in array element order. Positions where **mask** is .false.\n receive the corresponding value from **field**.\n\n This is the inverse operation of **pack**. Together, pack and unpack enable\n gathering selected elements for processing, then scattering results back.\n\n### **Options**\n\n- **vector**\n  : A rank-one array containing the values to scatter. Must have at least\n  as many elements as there are .true. values in **mask**.\n\n- **mask**\n  : A logical array defining where to place **vector** elements (.true.\n  positions) and where to use **field** values (.false. positions).\n\n- **field**\n  : An array or scalar of the same type as **vector** providing values for\n  positions where **mask** is .false. If scalar, that value fills all\n  .false. positions.\n\n### **Result**\n\n The result has the same shape as **mask** and the same type as **vector**.\n Position (i,j,...) of the result is:\n - vector(k) if mask(i,j,...) is the k-th .true. element of mask\n - field(i,j,...) if mask(i,j,...) is .false.\n\n### **Examples**\n\n Sample program:\n\n```fortran\nprogram demo_unpack\n  implicit none\n  integer :: i\n  integer :: v(3), result2d(2, 3)\n  integer :: field2d(2, 3)\n  logical :: mask2d(2, 3)\n\n  ! Basic unpack: scatter vector into 2D array\n  v = [10, 20, 30]\n  mask2d = reshape([.true., .false., .false., .true., .true., .false.], [2, 3])\n  field2d = 0\n\n  result2d = unpack(v, mask2d, field2d)\n\n  print '(a)', 'Mask (2x3):'\n  do i = 1, 2\n    print '(3l4)', mask2d(i, :)\n  end do\n\n  print *\n  print '(a,3i4)', 'Vector:       ', v\n  print *\n  print '(a)', 'Unpacked result (2x3):'\n  do i = 1, 2\n    print '(3i4)', result2d(i, :)\n  end do\n\n  ! Using scalar field value\n  result2d = unpack(v, mask2d, -1)\n  print *\n  print '(a)', 'With scalar field=-1:'\n  do i = 1, 2\n    print '(3i4)', result2d(i, :)\n  end do\n\n  ! Preserve existing array values\n  field2d = reshape([1, 2, 3, 4, 5, 6], [2, 3])\n  result2d = unpack(v, mask2d, field2d)\n  print *\n  print '(a)', 'Field array (2x3):'\n  do i = 1, 2\n    print '(3i4)', field2d(i, :)\n  end do\n  print *\n  print '(a)', 'Unpacked with field preservation:'\n  do i = 1, 2\n    print '(3i4)', result2d(i, :)\n  end do\n\n  ! Demonstrate pack/unpack roundtrip\n  print *\n  print '(a)', 'Pack/Unpack roundtrip:'\n  block\n    integer :: original(2, 3), processed(3), restored(2, 3)\n    logical :: m(2, 3)\n\n    original = reshape([1, 2, 3, 4, 5, 6], [2, 3])\n    m = original > 2  ! Select elements > 2\n\n    print '(a)', 'Original array:'\n    do i = 1, 2\n      print '(3i4)', original(i, :)\n    end do\n\n    ! Pack elements > 2\n    processed = pack(original, m)\n    print '(a,*(i4))', 'Packed (>2):  ', processed\n\n    ! Double the packed values\n    processed = processed * 2\n    print '(a,*(i4))', 'Doubled:      ', processed\n\n    ! Unpack back, keeping original values where mask is false\n    restored = unpack(processed, m, original)\n    print '(a)', 'Restored (doubled where >2):'\n    do i = 1, 2\n      print '(3i4)', restored(i, :)\n    end do\n  end block\n\n  ! Create sparse matrix\n  print *\n  print '(a)', 'Create sparse matrix with unpack:'\n  block\n    integer :: diag(3), sparse(3, 3)\n    logical :: diag_mask(3, 3)\n\n    diag = [1, 2, 3]\n    diag_mask = reshape([ &\n      .true., .false., .false., &\n      .false., .true., .false., &\n      .false., .false., .true.], [3, 3])\n\n    sparse = unpack(diag, diag_mask, 0)\n    print '(a)', 'Diagonal matrix:'\n    do i = 1, 3\n      print '(3i4)', sparse(i, :)\n    end do\n  end block\n\nend program demo_unpack\n```\n\n Results:\n\n```text\nMask (2x3):\n   T   F   T\n   F   T   F\n\nVector:         10  20  30\n\nUnpacked result (2x3):\n  10   0  30\n   0  20   0\n\nWith scalar field=-1:\n  10  -1  30\n  -1  20  -1\n\nField array (2x3):\n   1   3   5\n   2   4   6\n\nUnpacked with field preservation:\n  10   3  30\n   2  20   6\n\nPack/Unpack roundtrip:\nOriginal array:\n   1   3   5\n   2   4   6\nPacked (>2):     3   4   5   6\nDoubled:         6   8  10  12\nRestored (doubled where >2):\n   1   6  10\n   2   8  12\n\nCreate sparse matrix with unpack:\nDiagonal matrix:\n   1   0   0\n   0   2   0\n   0   0   3\n```\n\n### **Standard**\n\n Fortran 90\n\n### **See Also**\n\n - [**pack**](#pack) - Pack array elements into a rank-one array under mask control\n - [**merge**](#merge) - Merge two arrays under mask control\n - [**spread**](#spread) - Replicate an array by adding a dimension\n - [**reshape**](#reshape) - Construct an array with a specified shape"
}
