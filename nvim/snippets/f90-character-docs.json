{
  "achar": "## achar\n\n### **Name**\n\n**achar** - \\[CHARACTER:MANIPULATION\\] Return the character at a position in the ASCII collating sequence\n\n### **Synopsis**\n```fortran\n    result = achar(i)\n    result = achar(i, kind)\n```\n```fortran\n     elemental function achar(i, kind) result(res)\n\n      integer, intent(in)           :: i\n      integer, intent(in), optional :: kind\n      character(len=1, kind=KIND)   :: res\n```\n\n### **Characteristics**\n\n - **i** is of type integer.\n - **kind** is a scalar integer constant expression (optional).\n - The result is a single character of type character with kind **kind**\n   if present, otherwise default character kind.\n - This is an elemental function: it operates element-by-element on arrays.\n\n### **Description**\n\n **achar** returns the character located at position **i** in the ASCII\n collating sequence. This is the inverse of the **iachar** function.\n It always uses ASCII ordering regardless of the processor's native\n character set, making it portable across platforms.\n\n For standard ASCII characters (0-127), the mapping is well-defined:\n - 0-31: Control characters (NUL, TAB, LF, CR, etc.)\n - 32: Space\n - 48-57: Digits '0'-'9'\n - 65-90: Uppercase letters 'A'-'Z'\n - 97-122: Lowercase letters 'a'-'z'\n - 32-126: Printable characters\n - 127: DEL character\n\n### **Options**\n\n- **i**\n  : The integer code point in the ASCII sequence. Valid values are 0-127\n  for standard ASCII. Values outside this range produce processor-dependent\n  results. Negative values are not valid.\n\n- **kind**\n  : Optional. The kind type parameter of the result. If absent, the result\n  is default character kind. Use this for Unicode or other character kinds.\n\n### **Result**\n\n  A single character at position **i** in the ASCII collating sequence.\n  The result has length 1 and kind equal to **kind** if specified,\n  otherwise the default character kind.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_achar\n  implicit none\n  integer :: i\n  character(len=26) :: alphabet\n\n  ! Print some ASCII characters\n  print '(A,A)', 'ASCII 65 (A): ', achar(65)\n  print '(A,A)', 'ASCII 97 (a): ', achar(97)\n  print '(A,A)', 'ASCII 48 (0): ', achar(48)\n  print '(A,A)', 'ASCII 32 (space): [', achar(32), ']'\n\n  ! Build the uppercase alphabet\n  do i = 1, 26\n    alphabet(i:i) = achar(64 + i)\n  end do\n  print '(A,A)', 'Uppercase alphabet: ', alphabet\n\n  ! Build the lowercase alphabet\n  do i = 1, 26\n    alphabet(i:i) = achar(96 + i)\n  end do\n  print '(A,A)', 'Lowercase alphabet: ', alphabet\n\n  ! Create special characters for formatting\n  print '(A)', 'Tab character: [' // achar(9) // ']'\n  print '(A)', 'Using newline:'\n  print '(A)', 'Line 1' // achar(10) // 'Line 2'\n\n  ! Convert integer codes to string\n  print '(A)', 'Hello from codes: ' // &\n    achar(72) // achar(101) // achar(108) // achar(108) // achar(111)\n\nend program demo_achar\n```\nResults:\n```text\nASCII 65 (A): A\nASCII 97 (a): a\nASCII 48 (0): 0\nASCII 32 (space): [ ]\nUppercase alphabet: ABCDEFGHIJKLMNOPQRSTUVWXYZ\nLowercase alphabet: abcdefghijklmnopqrstuvwxyz\nTab character: [\\t]\nUsing newline:\nLine 1\nLine 2\nHello from codes: Hello\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**iachar**(3)](#iachar),\n[**char**(3)](#char),\n[**ichar**(3)](#ichar)",

  "adjustl": "## adjustl\n\n### **Name**\n\n**adjustl** - \\[CHARACTER:MANIPULATION\\] Left-justify a string by removing leading blanks\n\n### **Synopsis**\n```fortran\n    result = adjustl(string)\n```\n```fortran\n     elemental function adjustl(string) result(res)\n\n      character(len=*), intent(in) :: string\n      character(len=len(string))   :: res\n```\n\n### **Characteristics**\n\n - **string** is of type character and may be any kind.\n - The result is of type character with the same length and kind as **string**.\n - This is an elemental function: it operates element-by-element on arrays.\n\n### **Description**\n\n **adjustl** returns the argument **string** with leading blanks removed\n and the same number of trailing blanks appended. The string is effectively\n left-justified within its original length. The total length of the result\n is always equal to the length of the input string.\n\n This function is commonly used for:\n - Aligning text output to the left margin\n - Preparing strings for comparison operations\n - Normalizing user input that may have leading spaces\n - Cleaning up fixed-length character variables\n\n### **Options**\n\n- **string**\n  : The character string to be left-justified. Leading blanks (spaces) are\n  moved to the end of the string. May be of any character kind. The string\n  length is preserved.\n\n### **Result**\n\n  A character string of the same length and kind as **string**, with\n  leading blanks removed and appended as trailing blanks. If the string\n  contains only blanks, the result is unchanged. If there are no leading\n  blanks, the string is returned unchanged.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_adjustl\n  implicit none\n  character(len=20) :: str1, str2\n  character(len=20) :: names(3)\n  integer :: i\n\n  ! Basic left-justification\n  str1 = '     Hello World'\n  print '(A,A,A)', 'Original:    [', str1, ']'\n\n  str2 = adjustl(str1)\n  print '(A,A,A)', 'After adjustl: [', str2, ']'\n\n  ! Combining adjustl with trim for clean output\n  print '(A,A,A)', 'Trimmed:       [', trim(adjustl(str1)), ']'\n\n  ! Processing array of strings\n  names(1) = '   Alice'\n  names(2) = '      Bob'\n  names(3) = ' Charlie'\n\n  print '(A)', ''\n  print '(A)', 'Before adjustl:'\n  do i = 1, 3\n    print '(A,A,A)', '  [', names(i), ']'\n  end do\n\n  names = adjustl(names)  ! Elemental: works on whole array\n\n  print '(A)', 'After adjustl:'\n  do i = 1, 3\n    print '(A,A,A)', '  [', names(i), ']'\n  end do\n\n  ! String with no leading blanks is unchanged\n  str1 = 'NoLeadingBlanks'\n  str2 = adjustl(str1)\n  print '(A)', ''\n  print '(A,A,A)', 'No change needed: [', str2, ']'\n\n  ! All blanks remain all blanks\n  str1 = '                    '\n  str2 = adjustl(str1)\n  print '(A,I0)', 'All blanks - len_trim: ', len_trim(str2)\n\nend program demo_adjustl\n```\nResults:\n```text\nOriginal:    [     Hello World    ]\nAfter adjustl: [Hello World         ]\nTrimmed:       [Hello World]\n\nBefore adjustl:\n  [   Alice             ]\n  [      Bob            ]\n  [ Charlie             ]\nAfter adjustl:\n  [Alice               ]\n  [Bob                 ]\n  [Charlie             ]\n\nNo change needed: [NoLeadingBlanks     ]\nAll blanks - len_trim: 0\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**adjustr**(3)](#adjustr),\n[**trim**(3)](#trim),\n[**len_trim**(3)](#len_trim)",

  "adjustr": "## adjustr\n\n### **Name**\n\n**adjustr** - \\[CHARACTER:MANIPULATION\\] Right-justify a string by removing trailing blanks\n\n### **Synopsis**\n```fortran\n    result = adjustr(string)\n```\n```fortran\n     elemental function adjustr(string) result(res)\n\n      character(len=*), intent(in) :: string\n      character(len=len(string))   :: res\n```\n\n### **Characteristics**\n\n - **string** is of type character and may be any kind.\n - The result is of type character with the same length and kind as **string**.\n - This is an elemental function: it operates element-by-element on arrays.\n\n### **Description**\n\n **adjustr** returns the argument **string** with trailing blanks removed\n and the same number of leading blanks prepended. The string is effectively\n right-justified within its original length. The total length of the result\n is always equal to the length of the input string.\n\n This function is commonly used for:\n - Right-aligning text in columns for tabular output\n - Aligning numeric strings for display\n - Formatting fixed-width fields\n - Creating visually aligned output reports\n\n### **Options**\n\n- **string**\n  : The character string to be right-justified. Trailing blanks (spaces) are\n  moved to the beginning of the string. May be of any character kind. The\n  string length is preserved.\n\n### **Result**\n\n  A character string of the same length and kind as **string**, with\n  trailing blanks removed and prepended as leading blanks. If the string\n  contains only blanks, the result is unchanged. If there are no trailing\n  blanks, the string is returned unchanged.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_adjustr\n  implicit none\n  character(len=20) :: str1, str2\n  character(len=10) :: items(4)\n  real :: prices(4)\n  integer :: i\n\n  ! Basic right-justification\n  str1 = 'Hello World'\n  print '(A,A,A)', 'Original:    [', str1, ']'\n\n  str2 = adjustr(str1)\n  print '(A,A,A)', 'After adjustr: [', str2, ']'\n\n  ! Creating aligned columns\n  items = ['Apple', 'Banana', 'Cherry', 'Date']\n  prices = [1.50, 2.25, 3.00, 0.75]\n\n  print '(A)', ''\n  print '(A)', 'Right-aligned price list:'\n  print '(A)', '========================'\n  do i = 1, 4\n    print '(A,A,F6.2)', adjustr(items(i)), ' $', prices(i)\n  end do\n\n  ! Comparing left vs right justification\n  str1 = '  Centered?  '\n  print '(A)', ''\n  print '(A,A,A)', 'Original: [', str1, ']'\n  print '(A,A,A)', 'adjustl:  [', adjustl(str1), ']'\n  print '(A,A,A)', 'adjustr:  [', adjustr(str1), ']'\n\n  ! String already right-justified stays the same\n  str1 = '         RightSide'\n  str2 = adjustr(str1)\n  print '(A)', ''\n  print '(A,A,A)', 'Already right: [', str2, ']'\n\nend program demo_adjustr\n```\nResults:\n```text\nOriginal:    [Hello World         ]\nAfter adjustr: [         Hello World]\n\nRight-aligned price list:\n========================\n     Apple $  1.50\n    Banana $  2.25\n    Cherry $  3.00\n      Date $  0.75\n\nOriginal: [  Centered?       ]\nadjustl:  [Centered?         ]\nadjustr:  [         Centered?]\n\nAlready right: [         RightSide]\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**adjustl**(3)](#adjustl),\n[**trim**(3)](#trim),\n[**len_trim**(3)](#len_trim)",

  "iachar": "## iachar\n\n### **Name**\n\n**iachar** - \\[CHARACTER:MANIPULATION\\] Return the ASCII code of a character\n\n### **Synopsis**\n```fortran\n    result = iachar(c)\n    result = iachar(c, kind)\n```\n```fortran\n     elemental function iachar(c, kind) result(res)\n\n      character(len=1), intent(in)  :: c\n      integer, intent(in), optional :: kind\n      integer(kind=KIND)            :: res\n```\n\n### **Characteristics**\n\n - **c** is a single character of type character.\n - **kind** is a scalar integer constant expression (optional).\n - The result is of type integer with kind **kind** if present,\n   otherwise default integer kind.\n - This is an elemental function: it operates element-by-element on arrays.\n\n### **Description**\n\n **iachar** returns the position of the character **c** in the ASCII\n collating sequence. This is the inverse of the **achar** function.\n It always uses ASCII ordering regardless of the processor's native\n character set, making it portable across platforms.\n\n Key ASCII code ranges:\n - 0-31: Control characters\n - 32: Space\n - 48-57: Digits '0'-'9'\n - 65-90: Uppercase letters 'A'-'Z'\n - 97-122: Lowercase letters 'a'-'z'\n - 127: DEL character\n\n### **Options**\n\n- **c**\n  : A single character whose ASCII code is to be returned. Only the first\n  character is used if the argument has length greater than one. If the\n  character is not in the ASCII character set, the result is processor-dependent.\n\n- **kind**\n  : Optional. The kind type parameter of the result. If absent, the result\n  is default integer kind. Use this when you need a specific integer kind\n  for the result.\n\n### **Result**\n\n  An integer representing the position of **c** in the ASCII collating\n  sequence. Returns values 0-127 for standard ASCII characters.\n  The kind of the result is **kind** if present, otherwise default integer.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_iachar\n  implicit none\n  character :: c\n  character(len=26) :: str\n  integer :: code, i\n\n  ! Get ASCII codes for common characters\n  print '(A,I0)', 'ASCII code of A: ', iachar('A')\n  print '(A,I0)', 'ASCII code of Z: ', iachar('Z')\n  print '(A,I0)', 'ASCII code of a: ', iachar('a')\n  print '(A,I0)', 'ASCII code of z: ', iachar('z')\n  print '(A,I0)', 'ASCII code of 0: ', iachar('0')\n  print '(A,I0)', 'ASCII code of 9: ', iachar('9')\n  print '(A,I0)', 'ASCII code of space: ', iachar(' ')\n\n  ! Convert uppercase to lowercase using ASCII arithmetic\n  str = 'HELLO WORLD FORTRAN CODE'\n  print '(A)', ''\n  print '(A,A)', 'Original: ', str\n  do i = 1, len(str)\n    code = iachar(str(i:i))\n    if (code >= 65 .and. code <= 90) then\n      str(i:i) = achar(code + 32)\n    end if\n  end do\n  print '(A,A)', 'Lowercase: ', str\n\n  ! Check character classification\n  print '(A)', ''\n  print '(A)', 'Character classification:'\n  do i = 1, 5\n    c = 'aB1! '(i:i)\n    code = iachar(c)\n    print '(A,A,A,I0,A)', '  \"', c, '\" (code ', code, ') is ', &\n      classify_char(code)\n  end do\n\n  ! Using kind parameter\n  print '(A)', ''\n  print '(A,I0)', 'With kind=8: ', iachar('Z', kind=8)\n\ncontains\n\n  function classify_char(code) result(class)\n    integer, intent(in) :: code\n    character(len=20) :: class\n    if (code >= 65 .and. code <= 90) then\n      class = 'uppercase letter'\n    else if (code >= 97 .and. code <= 122) then\n      class = 'lowercase letter'\n    else if (code >= 48 .and. code <= 57) then\n      class = 'digit'\n    else if (code == 32) then\n      class = 'space'\n    else\n      class = 'other'\n    end if\n  end function classify_char\n\nend program demo_iachar\n```\nResults:\n```text\nASCII code of A: 65\nASCII code of Z: 90\nASCII code of a: 97\nASCII code of z: 122\nASCII code of 0: 48\nASCII code of 9: 57\nASCII code of space: 32\n\nOriginal: HELLO WORLD FORTRAN CODE\nLowercase: hello world fortran code\n\nCharacter classification:\n  \"a\" (code 97) is lowercase letter\n  \"B\" (code 66) is uppercase letter\n  \"1\" (code 49) is digit\n  \"!\" (code 33) is other\n  \" \" (code 32) is space\n\nWith kind=8: 90\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**achar**(3)](#achar),\n[**ichar**(3)](#ichar),\n[**char**(3)](#char)",

  "len_trim": "## len_trim\n\n### **Name**\n\n**len_trim** - \\[CHARACTER:MANIPULATION\\] Length of a string without trailing blanks\n\n### **Synopsis**\n```fortran\n    result = len_trim(string)\n    result = len_trim(string, kind)\n```\n```fortran\n     elemental function len_trim(string, kind) result(res)\n\n      character(len=*), intent(in)  :: string\n      integer, intent(in), optional :: kind\n      integer(kind=KIND)            :: res\n```\n\n### **Characteristics**\n\n - **string** is of type character and may be any kind.\n - **kind** is a scalar integer constant expression (optional).\n - The result is of type integer. If **kind** is present, the result has\n   that kind; otherwise, it is default integer kind.\n - This is an elemental function: it operates element-by-element on arrays.\n\n### **Description**\n\n **len_trim** returns the length of **string** ignoring any trailing blanks.\n This is equivalent to `len(trim(string))` but is more efficient as it does\n not create an intermediate trimmed string. The function counts characters\n from the beginning up to and including the last non-blank character.\n\n Common uses include:\n - Determining actual content length for memory allocation\n - Computing string boundaries for substring operations\n - Formatting output with proper field widths\n - Validating that strings contain actual content\n\n### **Options**\n\n- **string**\n  : The character string whose trimmed length is to be determined.\n  May be of any character kind. Leading blanks are included in the count;\n  only trailing blanks are ignored.\n\n- **kind**\n  : Optional. An integer initialization expression indicating the kind\n  parameter of the result. Useful when working with very long strings\n  that might exceed default integer range.\n\n### **Result**\n\n  An integer representing the position of the last non-blank character\n  in **string**. If the string is entirely blank, the result is zero.\n  The kind of the result is determined by **kind** if present, otherwise\n  it is default integer kind.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_len_trim\n  implicit none\n  character(len=30) :: str\n  character(len=30) :: strings(3)\n  integer :: length, i\n\n  ! Basic usage\n  str = 'Hello World'\n  length = len_trim(str)\n  print '(A,I0)', 'Length of \"Hello World\": ', length\n\n  ! String with leading and trailing blanks\n  str = '   Padded Text   '\n  print '(A)', ''\n  print '(A,A,A)', 'String: [', str, ']'\n  print '(A,I0)', '  len():      ', len(str)\n  print '(A,I0)', '  len_trim(): ', len_trim(str)\n\n  ! All blanks gives zero\n  str = '                              '\n  print '(A)', ''\n  print '(A,I0)', 'All blanks - len_trim: ', len_trim(str)\n\n  ! Using with substring operations\n  str = 'Extract this part        '\n  print '(A)', ''\n  print '(A,A,A)', 'Content only: [', str(1:len_trim(str)), ']'\n\n  ! Array operations (elemental)\n  strings(1) = 'Short'\n  strings(2) = 'Medium length'\n  strings(3) = 'This is a longer string'\n\n  print '(A)', ''\n  print '(A)', 'Array of strings:'\n  do i = 1, 3\n    print '(A,I0,A,A,A)', '  len_trim = ', len_trim(strings(i)), &\n      ': [', trim(strings(i)), ']'\n  end do\n\n  ! Comparing len vs len_trim efficiency\n  str = 'Efficiency test'\n  print '(A)', ''\n  print '(A,I0)', 'len(str):           ', len(str)\n  print '(A,I0)', 'len_trim(str):      ', len_trim(str)\n  print '(A,I0)', 'len(trim(str)):     ', len(trim(str))  ! Same but less efficient\n\n  ! Using kind parameter\n  print '(A)', ''\n  print '(A,I0)', 'With kind=8: ', len_trim(str, kind=8)\n\nend program demo_len_trim\n```\nResults:\n```text\nLength of \"Hello World\": 11\n\nString: [   Padded Text               ]\n  len():      30\n  len_trim(): 14\n\nAll blanks - len_trim: 0\n\nContent only: [Extract this part]\n\nArray of strings:\n  len_trim = 5: [Short]\n  len_trim = 13: [Medium length]\n  len_trim = 23: [This is a longer string]\n\nlen(str):           30\nlen_trim(str):      15\nlen(trim(str)):     15\n\nWith kind=8: 15\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**len**(3)](#len),\n[**trim**(3)](#trim),\n[**adjustl**(3)](#adjustl),\n[**adjustr**(3)](#adjustr)",

  "repeat": "## repeat\n\n### **Name**\n\n**repeat** - \\[CHARACTER:MANIPULATION\\] Concatenate copies of a string\n\n### **Synopsis**\n```fortran\n    result = repeat(string, ncopies)\n```\n```fortran\n     pure function repeat(string, ncopies) result(res)\n\n      character(len=*), intent(in) :: string\n      integer, intent(in)          :: ncopies\n      character(len=len(string)*ncopies) :: res\n```\n\n### **Characteristics**\n\n - **string** is a scalar of type character.\n - **ncopies** is a scalar of type integer and must be non-negative.\n - The result is of type character with the same kind as **string**.\n - The result length is `len(string) * ncopies`.\n - This is a transformational function (not elemental).\n\n### **Description**\n\n **repeat** returns a string formed by concatenating **ncopies** copies\n of **string**. This is a convenient way to create repeated patterns,\n separator lines, padding, or any string that consists of a repeated\n substring without using explicit loops.\n\n Common uses include:\n - Creating horizontal separator lines for output\n - Building indentation strings\n - Generating repeated patterns for formatting\n - Creating padding of specific lengths\n\n### **Options**\n\n- **string**\n  : The character string to be repeated. May be of any character kind.\n  May be zero-length, in which case the result is also zero-length\n  regardless of **ncopies**.\n\n- **ncopies**\n  : The number of times to repeat **string**. Must be a non-negative\n  integer. If zero, the result is a zero-length string. Negative values\n  are not permitted and will cause an error.\n\n### **Result**\n\n  A character string of length `len(string) * ncopies` containing\n  **ncopies** concatenated copies of **string**. Has the same kind\n  as **string**. If **ncopies** is zero or **string** is zero-length,\n  the result is a zero-length string.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_repeat\n  implicit none\n  character(len=:), allocatable :: line, indent\n  character(len=3) :: abc\n  integer :: i\n\n  ! Create separator lines\n  line = repeat('-', 50)\n  print '(A)', line\n  print '(A)', 'Title'\n  print '(A)', line\n\n  ! Create a decorated box\n  print '(A)', ''\n  print '(A)', repeat('*', 30)\n  print '(A)', '*' // repeat(' ', 28) // '*'\n  print '(A)', '*      Hello, Fortran!      *'\n  print '(A)', '*' // repeat(' ', 28) // '*'\n  print '(A)', repeat('*', 30)\n\n  ! Create indentation for nested output\n  print '(A)', ''\n  print '(A)', 'Nested structure:'\n  do i = 0, 3\n    indent = repeat('  ', i)\n    print '(A,A,I0,A)', indent, 'Level ', i, ' item'\n  end do\n\n  ! Repeat a multi-character pattern\n  abc = '=-='\n  print '(A)', ''\n  print '(A)', repeat(abc, 10)\n\n  ! Zero copies gives empty string\n  print '(A)', ''\n  print '(A,I0,A)', 'Zero copies: [', len(repeat('x', 0)), ' chars]'\n\n  ! Create padding for right-alignment\n  print '(A)', ''\n  print '(A)', 'Right-aligned numbers:'\n  do i = 1, 1000, 333\n    print '(A,I0)', repeat(' ', 10 - int(log10(real(i))) - 1), i\n  end do\n\n  ! Build a simple progress bar\n  print '(A)', ''\n  print '(A)', 'Progress bar:'\n  do i = 1, 5\n    print '(A,A,A,I0,A)', '[', repeat('#', i*4), &\n      repeat(' ', 20-i*4), '] ', i*20, '%'\n  end do\n\nend program demo_repeat\n```\nResults:\n```text\n--------------------------------------------------\nTitle\n--------------------------------------------------\n\n******************************\n*                            *\n*      Hello, Fortran!      *\n*                            *\n******************************\n\nNested structure:\nLevel 0 item\n  Level 1 item\n    Level 2 item\n      Level 3 item\n\n=-==-==-==-==-==-==-==-==-==-=\n\nZero copies: [0 chars]\n\nRight-aligned numbers:\n         1\n       334\n       667\n      1000\n\nProgress bar:\n[####                ] 20%\n[########            ] 40%\n[############        ] 60%\n[################    ] 80%\n[####################] 100%\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**trim**(3)](#trim),\n[**len**(3)](#len),\n[**adjustl**(3)](#adjustl),\n[**adjustr**(3)](#adjustr)",

  "scan": "## scan\n\n### **Name**\n\n**scan** - \\[CHARACTER:MANIPULATION\\] Scan a string for any character in a set\n\n### **Synopsis**\n```fortran\n    result = scan(string, set)\n    result = scan(string, set, back)\n    result = scan(string, set, back, kind)\n```\n```fortran\n     elemental function scan(string, set, back, kind) result(res)\n\n      character(len=*), intent(in)           :: string\n      character(len=*), intent(in)           :: set\n      logical, intent(in), optional          :: back\n      integer, intent(in), optional          :: kind\n      integer(kind=KIND)                     :: res\n```\n\n### **Characteristics**\n\n - **string** is of type character.\n - **set** is of type character with the same kind as **string**.\n - **back** is of type logical (optional).\n - **kind** is a scalar integer constant expression (optional).\n - The result is of type integer with kind **kind** if present, else default.\n - This is an elemental function: it operates element-by-element on arrays.\n\n### **Description**\n\n **scan** searches **string** for the first occurrence of any character\n that is contained in **set**. If **back** is present and true, the search\n proceeds from the end of the string toward the beginning, returning the\n position of the last matching character.\n\n This function is useful for:\n - Finding delimiters in strings (commas, semicolons, etc.)\n - Locating specific character classes (vowels, digits, etc.)\n - Parsing structured text formats\n - Tokenizing input strings\n\n### **Options**\n\n- **string**\n  : The character string to be scanned for characters from **set**.\n\n- **set**\n  : The set of characters to search for. Any single character from this\n  set triggers a match. The order of characters in **set** does not matter.\n\n- **back**\n  : Optional. If present and `.true.`, scan from the rightmost position\n  toward the left, returning the position of the last matching character.\n  Default is `.false.` (scan left to right).\n\n- **kind**\n  : Optional. An integer initialization expression indicating the kind\n  parameter of the result.\n\n### **Result**\n\n  An integer indicating the position of the first (or last if `back=.true.`)\n  character in **string** that is also in **set**. Returns zero if:\n  - No character from **set** is found in **string**\n  - **string** is zero-length\n  - **set** is zero-length\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_scan\n  implicit none\n  character(len=50) :: str\n  character(len=*), parameter :: vowels = 'aeiouAEIOU'\n  character(len=*), parameter :: digits = '0123456789'\n  character(len=*), parameter :: delims = ',;:|'\n  integer :: pos, start\n\n  ! Find first vowel\n  str = 'Hello, World!'\n  pos = scan(str, vowels)\n  print '(A,I0,A,A)', 'First vowel at position ', pos, ': ', str(pos:pos)\n\n  ! Find last vowel\n  pos = scan(str, vowels, back=.true.)\n  print '(A,I0,A,A)', 'Last vowel at position ', pos, ': ', str(pos:pos)\n\n  ! Find first punctuation\n  pos = scan(str, ',.!?;:')\n  if (pos > 0) then\n    print '(A,I0,A,A)', 'First punctuation at ', pos, ': ', str(pos:pos)\n  end if\n\n  ! Search for characters not present\n  pos = scan(str, 'xyz')\n  print '(A,I0)', 'xyz not found, scan returns: ', pos\n\n  ! Find first digit in mixed string\n  str = 'Order #12345 received'\n  pos = scan(str, digits)\n  print '(A)', ''\n  print '(A,I0)', 'First digit at position: ', pos\n\n  ! Parse CSV: extract fields using scan\n  str = 'apple,banana,cherry,date'\n  print '(A)', ''\n  print '(A)', 'Parsing CSV:'\n  start = 1\n  do\n    pos = scan(str(start:), ',')\n    if (pos == 0) then\n      print '(A,A)', '  Field: ', trim(str(start:))\n      exit\n    else\n      print '(A,A)', '  Field: ', str(start:start+pos-2)\n      start = start + pos\n    end if\n  end do\n\n  ! Find any delimiter in a string with multiple delimiter types\n  str = 'field1,field2;field3|field4'\n  print '(A)', ''\n  print '(A,A)', 'String: ', trim(str)\n  pos = scan(str, delims)\n  print '(A,I0,A,A)', 'First delimiter at ', pos, ': ', str(pos:pos)\n  pos = scan(str, delims, back=.true.)\n  print '(A,I0,A,A)', 'Last delimiter at ', pos, ': ', str(pos:pos)\n\n  ! Check if string contains any whitespace\n  str = 'NoSpacesHere'\n  pos = scan(str, ' ' // achar(9))  ! space or tab\n  print '(A)', ''\n  if (pos == 0) then\n    print '(A,A,A)', '\"', trim(str), '\" contains no whitespace'\n  else\n    print '(A,A,A,I0)', '\"', trim(str), '\" has whitespace at ', pos\n  end if\n\nend program demo_scan\n```\nResults:\n```text\nFirst vowel at position 2: e\nLast vowel at position 8: o\nFirst punctuation at 6: ,\nxyz not found, scan returns: 0\n\nFirst digit at position: 8\n\nParsing CSV:\n  Field: apple\n  Field: banana\n  Field: cherry\n  Field: date\n\nString: field1,field2;field3|field4\nFirst delimiter at 7: ,\nLast delimiter at 21: |\n\n\"NoSpacesHere\" contains no whitespace\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**verify**(3)](#verify),\n[**index**(3)](#index),\n[**len_trim**(3)](#len_trim)",

  "trim": "## trim\n\n### **Name**\n\n**trim** - \\[CHARACTER:MANIPULATION\\] Remove trailing blank characters from a string\n\n### **Synopsis**\n```fortran\n    result = trim(string)\n```\n```fortran\n     pure function trim(string) result(res)\n\n      character(len=*), intent(in) :: string\n      character(len=:), allocatable :: res  ! length = len_trim(string)\n```\n\n### **Characteristics**\n\n - **string** is a scalar of type character.\n - The result is of type character with the same kind as **string**.\n - The result length equals `len(string)` minus the number of trailing blanks.\n - This is a transformational function (not elemental).\n\n### **Description**\n\n **trim** returns the argument **string** with all trailing blank characters\n removed. Leading blanks are preserved. If the string is entirely blank,\n the result is a zero-length string.\n\n This function is commonly used for:\n - Preparing strings for concatenation without unwanted spaces\n - Creating clean output without trailing padding\n - Comparing strings without regard to trailing blanks\n - Reducing memory usage by removing unnecessary characters\n\n### **Options**\n\n- **string**\n  : The character string to be trimmed. May be of any character kind.\n  Must be a scalar value. Trailing blank characters (spaces) are removed\n  from the result.\n\n### **Result**\n\n  A character string of the same kind as **string** with trailing blanks\n  removed. The length of the result is `len(string)` minus the count of\n  trailing blank characters. If **string** contains only blanks, the result\n  is a zero-length string.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_trim\n  implicit none\n  character(len=20) :: str1, str2\n  character(len=50) :: combined\n  character(len=10) :: words(3)\n  integer :: i\n\n  ! Basic trimming\n  str1 = 'Hello'\n  str2 = 'World'\n  print '(A,A,A)', 'str1: [', str1, ']'\n  print '(A,A,A)', 'trim(str1): [', trim(str1), ']'\n\n  ! Without trim, concatenation includes trailing blanks\n  combined = str1 // str2\n  print '(A)', ''\n  print '(A,A,A)', 'str1 // str2: [', combined, ']'\n\n  ! With trim, trailing blanks are removed before concatenation\n  combined = trim(str1) // ' ' // trim(str2) // '!'\n  print '(A,A,A)', 'trim concat:  [', trim(combined), ']'\n\n  ! Length comparison\n  print '(A)', ''\n  print '(A,I0)', 'len(str1):       ', len(str1)\n  print '(A,I0)', 'len(trim(str1)): ', len(trim(str1))\n\n  ! Trimming an all-blank string\n  str1 = '                    '\n  print '(A)', ''\n  print '(A,I0)', 'len(trim(all blanks)): ', len(trim(str1))\n\n  ! Building sentences from word arrays\n  words(1) = 'Fortran'\n  words(2) = 'is'\n  words(3) = 'great'\n\n  print '(A)', ''\n  print '(A)', 'Building sentence from array:'\n  combined = ''\n  do i = 1, 3\n    if (i > 1) combined = trim(combined) // ' '\n    combined = trim(combined) // trim(words(i))\n  end do\n  print '(A,A)', '  Result: ', trim(combined)\n\n  ! Using trim in formatted output\n  print '(A)', ''\n  print '(A)', 'Formatted output:'\n  str1 = 'Name:'\n  str2 = 'John Doe'\n  print '(A,A,1X,A)', '  ', trim(str1), trim(str2)\n\n  ! Combining with adjustl for clean strings\n  str1 = '   Leading spaces   '\n  print '(A)', ''\n  print '(A,A,A)', 'Original:            [', str1, ']'\n  print '(A,A,A)', 'trim:                [', trim(str1), ']'\n  print '(A,A,A)', 'adjustl:             [', adjustl(str1), ']'\n  print '(A,A,A)', 'trim(adjustl):       [', trim(adjustl(str1)), ']'\n\nend program demo_trim\n```\nResults:\n```text\nstr1: [Hello               ]\ntrim(str1): [Hello]\n\nstr1 // str2: [Hello               World               ]\ntrim concat:  [Hello World!]\n\nlen(str1):       20\nlen(trim(str1)): 5\n\nlen(trim(all blanks)): 0\n\nBuilding sentence from array:\n  Result: Fortran is great\n\nFormatted output:\n  Name: John Doe\n\nOriginal:            [   Leading spaces   ]\ntrim:                [   Leading spaces]\nadjustl:             [Leading spaces      ]\ntrim(adjustl):       [Leading spaces]\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**adjustl**(3)](#adjustl),\n[**adjustr**(3)](#adjustr),\n[**len_trim**(3)](#len_trim)",

  "verify": "## verify\n\n### **Name**\n\n**verify** - \\[CHARACTER:MANIPULATION\\] Find first character not in a given set\n\n### **Synopsis**\n```fortran\n    result = verify(string, set)\n    result = verify(string, set, back)\n    result = verify(string, set, back, kind)\n```\n```fortran\n     elemental function verify(string, set, back, kind) result(res)\n\n      character(len=*), intent(in)           :: string\n      character(len=*), intent(in)           :: set\n      logical, intent(in), optional          :: back\n      integer, intent(in), optional          :: kind\n      integer(kind=KIND)                     :: res\n```\n\n### **Characteristics**\n\n - **string** is of type character.\n - **set** is of type character with the same kind as **string**.\n - **back** is of type logical (optional).\n - **kind** is a scalar integer constant expression (optional).\n - The result is of type integer with kind **kind** if present, else default.\n - This is an elemental function: it operates element-by-element on arrays.\n\n### **Description**\n\n **verify** searches **string** for the first character that is NOT\n contained in **set**. If **back** is present and true, the search\n proceeds from the end of the string toward the beginning, returning the\n position of the last character not in **set**.\n\n This is the complement of **scan**: while scan finds characters that ARE\n in a set, verify finds characters that are NOT in a set.\n\n This function is useful for:\n - Validating that strings contain only allowed characters\n - Finding invalid characters in input\n - Checking string format compliance\n - Locating non-conforming characters in data\n\n### **Options**\n\n- **string**\n  : The character string to be verified against **set**.\n\n- **set**\n  : The set of allowed characters. Every character in **string** should\n  be in this set for verify to return zero.\n\n- **back**\n  : Optional. If present and `.true.`, scan from the rightmost position\n  toward the left, returning the position of the last non-matching character.\n  Default is `.false.` (scan left to right).\n\n- **kind**\n  : Optional. An integer initialization expression indicating the kind\n  parameter of the result.\n\n### **Result**\n\n  An integer indicating the position of the first (or last if `back=.true.`)\n  character in **string** that is NOT in **set**. Returns zero if:\n  - All characters in **string** are present in **set**\n  - **string** is zero-length\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_verify\n  implicit none\n  character(len=50) :: str\n  character(len=*), parameter :: digits = '0123456789'\n  character(len=*), parameter :: alpha_lower = 'abcdefghijklmnopqrstuvwxyz'\n  character(len=*), parameter :: alpha_upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  character(len=*), parameter :: alpha = alpha_lower // alpha_upper\n  character(len=*), parameter :: alphanum = alpha // digits\n  integer :: pos\n\n  ! Verify string contains only digits\n  str = '12345'\n  pos = verify(str, digits)\n  if (pos == 0) then\n    print '(A,A,A)', '\"', trim(str), '\" contains only digits'\n  else\n    print '(A,A,A,I0)', '\"', trim(str), '\" has non-digit at position ', pos\n  end if\n\n  ! Find first non-digit character\n  str = '123abc456'\n  pos = verify(str, digits)\n  print '(A)', ''\n  print '(A,A,A)', 'String: \"', trim(str), '\"'\n  print '(A,I0,A,A)', '  First non-digit at position ', pos, ': \"', str(pos:pos), '\"'\n\n  ! Find last non-digit character\n  pos = verify(str, digits, back=.true.)\n  print '(A,I0,A,A)', '  Last non-digit at position ', pos, ': \"', str(pos:pos), '\"'\n\n  ! Validate lowercase-only input\n  str = 'hello'\n  if (verify(str, alpha_lower) == 0) then\n    print '(A)', ''\n    print '(A,A,A)', '\"', trim(str), '\" is all lowercase letters'\n  end if\n\n  ! Find invalid character in supposedly lowercase input\n  str = 'helloWorld'\n  pos = verify(str, alpha_lower)\n  if (pos > 0) then\n    print '(A)', ''\n    print '(A,A,A)', 'String: \"', trim(str), '\"'\n    print '(A,I0,A,A,A)', '  Invalid char at position ', pos, ': \"', str(pos:pos), '\"'\n  end if\n\n  ! Validate identifier format (alphanumeric + underscore, starts with letter)\n  str = 'var_name_1'\n  print '(A)', ''\n  print '(A,A,A)', 'Validating identifier: \"', trim(str), '\"'\n  if (verify(str(1:1), alpha) /= 0) then\n    print '(A)', '  Invalid: must start with a letter'\n  else if (verify(trim(str), alphanum // '_') /= 0) then\n    pos = verify(trim(str), alphanum // '_')\n    print '(A,I0,A,A,A)', '  Invalid char at ', pos, ': \"', str(pos:pos), '\"'\n  else\n    print '(A)', '  Valid identifier!'\n  end if\n\n  ! Validate phone number format (digits, dashes, parentheses, spaces)\n  str = '(555) 123-4567'\n  print '(A)', ''\n  print '(A,A,A)', 'Phone number: \"', trim(str), '\"'\n  pos = verify(trim(str), digits // '()-. ')\n  if (pos == 0) then\n    print '(A)', '  Valid phone number format'\n  else\n    print '(A,I0,A,A,A)', '  Invalid char at ', pos, ': \"', str(pos:pos), '\"'\n  end if\n\nend program demo_verify\n```\nResults:\n```text\n\"12345\" contains only digits\n\nString: \"123abc456\"\n  First non-digit at position 4: \"a\"\n  Last non-digit at position 6: \"c\"\n\n\"hello\" is all lowercase letters\n\nString: \"helloWorld\"\n  Invalid char at position 6: \"W\"\n\nValidating identifier: \"var_name_1\"\n  Valid identifier!\n\nPhone number: \"(555) 123-4567\"\n  Valid phone number format\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**scan**(3)](#scan),\n[**index**(3)](#index),\n[**len_trim**(3)](#len_trim)"
}
