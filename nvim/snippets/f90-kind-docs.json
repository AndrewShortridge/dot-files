{
  "kind": "## kind\n\n### **Name**\n\n**kind** - \\[TYPE:KIND\\] Query the kind type parameter of a variable\n\n### **Synopsis**\n```fortran\n    result = kind(x)\n```\n```fortran\n     integer function kind(x)\n\n      type(*), intent(in) :: x(..)\n```\n\n### **Characteristics**\n\n - **x** may be any intrinsic type: INTEGER, REAL, COMPLEX, LOGICAL, or CHARACTER.\n - **x** may be a scalar or an array of any rank.\n - The value of **x** is not used; only its type and kind are queried.\n - The result is a default INTEGER scalar.\n\n### **Description**\n\n **kind** is an inquiry function that returns the kind type parameter value\n of its argument. The kind type parameter is a non-negative integer that\n characterizes the representation of a data type. Different kinds of the\n same intrinsic type may have different precisions, ranges, or storage sizes.\n\n The kind system in Fortran allows portable programming by enabling code\n to query and select appropriate numeric precision without relying on\n processor-dependent assumptions about storage sizes. Rather than assuming\n that REAL uses 4 bytes, portable code uses kind functions to ensure the\n required precision is available.\n\n Note that kind values are processor-dependent. A kind value of 4 on one\n processor may represent single precision, while on another processor the\n same precision might use a different kind value. This is why the\n SELECTED_INT_KIND and SELECTED_REAL_KIND functions are preferred for\n portable kind selection.\n\n### **Options**\n\n- **x**\n  : A variable, constant, or expression of any intrinsic type. May be\n  INTEGER, REAL, COMPLEX, LOGICAL, or CHARACTER. The actual value is\n  not examined; only the type and kind information is used.\n\n### **Result**\n\n  The result is a default integer scalar containing the kind type\n  parameter value of the argument. Common kind values include:\n\n  - INTEGER: typically 1, 2, 4, or 8 (bytes)\n  - REAL: typically 4, 8, or 16 (bytes)\n  - COMPLEX: typically 4, 8, or 16 (component size)\n  - LOGICAL: typically 1, 2, 4, or 8 (bytes)\n  - CHARACTER: typically 1 (default), 4 (UCS-4/ISO 10646)\n\n  However, these values are not mandated by the standard and may vary\n  between compilers. Always use SELECTED_INT_KIND or SELECTED_REAL_KIND\n  for portable kind selection.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_kind\n  use iso_fortran_env, only: int8, int16, int32, int64, &\n                             real32, real64, real128\n  implicit none\n\n  ! Query kind of various intrinsic types\n  print '(A)', 'Kind values for default types:'\n  print '(A,I0)', '  Default INTEGER:   ', kind(0)\n  print '(A,I0)', '  Default REAL:      ', kind(0.0)\n  print '(A,I0)', '  Default COMPLEX:   ', kind((0.0, 0.0))\n  print '(A,I0)', '  Default LOGICAL:   ', kind(.true.)\n  print '(A,I0)', '  Default CHARACTER: ', kind('A')\n\n  print '(A)', ''\n  print '(A)', 'Kind values for explicit kinds:'\n  print '(A,I0)', '  INTEGER(int8):   ', kind(0_int8)\n  print '(A,I0)', '  INTEGER(int16):  ', kind(0_int16)\n  print '(A,I0)', '  INTEGER(int32):  ', kind(0_int32)\n  print '(A,I0)', '  INTEGER(int64):  ', kind(0_int64)\n\n  print '(A)', ''\n  print '(A,I0)', '  REAL(real32):    ', kind(0.0_real32)\n  print '(A,I0)', '  REAL(real64):    ', kind(0.0_real64)\n  print '(A,I0)', '  REAL(real128):   ', kind(0.0_real128)\n\n  ! Demonstrate that value does not matter\n  print '(A)', ''\n  print '(A)', 'Value does not affect result:'\n  print '(A,L1)', '  kind(0) == kind(huge(0)): ', kind(0) == kind(huge(0))\n  print '(A,L1)', '  kind(0.0) == kind(1.0e30): ', kind(0.0) == kind(1.0e30)\n\n  ! Using kind for portable declarations\n  call demonstrate_portable_kinds()\n\ncontains\n\n  subroutine demonstrate_portable_kinds()\n    integer, parameter :: wp = kind(1.0d0)  ! Working precision\n    real(wp) :: x\n\n    x = 3.141592653589793_wp\n    print '(A)', ''\n    print '(A)', 'Using kind for portable working precision:'\n    print '(A,I0)', '  Working precision kind: ', wp\n    print '(A,G0)', '  Pi value: ', x\n  end subroutine\n\nend program demo_kind\n```\nResults:\n```text\nKind values for default types:\n  Default INTEGER:   4\n  Default REAL:      4\n  Default COMPLEX:   4\n  Default LOGICAL:   4\n  Default CHARACTER: 1\n\nKind values for explicit kinds:\n  INTEGER(int8):   1\n  INTEGER(int16):  2\n  INTEGER(int32):  4\n  INTEGER(int64):  8\n\n  REAL(real32):    4\n  REAL(real64):    8\n  REAL(real128):   16\n\nValue does not affect result:\n  kind(0) == kind(huge(0)): T\n  kind(0.0) == kind(1.0e30): T\n\nUsing kind for portable working precision:\n  Working precision kind: 8\n  Pi value: 3.141592653589793\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**selected_int_kind**(3)](#selected_int_kind),\n[**selected_real_kind**(3)](#selected_real_kind),\n[**precision**(3)](#precision),\n[**range**(3)](#range),\n[**digits**(3)](#digits),\n[**epsilon**(3)](#epsilon),\n[**huge**(3)](#huge),\n[**tiny**(3)](#tiny)",
  "selected_int_kind": "## selected_int_kind\n\n### **Name**\n\n**selected_int_kind** - \\[TYPE:KIND\\] Select integer kind for specified decimal range\n\n### **Synopsis**\n```fortran\n    result = selected_int_kind(r)\n```\n```fortran\n     integer function selected_int_kind(r)\n\n      integer, intent(in) :: r\n```\n\n### **Characteristics**\n\n - **r** is a scalar INTEGER specifying the desired decimal exponent range.\n - The result is a default INTEGER scalar.\n - This is a transformational function.\n\n### **Description**\n\n **selected_int_kind** returns the kind type parameter value for the smallest\n integer type that can represent all integer values n where:\n\n     -10^r < n < 10^r\n\n This function enables portable selection of integer kinds based on the\n required range of values, rather than relying on processor-dependent\n kind values. By specifying the number of decimal digits required, code\n can automatically adapt to different hardware architectures.\n\n For example, `selected_int_kind(9)` requests a kind that can hold values\n up to at least 999,999,999, which typically corresponds to a 32-bit\n integer. Using `selected_int_kind(18)` requests a kind for values up to\n at least 10^18-1, typically requiring a 64-bit integer.\n\n If multiple integer kinds satisfy the requirement, the one with the\n smallest decimal exponent range is returned. If multiple kinds have the\n same range, the smallest kind value is returned.\n\n### **Options**\n\n- **r**\n  : A scalar integer specifying the required decimal exponent range.\n  The function returns a kind that can represent all integers n\n  satisfying -10^r < n < 10^r. Typical useful values:\n  - r=2: values up to 99\n  - r=4: values up to 9,999\n  - r=9: values up to ~10^9 (32-bit)\n  - r=18: values up to ~10^18 (64-bit)\n\n### **Result**\n\n  The result is an integer kind type parameter value, or -1 if no\n  suitable integer kind exists on the processor.\n\n  Return values:\n  - **positive integer**: The kind parameter for the smallest integer\n    type supporting the requested range.\n  - **-1**: No integer type on the processor can represent the requested\n    range. This may occur for very large values of r.\n\n  Typical correspondences (processor-dependent):\n  - r <= 2:  kind for 8-bit integers\n  - r <= 4:  kind for 16-bit integers\n  - r <= 9:  kind for 32-bit integers\n  - r <= 18: kind for 64-bit integers\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_selected_int_kind\n  implicit none\n\n  ! Define portable integer kinds\n  integer, parameter :: i1 = selected_int_kind(2)   ! at least -99 to 99\n  integer, parameter :: i2 = selected_int_kind(4)   ! at least -9999 to 9999\n  integer, parameter :: i4 = selected_int_kind(9)   ! at least 9 digits\n  integer, parameter :: i8 = selected_int_kind(18)  ! at least 18 digits\n\n  ! Declare variables with specific precision\n  integer(kind=i1) :: small_int\n  integer(kind=i2) :: medium_int\n  integer(kind=i4) :: large_int\n  integer(kind=i8) :: very_large_int\n\n  print '(A)', 'Selected integer kinds and their ranges:'\n  print '(A)', ''\n\n  print '(A,I0)', 'selected_int_kind(2)  = ', i1\n  print '(A,I0,A,I0)', '  Range: ', -huge(small_int), ' to ', huge(small_int)\n  print '(A)', ''\n\n  print '(A,I0)', 'selected_int_kind(4)  = ', i2\n  print '(A,I0,A,I0)', '  Range: ', -huge(medium_int), ' to ', huge(medium_int)\n  print '(A)', ''\n\n  print '(A,I0)', 'selected_int_kind(9)  = ', i4\n  print '(A,I0,A,I0)', '  Range: ', -huge(large_int), ' to ', huge(large_int)\n  print '(A)', ''\n\n  print '(A,I0)', 'selected_int_kind(18) = ', i8\n  print '(A,I0,A,I0)', '  Range: ', -huge(very_large_int), ' to ', &\n        huge(very_large_int)\n\n  ! Verify the selected kinds meet requirements\n  print '(A)', ''\n  print '(A)', 'Verification that kinds meet requirements:'\n  print '(A,L1)', '  huge(i1) >= 10**2-1:  ', huge(small_int) >= 10_i1**2-1\n  print '(A,L1)', '  huge(i2) >= 10**4-1:  ', huge(medium_int) >= 10_i2**4-1\n  print '(A,L1)', '  huge(i4) >= 10**9-1:  ', huge(large_int) >= 10_i4**9-1\n  print '(A,L1)', '  huge(i8) >= 10**18-1: ', huge(very_large_int) >= 10_i8**18-1\n\n  ! Check for unavailable kinds\n  print '(A)', ''\n  print '(A)', 'Testing unavailable range:'\n  print '(A,I0)', '  selected_int_kind(100) = ', selected_int_kind(100)\n\n  ! Practical example: factorial calculation\n  call factorial_example()\n\ncontains\n\n  subroutine factorial_example()\n    integer, parameter :: fac_kind = selected_int_kind(18)\n    integer(fac_kind) :: factorial\n    integer :: n\n\n    print '(A)', ''\n    print '(A)', 'Factorial calculation with 64-bit integers:'\n    factorial = 1\n    do n = 1, 20\n      factorial = factorial * n\n      print '(A,I2,A,I0)', '  ', n, '! = ', factorial\n    end do\n  end subroutine\n\nend program demo_selected_int_kind\n```\nResults:\n```text\nSelected integer kinds and their ranges:\n\nselected_int_kind(2)  = 1\n  Range: -127 to 127\n\nselected_int_kind(4)  = 2\n  Range: -32767 to 32767\n\nselected_int_kind(9)  = 4\n  Range: -2147483647 to 2147483647\n\nselected_int_kind(18) = 8\n  Range: -9223372036854775807 to 9223372036854775807\n\nVerification that kinds meet requirements:\n  huge(i1) >= 10**2-1:  T\n  huge(i2) >= 10**4-1:  T\n  huge(i4) >= 10**9-1:  T\n  huge(i8) >= 10**18-1: T\n\nTesting unavailable range:\n  selected_int_kind(100) = -1\n\nFactorial calculation with 64-bit integers:\n   1! = 1\n   2! = 2\n   3! = 6\n   4! = 24\n   5! = 120\n   6! = 720\n   7! = 5040\n   8! = 40320\n   9! = 362880\n  10! = 3628800\n  11! = 39916800\n  12! = 479001600\n  13! = 6227020800\n  14! = 87178291200\n  15! = 1307674368000\n  16! = 20922789888000\n  17! = 355687428096000\n  18! = 6402373705728000\n  19! = 121645100408832000\n  20! = 2432902008176640000\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**kind**(3)](#kind),\n[**selected_real_kind**(3)](#selected_real_kind),\n[**huge**(3)](#huge),\n[**range**(3)](#range),\n[**digits**(3)](#digits),\n[**bit_size**(3)](#bit_size)",
  "selected_real_kind": "## selected_real_kind\n\n### **Name**\n\n**selected_real_kind** - \\[TYPE:KIND\\] Select real kind for specified precision and range\n\n### **Synopsis**\n```fortran\n    result = selected_real_kind([p] [,r] [,radix])\n```\n```fortran\n     integer function selected_real_kind(p, r, radix)\n\n      integer, intent(in), optional :: p\n      integer, intent(in), optional :: r\n      integer, intent(in), optional :: radix\n```\n\n### **Characteristics**\n\n - **p** is an optional scalar INTEGER specifying minimum decimal precision.\n - **r** is an optional scalar INTEGER specifying minimum decimal exponent range.\n - **radix** is an optional scalar INTEGER specifying the desired radix (Fortran 2008).\n - At least one of **p** or **r** must be present (before Fortran 2008).\n - The result is a default INTEGER scalar.\n - This is a transformational function.\n\n### **Description**\n\n **selected_real_kind** returns the kind type parameter value for a real\n data type with at least **p** decimal digits of precision and a decimal\n exponent range of at least **r**. This function is fundamental for writing\n portable numerical code that requires specific precision guarantees.\n\n The precision **p** specifies the minimum number of significant decimal\n digits. The range **r** specifies that the real type must be able to\n represent values from 10^(-r) to 10^(+r).\n\n For example, `selected_real_kind(6, 37)` requests single precision\n (approximately 6 significant digits, exponent range of about 10^-37 to\n 10^37), while `selected_real_kind(15, 307)` requests double precision.\n\n If multiple real kinds satisfy the requirements, the one with the\n smallest decimal precision is returned. If there are still multiple\n candidates, the smallest kind value is chosen.\n\n### **Options**\n\n- **p**\n  : Optional. Minimum decimal precision (number of significant digits).\n  If absent, treated as zero. Common values:\n  - p=6: single precision (~7 decimal digits)\n  - p=15: double precision (~15-16 decimal digits)\n  - p=33: quadruple precision (~33-34 decimal digits)\n\n- **r**\n  : Optional. Minimum decimal exponent range. The resulting type must\n  represent values from 10^(-r) to 10^(+r). If absent, treated as zero.\n  Common values:\n  - r=37: single precision range\n  - r=307: double precision range\n  - r=4931: quadruple precision range\n\n- **radix**\n  : Optional (Fortran 2008). The desired radix (base) for the real\n  representation. Almost all modern systems use radix 2 (binary).\n  If specified, the returned kind must have this radix.\n\n### **Result**\n\n  The result is an integer kind type parameter value, or a negative\n  value if no suitable real kind exists:\n\n  Return values:\n  - **positive integer**: The kind parameter for a real type meeting\n    all specified requirements.\n  - **-1**: Precision **p** is not achievable, but **r** (and **radix**)\n    requirements can be met.\n  - **-2**: Exponent range **r** is not achievable, but **p** (and\n    **radix**) requirements can be met.\n  - **-3**: Neither **p** nor **r** can be achieved (both fail), but\n    **radix** requirement can be met.\n  - **-4**: The **radix** requirement can be met, but not both **p**\n    and **r** together (one or the other fails).\n  - **-5**: No real type exists with the specified **radix**.\n\n  Typical correspondences (processor-dependent):\n  - p=6, r=37:   single precision (REAL*4)\n  - p=15, r=307: double precision (REAL*8)\n  - p=33, r=4931: quadruple precision (REAL*16, if available)\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_selected_real_kind\n  implicit none\n\n  ! Define portable real kinds by precision and range\n  integer, parameter :: sp = selected_real_kind(6, 37)    ! Single\n  integer, parameter :: dp = selected_real_kind(15, 307)  ! Double\n  integer, parameter :: qp = selected_real_kind(33, 4931) ! Quad\n\n  ! Alternative definitions using only precision\n  integer, parameter :: r6  = selected_real_kind(p=6)\n  integer, parameter :: r15 = selected_real_kind(p=15)\n\n  ! Alternative definitions using only range\n  integer, parameter :: rng300 = selected_real_kind(r=300)\n\n  ! Declare variables\n  real(sp) :: single_var\n  real(dp) :: double_var\n\n  print '(A)', 'Selected real kinds:'\n  print '(A,I0)', '  Single precision (p=6, r=37):    ', sp\n  print '(A,I0)', '  Double precision (p=15, r=307):  ', dp\n  print '(A,I0)', '  Quad precision (p=33, r=4931):   ', qp\n  print '(A)', ''\n\n  print '(A)', 'Kind properties:'\n  print '(A)', ''\n  print '(A,I0)', 'Single precision (kind=', sp, '):'\n  print '(A,I0)', '  Precision: ', precision(single_var)\n  print '(A,I0)', '  Range:     ', range(single_var)\n  print '(A,ES15.8)', '  Epsilon:   ', epsilon(single_var)\n  print '(A,ES15.8)', '  Tiny:      ', tiny(single_var)\n  print '(A,ES15.8)', '  Huge:      ', huge(single_var)\n  print '(A)', ''\n\n  print '(A,I0)', 'Double precision (kind=', dp, '):'\n  print '(A,I0)', '  Precision: ', precision(double_var)\n  print '(A,I0)', '  Range:     ', range(double_var)\n  print '(A,ES23.16)', '  Epsilon:   ', epsilon(double_var)\n  print '(A,ES23.16)', '  Tiny:      ', tiny(double_var)\n  print '(A,ES23.16)', '  Huge:      ', huge(double_var)\n  print '(A)', ''\n\n  ! Demonstrate error codes for unavailable kinds\n  print '(A)', 'Testing unavailable kind requests:'\n  print '(A,I0)', '  selected_real_kind(p=50):     ', selected_real_kind(p=50)\n  print '(A,I0)', '  selected_real_kind(r=10000):  ', selected_real_kind(r=10000)\n  print '(A,I0)', '  selected_real_kind(50,10000): ', selected_real_kind(50,10000)\n  print '(A)', ''\n\n  ! Practical numerical computation example\n  call numerical_example()\n\ncontains\n\n  subroutine numerical_example()\n    ! Working precision for numerical algorithms\n    integer, parameter :: wp = selected_real_kind(15, 307)\n    real(wp), parameter :: pi = 3.1415926535897932384626433832795_wp\n    real(wp) :: x, y, result\n    integer :: i\n\n    print '(A)', 'Numerical computation with working precision:'\n    print '(A,I0)', '  Working precision kind: ', wp\n    print '(A,G0)', '  Pi constant: ', pi\n    print '(A)', ''\n\n    ! Compute sin(x) for small x to verify precision\n    print '(A)', '  Verifying sin(x) ~ x for small x:'\n    x = 1.0e-10_wp\n    print '(A,ES23.16)', '    x        = ', x\n    print '(A,ES23.16)', '    sin(x)   = ', sin(x)\n    print '(A,ES23.16)', '    sin(x)-x = ', sin(x) - x\n    print '(A)', ''\n\n    ! Demonstrate range with exponential\n    print '(A)', '  Large range demonstration:'\n    x = 100.0_wp\n    y = exp(x)\n    print '(A,ES23.16)', '    exp(100) = ', y\n    x = -100.0_wp\n    y = exp(x)\n    print '(A,ES23.16)', '    exp(-100) = ', y\n  end subroutine\n\nend program demo_selected_real_kind\n```\nResults:\n```text\nSelected real kinds:\n  Single precision (p=6, r=37):    4\n  Double precision (p=15, r=307):  8\n  Quad precision (p=33, r=4931):   16\n\nKind properties:\n\nSingle precision (kind=4):\n  Precision: 6\n  Range:     37\n  Epsilon:    1.19209290E-07\n  Tiny:       1.17549435E-38\n  Huge:       3.40282347E+38\n\nDouble precision (kind=8):\n  Precision: 15\n  Range:     307\n  Epsilon:    2.2204460492503131E-16\n  Tiny:       2.2250738585072014E-308\n  Huge:       1.7976931348623157E+308\n\nTesting unavailable kind requests:\n  selected_real_kind(p=50):     -1\n  selected_real_kind(r=10000):  -2\n  selected_real_kind(50,10000): -3\n\nNumerical computation with working precision:\n  Working precision kind: 8\n  Pi constant: 3.1415926535897931\n\n  Verifying sin(x) ~ x for small x:\n    x        =  1.0000000000000000E-10\n    sin(x)   =  1.0000000000000000E-10\n    sin(x)-x =  0.0000000000000000E+00\n\n  Large range demonstration:\n    exp(100) =  2.6881171418161356E+43\n    exp(-100) =  3.7200759760208361E-44\n```\n\n### **Standard**\n\nFortran 90 (p, r arguments); Fortran 2008 (radix argument)\n\n### **See Also**\n\n[**kind**(3)](#kind),\n[**selected_int_kind**(3)](#selected_int_kind),\n[**precision**(3)](#precision),\n[**range**(3)](#range),\n[**epsilon**(3)](#epsilon),\n[**huge**(3)](#huge),\n[**tiny**(3)](#tiny),\n[**digits**(3)](#digits),\n[**radix**(3)](#radix)"
}
