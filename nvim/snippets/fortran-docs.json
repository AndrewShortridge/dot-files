{
  "bindc": "## bind_c_function\n\n### **Name**\n\n**bind_c_function** - \\[INTEROP:C_BINDING\\] Declare a Fortran function interoperable with C\n\n### **Synopsis**\n```fortran\n    result = fortran_func(arg1, arg2)\n```\n```fortran\n     function fortran_func(arg1, arg2) result(res) bind(c, name='c_func_name')\n\n      use iso_c_binding, only: c_int, c_double, c_ptr\n      integer(c_int), intent(in), value :: arg1\n      real(c_double), intent(in)        :: arg2\n      integer(c_int)                    :: res\n```\n\n### **Characteristics**\n\n - **bind(c)** makes the function callable from C with C calling conventions.\n - **name='c_func_name'** specifies the external C name (optional, defaults to lowercase Fortran name).\n - All dummy arguments must be interoperable C types from ISO_C_BINDING.\n - Arguments passed by value use the **value** attribute.\n - Arguments passed by reference (C pointers) omit the value attribute.\n - The result type must be an interoperable scalar type or c_ptr.\n\n### **Description**\n\n **bind_c_function** creates a Fortran function that can be called from C code\n or that implements a C function interface. The BIND(C) attribute ensures the\n function uses C calling conventions and name mangling. The NAME= specifier\n allows controlling the exact symbol name visible to the C linker.\n\n### **Options**\n\n- **bind(c)**\n  : Required attribute that specifies C interoperability. The function will\n  use C calling conventions and be callable from C code.\n\n- **name='c_name'**\n  : Optional. Specifies the exact C symbol name for the function. If omitted,\n  the Fortran name is used in lowercase. Use this to match existing C APIs\n  or avoid name conflicts.\n\n- **value**\n  : Attribute for dummy arguments that should be passed by value (like C\n  scalar arguments). Without this attribute, arguments are passed by reference.\n\n- **intent(in/out/inout)**\n  : Specifies argument intent. For value arguments, only intent(in) is valid.\n  For reference arguments, any intent may be used.\n\n### **Result**\n\n  The function result must be an interoperable type: integer(c_int),\n  real(c_float), real(c_double), type(c_ptr), type(c_funptr), or other\n  C-compatible types. The result is returned to C as specified by the\n  platform's C ABI.\n\n### **Examples**\n\nSample program (Fortran side):\n```fortran\nmodule c_interface_module\n  use iso_c_binding\n  implicit none\ncontains\n\n  ! Function callable from C as: int add_integers(int a, int b)\n  function add_integers(a, b) result(sum) bind(c, name='add_integers')\n    integer(c_int), intent(in), value :: a, b\n    integer(c_int) :: sum\n    sum = a + b\n  end function add_integers\n\n  ! Function callable from C as: double compute_distance(double* x, double* y, int n)\n  function compute_distance(x, y, n) result(dist) bind(c, name='compute_distance')\n    integer(c_int), intent(in), value :: n\n    real(c_double), intent(in) :: x(n), y(n)\n    real(c_double) :: dist\n    dist = sqrt(sum((x - y)**2))\n  end function compute_distance\n\n  ! Function returning a C pointer\n  function get_data_pointer(arr, n) result(ptr) bind(c, name='get_data_pointer')\n    integer(c_int), intent(in), value :: n\n    real(c_double), intent(in), target :: arr(n)\n    type(c_ptr) :: ptr\n    ptr = c_loc(arr(1))\n  end function get_data_pointer\n\nend module c_interface_module\n\nprogram demo_bind_c_function\n  use c_interface_module\n  use iso_c_binding\n  implicit none\n\n  integer(c_int) :: result_int\n  real(c_double) :: x(3), y(3), dist\n\n  ! Test the functions from Fortran (they work both ways)\n  result_int = add_integers(10_c_int, 25_c_int)\n  print '(A,I0)', 'add_integers(10, 25) = ', result_int\n\n  x = [1.0_c_double, 2.0_c_double, 3.0_c_double]\n  y = [4.0_c_double, 6.0_c_double, 8.0_c_double]\n  dist = compute_distance(x, y, 3_c_int)\n  print '(A,F10.6)', 'Distance between vectors: ', dist\n\nend program demo_bind_c_function\n```\n\nCorresponding C header:\n```c\n/* c_interface.h */\n#ifndef C_INTERFACE_H\n#define C_INTERFACE_H\n\nint add_integers(int a, int b);\ndouble compute_distance(double* x, double* y, int n);\ndouble* get_data_pointer(double* arr, int n);\n\n#endif\n```\n\nResults:\n```text\nadd_integers(10, 25) = 35\nDistance between vectors:   7.071068\n```\n\n### **Standard**\n\nFortran 2003 (ISO/IEC 1539-1:2004)\n\n**Compatibility Notes:**\n- gfortran 4.3+, Intel Fortran 10.0+, NAG 5.1+\n- Requires USE ISO_C_BINDING for interoperable types\n- C function names are case-sensitive\n\n### **See Also**\n\n[**bind_c_subroutine**(3)](#bind_c_subroutine),\n[**bind_c_type**(3)](#bind_c_type),\n[**c_loc**(3)](#c_loc),\n[**c_f_pointer**(3)](#c_f_pointer),\n[**iso_c_binding**(3)](#iso_c_binding)",
  "assertsimple": "## assert_simple\n\n### **Name**\n\n**assert_simple** - \\[ERROR:HANDLING\\] Simple assertion that halts execution if condition is false\n\n### **Synopsis**\n```fortran\n    if (.not. condition) stop 'message'\n```\n```fortran\n     ! Simple assertion pattern\n\n      if (.not. (condition)) stop 'Assertion failed'\n```\n\n### **Characteristics**\n\n - Compact one-line assertion pattern.\n - Uses **stop** for immediate program termination.\n - Provides basic error message on failure.\n - Simple to use but less informative than full assertion pattern.\n\n### **Description**\n\n **assert_simple** provides a compact assertion pattern using a single-line\n if statement with stop. This is useful for quick checks where detailed\n error reporting is not required. For production code, consider using the\n full assertion pattern with error stop and descriptive messages.\n\n### **Options**\n\n- **condition**\n  : A logical expression that should evaluate to .true. under normal\n  circumstances. If .false., the program terminates.\n\n- **message**\n  : A character constant providing a brief description of the assertion.\n\n### **Result**\n\n  If the condition is true, execution continues. If false, the program\n  terminates with the message printed to standard output.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_assert_simple\nimplicit none\n  real :: x, y\n  integer :: n\n\n  ! Quick positivity check\n  x = 5.0\n  if (.not. (x > 0.0)) stop 'x must be positive'\n\n  ! Range check\n  n = 50\n  if (.not. (n >= 1 .and. n <= 100)) stop 'n out of range'\n\n  ! Non-zero check\n  y = 2.0\n  if (.not. (y /= 0.0)) stop 'y cannot be zero'\n\n  ! All checks passed\n  print '(A,F8.2)', 'x = ', x\n  print '(A,I0)',   'n = ', n\n  print '(A,F8.2)', 'y = ', y\n  print '(A)', 'All assertions passed.'\n\nend program demo_assert_simple\n```\nResults:\n```text\nx =     5.00\nn = 50\ny =     2.00\nAll assertions passed.\n```\n\n### **Standard**\n\nFortran 77 (stop), Fortran 2003 (stop with message)\n\n**Compatibility Notes:**\n- gfortran 4.5+, Intel Fortran 11.0+, NAG 5.3+\n- ERROR STOP provides termination with message\n- Use for runtime invariant checking\n\n### **See Also**\n\n[**stop**(3)](#stop),\n[**error_stop**(3)](#error_stop),\n[**assert**(3)](#assert)",
  "c_function": "## bind_c_function\n\n### **Name**\n\n**bind_c_function** - \\[INTEROP:C_BINDING\\] Declare a Fortran function interoperable with C\n\n### **Synopsis**\n```fortran\n    result = fortran_func(arg1, arg2)\n```\n```fortran\n     function fortran_func(arg1, arg2) result(res) bind(c, name='c_func_name')\n\n      use iso_c_binding, only: c_int, c_double, c_ptr\n      integer(c_int), intent(in), value :: arg1\n      real(c_double), intent(in)        :: arg2\n      integer(c_int)                    :: res\n```\n\n### **Characteristics**\n\n - **bind(c)** makes the function callable from C with C calling conventions.\n - **name='c_func_name'** specifies the external C name (optional, defaults to lowercase Fortran name).\n - All dummy arguments must be interoperable C types from ISO_C_BINDING.\n - Arguments passed by value use the **value** attribute.\n - Arguments passed by reference (C pointers) omit the value attribute.\n - The result type must be an interoperable scalar type or c_ptr.\n\n### **Description**\n\n **bind_c_function** creates a Fortran function that can be called from C code\n or that implements a C function interface. The BIND(C) attribute ensures the\n function uses C calling conventions and name mangling. The NAME= specifier\n allows controlling the exact symbol name visible to the C linker.\n\n### **Options**\n\n- **bind(c)**\n  : Required attribute that specifies C interoperability. The function will\n  use C calling conventions and be callable from C code.\n\n- **name='c_name'**\n  : Optional. Specifies the exact C symbol name for the function. If omitted,\n  the Fortran name is used in lowercase. Use this to match existing C APIs\n  or avoid name conflicts.\n\n- **value**\n  : Attribute for dummy arguments that should be passed by value (like C\n  scalar arguments). Without this attribute, arguments are passed by reference.\n\n- **intent(in/out/inout)**\n  : Specifies argument intent. For value arguments, only intent(in) is valid.\n  For reference arguments, any intent may be used.\n\n### **Result**\n\n  The function result must be an interoperable type: integer(c_int),\n  real(c_float), real(c_double), type(c_ptr), type(c_funptr), or other\n  C-compatible types. The result is returned to C as specified by the\n  platform's C ABI.\n\n### **Examples**\n\nSample program (Fortran side):\n```fortran\nmodule c_interface_module\n  use iso_c_binding\n  implicit none\ncontains\n\n  ! Function callable from C as: int add_integers(int a, int b)\n  function add_integers(a, b) result(sum) bind(c, name='add_integers')\n    integer(c_int), intent(in), value :: a, b\n    integer(c_int) :: sum\n    sum = a + b\n  end function add_integers\n\n  ! Function callable from C as: double compute_distance(double* x, double* y, int n)\n  function compute_distance(x, y, n) result(dist) bind(c, name='compute_distance')\n    integer(c_int), intent(in), value :: n\n    real(c_double), intent(in) :: x(n), y(n)\n    real(c_double) :: dist\n    dist = sqrt(sum((x - y)**2))\n  end function compute_distance\n\n  ! Function returning a C pointer\n  function get_data_pointer(arr, n) result(ptr) bind(c, name='get_data_pointer')\n    integer(c_int), intent(in), value :: n\n    real(c_double), intent(in), target :: arr(n)\n    type(c_ptr) :: ptr\n    ptr = c_loc(arr(1))\n  end function get_data_pointer\n\nend module c_interface_module\n\nprogram demo_bind_c_function\n  use c_interface_module\n  use iso_c_binding\n  implicit none\n\n  integer(c_int) :: result_int\n  real(c_double) :: x(3), y(3), dist\n\n  ! Test the functions from Fortran (they work both ways)\n  result_int = add_integers(10_c_int, 25_c_int)\n  print '(A,I0)', 'add_integers(10, 25) = ', result_int\n\n  x = [1.0_c_double, 2.0_c_double, 3.0_c_double]\n  y = [4.0_c_double, 6.0_c_double, 8.0_c_double]\n  dist = compute_distance(x, y, 3_c_int)\n  print '(A,F10.6)', 'Distance between vectors: ', dist\n\nend program demo_bind_c_function\n```\n\nCorresponding C header:\n```c\n/* c_interface.h */\n#ifndef C_INTERFACE_H\n#define C_INTERFACE_H\n\nint add_integers(int a, int b);\ndouble compute_distance(double* x, double* y, int n);\ndouble* get_data_pointer(double* arr, int n);\n\n#endif\n```\n\nResults:\n```text\nadd_integers(10, 25) = 35\nDistance between vectors:   7.071068\n```\n\n### **Standard**\n\nFortran 2003 (ISO/IEC 1539-1:2004)\n\n**Compatibility Notes:**\n- gfortran 4.3+, Intel Fortran 10.0+, NAG 5.1+\n- Requires USE ISO_C_BINDING for interoperable types\n- C function names are case-sensitive\n\n### **See Also**\n\n[**bind_c_subroutine**(3)](#bind_c_subroutine),\n[**bind_c_type**(3)](#bind_c_type),\n[**c_loc**(3)](#c_loc),\n[**c_f_pointer**(3)](#c_f_pointer),\n[**iso_c_binding**(3)](#iso_c_binding)",
  "elementalsub": "## elemental_subroutine\n\n### **Name**\n\n**elemental_subroutine** - \\[PROCEDURE:ELEMENTAL\\] Define an elemental subroutine that operates element-wise\n\n### **Synopsis**\n```fortran\n    call elemental_sub(array1, array2, result)\n```\n```fortran\n     elemental subroutine sub_name(arg1, arg2, result)\n\n      type, intent(in)  :: arg1, arg2\n      type, intent(out) :: result\n```\n\n### **Characteristics**\n\n - Declared with **ELEMENTAL** prefix.\n - All dummy arguments must be scalar.\n - When called with array arguments, operates element-wise.\n - Must be PURE (no side effects, no I/O).\n - Cannot have pointer, allocatable, or procedure arguments.\n\n### **Description**\n\n **elemental_subroutine** defines a subroutine that operates on scalar\n arguments but can be called with array arguments. When called with arrays,\n the subroutine is applied element-by-element. This enables writing scalar\n algorithms that automatically work on arrays of any shape.\n\n### **Options**\n\n- **ELEMENTAL**\n  : Required prefix indicating the subroutine operates element-wise.\n\n- **PURE**\n  : Implied by ELEMENTAL. The subroutine must have no side effects.\n\n- **IMPURE ELEMENTAL**\n  : Fortran 2008 allows elemental procedures with side effects using this\n  combined prefix.\n\n### **Result**\n\n  When called with array arguments, each element is processed independently.\n  The result array has the same shape as the input arrays.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_elemental_subroutine\nimplicit none\n  real :: a(5), b(5), c(5)\n  real :: x, y, z\n\n  ! Initialize arrays\n  a = [1.0, 2.0, 3.0, 4.0, 5.0]\n  b = [2.0, 2.0, 2.0, 2.0, 2.0]\n\n  ! Call elemental subroutine with arrays\n  call scale_and_add(a, b, c)\n  print '(A,5F8.2)', 'Array result: ', c\n\n  ! Call with scalars\n  call scale_and_add(3.0, 4.0, z)\n  print '(A,F8.2)', 'Scalar result: ', z\n\n  ! Mixed scalar/array (scalar is broadcast)\n  call scale_and_add(a, 10.0, c)\n  print '(A,5F8.2)', 'Broadcast result: ', c\n\n  ! Complex example: normalize to range [0,1]\n  a = [10.0, 20.0, 30.0, 40.0, 50.0]\n  call normalize_range(a, 10.0, 50.0, c)\n  print '(A,5F8.2)', 'Normalized: ', c\n\ncontains\n\n  elemental subroutine scale_and_add(x, y, result)\n    real, intent(in)  :: x, y\n    real, intent(out) :: result\n    result = 2.0 * x + y\n  end subroutine scale_and_add\n\n  elemental subroutine normalize_range(val, vmin, vmax, result)\n    real, intent(in)  :: val, vmin, vmax\n    real, intent(out) :: result\n    result = (val - vmin) / (vmax - vmin)\n  end subroutine normalize_range\n\nend program demo_elemental_subroutine\n```\nResults:\n```text\nArray result:     4.00    6.00    8.00   10.00   12.00\nScalar result:    10.00\nBroadcast result:    12.00   14.00   16.00   18.00   20.00\nNormalized:     0.00    0.25    0.50    0.75    1.00\n```\n\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**elemental**(3)](#elemental),\n[**pure**(3)](#pure),\n[**impure**(3)](#impure)",
  "elementalsubroutine": "## elemental_subroutine\n\n### **Name**\n\n**elemental_subroutine** - \\[PROCEDURE:ELEMENTAL\\] Define an elemental subroutine that operates element-wise\n\n### **Synopsis**\n```fortran\n    call elemental_sub(array1, array2, result)\n```\n```fortran\n     elemental subroutine sub_name(arg1, arg2, result)\n\n      type, intent(in)  :: arg1, arg2\n      type, intent(out) :: result\n```\n\n### **Characteristics**\n\n - Declared with **ELEMENTAL** prefix.\n - All dummy arguments must be scalar.\n - When called with array arguments, operates element-wise.\n - Must be PURE (no side effects, no I/O).\n - Cannot have pointer, allocatable, or procedure arguments.\n\n### **Description**\n\n **elemental_subroutine** defines a subroutine that operates on scalar\n arguments but can be called with array arguments. When called with arrays,\n the subroutine is applied element-by-element. This enables writing scalar\n algorithms that automatically work on arrays of any shape.\n\n### **Options**\n\n- **ELEMENTAL**\n  : Required prefix indicating the subroutine operates element-wise.\n\n- **PURE**\n  : Implied by ELEMENTAL. The subroutine must have no side effects.\n\n- **IMPURE ELEMENTAL**\n  : Fortran 2008 allows elemental procedures with side effects using this\n  combined prefix.\n\n### **Result**\n\n  When called with array arguments, each element is processed independently.\n  The result array has the same shape as the input arrays.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_elemental_subroutine\nimplicit none\n  real :: a(5), b(5), c(5)\n  real :: x, y, z\n\n  ! Initialize arrays\n  a = [1.0, 2.0, 3.0, 4.0, 5.0]\n  b = [2.0, 2.0, 2.0, 2.0, 2.0]\n\n  ! Call elemental subroutine with arrays\n  call scale_and_add(a, b, c)\n  print '(A,5F8.2)', 'Array result: ', c\n\n  ! Call with scalars\n  call scale_and_add(3.0, 4.0, z)\n  print '(A,F8.2)', 'Scalar result: ', z\n\n  ! Mixed scalar/array (scalar is broadcast)\n  call scale_and_add(a, 10.0, c)\n  print '(A,5F8.2)', 'Broadcast result: ', c\n\n  ! Complex example: normalize to range [0,1]\n  a = [10.0, 20.0, 30.0, 40.0, 50.0]\n  call normalize_range(a, 10.0, 50.0, c)\n  print '(A,5F8.2)', 'Normalized: ', c\n\ncontains\n\n  elemental subroutine scale_and_add(x, y, result)\n    real, intent(in)  :: x, y\n    real, intent(out) :: result\n    result = 2.0 * x + y\n  end subroutine scale_and_add\n\n  elemental subroutine normalize_range(val, vmin, vmax, result)\n    real, intent(in)  :: val, vmin, vmax\n    real, intent(out) :: result\n    result = (val - vmin) / (vmax - vmin)\n  end subroutine normalize_range\n\nend program demo_elemental_subroutine\n```\nResults:\n```text\nArray result:     4.00    6.00    8.00   10.00   12.00\nScalar result:    10.00\nBroadcast result:    12.00   14.00   16.00   18.00   20.00\nNormalized:     0.00    0.25    0.50    0.75    1.00\n```\n\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**elemental**(3)](#elemental),\n[**pure**(3)](#pure),\n[**impure**(3)](#impure)",
  "class": "## class_polymorphic\n\n### **Name**\n\n**class** - \\[STRUCTURE:TYPE\\] Declare a polymorphic variable that can hold a type or any of its extensions\n\n### **Synopsis**\n```fortran\n    class(type_name) :: variable\n    class(type_name), allocatable :: allocatable_var\n    class(*), pointer :: unlimited_ptr\n```\n```fortran\n     class(type_name), intent(in)  :: dummy_arg   ! Polymorphic dummy\n     class(type_name), allocatable :: alloc_var   ! Allocatable polymorphic\n     class(type_name), pointer     :: ptr_var     ! Pointer polymorphic\n     class(*)                      :: unlimited   ! Unlimited polymorphic\n```\n\n### **Characteristics**\n\n - **class(type_name)** declares a polymorphic variable of type type_name.\n - Polymorphic variables can hold objects of the declared type or any extending type.\n - Non-pointer, non-allocatable class variables must be dummy arguments.\n - **class(*)** declares unlimited polymorphic variables that can hold any type.\n - Dynamic type is determined at runtime; declared type sets the interface.\n\n### **Description**\n\n **class** declares a polymorphic entity whose dynamic type can differ from\n its declared type at runtime. The declared type establishes the interface\n (accessible components and type-bound procedures), while the dynamic type\n is the actual type of the object, which can be the declared type or any\n extension thereof. This enables runtime polymorphism, allowing procedures\n to operate on type hierarchies without knowing the specific type at\n compile time.\n\n### **Options**\n\n- **type_name**\n  : The declared type of the polymorphic variable. Must be an extensible\n  derived type (not SEQUENCE or BIND(C)). Determines which components\n  and type-bound procedures are directly accessible.\n\n- **class(*)**\n  : Unlimited polymorphic declaration. Can hold a value of any type,\n  including intrinsic types. Requires SELECT TYPE to access type-specific\n  features.\n\n- **allocatable**\n  : Allows the polymorphic variable to be allocated with any extending\n  type using ALLOCATE with SOURCE= or MOLD= specifiers.\n\n- **pointer**\n  : Allows the polymorphic variable to point to targets of any extending\n  type.\n\n### **Result**\n\n  A polymorphic variable that can hold objects of the declared type or\n  any type that extends it, enabling runtime polymorphism and dynamic\n  dispatch of type-bound procedures.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_class_polymorphic\nimplicit none\n\n  type :: animal\n    character(len=20) :: name = 'Unknown'\n  contains\n    procedure :: speak => animal_speak\n  end type animal\n\n  type, extends(animal) :: dog\n    character(len=20) :: breed = 'Mixed'\n  contains\n    procedure :: speak => dog_speak\n  end type dog\n\n  type, extends(animal) :: cat\n  contains\n    procedure :: speak => cat_speak\n  end type cat\n\n  type(dog) :: my_dog\n  type(cat) :: my_cat\n  class(animal), allocatable :: pet\n  class(animal), pointer :: pet_ptr\n\n  my_dog = dog(name='Buddy', breed='Labrador')\n  my_cat = cat(name='Whiskers')\n\n  ! Allocate polymorphic variable with dog\n  allocate(pet, source=my_dog)\n  call pet%speak()  ! Calls dog_speak\n\n  ! Reallocate with cat\n  deallocate(pet)\n  allocate(pet, source=my_cat)\n  call pet%speak()  ! Calls cat_speak\n\n  ! Use pointer to refer to different types\n  pet_ptr => my_dog\n  call pet_ptr%speak()\n\n  pet_ptr => my_cat\n  call pet_ptr%speak()\n\n  ! Demonstrate SELECT TYPE for type-specific access\n  allocate(pet, source=my_dog)\n  select type (pet)\n    type is (dog)\n      print '(a,a)', 'Breed: ', trim(pet%breed)\n    type is (cat)\n      print '(a)', 'It is a cat'\n    class default\n      print '(a)', 'Unknown animal type'\n  end select\n\n  deallocate(pet)\n\ncontains\n\n  subroutine animal_speak(self)\n    class(animal), intent(in) :: self\n    print '(a,a,a)', trim(self%name), ' says: ', '...'\n  end subroutine animal_speak\n\n  subroutine dog_speak(self)\n    class(dog), intent(in) :: self\n    print '(a,a,a)', trim(self%name), ' says: ', 'Woof!'\n  end subroutine dog_speak\n\n  subroutine cat_speak(self)\n    class(cat), intent(in) :: self\n    print '(a,a,a)', trim(self%name), ' says: ', 'Meow!'\n  end subroutine cat_speak\n\nend program demo_class_polymorphic\n```\nResults:\n```text\nBuddy says: Woof!\nWhiskers says: Meow!\nBuddy says: Woof!\nWhiskers says: Meow!\nBreed: Labrador\n```\n\n### **Standard**\n\nFortran 2003\n\n**Compatibility Notes:**\n- gfortran 4.5+, Intel Fortran 12.0+, NAG 5.3+\n- Required for polymorphism and type-bound procedures\n- CLASS variables must be allocatable, pointer, or dummy arguments\n\n### **See Also**\n\n[**type**(3)](#type),\n[**extends**(3)](#extends),\n[**select_type**(3)](#select_type),\n[**allocate**(3)](#allocate),\n[**abstract**(3)](#abstract)",
  "polymorphic": "## class_polymorphic\n\n### **Name**\n\n**class** - \\[STRUCTURE:TYPE\\] Declare a polymorphic variable that can hold a type or any of its extensions\n\n### **Synopsis**\n```fortran\n    class(type_name) :: variable\n    class(type_name), allocatable :: allocatable_var\n    class(*), pointer :: unlimited_ptr\n```\n```fortran\n     class(type_name), intent(in)  :: dummy_arg   ! Polymorphic dummy\n     class(type_name), allocatable :: alloc_var   ! Allocatable polymorphic\n     class(type_name), pointer     :: ptr_var     ! Pointer polymorphic\n     class(*)                      :: unlimited   ! Unlimited polymorphic\n```\n\n### **Characteristics**\n\n - **class(type_name)** declares a polymorphic variable of type type_name.\n - Polymorphic variables can hold objects of the declared type or any extending type.\n - Non-pointer, non-allocatable class variables must be dummy arguments.\n - **class(*)** declares unlimited polymorphic variables that can hold any type.\n - Dynamic type is determined at runtime; declared type sets the interface.\n\n### **Description**\n\n **class** declares a polymorphic entity whose dynamic type can differ from\n its declared type at runtime. The declared type establishes the interface\n (accessible components and type-bound procedures), while the dynamic type\n is the actual type of the object, which can be the declared type or any\n extension thereof. This enables runtime polymorphism, allowing procedures\n to operate on type hierarchies without knowing the specific type at\n compile time.\n\n### **Options**\n\n- **type_name**\n  : The declared type of the polymorphic variable. Must be an extensible\n  derived type (not SEQUENCE or BIND(C)). Determines which components\n  and type-bound procedures are directly accessible.\n\n- **class(*)**\n  : Unlimited polymorphic declaration. Can hold a value of any type,\n  including intrinsic types. Requires SELECT TYPE to access type-specific\n  features.\n\n- **allocatable**\n  : Allows the polymorphic variable to be allocated with any extending\n  type using ALLOCATE with SOURCE= or MOLD= specifiers.\n\n- **pointer**\n  : Allows the polymorphic variable to point to targets of any extending\n  type.\n\n### **Result**\n\n  A polymorphic variable that can hold objects of the declared type or\n  any type that extends it, enabling runtime polymorphism and dynamic\n  dispatch of type-bound procedures.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_class_polymorphic\nimplicit none\n\n  type :: animal\n    character(len=20) :: name = 'Unknown'\n  contains\n    procedure :: speak => animal_speak\n  end type animal\n\n  type, extends(animal) :: dog\n    character(len=20) :: breed = 'Mixed'\n  contains\n    procedure :: speak => dog_speak\n  end type dog\n\n  type, extends(animal) :: cat\n  contains\n    procedure :: speak => cat_speak\n  end type cat\n\n  type(dog) :: my_dog\n  type(cat) :: my_cat\n  class(animal), allocatable :: pet\n  class(animal), pointer :: pet_ptr\n\n  my_dog = dog(name='Buddy', breed='Labrador')\n  my_cat = cat(name='Whiskers')\n\n  ! Allocate polymorphic variable with dog\n  allocate(pet, source=my_dog)\n  call pet%speak()  ! Calls dog_speak\n\n  ! Reallocate with cat\n  deallocate(pet)\n  allocate(pet, source=my_cat)\n  call pet%speak()  ! Calls cat_speak\n\n  ! Use pointer to refer to different types\n  pet_ptr => my_dog\n  call pet_ptr%speak()\n\n  pet_ptr => my_cat\n  call pet_ptr%speak()\n\n  ! Demonstrate SELECT TYPE for type-specific access\n  allocate(pet, source=my_dog)\n  select type (pet)\n    type is (dog)\n      print '(a,a)', 'Breed: ', trim(pet%breed)\n    type is (cat)\n      print '(a)', 'It is a cat'\n    class default\n      print '(a)', 'Unknown animal type'\n  end select\n\n  deallocate(pet)\n\ncontains\n\n  subroutine animal_speak(self)\n    class(animal), intent(in) :: self\n    print '(a,a,a)', trim(self%name), ' says: ', '...'\n  end subroutine animal_speak\n\n  subroutine dog_speak(self)\n    class(dog), intent(in) :: self\n    print '(a,a,a)', trim(self%name), ' says: ', 'Woof!'\n  end subroutine dog_speak\n\n  subroutine cat_speak(self)\n    class(cat), intent(in) :: self\n    print '(a,a,a)', trim(self%name), ' says: ', 'Meow!'\n  end subroutine cat_speak\n\nend program demo_class_polymorphic\n```\nResults:\n```text\nBuddy says: Woof!\nWhiskers says: Meow!\nBuddy says: Woof!\nWhiskers says: Meow!\nBreed: Labrador\n```\n\n### **Standard**\n\nFortran 2003\n\n**Compatibility Notes:**\n- gfortran 4.5+, Intel Fortran 12.0+, NAG 5.3+\n- Requires CLASS declaration for polymorphic behavior\n- SELECT TYPE construct used for type-specific operations\n\n### **See Also**\n\n[**type**(3)](#type),\n[**extends**(3)](#extends),\n[**select_type**(3)](#select_type),\n[**allocate**(3)](#allocate),\n[**abstract**(3)](#abstract)",
  "bindctype": "## bind_c_type\n\n### **Name**\n\n**bind_c_type** - \\[INTEROP:C_BINDING\\] Define a derived type interoperable with C structs\n\n### **Synopsis**\n```fortran\n    type(my_c_struct) :: var\n```\n```fortran\n     type, bind(c) :: my_c_struct\n\n      use iso_c_binding, only: c_int, c_double, c_char, c_ptr\n      integer(c_int)    :: int_member\n      real(c_double)    :: real_member\n      character(c_char) :: char_member\n      type(c_ptr)       :: ptr_member\n     end type my_c_struct\n```\n\n### **Characteristics**\n\n - **bind(c)** makes the derived type compatible with C struct layout.\n - All components must be interoperable C types from ISO_C_BINDING.\n - Component order in Fortran matches member order in C struct.\n - No type-bound procedures, allocatable components, or pointer components (except c_ptr).\n - The type can be passed to/from C functions and stored in C arrays.\n - Padding and alignment follow C struct rules.\n\n### **Description**\n\n **bind_c_type** creates a Fortran derived type that has the same memory layout\n as a C struct. This enables direct data exchange between Fortran and C code\n without copying or marshaling. The BIND(C) attribute ensures the compiler\n uses C-compatible memory alignment and component ordering.\n\n### **Options**\n\n- **bind(c)**\n  : Required attribute that specifies C interoperability. The derived type\n  will have the same memory layout as an equivalent C struct.\n\n- **component types**\n  : All components must use interoperable types from ISO_C_BINDING:\n  - integer(c_int), integer(c_long), integer(c_size_t), etc.\n  - real(c_float), real(c_double), real(c_long_double)\n  - character(kind=c_char) for single characters\n  - type(c_ptr) for C pointers (void*)\n  - type(c_funptr) for C function pointers\n  - Other bind(c) derived types (nested structs)\n\n- **arrays**\n  : Fixed-size arrays are allowed as components. The array size must be\n  a constant expression. Variable-length arrays are not interoperable.\n\n### **Result**\n\n  The derived type can be used in Fortran code like any other type, but can\n  also be passed directly to C functions expecting the equivalent struct.\n  The memory layout is guaranteed to match C struct conventions.\n\n### **Examples**\n\nSample program (Fortran side):\n```fortran\nmodule c_struct_module\n  use iso_c_binding\n  implicit none\n\n  ! Equivalent to C struct: struct point { double x; double y; double z; };\n  type, bind(c) :: point\n    real(c_double) :: x\n    real(c_double) :: y\n    real(c_double) :: z\n  end type point\n\n  ! Equivalent to C struct: struct particle { int id; double mass; struct point pos; };\n  type, bind(c) :: particle\n    integer(c_int) :: id\n    real(c_double) :: mass\n    type(point)    :: pos\n  end type particle\n\n  ! Equivalent to C struct: struct buffer { int size; double data[100]; };\n  type, bind(c) :: buffer\n    integer(c_int)  :: size\n    real(c_double)  :: data(100)\n  end type buffer\n\n  interface\n    ! C function: void print_particle(struct particle* p);\n    subroutine print_particle(p) bind(c, name='print_particle')\n      import :: particle\n      type(particle), intent(in) :: p\n    end subroutine print_particle\n\n    ! C function: double compute_distance(struct point* a, struct point* b);\n    function compute_distance(a, b) result(dist) bind(c, name='compute_distance')\n      import :: point, c_double\n      type(point), intent(in) :: a, b\n      real(c_double) :: dist\n    end function compute_distance\n  end interface\n\nend module c_struct_module\n\nprogram demo_bind_c_type\n  use c_struct_module\n  use iso_c_binding\n  implicit none\n\n  type(point) :: p1, p2\n  type(particle) :: atom\n  type(buffer) :: buf\n  real(c_double) :: dist\n\n  ! Initialize point structures\n  p1 = point(0.0_c_double, 0.0_c_double, 0.0_c_double)\n  p2 = point(3.0_c_double, 4.0_c_double, 0.0_c_double)\n\n  ! Initialize particle with nested point\n  atom%id = 1\n  atom%mass = 12.011_c_double  ! Carbon mass\n  atom%pos = point(1.5_c_double, 2.5_c_double, 3.5_c_double)\n\n  ! Initialize buffer with fixed-size array\n  buf%size = 10\n  buf%data(1:10) = [(real(i, c_double), i = 1, 10)]\n\n  print '(A)', 'Point 1: '\n  print '(A,F6.2,A,F6.2,A,F6.2)', '  (', p1%x, ', ', p1%y, ', ', p1%z, ')'\n\n  print '(A)', 'Point 2: '\n  print '(A,F6.2,A,F6.2,A,F6.2)', '  (', p2%x, ', ', p2%y, ', ', p2%z, ')'\n\n  ! Calculate distance (pure Fortran, or could call C function)\n  dist = sqrt((p2%x - p1%x)**2 + (p2%y - p1%y)**2 + (p2%z - p1%z)**2)\n  print '(A,F10.6)', 'Distance: ', dist\n\n  print '(A)', 'Particle:'\n  print '(A,I0)', '  ID: ', atom%id\n  print '(A,F10.6)', '  Mass: ', atom%mass\n  print '(A,F6.2,A,F6.2,A,F6.2)', '  Position: (', &\n        atom%pos%x, ', ', atom%pos%y, ', ', atom%pos%z, ')'\n\nend program demo_bind_c_type\n```\n\nCorresponding C header:\n```c\n/* c_structs.h */\n#ifndef C_STRUCTS_H\n#define C_STRUCTS_H\n\nstruct point {\n    double x;\n    double y;\n    double z;\n};\n\nstruct particle {\n    int id;\n    double mass;\n    struct point pos;\n};\n\nstruct buffer {\n    int size;\n    double data[100];\n};\n\nvoid print_particle(struct particle* p);\ndouble compute_distance(struct point* a, struct point* b);\n\n#endif\n```\n\nResults:\n```text\nPoint 1:\n  (  0.00,   0.00,   0.00)\nPoint 2:\n  (  3.00,   4.00,   0.00)\nDistance:   5.000000\nParticle:\n  ID: 1\n  Mass:  12.011000\n  Position: (  1.50,   2.50,   3.50)\n```\n\n### **Standard**\n\nFortran 2003 (ISO/IEC 1539-1:2004)\n\n**Compatibility Notes:**\n- gfortran 4.3+, Intel Fortran 10.0+, NAG 5.1+\n- All components must be interoperable C types\n- SEQUENCE attribute implied for BIND(C) types\n\n### **See Also**\n\n[**bind_c_function**(3)](#bind_c_function),\n[**bind_c_subroutine**(3)](#bind_c_subroutine),\n[**c_loc**(3)](#c_loc),\n[**c_f_pointer**(3)](#c_f_pointer),\n[**iso_c_binding**(3)](#iso_c_binding)",
  "bind_c_type": "## bind_c_type\n\n### **Name**\n\n**bind_c_type** - \\[INTEROP:C_BINDING\\] Define a derived type interoperable with C structs\n\n### **Synopsis**\n```fortran\n    type(my_c_struct) :: var\n```\n```fortran\n     type, bind(c) :: my_c_struct\n\n      use iso_c_binding, only: c_int, c_double, c_char, c_ptr\n      integer(c_int)    :: int_member\n      real(c_double)    :: real_member\n      character(c_char) :: char_member\n      type(c_ptr)       :: ptr_member\n     end type my_c_struct\n```\n\n### **Characteristics**\n\n - **bind(c)** makes the derived type compatible with C struct layout.\n - All components must be interoperable C types from ISO_C_BINDING.\n - Component order in Fortran matches member order in C struct.\n - No type-bound procedures, allocatable components, or pointer components (except c_ptr).\n - The type can be passed to/from C functions and stored in C arrays.\n - Padding and alignment follow C struct rules.\n\n### **Description**\n\n **bind_c_type** creates a Fortran derived type that has the same memory layout\n as a C struct. This enables direct data exchange between Fortran and C code\n without copying or marshaling. The BIND(C) attribute ensures the compiler\n uses C-compatible memory alignment and component ordering.\n\n### **Options**\n\n- **bind(c)**\n  : Required attribute that specifies C interoperability. The derived type\n  will have the same memory layout as an equivalent C struct.\n\n- **component types**\n  : All components must use interoperable types from ISO_C_BINDING:\n  - integer(c_int), integer(c_long), integer(c_size_t), etc.\n  - real(c_float), real(c_double), real(c_long_double)\n  - character(kind=c_char) for single characters\n  - type(c_ptr) for C pointers (void*)\n  - type(c_funptr) for C function pointers\n  - Other bind(c) derived types (nested structs)\n\n- **arrays**\n  : Fixed-size arrays are allowed as components. The array size must be\n  a constant expression. Variable-length arrays are not interoperable.\n\n### **Result**\n\n  The derived type can be used in Fortran code like any other type, but can\n  also be passed directly to C functions expecting the equivalent struct.\n  The memory layout is guaranteed to match C struct conventions.\n\n### **Examples**\n\nSample program (Fortran side):\n```fortran\nmodule c_struct_module\n  use iso_c_binding\n  implicit none\n\n  ! Equivalent to C struct: struct point { double x; double y; double z; };\n  type, bind(c) :: point\n    real(c_double) :: x\n    real(c_double) :: y\n    real(c_double) :: z\n  end type point\n\n  ! Equivalent to C struct: struct particle { int id; double mass; struct point pos; };\n  type, bind(c) :: particle\n    integer(c_int) :: id\n    real(c_double) :: mass\n    type(point)    :: pos\n  end type particle\n\n  ! Equivalent to C struct: struct buffer { int size; double data[100]; };\n  type, bind(c) :: buffer\n    integer(c_int)  :: size\n    real(c_double)  :: data(100)\n  end type buffer\n\n  interface\n    ! C function: void print_particle(struct particle* p);\n    subroutine print_particle(p) bind(c, name='print_particle')\n      import :: particle\n      type(particle), intent(in) :: p\n    end subroutine print_particle\n\n    ! C function: double compute_distance(struct point* a, struct point* b);\n    function compute_distance(a, b) result(dist) bind(c, name='compute_distance')\n      import :: point, c_double\n      type(point), intent(in) :: a, b\n      real(c_double) :: dist\n    end function compute_distance\n  end interface\n\nend module c_struct_module\n\nprogram demo_bind_c_type\n  use c_struct_module\n  use iso_c_binding\n  implicit none\n\n  type(point) :: p1, p2\n  type(particle) :: atom\n  type(buffer) :: buf\n  real(c_double) :: dist\n\n  ! Initialize point structures\n  p1 = point(0.0_c_double, 0.0_c_double, 0.0_c_double)\n  p2 = point(3.0_c_double, 4.0_c_double, 0.0_c_double)\n\n  ! Initialize particle with nested point\n  atom%id = 1\n  atom%mass = 12.011_c_double  ! Carbon mass\n  atom%pos = point(1.5_c_double, 2.5_c_double, 3.5_c_double)\n\n  ! Initialize buffer with fixed-size array\n  buf%size = 10\n  buf%data(1:10) = [(real(i, c_double), i = 1, 10)]\n\n  print '(A)', 'Point 1: '\n  print '(A,F6.2,A,F6.2,A,F6.2)', '  (', p1%x, ', ', p1%y, ', ', p1%z, ')'\n\n  print '(A)', 'Point 2: '\n  print '(A,F6.2,A,F6.2,A,F6.2)', '  (', p2%x, ', ', p2%y, ', ', p2%z, ')'\n\n  ! Calculate distance (pure Fortran, or could call C function)\n  dist = sqrt((p2%x - p1%x)**2 + (p2%y - p1%y)**2 + (p2%z - p1%z)**2)\n  print '(A,F10.6)', 'Distance: ', dist\n\n  print '(A)', 'Particle:'\n  print '(A,I0)', '  ID: ', atom%id\n  print '(A,F10.6)', '  Mass: ', atom%mass\n  print '(A,F6.2,A,F6.2,A,F6.2)', '  Position: (', &\n        atom%pos%x, ', ', atom%pos%y, ', ', atom%pos%z, ')'\n\nend program demo_bind_c_type\n```\n\nCorresponding C header:\n```c\n/* c_structs.h */\n#ifndef C_STRUCTS_H\n#define C_STRUCTS_H\n\nstruct point {\n    double x;\n    double y;\n    double z;\n};\n\nstruct particle {\n    int id;\n    double mass;\n    struct point pos;\n};\n\nstruct buffer {\n    int size;\n    double data[100];\n};\n\nvoid print_particle(struct particle* p);\ndouble compute_distance(struct point* a, struct point* b);\n\n#endif\n```\n\nResults:\n```text\nPoint 1:\n  (  0.00,   0.00,   0.00)\nPoint 2:\n  (  3.00,   4.00,   0.00)\nDistance:   5.000000\nParticle:\n  ID: 1\n  Mass:  12.011000\n  Position: (  1.50,   2.50,   3.50)\n```\n\n### **Standard**\n\nFortran 2003 (ISO/IEC 1539-1:2004)\n\n**Compatibility Notes:**\n- gfortran 4.3+, Intel Fortran 10.0+, NAG 5.1+\n- All components must be interoperable C types\n- SEQUENCE attribute implied for BIND(C) types\n\n### **See Also**\n\n[**bind_c_function**(3)](#bind_c_function),\n[**bind_c_subroutine**(3)](#bind_c_subroutine),\n[**c_loc**(3)](#c_loc),\n[**c_f_pointer**(3)](#c_f_pointer),\n[**iso_c_binding**(3)](#iso_c_binding)",
  "thisimage": "## this_image / num_images\n\n### **Name**\n\n**this_image / num_images** - \\[PARALLEL:COARRAY\\] Query coarray image index and total image count\n\n### **Synopsis**\n```fortran\n    me = this_image()\n    nimages = num_images()\n```\n```fortran\n     function this_image() result(image_index)\n       integer :: image_index\n\n     function this_image(coarray) result(cosubscripts)\n       type(*), dimension[..] :: coarray\n       integer                :: cosubscripts(:)\n\n     function this_image(coarray, dim) result(cosubscript)\n       type(*), dimension[..] :: coarray\n       integer, intent(in)    :: dim\n       integer                :: cosubscript\n\n     function num_images() result(nimages)\n       integer :: nimages\n\n     function num_images(team) result(nimages)\n       type(team_type), intent(in) :: team\n       integer                     :: nimages\n\n     function num_images(team_number) result(nimages)\n       integer, intent(in) :: team_number\n       integer             :: nimages\n```\n\n### **Characteristics**\n\n - **this_image()** with no arguments returns the image index of the invoking image as a default integer.\n - **this_image(coarray)** returns an integer array of cosubscripts for the invoking image.\n - **this_image(coarray, dim)** returns the cosubscript for dimension **dim** as a scalar integer.\n - **num_images()** with no arguments returns the total number of images in the current team.\n - **num_images(team)** returns the number of images in the specified team.\n - **num_images(team_number)** returns the number of images in the team with the specified team number.\n - Image indices range from 1 to num_images().\n\n### **Description**\n\n **this_image** returns the image index of the invoking image within the current team, or the cosubscripts corresponding to the invoking image for a given coarray. **num_images** returns the total number of images in execution, either in the current team or a specified team. These functions are fundamental for coarray parallel programming, enabling each image to identify itself and coordinate with other images.\n\n### **Options**\n\n- **coarray**\n  : A coarray of any type. Used with this_image to determine the cosubscripts that would be used to access the invoking image's portion of the coarray.\n\n- **dim**\n  : An integer scalar indicating which dimension's cosubscript to return. Must be between 1 and the corank of the coarray.\n\n- **team**\n  : A scalar of type TEAM_TYPE from ISO_FORTRAN_ENV, specifying the team to query.\n\n- **team_number**\n  : An integer scalar specifying the team number to query.\n\n### **Result**\n\n  For **this_image()** with no arguments, the result is a default integer representing the image index (1 to num_images()).\n\n  For **this_image(coarray)**, the result is an integer array with size equal to the corank of the coarray, containing the cosubscripts for the invoking image.\n\n  For **this_image(coarray, dim)**, the result is a scalar integer representing the cosubscript for the specified dimension.\n\n  For **num_images()**, the result is a default integer representing the total number of images currently executing.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_coarray_image_query\n  use iso_fortran_env, only: team_type\n  implicit none\n  integer :: me, nimages\n  integer :: data[*]  ! Simple coarray\n  integer :: matrix[2, *]  ! 2D cobounds coarray\n  integer :: cosubs(1)\n\n  ! Get image index and total images\n  me = this_image()\n  nimages = num_images()\n\n  print '(A,I0,A,I0)', 'Image ', me, ' of ', nimages\n\n  ! Initialize local data\n  data = me * 10\n\n  ! Synchronize all images before accessing remote data\n  sync all\n\n  ! Image 1 collects data from all images\n  if (me == 1) then\n    print *, 'Image 1 collecting data:'\n    block\n      integer :: i\n      do i = 1, nimages\n        print '(A,I0,A,I0)', '  data[', i, '] = ', data[i]\n      end do\n    end block\n  end if\n\n  ! Get cosubscripts for a coarray\n  cosubs = this_image(data)\n  print '(A,I0,A,I0)', 'Image ', me, ' has cosubscript: ', cosubs(1)\n\n  sync all\n\nend program demo_coarray_image_query\n```\nResults (with 4 images):\n```text\nImage 1 of 4\nImage 2 of 4\nImage 3 of 4\nImage 4 of 4\n Image 1 collecting data:\n  data[1] = 10\n  data[2] = 20\n  data[3] = 30\n  data[4] = 40\nImage 1 has cosubscript: 1\nImage 2 has cosubscript: 2\nImage 3 has cosubscript: 3\nImage 4 has cosubscript: 4\n```\n\n### **Standard**\n\nFortran 2008 (basic forms), Fortran 2018 (team arguments)\n\n**Compatibility Notes:**\n- gfortran 5.0+, Intel Fortran 12.0+, NAG 6.0+\n- Returns current image index (1 to NUM_IMAGES())\n- With coarray argument, returns cobounds\n\n### **See Also**\n\n[**sync_all**(3)](#sync_all),\n[**sync_images**(3)](#sync_images),\n[**co_sum**(3)](#co_sum),\n[**co_broadcast**(3)](#co_broadcast),\n[**team_type**(3)](#team_type)",
  "numimages": "## this_image / num_images\n\n### **Name**\n\n**this_image / num_images** - \\[PARALLEL:COARRAY\\] Query coarray image index and total image count\n\n### **Synopsis**\n```fortran\n    me = this_image()\n    nimages = num_images()\n```\n```fortran\n     function this_image() result(image_index)\n       integer :: image_index\n\n     function this_image(coarray) result(cosubscripts)\n       type(*), dimension[..] :: coarray\n       integer                :: cosubscripts(:)\n\n     function this_image(coarray, dim) result(cosubscript)\n       type(*), dimension[..] :: coarray\n       integer, intent(in)    :: dim\n       integer                :: cosubscript\n\n     function num_images() result(nimages)\n       integer :: nimages\n\n     function num_images(team) result(nimages)\n       type(team_type), intent(in) :: team\n       integer                     :: nimages\n\n     function num_images(team_number) result(nimages)\n       integer, intent(in) :: team_number\n       integer             :: nimages\n```\n\n### **Characteristics**\n\n - **this_image()** with no arguments returns the image index of the invoking image as a default integer.\n - **this_image(coarray)** returns an integer array of cosubscripts for the invoking image.\n - **this_image(coarray, dim)** returns the cosubscript for dimension **dim** as a scalar integer.\n - **num_images()** with no arguments returns the total number of images in the current team.\n - **num_images(team)** returns the number of images in the specified team.\n - **num_images(team_number)** returns the number of images in the team with the specified team number.\n - Image indices range from 1 to num_images().\n\n### **Description**\n\n **this_image** returns the image index of the invoking image within the current team, or the cosubscripts corresponding to the invoking image for a given coarray. **num_images** returns the total number of images in execution, either in the current team or a specified team. These functions are fundamental for coarray parallel programming, enabling each image to identify itself and coordinate with other images.\n\n### **Options**\n\n- **coarray**\n  : A coarray of any type. Used with this_image to determine the cosubscripts that would be used to access the invoking image's portion of the coarray.\n\n- **dim**\n  : An integer scalar indicating which dimension's cosubscript to return. Must be between 1 and the corank of the coarray.\n\n- **team**\n  : A scalar of type TEAM_TYPE from ISO_FORTRAN_ENV, specifying the team to query.\n\n- **team_number**\n  : An integer scalar specifying the team number to query.\n\n### **Result**\n\n  For **this_image()** with no arguments, the result is a default integer representing the image index (1 to num_images()).\n\n  For **this_image(coarray)**, the result is an integer array with size equal to the corank of the coarray, containing the cosubscripts for the invoking image.\n\n  For **this_image(coarray, dim)**, the result is a scalar integer representing the cosubscript for the specified dimension.\n\n  For **num_images()**, the result is a default integer representing the total number of images currently executing.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_coarray_image_query\n  use iso_fortran_env, only: team_type\n  implicit none\n  integer :: me, nimages\n  integer :: data[*]  ! Simple coarray\n  integer :: matrix[2, *]  ! 2D cobounds coarray\n  integer :: cosubs(1)\n\n  ! Get image index and total images\n  me = this_image()\n  nimages = num_images()\n\n  print '(A,I0,A,I0)', 'Image ', me, ' of ', nimages\n\n  ! Initialize local data\n  data = me * 10\n\n  ! Synchronize all images before accessing remote data\n  sync all\n\n  ! Image 1 collects data from all images\n  if (me == 1) then\n    print *, 'Image 1 collecting data:'\n    block\n      integer :: i\n      do i = 1, nimages\n        print '(A,I0,A,I0)', '  data[', i, '] = ', data[i]\n      end do\n    end block\n  end if\n\n  ! Get cosubscripts for a coarray\n  cosubs = this_image(data)\n  print '(A,I0,A,I0)', 'Image ', me, ' has cosubscript: ', cosubs(1)\n\n  sync all\n\nend program demo_coarray_image_query\n```\nResults (with 4 images):\n```text\nImage 1 of 4\nImage 2 of 4\nImage 3 of 4\nImage 4 of 4\n Image 1 collecting data:\n  data[1] = 10\n  data[2] = 20\n  data[3] = 30\n  data[4] = 40\nImage 1 has cosubscript: 1\nImage 2 has cosubscript: 2\nImage 3 has cosubscript: 3\nImage 4 has cosubscript: 4\n```\n\n### **Standard**\n\nFortran 2008 (basic forms), Fortran 2018 (team arguments)\n\n**Compatibility Notes:**\n- gfortran 5.0+, Intel Fortran 12.0+, NAG 6.0+\n- Returns total number of images in current team\n- Use -fcoarray flag with gfortran\n\n### **See Also**\n\n[**sync_all**(3)](#sync_all),\n[**sync_images**(3)](#sync_images),\n[**co_sum**(3)](#co_sum),\n[**co_broadcast**(3)](#co_broadcast),\n[**team_type**(3)](#team_type)",
  "get_environment_variable": "## get_environment_variable\n\n### **Name**\n\n**get_environment_variable** - \\[SYSTEM:ENVIRONMENT\\] Retrieve the value of an environment variable\n\n### **Synopsis**\n```fortran\n    call get_environment_variable(name [,value] [,length] [,status] [,trim_name] [,errmsg])\n```\n```fortran\n     subroutine get_environment_variable(name, value, length, status, trim_name, errmsg)\n\n      character(len=*), intent(in)            :: name\n      character(len=*), intent(out), optional :: value\n      integer, intent(out), optional          :: length\n      integer, intent(out), optional          :: status\n      logical, intent(in), optional           :: trim_name\n      character(len=*), intent(inout), optional :: errmsg\n```\n\n### **Characteristics**\n\n - **name** is the environment variable name to query.\n - **value** receives the variable's value if it exists.\n - **status** indicates success or type of failure.\n - Returns empty string if variable is not set.\n\n### **Description**\n\n **get_environment_variable** retrieves the value of an environment variable\n from the operating system. This is useful for configuration, reading paths,\n and adapting program behavior to the environment.\n\n### **Options**\n\n- **name**\n  : Character string specifying the environment variable name.\n\n- **value**\n  : Optional. Character variable to receive the value. If variable doesn't\n  exist, receives blanks.\n\n- **length**\n  : Optional. Returns the actual length of the value, or 0 if not set.\n\n- **status**\n  : Optional. Returns: 0 = success, 1 = variable not set, 2 = processor doesn't\n  support environment variables, -1 = value was truncated.\n\n- **trim_name**\n  : Optional. If .true., trailing blanks in name are significant. Default .true.\n\n- **errmsg**\n  : Optional. Returns error message on failure.\n\n### **Result**\n\n  The environment variable value is returned in the value argument.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_get_environment_variable\nimplicit none\n  character(len=256) :: value\n  character(len=256) :: errmsg\n  integer :: length, status\n\n  ! Get HOME directory\n  call get_environment_variable('HOME', value, length, status)\n  if (status == 0) then\n    print '(A,A)', 'HOME = ', trim(value)\n    print '(A,I0)', 'Length = ', length\n  else if (status == 1) then\n    print '(A)', 'HOME is not set'\n  end if\n\n  ! Get PATH\n  call get_environment_variable('PATH', value, length, status)\n  if (status == 0) then\n    print '(A,I0,A)', 'PATH has ', length, ' characters'\n    print '(A,A,A)', 'PATH = ', value(1:min(50,length)), '...'\n  else if (status == -1) then\n    print '(A)', 'PATH was truncated (very long)'\n  end if\n\n  ! Check for optional variable\n  call get_environment_variable('MY_APP_CONFIG', value, status=status)\n  select case (status)\n  case (0)\n    print '(A,A)', 'MY_APP_CONFIG = ', trim(value)\n  case (1)\n    print '(A)', 'MY_APP_CONFIG not set, using defaults'\n  case (2)\n    print '(A)', 'Environment variables not supported'\n  end select\n\n  ! Get current user\n  call get_environment_variable('USER', value, status=status)\n  if (status == 0) then\n    print '(A,A)', 'Current user: ', trim(value)\n  end if\n\nend program demo_get_environment_variable\n```\nResults:\n```text\nHOME = /home/user\nLength = 10\nPATH has 1500 characters\nPATH = /usr/local/bin:/usr/bin:/bin:/usr/local/games...\nMY_APP_CONFIG not set, using defaults\nCurrent user: user\n```\n\n### **Standard**\n\nFortran 2003\n\n**Compatibility Notes:**\n- gfortran 4.0+, Intel Fortran 9.0+, NAG 5.0+\n- Behavior is processor-dependent if variable doesn't exist\n- Use STATUS argument to check for errors\n\n### **See Also**\n\n[**command_argument_count**(3)](#command_argument_count),\n[**get_command_argument**(3)](#get_command_argument)",
  "ctype": "## bind_c_type\n\n### **Name**\n\n**bind_c_type** - \\[INTEROP:C_BINDING\\] Define a derived type interoperable with C structs\n\n### **Synopsis**\n```fortran\n    type(my_c_struct) :: var\n```\n```fortran\n     type, bind(c) :: my_c_struct\n\n      use iso_c_binding, only: c_int, c_double, c_char, c_ptr\n      integer(c_int)    :: int_member\n      real(c_double)    :: real_member\n      character(c_char) :: char_member\n      type(c_ptr)       :: ptr_member\n     end type my_c_struct\n```\n\n### **Characteristics**\n\n - **bind(c)** makes the derived type compatible with C struct layout.\n - All components must be interoperable C types from ISO_C_BINDING.\n - Component order in Fortran matches member order in C struct.\n - No type-bound procedures, allocatable components, or pointer components (except c_ptr).\n - The type can be passed to/from C functions and stored in C arrays.\n - Padding and alignment follow C struct rules.\n\n### **Description**\n\n **bind_c_type** creates a Fortran derived type that has the same memory layout\n as a C struct. This enables direct data exchange between Fortran and C code\n without copying or marshaling. The BIND(C) attribute ensures the compiler\n uses C-compatible memory alignment and component ordering.\n\n### **Options**\n\n- **bind(c)**\n  : Required attribute that specifies C interoperability. The derived type\n  will have the same memory layout as an equivalent C struct.\n\n- **component types**\n  : All components must use interoperable types from ISO_C_BINDING:\n  - integer(c_int), integer(c_long), integer(c_size_t), etc.\n  - real(c_float), real(c_double), real(c_long_double)\n  - character(kind=c_char) for single characters\n  - type(c_ptr) for C pointers (void*)\n  - type(c_funptr) for C function pointers\n  - Other bind(c) derived types (nested structs)\n\n- **arrays**\n  : Fixed-size arrays are allowed as components. The array size must be\n  a constant expression. Variable-length arrays are not interoperable.\n\n### **Result**\n\n  The derived type can be used in Fortran code like any other type, but can\n  also be passed directly to C functions expecting the equivalent struct.\n  The memory layout is guaranteed to match C struct conventions.\n\n### **Examples**\n\nSample program (Fortran side):\n```fortran\nmodule c_struct_module\n  use iso_c_binding\n  implicit none\n\n  ! Equivalent to C struct: struct point { double x; double y; double z; };\n  type, bind(c) :: point\n    real(c_double) :: x\n    real(c_double) :: y\n    real(c_double) :: z\n  end type point\n\n  ! Equivalent to C struct: struct particle { int id; double mass; struct point pos; };\n  type, bind(c) :: particle\n    integer(c_int) :: id\n    real(c_double) :: mass\n    type(point)    :: pos\n  end type particle\n\n  ! Equivalent to C struct: struct buffer { int size; double data[100]; };\n  type, bind(c) :: buffer\n    integer(c_int)  :: size\n    real(c_double)  :: data(100)\n  end type buffer\n\n  interface\n    ! C function: void print_particle(struct particle* p);\n    subroutine print_particle(p) bind(c, name='print_particle')\n      import :: particle\n      type(particle), intent(in) :: p\n    end subroutine print_particle\n\n    ! C function: double compute_distance(struct point* a, struct point* b);\n    function compute_distance(a, b) result(dist) bind(c, name='compute_distance')\n      import :: point, c_double\n      type(point), intent(in) :: a, b\n      real(c_double) :: dist\n    end function compute_distance\n  end interface\n\nend module c_struct_module\n\nprogram demo_bind_c_type\n  use c_struct_module\n  use iso_c_binding\n  implicit none\n\n  type(point) :: p1, p2\n  type(particle) :: atom\n  type(buffer) :: buf\n  real(c_double) :: dist\n\n  ! Initialize point structures\n  p1 = point(0.0_c_double, 0.0_c_double, 0.0_c_double)\n  p2 = point(3.0_c_double, 4.0_c_double, 0.0_c_double)\n\n  ! Initialize particle with nested point\n  atom%id = 1\n  atom%mass = 12.011_c_double  ! Carbon mass\n  atom%pos = point(1.5_c_double, 2.5_c_double, 3.5_c_double)\n\n  ! Initialize buffer with fixed-size array\n  buf%size = 10\n  buf%data(1:10) = [(real(i, c_double), i = 1, 10)]\n\n  print '(A)', 'Point 1: '\n  print '(A,F6.2,A,F6.2,A,F6.2)', '  (', p1%x, ', ', p1%y, ', ', p1%z, ')'\n\n  print '(A)', 'Point 2: '\n  print '(A,F6.2,A,F6.2,A,F6.2)', '  (', p2%x, ', ', p2%y, ', ', p2%z, ')'\n\n  ! Calculate distance (pure Fortran, or could call C function)\n  dist = sqrt((p2%x - p1%x)**2 + (p2%y - p1%y)**2 + (p2%z - p1%z)**2)\n  print '(A,F10.6)', 'Distance: ', dist\n\n  print '(A)', 'Particle:'\n  print '(A,I0)', '  ID: ', atom%id\n  print '(A,F10.6)', '  Mass: ', atom%mass\n  print '(A,F6.2,A,F6.2,A,F6.2)', '  Position: (', &\n        atom%pos%x, ', ', atom%pos%y, ', ', atom%pos%z, ')'\n\nend program demo_bind_c_type\n```\n\nCorresponding C header:\n```c\n/* c_structs.h */\n#ifndef C_STRUCTS_H\n#define C_STRUCTS_H\n\nstruct point {\n    double x;\n    double y;\n    double z;\n};\n\nstruct particle {\n    int id;\n    double mass;\n    struct point pos;\n};\n\nstruct buffer {\n    int size;\n    double data[100];\n};\n\nvoid print_particle(struct particle* p);\ndouble compute_distance(struct point* a, struct point* b);\n\n#endif\n```\n\nResults:\n```text\nPoint 1:\n  (  0.00,   0.00,   0.00)\nPoint 2:\n  (  3.00,   4.00,   0.00)\nDistance:   5.000000\nParticle:\n  ID: 1\n  Mass:  12.011000\n  Position: (  1.50,   2.50,   3.50)\n```\n\n### **Standard**\n\nFortran 2003 (ISO/IEC 1539-1:2004)\n\n**Compatibility Notes:**\n- gfortran 4.3+, Intel Fortran 10.0+, NAG 5.1+\n- Use C_INT, C_DOUBLE, C_PTR, etc. from ISO_C_BINDING\n- Interoperable with corresponding C types\n\n### **See Also**\n\n[**bind_c_function**(3)](#bind_c_function),\n[**bind_c_subroutine**(3)](#bind_c_subroutine),\n[**c_loc**(3)](#c_loc),\n[**c_f_pointer**(3)](#c_f_pointer),\n[**iso_c_binding**(3)](#iso_c_binding)",
  "num_images": "## this_image / num_images\n\n### **Name**\n\n**this_image / num_images** - \\[PARALLEL:COARRAY\\] Query coarray image index and total image count\n\n### **Synopsis**\n```fortran\n    me = this_image()\n    nimages = num_images()\n```\n```fortran\n     function this_image() result(image_index)\n       integer :: image_index\n\n     function this_image(coarray) result(cosubscripts)\n       type(*), dimension[..] :: coarray\n       integer                :: cosubscripts(:)\n\n     function this_image(coarray, dim) result(cosubscript)\n       type(*), dimension[..] :: coarray\n       integer, intent(in)    :: dim\n       integer                :: cosubscript\n\n     function num_images() result(nimages)\n       integer :: nimages\n\n     function num_images(team) result(nimages)\n       type(team_type), intent(in) :: team\n       integer                     :: nimages\n\n     function num_images(team_number) result(nimages)\n       integer, intent(in) :: team_number\n       integer             :: nimages\n```\n\n### **Characteristics**\n\n - **this_image()** with no arguments returns the image index of the invoking image as a default integer.\n - **this_image(coarray)** returns an integer array of cosubscripts for the invoking image.\n - **this_image(coarray, dim)** returns the cosubscript for dimension **dim** as a scalar integer.\n - **num_images()** with no arguments returns the total number of images in the current team.\n - **num_images(team)** returns the number of images in the specified team.\n - **num_images(team_number)** returns the number of images in the team with the specified team number.\n - Image indices range from 1 to num_images().\n\n### **Description**\n\n **this_image** returns the image index of the invoking image within the current team, or the cosubscripts corresponding to the invoking image for a given coarray. **num_images** returns the total number of images in execution, either in the current team or a specified team. These functions are fundamental for coarray parallel programming, enabling each image to identify itself and coordinate with other images.\n\n### **Options**\n\n- **coarray**\n  : A coarray of any type. Used with this_image to determine the cosubscripts that would be used to access the invoking image's portion of the coarray.\n\n- **dim**\n  : An integer scalar indicating which dimension's cosubscript to return. Must be between 1 and the corank of the coarray.\n\n- **team**\n  : A scalar of type TEAM_TYPE from ISO_FORTRAN_ENV, specifying the team to query.\n\n- **team_number**\n  : An integer scalar specifying the team number to query.\n\n### **Result**\n\n  For **this_image()** with no arguments, the result is a default integer representing the image index (1 to num_images()).\n\n  For **this_image(coarray)**, the result is an integer array with size equal to the corank of the coarray, containing the cosubscripts for the invoking image.\n\n  For **this_image(coarray, dim)**, the result is a scalar integer representing the cosubscript for the specified dimension.\n\n  For **num_images()**, the result is a default integer representing the total number of images currently executing.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_coarray_image_query\n  use iso_fortran_env, only: team_type\n  implicit none\n  integer :: me, nimages\n  integer :: data[*]  ! Simple coarray\n  integer :: matrix[2, *]  ! 2D cobounds coarray\n  integer :: cosubs(1)\n\n  ! Get image index and total images\n  me = this_image()\n  nimages = num_images()\n\n  print '(A,I0,A,I0)', 'Image ', me, ' of ', nimages\n\n  ! Initialize local data\n  data = me * 10\n\n  ! Synchronize all images before accessing remote data\n  sync all\n\n  ! Image 1 collects data from all images\n  if (me == 1) then\n    print *, 'Image 1 collecting data:'\n    block\n      integer :: i\n      do i = 1, nimages\n        print '(A,I0,A,I0)', '  data[', i, '] = ', data[i]\n      end do\n    end block\n  end if\n\n  ! Get cosubscripts for a coarray\n  cosubs = this_image(data)\n  print '(A,I0,A,I0)', 'Image ', me, ' has cosubscript: ', cosubs(1)\n\n  sync all\n\nend program demo_coarray_image_query\n```\nResults (with 4 images):\n```text\nImage 1 of 4\nImage 2 of 4\nImage 3 of 4\nImage 4 of 4\n Image 1 collecting data:\n  data[1] = 10\n  data[2] = 20\n  data[3] = 30\n  data[4] = 40\nImage 1 has cosubscript: 1\nImage 2 has cosubscript: 2\nImage 3 has cosubscript: 3\nImage 4 has cosubscript: 4\n```\n\n### **Standard**\n\nFortran 2008 (basic forms), Fortran 2018 (team arguments)\n\n**Compatibility Notes:**\n- gfortran 5.0+, Intel Fortran 12.0+, NAG 6.0+\n- Returns total number of images in current team\n- Use -fcoarray flag with gfortran\n\n### **See Also**\n\n[**sync_all**(3)](#sync_all),\n[**sync_images**(3)](#sync_images),\n[**co_sum**(3)](#co_sum),\n[**co_broadcast**(3)](#co_broadcast),\n[**team_type**(3)](#team_type)",
  "coarrayquery": "## this_image / num_images\n\n### **Name**\n\n**this_image / num_images** - \\[PARALLEL:COARRAY\\] Query coarray image index and total image count\n\n### **Synopsis**\n```fortran\n    me = this_image()\n    nimages = num_images()\n```\n```fortran\n     function this_image() result(image_index)\n       integer :: image_index\n\n     function this_image(coarray) result(cosubscripts)\n       type(*), dimension[..] :: coarray\n       integer                :: cosubscripts(:)\n\n     function this_image(coarray, dim) result(cosubscript)\n       type(*), dimension[..] :: coarray\n       integer, intent(in)    :: dim\n       integer                :: cosubscript\n\n     function num_images() result(nimages)\n       integer :: nimages\n\n     function num_images(team) result(nimages)\n       type(team_type), intent(in) :: team\n       integer                     :: nimages\n\n     function num_images(team_number) result(nimages)\n       integer, intent(in) :: team_number\n       integer             :: nimages\n```\n\n### **Characteristics**\n\n - **this_image()** with no arguments returns the image index of the invoking image as a default integer.\n - **this_image(coarray)** returns an integer array of cosubscripts for the invoking image.\n - **this_image(coarray, dim)** returns the cosubscript for dimension **dim** as a scalar integer.\n - **num_images()** with no arguments returns the total number of images in the current team.\n - **num_images(team)** returns the number of images in the specified team.\n - **num_images(team_number)** returns the number of images in the team with the specified team number.\n - Image indices range from 1 to num_images().\n\n### **Description**\n\n **this_image** returns the image index of the invoking image within the current team, or the cosubscripts corresponding to the invoking image for a given coarray. **num_images** returns the total number of images in execution, either in the current team or a specified team. These functions are fundamental for coarray parallel programming, enabling each image to identify itself and coordinate with other images.\n\n### **Options**\n\n- **coarray**\n  : A coarray of any type. Used with this_image to determine the cosubscripts that would be used to access the invoking image's portion of the coarray.\n\n- **dim**\n  : An integer scalar indicating which dimension's cosubscript to return. Must be between 1 and the corank of the coarray.\n\n- **team**\n  : A scalar of type TEAM_TYPE from ISO_FORTRAN_ENV, specifying the team to query.\n\n- **team_number**\n  : An integer scalar specifying the team number to query.\n\n### **Result**\n\n  For **this_image()** with no arguments, the result is a default integer representing the image index (1 to num_images()).\n\n  For **this_image(coarray)**, the result is an integer array with size equal to the corank of the coarray, containing the cosubscripts for the invoking image.\n\n  For **this_image(coarray, dim)**, the result is a scalar integer representing the cosubscript for the specified dimension.\n\n  For **num_images()**, the result is a default integer representing the total number of images currently executing.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_coarray_image_query\n  use iso_fortran_env, only: team_type\n  implicit none\n  integer :: me, nimages\n  integer :: data[*]  ! Simple coarray\n  integer :: matrix[2, *]  ! 2D cobounds coarray\n  integer :: cosubs(1)\n\n  ! Get image index and total images\n  me = this_image()\n  nimages = num_images()\n\n  print '(A,I0,A,I0)', 'Image ', me, ' of ', nimages\n\n  ! Initialize local data\n  data = me * 10\n\n  ! Synchronize all images before accessing remote data\n  sync all\n\n  ! Image 1 collects data from all images\n  if (me == 1) then\n    print *, 'Image 1 collecting data:'\n    block\n      integer :: i\n      do i = 1, nimages\n        print '(A,I0,A,I0)', '  data[', i, '] = ', data[i]\n      end do\n    end block\n  end if\n\n  ! Get cosubscripts for a coarray\n  cosubs = this_image(data)\n  print '(A,I0,A,I0)', 'Image ', me, ' has cosubscript: ', cosubs(1)\n\n  sync all\n\nend program demo_coarray_image_query\n```\nResults (with 4 images):\n```text\nImage 1 of 4\nImage 2 of 4\nImage 3 of 4\nImage 4 of 4\n Image 1 collecting data:\n  data[1] = 10\n  data[2] = 20\n  data[3] = 30\n  data[4] = 40\nImage 1 has cosubscript: 1\nImage 2 has cosubscript: 2\nImage 3 has cosubscript: 3\nImage 4 has cosubscript: 4\n```\n\n### **Standard**\n\nFortran 2008 (basic forms), Fortran 2018 (team arguments)\n\n**Compatibility Notes:**\n- gfortran 5.0+, Intel Fortran 12.0+, NAG 6.0+\n- THIS_IMAGE() returns current image number\n- NUM_IMAGES() returns total number of images\n\n### **See Also**\n\n[**sync_all**(3)](#sync_all),\n[**sync_images**(3)](#sync_images),\n[**co_sum**(3)](#co_sum),\n[**co_broadcast**(3)](#co_broadcast),\n[**team_type**(3)](#team_type)",
  "errorunit": "## error_unit\n\n### **Name**\n\n**error_unit** - \\[IO:FILE\\] Write diagnostic messages to standard error stream\n\n### **Synopsis**\n```fortran\n    use iso_fortran_env, only: error_unit\n    write(error_unit, fmt) message\n```\n```fortran\n     use iso_fortran_env, only: error_unit, output_unit, input_unit\n\n     ! error_unit is a default integer constant\n     integer, parameter :: error_unit = <processor-defined>\n\n     write(unit=error_unit, fmt=format_spec) output_list\n```\n\n### **Characteristics**\n\n - **error_unit** is a named constant from ISO_FORTRAN_ENV module.\n - It identifies the unit number preconnected to standard error.\n - Typically unit 0 on Unix-like systems, but processor-dependent.\n - Messages written to error_unit appear on stderr, separate from stdout.\n - Useful for error messages that should not mix with program output.\n\n### **Description**\n\n **error_unit** from ISO_FORTRAN_ENV provides a portable way to write to the standard error stream. This is the Fortran equivalent of fprintf(stderr, ...) in C. Error messages written to error_unit:\n - Appear on the terminal even if stdout is redirected\n - Can be redirected separately from normal output\n - Follow Unix conventions for error reporting\n - Are unbuffered on many systems for immediate display\n\n### **Options**\n\n- **error_unit**\n  : The preconnected unit for standard error output. Use with WRITE statement.\n\n- **output_unit**\n  : Related constant for standard output (stdout), typically unit 6.\n\n- **input_unit**\n  : Related constant for standard input (stdin), typically unit 5.\n\n### **Result**\n\n  Formatted output is written to the standard error stream, which is typically displayed on the terminal but can be redirected separately from standard output.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_error_unit\nuse iso_fortran_env, only: error_unit, output_unit\nimplicit none\n  integer :: ierr\n  real :: value\n  character(len=100) :: filename\n\n  filename = 'nonexistent_file.dat'\n\n  ! Normal output goes to stdout\n  write(output_unit, '(A)') 'Program starting...'\n\n  ! Error messages go to stderr\n  open(unit=10, file=filename, status='old', iostat=ierr)\n  if (ierr /= 0) then\n    write(error_unit, '(A,A)') 'ERROR: Cannot open file: ', trim(filename)\n    write(error_unit, '(A,I0)') 'IOSTAT code: ', ierr\n  end if\n\n  ! Demonstrate mixing stdout and stderr\n  write(output_unit, '(A)') 'Continuing with calculations...'\n\n  value = -1.0\n  if (value < 0.0) then\n    write(error_unit, '(A,F8.3)') 'WARNING: Negative value encountered: ', value\n  end if\n\n  write(output_unit, '(A)') 'Program complete.'\n\n  ! Usage with format specifications\n  write(error_unit, '(A,I0,A)') 'Debug: processed ', 100, ' items'\n\nend program demo_error_unit\n```\nResults (stderr output shown with > prefix):\n```text\nProgram starting...\n> ERROR: Cannot open file: nonexistent_file.dat\n> IOSTAT code: 2\nContinuing with calculations...\n> WARNING: Negative value encountered:   -1.000\nProgram complete.\n> Debug: processed 100 items\n```\n\n### **Standard**\n\nFortran 2003 (ISO_FORTRAN_ENV module)\n\n**Compatibility Notes:**\n- gfortran 4.0+, Intel Fortran 9.0+, NAG 5.0+\n- Use ISO_FORTRAN_ENV for portable unit numbers\n- ERROR_UNIT typically maps to stderr (unit 0)\n\n### **See Also**\n\n[**output_unit**(3)](#output_unit),\n[**input_unit**(3)](#input_unit),\n[**write**(3)](#write),\n[**iso_fortran_env**(3)](#iso_fortran_env)",
  "cstring": "## c_to_f_string\n\n### **Name**\n\n**c_to_f_string** - \\[INTEROP:C_BINDING\\] Convert a C null-terminated string to a Fortran string\n\n### **Synopsis**\n```fortran\n    f_string = c_to_f_string(c_string)\n```\n```fortran\n     function c_to_f_string(c_string) result(f_string)\n\n      character(kind=c_char), intent(in) :: c_string(*)\n      character(len=:), allocatable      :: f_string\n```\n\n### **Characteristics**\n\n - **c_string** is a C-style null-terminated character array.\n - **f_string** is an allocatable Fortran character string.\n - The function scans for C_NULL_CHAR to determine string length.\n - The null terminator is NOT included in the Fortran string.\n - Handles empty strings (immediate null terminator) correctly.\n\n### **Description**\n\n **c_to_f_string** converts a C-style null-terminated string to a Fortran\n allocatable character string. This is essential when receiving strings\n from C functions, as C strings use null termination while Fortran uses\n fixed or deferred lengths. The function allocates exactly the right\n amount of memory and copies characters up to (but not including) the\n null terminator.\n\n### **Options**\n\n- **c_string**\n  : A C-style character array ending with C_NULL_CHAR (character(0)).\n  Typically received from a C function via type(c_ptr) and c_f_pointer,\n  or passed directly as character(kind=c_char) array.\n\n### **Result**\n\n  An allocatable character string containing the C string contents without\n  the null terminator. The length equals the position of C_NULL_CHAR minus 1.\n  If the C string is empty (starts with null), returns a zero-length string.\n\n### **Examples**\n\nSample program:\n```fortran\nmodule c_string_utils\n  use iso_c_binding\n  implicit none\ncontains\n\n  ! Convert C null-terminated string to Fortran allocatable string\n  function c_to_f_string(c_string) result(f_string)\n    character(kind=c_char), intent(in) :: c_string(*)\n    character(len=:), allocatable :: f_string\n    integer :: i, length\n\n    ! Find the null terminator\n    length = 0\n    do i = 1, huge(1)\n      if (c_string(i) == c_null_char) exit\n      length = length + 1\n    end do\n\n    ! Allocate and copy\n    allocate(character(len=length) :: f_string)\n    do i = 1, length\n      f_string(i:i) = c_string(i)\n    end do\n  end function c_to_f_string\n\n  ! Convert C pointer to Fortran string\n  function c_ptr_to_f_string(c_ptr_str) result(f_string)\n    type(c_ptr), intent(in) :: c_ptr_str\n    character(len=:), allocatable :: f_string\n    character(kind=c_char), pointer :: c_string(:)\n    integer :: length, i\n\n    if (.not. c_associated(c_ptr_str)) then\n      f_string = ''\n      return\n    end if\n\n    ! Get length first\n    call c_f_pointer(c_ptr_str, c_string, [1024])  ! Max length\n    length = 0\n    do i = 1, 1024\n      if (c_string(i) == c_null_char) exit\n      length = length + 1\n    end do\n\n    ! Allocate and copy\n    allocate(character(len=length) :: f_string)\n    do i = 1, length\n      f_string(i:i) = c_string(i)\n    end do\n  end function c_ptr_to_f_string\n\nend module c_string_utils\n\nprogram demo_c_to_f_string\n  use c_string_utils\n  use iso_c_binding\n  implicit none\n\n  interface\n    ! C function: const char* get_message(void)\n    function get_message() result(ptr) bind(c, name='get_message')\n      import :: c_ptr\n      type(c_ptr) :: ptr\n    end function get_message\n  end interface\n\n  character(kind=c_char) :: c_str(20)\n  character(len=:), allocatable :: f_str\n\n  ! Example 1: Convert inline C string\n  c_str = ['H', 'e', 'l', 'l', 'o', c_null_char, ' ', ' ', ' ', ' ', &\n           ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ']\n  f_str = c_to_f_string(c_str)\n  print '(A,A,A,I0)', 'Converted: \"', f_str, '\" (length: ', len(f_str), ')'\n\n  ! Example 2: Handle empty string\n  c_str(1) = c_null_char\n  f_str = c_to_f_string(c_str)\n  print '(A,I0)', 'Empty string length: ', len(f_str)\n\n  ! Example 3: String with special characters\n  c_str = ['T', 'a', 'b', ':', char(9), 'X', c_null_char, &\n           ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ']\n  f_str = c_to_f_string(c_str)\n  print '(A,A,A)', 'With tab: \"', f_str, '\"'\n\nend program demo_c_to_f_string\n```\n\nResults:\n```text\nConverted: \"Hello\" (length: 5)\nEmpty string length: 0\nWith tab: \"Tab:\tX\"\n```\n\n### **Standard**\n\nFortran 2003 (user-defined utility using ISO_C_BINDING)\n\n**Compatibility Notes:**\n- gfortran 4.3+, Intel Fortran 10.0+, NAG 5.1+\n- C strings are null-terminated (C_NULL_CHAR)\n- Use C_CHAR and character arrays for string interop\n\n### **See Also**\n\n[**f_to_c_string**(3)](#f_to_c_string),\n[**c_f_pointer**(3)](#c_f_pointer),\n[**c_null_char**(3)](#c_null_char),\n[**iso_c_binding**(3)](#iso_c_binding)",
  "ompcritical": "## critical\n\n### **Name**\n\n**critical** - \\[PARALLEL:OPENMP\\] Mutual exclusion synchronization construct\n\n### **Synopsis**\n\n```fortran\n    !$omp critical [(name) [, hint(hint-expression)]]\n        structured-block\n    !$omp end critical [(name)]\n```\n\n```fortran\n    ! Directive structure\n    !$omp critical [(name) [, hint(hint-expr)]]\n\n      ! name           - Optional global identifier for the critical region\n      ! hint-expr      - Scalar expression of kind omp_sync_hint_kind\n\n    !$omp end critical [(name)]\n```\n\n### **Characteristics**\n\n - **name** is an optional global identifier that labels the critical region.\n - **hint-expression** is a constant expression evaluating to a scalar value with kind `omp_sync_hint_kind`.\n - All critical constructs with the same name are treated as the same region.\n - Unnamed critical sections are all treated as the same section.\n - The binding thread set encompasses all threads in the contention group.\n\n### **Description**\n\n **critical** restricts execution of the associated structured block to a single thread at a time. When a thread encounters a critical region, it waits until no other thread in the contention group is executing that named critical region. This provides mutual exclusion synchronization for the enclosed code block.\n\n The optional name acts as a global identifier. Different critical regions with the same name enforce mutual exclusion against each other across all threads in the contention group, regardless of which team the threads belong to.\n\n### **Options**\n\n- **name**\n  : Optional identifier for the critical region. Names are global entities of the program in Fortran. Critical regions with the same name share mutual exclusion. If omitted, the critical section shares an implicit common name with all other unnamed critical sections.\n\n- **hint(hint-expression)**\n  : Optional clause providing implementation hints about expected runtime properties. Valid hint values (from `omp_lib` module):\n  - `omp_sync_hint_none` (default) - No hint specified\n  - `omp_sync_hint_uncontended` - Low contention expected\n  - `omp_sync_hint_contended` - High contention expected\n  - `omp_sync_hint_nonspeculative` - Use non-speculative locking\n  - `omp_sync_hint_speculative` - Use speculative locking (hardware transactional memory)\n  \n  Hints do not affect isolation guarantees and may be ignored by the implementation. A hint clause requires a named construct.\n\n### **Result**\n\n  The critical construct ensures that only one thread at a time executes the enclosed structured block. Upon exiting the critical region, the thread releases the lock, allowing another waiting thread to enter. All memory operations within the critical region are protected from concurrent access by other threads entering the same named (or unnamed) critical region.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_omp_critical\n  use omp_lib\n  implicit none\n  integer :: total, thread_id\n  integer :: i\n  integer, parameter :: n = 100\n\n  total = 0\n\n  !$omp parallel private(thread_id, i)\n    thread_id = omp_get_thread_num()\n\n    ! Named critical section for safe accumulation\n    do i = 1, n\n      !$omp critical (accumulate)\n        total = total + 1\n      !$omp end critical (accumulate)\n    end do\n\n    ! Unnamed critical for I/O\n    !$omp critical\n      print '(A,I2,A,I6)', 'Thread ', thread_id, ' sees total = ', total\n    !$omp end critical\n\n  !$omp end parallel\n\n  print '(A,I6)', 'Final total = ', total\n\nend program demo_omp_critical\n```\n\nSample program with hint clause:\n\n```fortran\nprogram demo_omp_critical_hint\n  use omp_lib\n  implicit none\n  real(8) :: sum_val\n  integer :: i\n  integer, parameter :: n = 1000000\n\n  sum_val = 0.0d0\n\n  !$omp parallel do private(i)\n  do i = 1, n\n    ! Hint that contention is expected (many threads updating)\n    !$omp critical (sum_region, hint(omp_sync_hint_contended))\n      sum_val = sum_val + 1.0d0 / real(i, 8)\n    !$omp end critical (sum_region)\n  end do\n  !$omp end parallel do\n\n  print '(A,F12.6)', 'Harmonic sum approximation = ', sum_val\n\nend program demo_omp_critical_hint\n```\n\nResults:\n```text\nThread  0 sees total =    127\nThread  2 sees total =    298\nThread  1 sees total =    364\nThread  3 sees total =    400\nFinal total =    400\n\nHarmonic sum approximation =    14.392727\n```\n\n### **Standard**\n\nOpenMP 1.0 (critical construct), OpenMP 4.5 (hint clause)\n\n### **See Also**\n\n[**!$omp atomic**(3)](#omp_atomic),\n[**!$omp barrier**(3)](#omp_barrier),\n[**!$omp parallel**(3)](#omp_parallel),\n[**omp_set_lock**(3)](#omp_set_lock),\n[**omp_init_lock_with_hint**(3)](#omp_init_lock_with_hint)\n\n### **Resources**\n\n- [OpenMP 5.0 Critical Construct Specification](https://www.openmp.org/spec-html/5.0/openmpsu89.html)\n- [OpenMP 5.0 Synchronization Hints](https://www.openmp.org/spec-html/5.0/openmpsu100.html)\n- [LLNL HPC Tutorials - Critical Directive](https://hpc-tutorials.llnl.gov/openmp/critical_directive/)",
  "error_unit": "## error_unit\n\n### **Name**\n\n**error_unit** - \\[IO:FILE\\] Write diagnostic messages to standard error stream\n\n### **Synopsis**\n```fortran\n    use iso_fortran_env, only: error_unit\n    write(error_unit, fmt) message\n```\n```fortran\n     use iso_fortran_env, only: error_unit, output_unit, input_unit\n\n     ! error_unit is a default integer constant\n     integer, parameter :: error_unit = <processor-defined>\n\n     write(unit=error_unit, fmt=format_spec) output_list\n```\n\n### **Characteristics**\n\n - **error_unit** is a named constant from ISO_FORTRAN_ENV module.\n - It identifies the unit number preconnected to standard error.\n - Typically unit 0 on Unix-like systems, but processor-dependent.\n - Messages written to error_unit appear on stderr, separate from stdout.\n - Useful for error messages that should not mix with program output.\n\n### **Description**\n\n **error_unit** from ISO_FORTRAN_ENV provides a portable way to write to the standard error stream. This is the Fortran equivalent of fprintf(stderr, ...) in C. Error messages written to error_unit:\n - Appear on the terminal even if stdout is redirected\n - Can be redirected separately from normal output\n - Follow Unix conventions for error reporting\n - Are unbuffered on many systems for immediate display\n\n### **Options**\n\n- **error_unit**\n  : The preconnected unit for standard error output. Use with WRITE statement.\n\n- **output_unit**\n  : Related constant for standard output (stdout), typically unit 6.\n\n- **input_unit**\n  : Related constant for standard input (stdin), typically unit 5.\n\n### **Result**\n\n  Formatted output is written to the standard error stream, which is typically displayed on the terminal but can be redirected separately from standard output.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_error_unit\nuse iso_fortran_env, only: error_unit, output_unit\nimplicit none\n  integer :: ierr\n  real :: value\n  character(len=100) :: filename\n\n  filename = 'nonexistent_file.dat'\n\n  ! Normal output goes to stdout\n  write(output_unit, '(A)') 'Program starting...'\n\n  ! Error messages go to stderr\n  open(unit=10, file=filename, status='old', iostat=ierr)\n  if (ierr /= 0) then\n    write(error_unit, '(A,A)') 'ERROR: Cannot open file: ', trim(filename)\n    write(error_unit, '(A,I0)') 'IOSTAT code: ', ierr\n  end if\n\n  ! Demonstrate mixing stdout and stderr\n  write(output_unit, '(A)') 'Continuing with calculations...'\n\n  value = -1.0\n  if (value < 0.0) then\n    write(error_unit, '(A,F8.3)') 'WARNING: Negative value encountered: ', value\n  end if\n\n  write(output_unit, '(A)') 'Program complete.'\n\n  ! Usage with format specifications\n  write(error_unit, '(A,I0,A)') 'Debug: processed ', 100, ' items'\n\nend program demo_error_unit\n```\nResults (stderr output shown with > prefix):\n```text\nProgram starting...\n> ERROR: Cannot open file: nonexistent_file.dat\n> IOSTAT code: 2\nContinuing with calculations...\n> WARNING: Negative value encountered:   -1.000\nProgram complete.\n> Debug: processed 100 items\n```\n\n### **Standard**\n\nFortran 2003 (ISO_FORTRAN_ENV module)\n\n**Compatibility Notes:**\n- gfortran 4.0+, Intel Fortran 9.0+, NAG 5.0+\n- Use ISO_FORTRAN_ENV for portable unit numbers\n- ERROR_UNIT typically maps to stderr (unit 0)\n\n### **See Also**\n\n[**output_unit**(3)](#output_unit),\n[**input_unit**(3)](#input_unit),\n[**write**(3)](#write),\n[**iso_fortran_env**(3)](#iso_fortran_env)",
  "critical": "## critical\n\n### **Name**\n\n**critical** - \\[PARALLEL:OPENMP\\] Mutual exclusion synchronization construct\n\n### **Synopsis**\n\n```fortran\n    !$omp critical [(name) [, hint(hint-expression)]]\n        structured-block\n    !$omp end critical [(name)]\n```\n\n```fortran\n    ! Directive structure\n    !$omp critical [(name) [, hint(hint-expr)]]\n\n      ! name           - Optional global identifier for the critical region\n      ! hint-expr      - Scalar expression of kind omp_sync_hint_kind\n\n    !$omp end critical [(name)]\n```\n\n### **Characteristics**\n\n - **name** is an optional global identifier that labels the critical region.\n - **hint-expression** is a constant expression evaluating to a scalar value with kind `omp_sync_hint_kind`.\n - All critical constructs with the same name are treated as the same region.\n - Unnamed critical sections are all treated as the same section.\n - The binding thread set encompasses all threads in the contention group.\n\n### **Description**\n\n **critical** restricts execution of the associated structured block to a single thread at a time. When a thread encounters a critical region, it waits until no other thread in the contention group is executing that named critical region. This provides mutual exclusion synchronization for the enclosed code block.\n\n The optional name acts as a global identifier. Different critical regions with the same name enforce mutual exclusion against each other across all threads in the contention group, regardless of which team the threads belong to.\n\n### **Options**\n\n- **name**\n  : Optional identifier for the critical region. Names are global entities of the program in Fortran. Critical regions with the same name share mutual exclusion. If omitted, the critical section shares an implicit common name with all other unnamed critical sections.\n\n- **hint(hint-expression)**\n  : Optional clause providing implementation hints about expected runtime properties. Valid hint values (from `omp_lib` module):\n  - `omp_sync_hint_none` (default) - No hint specified\n  - `omp_sync_hint_uncontended` - Low contention expected\n  - `omp_sync_hint_contended` - High contention expected\n  - `omp_sync_hint_nonspeculative` - Use non-speculative locking\n  - `omp_sync_hint_speculative` - Use speculative locking (hardware transactional memory)\n  \n  Hints do not affect isolation guarantees and may be ignored by the implementation. A hint clause requires a named construct.\n\n### **Result**\n\n  The critical construct ensures that only one thread at a time executes the enclosed structured block. Upon exiting the critical region, the thread releases the lock, allowing another waiting thread to enter. All memory operations within the critical region are protected from concurrent access by other threads entering the same named (or unnamed) critical region.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_omp_critical\n  use omp_lib\n  implicit none\n  integer :: total, thread_id\n  integer :: i\n  integer, parameter :: n = 100\n\n  total = 0\n\n  !$omp parallel private(thread_id, i)\n    thread_id = omp_get_thread_num()\n\n    ! Named critical section for safe accumulation\n    do i = 1, n\n      !$omp critical (accumulate)\n        total = total + 1\n      !$omp end critical (accumulate)\n    end do\n\n    ! Unnamed critical for I/O\n    !$omp critical\n      print '(A,I2,A,I6)', 'Thread ', thread_id, ' sees total = ', total\n    !$omp end critical\n\n  !$omp end parallel\n\n  print '(A,I6)', 'Final total = ', total\n\nend program demo_omp_critical\n```\n\nSample program with hint clause:\n\n```fortran\nprogram demo_omp_critical_hint\n  use omp_lib\n  implicit none\n  real(8) :: sum_val\n  integer :: i\n  integer, parameter :: n = 1000000\n\n  sum_val = 0.0d0\n\n  !$omp parallel do private(i)\n  do i = 1, n\n    ! Hint that contention is expected (many threads updating)\n    !$omp critical (sum_region, hint(omp_sync_hint_contended))\n      sum_val = sum_val + 1.0d0 / real(i, 8)\n    !$omp end critical (sum_region)\n  end do\n  !$omp end parallel do\n\n  print '(A,F12.6)', 'Harmonic sum approximation = ', sum_val\n\nend program demo_omp_critical_hint\n```\n\nResults:\n```text\nThread  0 sees total =    127\nThread  2 sees total =    298\nThread  1 sees total =    364\nThread  3 sees total =    400\nFinal total =    400\n\nHarmonic sum approximation =    14.392727\n```\n\n### **Standard**\n\nOpenMP 1.0 (critical construct), OpenMP 4.5 (hint clause)\n\n### **See Also**\n\n[**!$omp atomic**(3)](#omp_atomic),\n[**!$omp barrier**(3)](#omp_barrier),\n[**!$omp parallel**(3)](#omp_parallel),\n[**omp_set_lock**(3)](#omp_set_lock),\n[**omp_init_lock_with_hint**(3)](#omp_init_lock_with_hint)\n\n### **Resources**\n\n- [OpenMP 5.0 Critical Construct Specification](https://www.openmp.org/spec-html/5.0/openmpsu89.html)\n- [OpenMP 5.0 Synchronization Hints](https://www.openmp.org/spec-html/5.0/openmpsu100.html)\n- [LLNL HPC Tutorials - Critical Directive](https://hpc-tutorials.llnl.gov/openmp/critical_directive/)",
  "c_to_f_string": "## c_to_f_string\n\n### **Name**\n\n**c_to_f_string** - \\[INTEROP:C_BINDING\\] Convert a C null-terminated string to a Fortran string\n\n### **Synopsis**\n```fortran\n    f_string = c_to_f_string(c_string)\n```\n```fortran\n     function c_to_f_string(c_string) result(f_string)\n\n      character(kind=c_char), intent(in) :: c_string(*)\n      character(len=:), allocatable      :: f_string\n```\n\n### **Characteristics**\n\n - **c_string** is a C-style null-terminated character array.\n - **f_string** is an allocatable Fortran character string.\n - The function scans for C_NULL_CHAR to determine string length.\n - The null terminator is NOT included in the Fortran string.\n - Handles empty strings (immediate null terminator) correctly.\n\n### **Description**\n\n **c_to_f_string** converts a C-style null-terminated string to a Fortran\n allocatable character string. This is essential when receiving strings\n from C functions, as C strings use null termination while Fortran uses\n fixed or deferred lengths. The function allocates exactly the right\n amount of memory and copies characters up to (but not including) the\n null terminator.\n\n### **Options**\n\n- **c_string**\n  : A C-style character array ending with C_NULL_CHAR (character(0)).\n  Typically received from a C function via type(c_ptr) and c_f_pointer,\n  or passed directly as character(kind=c_char) array.\n\n### **Result**\n\n  An allocatable character string containing the C string contents without\n  the null terminator. The length equals the position of C_NULL_CHAR minus 1.\n  If the C string is empty (starts with null), returns a zero-length string.\n\n### **Examples**\n\nSample program:\n```fortran\nmodule c_string_utils\n  use iso_c_binding\n  implicit none\ncontains\n\n  ! Convert C null-terminated string to Fortran allocatable string\n  function c_to_f_string(c_string) result(f_string)\n    character(kind=c_char), intent(in) :: c_string(*)\n    character(len=:), allocatable :: f_string\n    integer :: i, length\n\n    ! Find the null terminator\n    length = 0\n    do i = 1, huge(1)\n      if (c_string(i) == c_null_char) exit\n      length = length + 1\n    end do\n\n    ! Allocate and copy\n    allocate(character(len=length) :: f_string)\n    do i = 1, length\n      f_string(i:i) = c_string(i)\n    end do\n  end function c_to_f_string\n\n  ! Convert C pointer to Fortran string\n  function c_ptr_to_f_string(c_ptr_str) result(f_string)\n    type(c_ptr), intent(in) :: c_ptr_str\n    character(len=:), allocatable :: f_string\n    character(kind=c_char), pointer :: c_string(:)\n    integer :: length, i\n\n    if (.not. c_associated(c_ptr_str)) then\n      f_string = ''\n      return\n    end if\n\n    ! Get length first\n    call c_f_pointer(c_ptr_str, c_string, [1024])  ! Max length\n    length = 0\n    do i = 1, 1024\n      if (c_string(i) == c_null_char) exit\n      length = length + 1\n    end do\n\n    ! Allocate and copy\n    allocate(character(len=length) :: f_string)\n    do i = 1, length\n      f_string(i:i) = c_string(i)\n    end do\n  end function c_ptr_to_f_string\n\nend module c_string_utils\n\nprogram demo_c_to_f_string\n  use c_string_utils\n  use iso_c_binding\n  implicit none\n\n  interface\n    ! C function: const char* get_message(void)\n    function get_message() result(ptr) bind(c, name='get_message')\n      import :: c_ptr\n      type(c_ptr) :: ptr\n    end function get_message\n  end interface\n\n  character(kind=c_char) :: c_str(20)\n  character(len=:), allocatable :: f_str\n\n  ! Example 1: Convert inline C string\n  c_str = ['H', 'e', 'l', 'l', 'o', c_null_char, ' ', ' ', ' ', ' ', &\n           ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ']\n  f_str = c_to_f_string(c_str)\n  print '(A,A,A,I0)', 'Converted: \"', f_str, '\" (length: ', len(f_str), ')'\n\n  ! Example 2: Handle empty string\n  c_str(1) = c_null_char\n  f_str = c_to_f_string(c_str)\n  print '(A,I0)', 'Empty string length: ', len(f_str)\n\n  ! Example 3: String with special characters\n  c_str = ['T', 'a', 'b', ':', char(9), 'X', c_null_char, &\n           ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ']\n  f_str = c_to_f_string(c_str)\n  print '(A,A,A)', 'With tab: \"', f_str, '\"'\n\nend program demo_c_to_f_string\n```\n\nResults:\n```text\nConverted: \"Hello\" (length: 5)\nEmpty string length: 0\nWith tab: \"Tab:\tX\"\n```\n\n### **Standard**\n\nFortran 2003 (user-defined utility using ISO_C_BINDING)\n\n**Compatibility Notes:**\n- gfortran 4.3+, Intel Fortran 10.0+, NAG 5.1+\n- Scan for C_NULL_CHAR to find string length\n- Allocate appropriate length Fortran string\n\n### **See Also**\n\n[**f_to_c_string**(3)](#f_to_c_string),\n[**c_f_pointer**(3)](#c_f_pointer),\n[**c_null_char**(3)](#c_null_char),\n[**iso_c_binding**(3)](#iso_c_binding)",
  "mpireduce": "## MPI_Reduce\n\n### **Name**\n\n**MPI_Reduce** - \\[PARALLEL:MPI\\] Perform a global reduction operation across all processes in a communicator\n\n### **Synopsis**\n\n```fortran\n    call MPI_Reduce(sendbuf, recvbuf, count, datatype, op, root, comm, ierr)\n```\n\n```fortran\n     subroutine MPI_Reduce(sendbuf, recvbuf, count, datatype, op, root, comm, ierr)\n\n      <type>            :: sendbuf(*)\n      <type>            :: recvbuf(*)\n      integer           :: count\n      integer           :: datatype\n      integer           :: op\n      integer           :: root\n      integer           :: comm\n      integer           :: ierr\n```\n\n### **Characteristics**\n\n - **sendbuf** is an array of any numeric or logical type containing the local contribution to the reduction.\n - **recvbuf** is an array of the same type as sendbuf; only significant at the root process.\n - **count** is an integer specifying the number of elements in the send buffer.\n - **datatype** is an integer MPI datatype handle (e.g., MPI_DOUBLE_PRECISION, MPI_INTEGER).\n - **op** is an integer MPI operation handle specifying the reduction operation.\n - **root** is an integer specifying the rank of the process that receives the result.\n - **comm** is an integer MPI communicator handle.\n - **ierr** is an integer error code (0 indicates success).\n - All processes in the communicator must call with identical count, datatype, op, root, and comm.\n\n### **Description**\n\n **MPI_Reduce** combines the elements provided in the input buffer of each\n process in the group, using the specified reduction operation **op**, and\n returns the combined value in the output buffer of the process with rank\n **root**. The operation is performed element-wise when count > 1.\n\n### **Options**\n\n- **sendbuf**\n  : Address of the send buffer containing count elements of the specified\n  datatype. Each process contributes its local data to the reduction.\n  The root process may use MPI_IN_PLACE to use recvbuf as both input and output.\n\n- **recvbuf**\n  : Address of the receive buffer where the reduction result is stored.\n  Only significant at the root process; ignored on other processes.\n\n- **count**\n  : Number of elements in the send buffer. Must be non-negative and identical\n  across all processes in the communicator.\n\n- **datatype**\n  : MPI datatype handle describing each element. Common values:\n  MPI_INTEGER, MPI_REAL, MPI_DOUBLE_PRECISION, MPI_COMPLEX, MPI_LOGICAL.\n\n- **op**\n  : MPI reduction operation handle. Predefined operations:\n  - MPI_MAX     - Maximum value\n  - MPI_MIN     - Minimum value\n  - MPI_SUM     - Sum\n  - MPI_PROD    - Product\n  - MPI_LAND    - Logical AND\n  - MPI_BAND    - Bitwise AND\n  - MPI_LOR     - Logical OR\n  - MPI_BOR     - Bitwise OR\n  - MPI_LXOR    - Logical XOR\n  - MPI_BXOR    - Bitwise XOR\n  - MPI_MAXLOC  - Maximum value and location\n  - MPI_MINLOC  - Minimum value and location\n\n- **root**\n  : Rank of the root process (0 to size-1) within the communicator.\n  Only this process receives the reduction result in recvbuf.\n\n- **comm**\n  : MPI communicator handle defining the process group. Typically\n  MPI_COMM_WORLD for all processes or a user-defined communicator.\n\n- **ierr**\n  : Integer error code. Returns MPI_SUCCESS (0) on success, or an\n  MPI error code on failure.\n\n\n\n### **Result**\n\n  On the root process, **recvbuf** contains the combined result of applying\n  the reduction operation to the corresponding elements from all processes.\n  The operation is applied element-wise for arrays (when count > 1). The\n  recvbuf on non-root processes is not modified and may contain undefined\n  values. For MPI_MAXLOC and MPI_MINLOC operations, the result includes\n  both the extreme value and the rank of the process that contributed it.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_mpi_reduce\n  use mpi\n  implicit none\n\n  integer :: ierr, rank, nprocs\n  real(8) :: local_value, global_sum, global_max, global_min\n  real(8), dimension(3) :: local_array, sum_array\n  integer :: i\n\n  ! Initialize MPI\n  call MPI_Init(ierr)\n  call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierr)\n  call MPI_Comm_size(MPI_COMM_WORLD, nprocs, ierr)\n\n  ! Each process has a different value based on its rank\n  local_value = real(rank + 1, 8) * 10.0d0\n\n  ! Reduce with SUM operation - result goes to root (rank 0)\n  call MPI_Reduce(local_value, global_sum, 1, MPI_DOUBLE_PRECISION, &\n                  MPI_SUM, 0, MPI_COMM_WORLD, ierr)\n\n  ! Reduce with MAX operation\n  call MPI_Reduce(local_value, global_max, 1, MPI_DOUBLE_PRECISION, &\n                  MPI_MAX, 0, MPI_COMM_WORLD, ierr)\n\n  ! Reduce with MIN operation\n  call MPI_Reduce(local_value, global_min, 1, MPI_DOUBLE_PRECISION, &\n                  MPI_MIN, 0, MPI_COMM_WORLD, ierr)\n\n  ! Only root process has valid results\n  if (rank == 0) then\n    print '(A,I0,A)', 'Running with ', nprocs, ' processes'\n    print '(A,F10.2)', 'Global sum: ', global_sum\n    print '(A,F10.2)', 'Global max: ', global_max\n    print '(A,F10.2)', 'Global min: ', global_min\n  end if\n\n  ! Example with arrays: reduce multiple elements at once\n  do i = 1, 3\n    local_array(i) = real(rank * 3 + i, 8)\n  end do\n\n  call MPI_Reduce(local_array, sum_array, 3, MPI_DOUBLE_PRECISION, &\n                  MPI_SUM, 0, MPI_COMM_WORLD, ierr)\n\n  if (rank == 0) then\n    print '(A)', 'Array reduction (SUM):'\n    print '(A,3F8.2)', '  Result: ', sum_array\n  end if\n\n  call MPI_Finalize(ierr)\n\nend program demo_mpi_reduce\n```\n\nResults (with 4 processes):\n\n```text\nRunning with 4 processes\nGlobal sum:     100.00\nGlobal max:      40.00\nGlobal min:      10.00\nArray reduction (SUM):\n  Result:    22.00   26.00   30.00\n```\n\n### **Standard**\n\nMPI-1.0\n\n### **See Also**\n\n[**MPI_Allreduce**(3)](#mpi_allreduce),\n[**MPI_Reduce_scatter**(3)](#mpi_reduce_scatter),\n[**MPI_Op_create**(3)](#mpi_op_create),\n[**MPI_Comm_rank**(3)](#mpi_comm_rank),\n[**MPI_Comm_size**(3)](#mpi_comm_size),\n[**MPI_Init**(3)](#mpi_init),\n[**MPI_Finalize**(3)](#mpi_finalize)\n\n### **Resources**\n\n- [Open MPI Documentation](https://docs.open-mpi.org/en/v5.0.x/man-openmpi/man3/MPI_Reduce.3.html)\n- [MPI Forum Standards](https://www.mpi-forum.org/docs/)\n- [MPI Tutorial - Reduce and Allreduce](https://mpitutorial.com/tutorials/mpi-reduce-and-allreduce/)",
  "exitloop": "## exit_named_loop\n\n### **Name**\n\n**exit** - \\[CONTROL:LOOP\\] Terminate execution of a named loop construct\n\n### **Synopsis**\n```fortran\n    exit loop_name\n```\n```fortran\n     loop_name: do i = 1, n\n       if (condition) exit loop_name\n     end do loop_name\n```\n\n### **Characteristics**\n\n - **loop_name** must be the name of an enclosing DO, DO WHILE, or DO CONCURRENT construct.\n - Transfers control to the statement following the named END DO.\n - Enables exiting outer loops from within nested loops.\n - Without a loop name, EXIT terminates the innermost enclosing loop.\n - Control transfers immediately; no further iterations execute.\n\n### **Description**\n\n **exit** causes immediate termination of the named loop construct. Control\n transfers to the first statement following the END DO of the specified loop.\n This is particularly useful in nested loops where you need to exit an outer\n loop based on a condition detected in an inner loop, without having to use\n flags or additional conditional logic.\n\n### **Options**\n\n- **loop_name**\n  : The construct name of the DO loop to exit. Must match the label on an\n  enclosing DO statement. When omitted, EXIT terminates the innermost\n  enclosing DO construct.\n\n### **Result**\n\n  Immediate transfer of control to the statement following the named loop's\n  END DO statement. The loop counter retains its current value.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_exit_named_loop\nimplicit none\n  integer :: i, j, k\n  integer :: target_value\n  logical :: found\n  integer :: matrix(5,5)\n\n  ! Initialize matrix with values\n  do i = 1, 5\n    do j = 1, 5\n      matrix(i,j) = i * 10 + j\n    end do\n  end do\n\n  ! Example 1: Search for value in 2D matrix, exit both loops when found\n  target_value = 34\n  found = .false.\n\n  search_rows: do i = 1, 5\n    search_cols: do j = 1, 5\n      if (matrix(i,j) == target_value) then\n        found = .true.\n        print '(a,i0,a,i0,a,i0)', 'Found ', target_value, &\n              ' at position (', i, ',', j, ')'\n        exit search_rows  ! Exit outer loop immediately\n      end if\n    end do search_cols\n  end do search_rows\n\n  if (.not. found) print '(a,i0,a)', 'Value ', target_value, ' not found'\n\n  ! Example 2: Triple nested loop with targeted exit\n  print '(a)', 'Finding first product > 50:'\n\n  level1: do i = 1, 10\n    level2: do j = 1, 10\n      level3: do k = 1, 10\n        if (i * j * k > 50) then\n          print '(a,i0,a,i0,a,i0,a,i0)', &\n                'i=', i, ', j=', j, ', k=', k, &\n                ', product=', i*j*k\n          exit level1  ! Exit all three loops\n        end if\n      end do level3\n    end do level2\n  end do level1\n\n  ! Example 3: Exit vs Cycle comparison\n  print '(a)', 'Processing with exit condition:'\n  process: do i = 1, 10\n    if (i == 5) exit process  ! Stops at 5\n    print '(a,i0)', 'Processing i = ', i\n  end do process\n\nend program demo_exit_named_loop\n```\nResults:\n```text\nFound 34 at position (3,4)\nFinding first product > 50:\ni=1, j=6, k=9, product=54\nProcessing with exit condition:\nProcessing i = 1\nProcessing i = 2\nProcessing i = 3\nProcessing i = 4\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**cycle**(3)](#cycle),\n[**do**(3)](#do),\n[**do_while**(3)](#do_while),\n[**named_do_loop**(3)](#named_do_loop)",
  "mpi_reduce": "## MPI_Reduce\n\n### **Name**\n\n**MPI_Reduce** - \\[PARALLEL:MPI\\] Perform a global reduction operation across all processes in a communicator\n\n### **Synopsis**\n\n```fortran\n    call MPI_Reduce(sendbuf, recvbuf, count, datatype, op, root, comm, ierr)\n```\n\n```fortran\n     subroutine MPI_Reduce(sendbuf, recvbuf, count, datatype, op, root, comm, ierr)\n\n      <type>            :: sendbuf(*)\n      <type>            :: recvbuf(*)\n      integer           :: count\n      integer           :: datatype\n      integer           :: op\n      integer           :: root\n      integer           :: comm\n      integer           :: ierr\n```\n\n### **Characteristics**\n\n - **sendbuf** is an array of any numeric or logical type containing the local contribution to the reduction.\n - **recvbuf** is an array of the same type as sendbuf; only significant at the root process.\n - **count** is an integer specifying the number of elements in the send buffer.\n - **datatype** is an integer MPI datatype handle (e.g., MPI_DOUBLE_PRECISION, MPI_INTEGER).\n - **op** is an integer MPI operation handle specifying the reduction operation.\n - **root** is an integer specifying the rank of the process that receives the result.\n - **comm** is an integer MPI communicator handle.\n - **ierr** is an integer error code (0 indicates success).\n - All processes in the communicator must call with identical count, datatype, op, root, and comm.\n\n### **Description**\n\n **MPI_Reduce** combines the elements provided in the input buffer of each\n process in the group, using the specified reduction operation **op**, and\n returns the combined value in the output buffer of the process with rank\n **root**. The operation is performed element-wise when count > 1.\n\n### **Options**\n\n- **sendbuf**\n  : Address of the send buffer containing count elements of the specified\n  datatype. Each process contributes its local data to the reduction.\n  The root process may use MPI_IN_PLACE to use recvbuf as both input and output.\n\n- **recvbuf**\n  : Address of the receive buffer where the reduction result is stored.\n  Only significant at the root process; ignored on other processes.\n\n- **count**\n  : Number of elements in the send buffer. Must be non-negative and identical\n  across all processes in the communicator.\n\n- **datatype**\n  : MPI datatype handle describing each element. Common values:\n  MPI_INTEGER, MPI_REAL, MPI_DOUBLE_PRECISION, MPI_COMPLEX, MPI_LOGICAL.\n\n- **op**\n  : MPI reduction operation handle. Predefined operations:\n  - MPI_MAX     - Maximum value\n  - MPI_MIN     - Minimum value\n  - MPI_SUM     - Sum\n  - MPI_PROD    - Product\n  - MPI_LAND    - Logical AND\n  - MPI_BAND    - Bitwise AND\n  - MPI_LOR     - Logical OR\n  - MPI_BOR     - Bitwise OR\n  - MPI_LXOR    - Logical XOR\n  - MPI_BXOR    - Bitwise XOR\n  - MPI_MAXLOC  - Maximum value and location\n  - MPI_MINLOC  - Minimum value and location\n\n- **root**\n  : Rank of the root process (0 to size-1) within the communicator.\n  Only this process receives the reduction result in recvbuf.\n\n- **comm**\n  : MPI communicator handle defining the process group. Typically\n  MPI_COMM_WORLD for all processes or a user-defined communicator.\n\n- **ierr**\n  : Integer error code. Returns MPI_SUCCESS (0) on success, or an\n  MPI error code on failure.\n\n\n\n### **Result**\n\n  On the root process, **recvbuf** contains the combined result of applying\n  the reduction operation to the corresponding elements from all processes.\n  The operation is applied element-wise for arrays (when count > 1). The\n  recvbuf on non-root processes is not modified and may contain undefined\n  values. For MPI_MAXLOC and MPI_MINLOC operations, the result includes\n  both the extreme value and the rank of the process that contributed it.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_mpi_reduce\n  use mpi\n  implicit none\n\n  integer :: ierr, rank, nprocs\n  real(8) :: local_value, global_sum, global_max, global_min\n  real(8), dimension(3) :: local_array, sum_array\n  integer :: i\n\n  ! Initialize MPI\n  call MPI_Init(ierr)\n  call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierr)\n  call MPI_Comm_size(MPI_COMM_WORLD, nprocs, ierr)\n\n  ! Each process has a different value based on its rank\n  local_value = real(rank + 1, 8) * 10.0d0\n\n  ! Reduce with SUM operation - result goes to root (rank 0)\n  call MPI_Reduce(local_value, global_sum, 1, MPI_DOUBLE_PRECISION, &\n                  MPI_SUM, 0, MPI_COMM_WORLD, ierr)\n\n  ! Reduce with MAX operation\n  call MPI_Reduce(local_value, global_max, 1, MPI_DOUBLE_PRECISION, &\n                  MPI_MAX, 0, MPI_COMM_WORLD, ierr)\n\n  ! Reduce with MIN operation\n  call MPI_Reduce(local_value, global_min, 1, MPI_DOUBLE_PRECISION, &\n                  MPI_MIN, 0, MPI_COMM_WORLD, ierr)\n\n  ! Only root process has valid results\n  if (rank == 0) then\n    print '(A,I0,A)', 'Running with ', nprocs, ' processes'\n    print '(A,F10.2)', 'Global sum: ', global_sum\n    print '(A,F10.2)', 'Global max: ', global_max\n    print '(A,F10.2)', 'Global min: ', global_min\n  end if\n\n  ! Example with arrays: reduce multiple elements at once\n  do i = 1, 3\n    local_array(i) = real(rank * 3 + i, 8)\n  end do\n\n  call MPI_Reduce(local_array, sum_array, 3, MPI_DOUBLE_PRECISION, &\n                  MPI_SUM, 0, MPI_COMM_WORLD, ierr)\n\n  if (rank == 0) then\n    print '(A)', 'Array reduction (SUM):'\n    print '(A,3F8.2)', '  Result: ', sum_array\n  end if\n\n  call MPI_Finalize(ierr)\n\nend program demo_mpi_reduce\n```\n\nResults (with 4 processes):\n\n```text\nRunning with 4 processes\nGlobal sum:     100.00\nGlobal max:      40.00\nGlobal min:      10.00\nArray reduction (SUM):\n  Result:    22.00   26.00   30.00\n```\n\n### **Standard**\n\nMPI-1.0\n\n### **See Also**\n\n[**MPI_Allreduce**(3)](#mpi_allreduce),\n[**MPI_Reduce_scatter**(3)](#mpi_reduce_scatter),\n[**MPI_Op_create**(3)](#mpi_op_create),\n[**MPI_Comm_rank**(3)](#mpi_comm_rank),\n[**MPI_Comm_size**(3)](#mpi_comm_size),\n[**MPI_Init**(3)](#mpi_init),\n[**MPI_Finalize**(3)](#mpi_finalize)\n\n### **Resources**\n\n- [Open MPI Documentation](https://docs.open-mpi.org/en/v5.0.x/man-openmpi/man3/MPI_Reduce.3.html)\n- [MPI Forum Standards](https://www.mpi-forum.org/docs/)\n- [MPI Tutorial - Reduce and Allreduce](https://mpitutorial.com/tutorials/mpi-reduce-and-allreduce/)",
  "exit_loop": "## exit_named_loop\n\n### **Name**\n\n**exit** - \\[CONTROL:LOOP\\] Terminate execution of a named loop construct\n\n### **Synopsis**\n```fortran\n    exit loop_name\n```\n```fortran\n     loop_name: do i = 1, n\n       if (condition) exit loop_name\n     end do loop_name\n```\n\n### **Characteristics**\n\n - **loop_name** must be the name of an enclosing DO, DO WHILE, or DO CONCURRENT construct.\n - Transfers control to the statement following the named END DO.\n - Enables exiting outer loops from within nested loops.\n - Without a loop name, EXIT terminates the innermost enclosing loop.\n - Control transfers immediately; no further iterations execute.\n\n### **Description**\n\n **exit** causes immediate termination of the named loop construct. Control\n transfers to the first statement following the END DO of the specified loop.\n This is particularly useful in nested loops where you need to exit an outer\n loop based on a condition detected in an inner loop, without having to use\n flags or additional conditional logic.\n\n### **Options**\n\n- **loop_name**\n  : The construct name of the DO loop to exit. Must match the label on an\n  enclosing DO statement. When omitted, EXIT terminates the innermost\n  enclosing DO construct.\n\n### **Result**\n\n  Immediate transfer of control to the statement following the named loop's\n  END DO statement. The loop counter retains its current value.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_exit_named_loop\nimplicit none\n  integer :: i, j, k\n  integer :: target_value\n  logical :: found\n  integer :: matrix(5,5)\n\n  ! Initialize matrix with values\n  do i = 1, 5\n    do j = 1, 5\n      matrix(i,j) = i * 10 + j\n    end do\n  end do\n\n  ! Example 1: Search for value in 2D matrix, exit both loops when found\n  target_value = 34\n  found = .false.\n\n  search_rows: do i = 1, 5\n    search_cols: do j = 1, 5\n      if (matrix(i,j) == target_value) then\n        found = .true.\n        print '(a,i0,a,i0,a,i0)', 'Found ', target_value, &\n              ' at position (', i, ',', j, ')'\n        exit search_rows  ! Exit outer loop immediately\n      end if\n    end do search_cols\n  end do search_rows\n\n  if (.not. found) print '(a,i0,a)', 'Value ', target_value, ' not found'\n\n  ! Example 2: Triple nested loop with targeted exit\n  print '(a)', 'Finding first product > 50:'\n\n  level1: do i = 1, 10\n    level2: do j = 1, 10\n      level3: do k = 1, 10\n        if (i * j * k > 50) then\n          print '(a,i0,a,i0,a,i0,a,i0)', &\n                'i=', i, ', j=', j, ', k=', k, &\n                ', product=', i*j*k\n          exit level1  ! Exit all three loops\n        end if\n      end do level3\n    end do level2\n  end do level1\n\n  ! Example 3: Exit vs Cycle comparison\n  print '(a)', 'Processing with exit condition:'\n  process: do i = 1, 10\n    if (i == 5) exit process  ! Stops at 5\n    print '(a,i0)', 'Processing i = ', i\n  end do process\n\nend program demo_exit_named_loop\n```\nResults:\n```text\nFound 34 at position (3,4)\nFinding first product > 50:\ni=1, j=6, k=9, product=54\nProcessing with exit condition:\nProcessing i = 1\nProcessing i = 2\nProcessing i = 3\nProcessing i = 4\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**cycle**(3)](#cycle),\n[**do**(3)](#do),\n[**do_while**(3)](#do_while),\n[**named_do_loop**(3)](#named_do_loop)",
  "paralleldo": "## omp_parallel_do\n\n### **Name**\n\n**omp_parallel_do** - \\[PARALLEL:OPENMP\\] Combined parallel worksharing-loop construct\n\n### **Synopsis**\n\n```fortran\n    !$omp parallel do [clause [[,] clause] ...]\n    do i = start, end [, step]\n      ! loop body\n    end do\n    !$omp end parallel do\n```\n\n```fortran\n    !$omp parallel do private(list) shared(list) default(none|shared|private)\n    !$omp& firstprivate(list) lastprivate(list) reduction(operator:list)\n    !$omp& schedule(type [, chunk_size]) collapse(n) ordered\n    !$omp& if(scalar-logical-expr) num_threads(scalar-integer-expr)\n    do index = lower, upper [, stride]\n      ! loop body - iterations distributed across threads\n    end do\n    !$omp end parallel do\n```\n\n### **Characteristics**\n\n - **private(list)** creates thread-private copies of listed variables with undefined initial values.\n - **shared(list)** specifies variables shared among all threads in the team.\n - **default(none|shared|private)** sets the default data-sharing attribute for variables.\n - **firstprivate(list)** creates private copies initialized from the original value.\n - **lastprivate(list)** copies the value from the last sequential iteration to the original.\n - **reduction(operator:list)** performs a reduction operation across all threads.\n - **schedule(type [, chunk])** controls how loop iterations are distributed among threads.\n - **collapse(n)** combines n nested loops into a single iteration space.\n - **ordered** enforces sequential ordering for ordered regions within the loop.\n - **if(expr)** conditionally executes in parallel; runs serially if false.\n - **num_threads(expr)** specifies the number of threads to use.\n - An implicit barrier exists at the end of the parallel do region.\n\n### **Description**\n\n **!$omp parallel do** creates a parallel region containing a single worksharing-loop construct, distributing loop iterations across a team of threads. This combined construct is a shorthand for a parallel region containing only a single do directive, and is the most common OpenMP construct for parallelizing Fortran loops.\n\n When execution reaches the parallel do directive, a team of threads is created. The loop iterations are then distributed among the threads according to the schedule clause. Each thread executes its assigned portion of the loop iterations. At the end of the construct, threads synchronize at an implicit barrier before only the master thread continues.\n\n### **Options**\n\n- **private(list)**\n  : Creates a new private instance of each listed variable for each thread. The initial value is undefined. At the end of the parallel region, the original variable is unchanged.\n\n- **shared(list)**\n  : Specifies that listed variables are shared among all threads. All threads access the same storage location. Care must be taken to avoid race conditions.\n\n- **default(none|shared|private)**\n  : Sets the default data-sharing attribute for variables. Using `none` is recommended as it requires explicit specification of all variables, preventing accidental sharing bugs.\n\n- **firstprivate(list)**\n  : Like private, but each thread's copy is initialized from the original variable's value before the parallel region begins.\n\n- **lastprivate(list)**\n  : Like private, but the value from the sequentially last iteration is copied back to the original variable after the loop completes.\n\n- **reduction(operator:list)**\n  : Performs a reduction using the specified operator. Each thread has a private copy initialized appropriately (0 for +, 1 for *, etc.). At region end, partial results are combined. Operators: +, -, *, .and., .or., .eqv., .neqv., max, min, iand, ior, ieor.\n\n- **schedule(type [, chunk_size])**\n  : Controls iteration distribution:\n  - `static` - Iterations divided into chunks assigned round-robin (default)\n  - `dynamic` - Threads take chunks from a queue as they finish\n  - `guided` - Chunk sizes decrease exponentially\n  - `runtime` - Determined by OMP_SCHEDULE environment variable\n  - `auto` - Compiler/runtime decides\n\n- **collapse(n)**\n  : Combines n nested loops into one larger iteration space for better load balancing.\n\n- **num_threads(expr)**\n  : Specifies the number of threads for the parallel region.\n\n- **if(expr)**\n  : If false, the region executes serially with a single thread.\n\n### **Result**\n\n  The parallel do construct distributes loop iterations across multiple threads, achieving parallel execution of the loop body. Upon completion, all threads have executed their assigned iterations, any reduction variables contain the combined result, and lastprivate variables hold the value from the final sequential iteration.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_omp_parallel_do\n  use omp_lib\n  implicit none\n  integer, parameter :: n = 1000\n  real(8) :: a(n), b(n), c(n)\n  real(8) :: sum_result\n  integer :: i, thread_id\n\n  ! Initialize arrays\n  do i = 1, n\n    a(i) = real(i, 8)\n    b(i) = real(i, 8) * 2.0d0\n  end do\n\n  ! Basic parallel do - array addition\n  !$omp parallel do private(i) shared(a, b, c)\n  do i = 1, n\n    c(i) = a(i) + b(i)\n  end do\n  !$omp end parallel do\n\n  print '(A,F10.2)', 'c(1) = ', c(1)\n  print '(A,F10.2)', 'c(n) = ', c(n)\n\n  ! Parallel do with reduction\n  sum_result = 0.0d0\n  !$omp parallel do private(i) shared(a) reduction(+:sum_result)\n  do i = 1, n\n    sum_result = sum_result + a(i)\n  end do\n  !$omp end parallel do\n\n  print '(A,F15.2)', 'Sum of a: ', sum_result\n\n  ! Parallel do with schedule and thread info\n  !$omp parallel do private(i, thread_id) schedule(dynamic, 100)\n  do i = 1, n\n    thread_id = omp_get_thread_num()\n    if (mod(i, 250) == 0) then\n      !$omp critical\n      print '(A,I4,A,I2)', 'Iteration ', i, ' executed by thread ', thread_id\n      !$omp end critical\n    end if\n  end do\n  !$omp end parallel do\n\nend program demo_omp_parallel_do\n```\n\nCompile with:\n```text\ngfortran -fopenmp demo_omp_parallel_do.f90 -o demo_omp_parallel_do\nifort -qopenmp demo_omp_parallel_do.f90 -o demo_omp_parallel_do\n```\n\nResults:\n```text\nc(1) =       3.00\nc(n) =    3000.00\nSum of a:       500500.00\nIteration  250 executed by thread  1\nIteration  500 executed by thread  0\nIteration  750 executed by thread  2\nIteration 1000 executed by thread  3\n```\n\n### **Standard**\n\nOpenMP 1.0 (1997 for Fortran)\n\n### **See Also**\n\n[**!$omp parallel**(3)](#omp_parallel),\n[**!$omp do**(3)](#omp_do),\n[**!$omp parallel do simd**(3)](#omp_parallel_do_simd),\n[**!$omp critical**(3)](#omp_critical),\n[**!$omp reduction**(3)](#omp_reduction),\n[**omp_get_thread_num**(3)](#omp_get_thread_num),\n[**omp_get_num_threads**(3)](#omp_get_num_threads)\n\n### **Resources**\n\n- [OpenMP 5.0 Worksharing-Loop Construct](https://www.openmp.org/spec-html/5.0/openmpsu41.html)\n- [LLNL OpenMP Tutorial](https://hpc-tutorials.llnl.gov/openmp/)\n- [OpenMP Official Site](https://www.openmp.org/)",
  "omp_parallel_do": "## omp_parallel_do\n\n### **Name**\n\n**omp_parallel_do** - \\[PARALLEL:OPENMP\\] Combined parallel worksharing-loop construct\n\n### **Synopsis**\n\n```fortran\n    !$omp parallel do [clause [[,] clause] ...]\n    do i = start, end [, step]\n      ! loop body\n    end do\n    !$omp end parallel do\n```\n\n```fortran\n    !$omp parallel do private(list) shared(list) default(none|shared|private)\n    !$omp& firstprivate(list) lastprivate(list) reduction(operator:list)\n    !$omp& schedule(type [, chunk_size]) collapse(n) ordered\n    !$omp& if(scalar-logical-expr) num_threads(scalar-integer-expr)\n    do index = lower, upper [, stride]\n      ! loop body - iterations distributed across threads\n    end do\n    !$omp end parallel do\n```\n\n### **Characteristics**\n\n - **private(list)** creates thread-private copies of listed variables with undefined initial values.\n - **shared(list)** specifies variables shared among all threads in the team.\n - **default(none|shared|private)** sets the default data-sharing attribute for variables.\n - **firstprivate(list)** creates private copies initialized from the original value.\n - **lastprivate(list)** copies the value from the last sequential iteration to the original.\n - **reduction(operator:list)** performs a reduction operation across all threads.\n - **schedule(type [, chunk])** controls how loop iterations are distributed among threads.\n - **collapse(n)** combines n nested loops into a single iteration space.\n - **ordered** enforces sequential ordering for ordered regions within the loop.\n - **if(expr)** conditionally executes in parallel; runs serially if false.\n - **num_threads(expr)** specifies the number of threads to use.\n - An implicit barrier exists at the end of the parallel do region.\n\n### **Description**\n\n **!$omp parallel do** creates a parallel region containing a single worksharing-loop construct, distributing loop iterations across a team of threads. This combined construct is a shorthand for a parallel region containing only a single do directive, and is the most common OpenMP construct for parallelizing Fortran loops.\n\n When execution reaches the parallel do directive, a team of threads is created. The loop iterations are then distributed among the threads according to the schedule clause. Each thread executes its assigned portion of the loop iterations. At the end of the construct, threads synchronize at an implicit barrier before only the master thread continues.\n\n### **Options**\n\n- **private(list)**\n  : Creates a new private instance of each listed variable for each thread. The initial value is undefined. At the end of the parallel region, the original variable is unchanged.\n\n- **shared(list)**\n  : Specifies that listed variables are shared among all threads. All threads access the same storage location. Care must be taken to avoid race conditions.\n\n- **default(none|shared|private)**\n  : Sets the default data-sharing attribute for variables. Using `none` is recommended as it requires explicit specification of all variables, preventing accidental sharing bugs.\n\n- **firstprivate(list)**\n  : Like private, but each thread's copy is initialized from the original variable's value before the parallel region begins.\n\n- **lastprivate(list)**\n  : Like private, but the value from the sequentially last iteration is copied back to the original variable after the loop completes.\n\n- **reduction(operator:list)**\n  : Performs a reduction using the specified operator. Each thread has a private copy initialized appropriately (0 for +, 1 for *, etc.). At region end, partial results are combined. Operators: +, -, *, .and., .or., .eqv., .neqv., max, min, iand, ior, ieor.\n\n- **schedule(type [, chunk_size])**\n  : Controls iteration distribution:\n  - `static` - Iterations divided into chunks assigned round-robin (default)\n  - `dynamic` - Threads take chunks from a queue as they finish\n  - `guided` - Chunk sizes decrease exponentially\n  - `runtime` - Determined by OMP_SCHEDULE environment variable\n  - `auto` - Compiler/runtime decides\n\n- **collapse(n)**\n  : Combines n nested loops into one larger iteration space for better load balancing.\n\n- **num_threads(expr)**\n  : Specifies the number of threads for the parallel region.\n\n- **if(expr)**\n  : If false, the region executes serially with a single thread.\n\n### **Result**\n\n  The parallel do construct distributes loop iterations across multiple threads, achieving parallel execution of the loop body. Upon completion, all threads have executed their assigned iterations, any reduction variables contain the combined result, and lastprivate variables hold the value from the final sequential iteration.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_omp_parallel_do\n  use omp_lib\n  implicit none\n  integer, parameter :: n = 1000\n  real(8) :: a(n), b(n), c(n)\n  real(8) :: sum_result\n  integer :: i, thread_id\n\n  ! Initialize arrays\n  do i = 1, n\n    a(i) = real(i, 8)\n    b(i) = real(i, 8) * 2.0d0\n  end do\n\n  ! Basic parallel do - array addition\n  !$omp parallel do private(i) shared(a, b, c)\n  do i = 1, n\n    c(i) = a(i) + b(i)\n  end do\n  !$omp end parallel do\n\n  print '(A,F10.2)', 'c(1) = ', c(1)\n  print '(A,F10.2)', 'c(n) = ', c(n)\n\n  ! Parallel do with reduction\n  sum_result = 0.0d0\n  !$omp parallel do private(i) shared(a) reduction(+:sum_result)\n  do i = 1, n\n    sum_result = sum_result + a(i)\n  end do\n  !$omp end parallel do\n\n  print '(A,F15.2)', 'Sum of a: ', sum_result\n\n  ! Parallel do with schedule and thread info\n  !$omp parallel do private(i, thread_id) schedule(dynamic, 100)\n  do i = 1, n\n    thread_id = omp_get_thread_num()\n    if (mod(i, 250) == 0) then\n      !$omp critical\n      print '(A,I4,A,I2)', 'Iteration ', i, ' executed by thread ', thread_id\n      !$omp end critical\n    end if\n  end do\n  !$omp end parallel do\n\nend program demo_omp_parallel_do\n```\n\nCompile with:\n```text\ngfortran -fopenmp demo_omp_parallel_do.f90 -o demo_omp_parallel_do\nifort -qopenmp demo_omp_parallel_do.f90 -o demo_omp_parallel_do\n```\n\nResults:\n```text\nc(1) =       3.00\nc(n) =    3000.00\nSum of a:       500500.00\nIteration  250 executed by thread  1\nIteration  500 executed by thread  0\nIteration  750 executed by thread  2\nIteration 1000 executed by thread  3\n```\n\n### **Standard**\n\nOpenMP 1.0 (1997 for Fortran)\n\n### **See Also**\n\n[**!$omp parallel**(3)](#omp_parallel),\n[**!$omp do**(3)](#omp_do),\n[**!$omp parallel do simd**(3)](#omp_parallel_do_simd),\n[**!$omp critical**(3)](#omp_critical),\n[**!$omp reduction**(3)](#omp_reduction),\n[**omp_get_thread_num**(3)](#omp_get_thread_num),\n[**omp_get_num_threads**(3)](#omp_get_num_threads)\n\n### **Resources**\n\n- [OpenMP 5.0 Worksharing-Loop Construct](https://www.openmp.org/spec-html/5.0/openmpsu41.html)\n- [LLNL OpenMP Tutorial](https://hpc-tutorials.llnl.gov/openmp/)\n- [OpenMP Official Site](https://www.openmp.org/)",
  "extends": "## extended_type\n\n### **Name**\n\n**extended_type** - \\[STRUCTURE:TYPE\\] Define a derived type that inherits from a parent type\n\n### **Synopsis**\n\n```fortran\n    type, extends(parent_type) :: child_type\n```\n\n```fortran\n     type, extends(parent_type) :: child_type\n\n      ! Inherited components from parent_type are implicitly available\n      type(component_type) :: new_component  ! Additional components\n     contains\n      procedure :: new_method  ! Additional type-bound procedures\n     end type child_type\n```\n\n### **Characteristics**\n\n - **parent_type** is an existing extensible derived type (non-SEQUENCE, non-BIND(C)).\n - **child_type** inherits all components and type-bound procedures from **parent_type**.\n - The child type can add new components and procedures, or override inherited procedures.\n - A child type object can be used anywhere a parent type is expected (polymorphism).\n - Only single inheritance is supported; a type can extend exactly one parent.\n\n### **Description**\n\n **extended_type** uses the EXTENDS attribute to create a derived type that inherits\n from a parent type. The child type automatically contains all components and\n type-bound procedures of the parent type, and can add new components, add new\n procedures, or override inherited procedures with its own implementations.\n This enables object-oriented programming patterns including inheritance and\n polymorphism in Fortran.\n\n### **Options**\n\n- **parent_type**\n  : The name of the base type to inherit from. Must be an extensible derived\n  type (cannot be SEQUENCE or BIND(C) type). The parent type must be accessible\n  in the current scope.\n\n- **child_type**\n  : The name of the new derived type being defined. This type will contain all\n  components of parent_type plus any additional components declared in the\n  type definition body.\n\n- **new_component**\n  : Optional additional component declarations. These extend the parent type's\n  component list. Access the parent's components directly by name.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_extended_type\nimplicit none\n\n  ! Base type for geometric shapes\n  type :: shape\n    real :: x = 0.0  ! x-coordinate of center\n    real :: y = 0.0  ! y-coordinate of center\n  contains\n    procedure :: move => shape_move\n    procedure :: describe => shape_describe\n  end type shape\n\n  ! Extended type: circle inherits from shape\n  type, extends(shape) :: circle\n    real :: radius = 1.0\n  contains\n    procedure :: area => circle_area\n    procedure :: describe => circle_describe  ! Override parent method\n  end type circle\n\n  ! Extended type: rectangle inherits from shape\n  type, extends(shape) :: rectangle\n    real :: width = 1.0\n    real :: height = 1.0\n  contains\n    procedure :: area => rectangle_area\n    procedure :: describe => rectangle_describe  ! Override parent method\n  end type rectangle\n\n  type(circle) :: c\n  type(rectangle) :: r\n  class(shape), pointer :: s\n\n  ! Initialize objects\n  c = circle(x=0.0, y=0.0, radius=5.0)\n  r = rectangle(x=2.0, y=3.0, width=4.0, height=6.0)\n\n  ! Call inherited method\n  call c%move(1.0, 1.0)\n  print *, 'Circle center after move:', c%x, c%y\n\n  ! Call overridden method\n  call c%describe()\n  call r%describe()\n\n  ! Demonstrate polymorphism\n  s => c\n  call s%describe()  ! Calls circle_describe\n\n  s => r\n  call s%describe()  ! Calls rectangle_describe\n\n  print *, 'Circle area:', c%area()\n  print *, 'Rectangle area:', r%area()\n\ncontains\n\n  subroutine shape_move(self, dx, dy)\n    class(shape), intent(inout) :: self\n    real, intent(in) :: dx, dy\n    self%x = self%x + dx\n    self%y = self%y + dy\n  end subroutine shape_move\n\n  subroutine shape_describe(self)\n    class(shape), intent(in) :: self\n    print *, 'Shape at (', self%x, ',', self%y, ')'\n  end subroutine shape_describe\n\n  subroutine circle_describe(self)\n    class(circle), intent(in) :: self\n    print *, 'Circle at (', self%x, ',', self%y, ') with radius', self%radius\n  end subroutine circle_describe\n\n  function circle_area(self) result(a)\n    class(circle), intent(in) :: self\n    real :: a\n    real, parameter :: pi = 3.14159265359\n    a = pi * self%radius**2\n  end function circle_area\n\n  subroutine rectangle_describe(self)\n    class(rectangle), intent(in) :: self\n    print *, 'Rectangle at (', self%x, ',', self%y, ') size', self%width, 'x', self%height\n  end subroutine rectangle_describe\n\n  function rectangle_area(self) result(a)\n    class(rectangle), intent(in) :: self\n    real :: a\n    a = self%width * self%height\n  end function rectangle_area\n\nend program demo_extended_type\n```\n\nResults:\n\n```text\n Circle center after move:   1.00000000       1.00000000\n Circle at (   1.00000000     ,   1.00000000     ) with radius   5.00000000\n Rectangle at (   2.00000000     ,   3.00000000     ) size   4.00000000     x   6.00000000\n Circle at (   1.00000000     ,   1.00000000     ) with radius   5.00000000\n Rectangle at (   2.00000000     ,   3.00000000     ) size   4.00000000     x   6.00000000\n Circle area:   78.5398178\n Rectangle area:   24.0000000\n```\n\n### **Standard**\n\nFortran 2003\n\n**Compatibility Notes:**\n- gfortran 4.5+, Intel Fortran 12.0+, NAG 5.3+\n- Only single inheritance supported in Fortran\n- Extended type includes all components and procedures from parent\n\n### **See Also**\n\n[**type**](#type),\n[**class**](#class),\n[**select_type**](#select_type),\n[**abstract_type**](#abstract_type),\n[**procedure**](#procedure)",
  "extendedtype": "## extended_type\n\n### **Name**\n\n**extended_type** - \\[STRUCTURE:TYPE\\] Define a derived type that inherits from a parent type\n\n### **Synopsis**\n\n```fortran\n    type, extends(parent_type) :: child_type\n```\n\n```fortran\n     type, extends(parent_type) :: child_type\n\n      ! Inherited components from parent_type are implicitly available\n      type(component_type) :: new_component  ! Additional components\n     contains\n      procedure :: new_method  ! Additional type-bound procedures\n     end type child_type\n```\n\n### **Characteristics**\n\n - **parent_type** is an existing extensible derived type (non-SEQUENCE, non-BIND(C)).\n - **child_type** inherits all components and type-bound procedures from **parent_type**.\n - The child type can add new components and procedures, or override inherited procedures.\n - A child type object can be used anywhere a parent type is expected (polymorphism).\n - Only single inheritance is supported; a type can extend exactly one parent.\n\n### **Description**\n\n **extended_type** uses the EXTENDS attribute to create a derived type that inherits\n from a parent type. The child type automatically contains all components and\n type-bound procedures of the parent type, and can add new components, add new\n procedures, or override inherited procedures with its own implementations.\n This enables object-oriented programming patterns including inheritance and\n polymorphism in Fortran.\n\n### **Options**\n\n- **parent_type**\n  : The name of the base type to inherit from. Must be an extensible derived\n  type (cannot be SEQUENCE or BIND(C) type). The parent type must be accessible\n  in the current scope.\n\n- **child_type**\n  : The name of the new derived type being defined. This type will contain all\n  components of parent_type plus any additional components declared in the\n  type definition body.\n\n- **new_component**\n  : Optional additional component declarations. These extend the parent type's\n  component list. Access the parent's components directly by name.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_extended_type\nimplicit none\n\n  ! Base type for geometric shapes\n  type :: shape\n    real :: x = 0.0  ! x-coordinate of center\n    real :: y = 0.0  ! y-coordinate of center\n  contains\n    procedure :: move => shape_move\n    procedure :: describe => shape_describe\n  end type shape\n\n  ! Extended type: circle inherits from shape\n  type, extends(shape) :: circle\n    real :: radius = 1.0\n  contains\n    procedure :: area => circle_area\n    procedure :: describe => circle_describe  ! Override parent method\n  end type circle\n\n  ! Extended type: rectangle inherits from shape\n  type, extends(shape) :: rectangle\n    real :: width = 1.0\n    real :: height = 1.0\n  contains\n    procedure :: area => rectangle_area\n    procedure :: describe => rectangle_describe  ! Override parent method\n  end type rectangle\n\n  type(circle) :: c\n  type(rectangle) :: r\n  class(shape), pointer :: s\n\n  ! Initialize objects\n  c = circle(x=0.0, y=0.0, radius=5.0)\n  r = rectangle(x=2.0, y=3.0, width=4.0, height=6.0)\n\n  ! Call inherited method\n  call c%move(1.0, 1.0)\n  print *, 'Circle center after move:', c%x, c%y\n\n  ! Call overridden method\n  call c%describe()\n  call r%describe()\n\n  ! Demonstrate polymorphism\n  s => c\n  call s%describe()  ! Calls circle_describe\n\n  s => r\n  call s%describe()  ! Calls rectangle_describe\n\n  print *, 'Circle area:', c%area()\n  print *, 'Rectangle area:', r%area()\n\ncontains\n\n  subroutine shape_move(self, dx, dy)\n    class(shape), intent(inout) :: self\n    real, intent(in) :: dx, dy\n    self%x = self%x + dx\n    self%y = self%y + dy\n  end subroutine shape_move\n\n  subroutine shape_describe(self)\n    class(shape), intent(in) :: self\n    print *, 'Shape at (', self%x, ',', self%y, ')'\n  end subroutine shape_describe\n\n  subroutine circle_describe(self)\n    class(circle), intent(in) :: self\n    print *, 'Circle at (', self%x, ',', self%y, ') with radius', self%radius\n  end subroutine circle_describe\n\n  function circle_area(self) result(a)\n    class(circle), intent(in) :: self\n    real :: a\n    real, parameter :: pi = 3.14159265359\n    a = pi * self%radius**2\n  end function circle_area\n\n  subroutine rectangle_describe(self)\n    class(rectangle), intent(in) :: self\n    print *, 'Rectangle at (', self%x, ',', self%y, ') size', self%width, 'x', self%height\n  end subroutine rectangle_describe\n\n  function rectangle_area(self) result(a)\n    class(rectangle), intent(in) :: self\n    real :: a\n    a = self%width * self%height\n  end function rectangle_area\n\nend program demo_extended_type\n```\n\nResults:\n\n```text\n Circle center after move:   1.00000000       1.00000000\n Circle at (   1.00000000     ,   1.00000000     ) with radius   5.00000000\n Rectangle at (   2.00000000     ,   3.00000000     ) size   4.00000000     x   6.00000000\n Circle at (   1.00000000     ,   1.00000000     ) with radius   5.00000000\n Rectangle at (   2.00000000     ,   3.00000000     ) size   4.00000000     x   6.00000000\n Circle area:   78.5398178\n Rectangle area:   24.0000000\n```\n\n### **Standard**\n\nFortran 2003\n\n**Compatibility Notes:**\n- gfortran 4.5+, Intel Fortran 12.0+, NAG 5.3+\n- Only single inheritance supported\n- Parent components accessed via parent-component syntax\n\n### **See Also**\n\n[**type**](#type),\n[**class**](#class),\n[**select_type**](#select_type),\n[**abstract_type**](#abstract_type),\n[**procedure**](#procedure)",
  "destructor": "## type_destructor\n\n### **Name**\n\n**type_destructor** - \\[STRUCTURE:TYPE\\] Subroutine for derived type cleanup and resource deallocation\n\n### **Synopsis**\n```fortran\n    call type_name_destructor(self)\n```\n```fortran\n     subroutine type_name_destructor(self)\n\n      type(type_name), intent(inout) :: self\n```\n\n### **Characteristics**\n\n - **self** is a derived type instance to be cleaned up.\n - The subroutine deallocates allocatable components to prevent memory leaks.\n - Can be bound to the type as a FINAL procedure for automatic cleanup.\n - Intent(inout) allows modification of the object during cleanup.\n\n### **Description**\n\n **type_destructor** performs cleanup operations on a derived type instance,\n deallocating any allocatable components and releasing resources. When bound\n as a FINAL procedure, it is automatically called when the object goes out\n of scope or is explicitly deallocated.\n\n### **Options**\n\n- **self**\n  : The derived type instance to be destroyed. All allocatable components\n  will be deallocated. The object should not be used after destruction\n  unless reinitialized.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_type_destructor\nimplicit none\n\n  type :: container\n    integer, allocatable :: data(:)\n    character(len=:), allocatable :: name\n  contains\n    final :: container_destructor\n  end type container\n\n  type(container) :: obj\n\n  ! Allocate components\n  allocate(obj%data(100))\n  obj%data = 42\n  obj%name = 'test_container'\n\n  print *, 'Data allocated:', allocated(obj%data)\n  print *, 'Name allocated:', allocated(obj%name)\n\n  ! Manual cleanup (or automatic when obj goes out of scope)\n  call container_destructor(obj)\n\n  print *, 'After destructor:'\n  print *, 'Data allocated:', allocated(obj%data)\n  print *, 'Name allocated:', allocated(obj%name)\n\ncontains\n\n  subroutine container_destructor(self)\n    type(container), intent(inout) :: self\n\n    if (allocated(self%data)) then\n      deallocate(self%data)\n    end if\n\n    if (allocated(self%name)) then\n      deallocate(self%name)\n    end if\n\n  end subroutine container_destructor\n\nend program demo_type_destructor\n```\nResults:\n```text\n Data allocated: T\n Name allocated: T\n After destructor:\n Data allocated: F\n Name allocated: F\n```\n\n### **Standard**\n\nFortran 90 (FINAL procedures: Fortran 2003)\n\n**Compatibility Notes:**\n- gfortran 4.9+, Intel Fortran 15.0+, NAG 6.0+\n- Use FINAL procedures for cleanup\n- Called automatically when variable goes out of scope\n\n### **See Also**\n\n[**type_constructor**(3)](#type_constructor),\n[**allocate**(3)](#allocate),\n[**deallocate**(3)](#deallocate),\n[**derived_type**(3)](#derived_type)",
  "inheritance": "## extended_type\n\n### **Name**\n\n**extended_type** - \\[STRUCTURE:TYPE\\] Define a derived type that inherits from a parent type\n\n### **Synopsis**\n\n```fortran\n    type, extends(parent_type) :: child_type\n```\n\n```fortran\n     type, extends(parent_type) :: child_type\n\n      ! Inherited components from parent_type are implicitly available\n      type(component_type) :: new_component  ! Additional components\n     contains\n      procedure :: new_method  ! Additional type-bound procedures\n     end type child_type\n```\n\n### **Characteristics**\n\n - **parent_type** is an existing extensible derived type (non-SEQUENCE, non-BIND(C)).\n - **child_type** inherits all components and type-bound procedures from **parent_type**.\n - The child type can add new components and procedures, or override inherited procedures.\n - A child type object can be used anywhere a parent type is expected (polymorphism).\n - Only single inheritance is supported; a type can extend exactly one parent.\n\n### **Description**\n\n **extended_type** uses the EXTENDS attribute to create a derived type that inherits\n from a parent type. The child type automatically contains all components and\n type-bound procedures of the parent type, and can add new components, add new\n procedures, or override inherited procedures with its own implementations.\n This enables object-oriented programming patterns including inheritance and\n polymorphism in Fortran.\n\n### **Options**\n\n- **parent_type**\n  : The name of the base type to inherit from. Must be an extensible derived\n  type (cannot be SEQUENCE or BIND(C) type). The parent type must be accessible\n  in the current scope.\n\n- **child_type**\n  : The name of the new derived type being defined. This type will contain all\n  components of parent_type plus any additional components declared in the\n  type definition body.\n\n- **new_component**\n  : Optional additional component declarations. These extend the parent type's\n  component list. Access the parent's components directly by name.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_extended_type\nimplicit none\n\n  ! Base type for geometric shapes\n  type :: shape\n    real :: x = 0.0  ! x-coordinate of center\n    real :: y = 0.0  ! y-coordinate of center\n  contains\n    procedure :: move => shape_move\n    procedure :: describe => shape_describe\n  end type shape\n\n  ! Extended type: circle inherits from shape\n  type, extends(shape) :: circle\n    real :: radius = 1.0\n  contains\n    procedure :: area => circle_area\n    procedure :: describe => circle_describe  ! Override parent method\n  end type circle\n\n  ! Extended type: rectangle inherits from shape\n  type, extends(shape) :: rectangle\n    real :: width = 1.0\n    real :: height = 1.0\n  contains\n    procedure :: area => rectangle_area\n    procedure :: describe => rectangle_describe  ! Override parent method\n  end type rectangle\n\n  type(circle) :: c\n  type(rectangle) :: r\n  class(shape), pointer :: s\n\n  ! Initialize objects\n  c = circle(x=0.0, y=0.0, radius=5.0)\n  r = rectangle(x=2.0, y=3.0, width=4.0, height=6.0)\n\n  ! Call inherited method\n  call c%move(1.0, 1.0)\n  print *, 'Circle center after move:', c%x, c%y\n\n  ! Call overridden method\n  call c%describe()\n  call r%describe()\n\n  ! Demonstrate polymorphism\n  s => c\n  call s%describe()  ! Calls circle_describe\n\n  s => r\n  call s%describe()  ! Calls rectangle_describe\n\n  print *, 'Circle area:', c%area()\n  print *, 'Rectangle area:', r%area()\n\ncontains\n\n  subroutine shape_move(self, dx, dy)\n    class(shape), intent(inout) :: self\n    real, intent(in) :: dx, dy\n    self%x = self%x + dx\n    self%y = self%y + dy\n  end subroutine shape_move\n\n  subroutine shape_describe(self)\n    class(shape), intent(in) :: self\n    print *, 'Shape at (', self%x, ',', self%y, ')'\n  end subroutine shape_describe\n\n  subroutine circle_describe(self)\n    class(circle), intent(in) :: self\n    print *, 'Circle at (', self%x, ',', self%y, ') with radius', self%radius\n  end subroutine circle_describe\n\n  function circle_area(self) result(a)\n    class(circle), intent(in) :: self\n    real :: a\n    real, parameter :: pi = 3.14159265359\n    a = pi * self%radius**2\n  end function circle_area\n\n  subroutine rectangle_describe(self)\n    class(rectangle), intent(in) :: self\n    print *, 'Rectangle at (', self%x, ',', self%y, ') size', self%width, 'x', self%height\n  end subroutine rectangle_describe\n\n  function rectangle_area(self) result(a)\n    class(rectangle), intent(in) :: self\n    real :: a\n    a = self%width * self%height\n  end function rectangle_area\n\nend program demo_extended_type\n```\n\nResults:\n\n```text\n Circle center after move:   1.00000000       1.00000000\n Circle at (   1.00000000     ,   1.00000000     ) with radius   5.00000000\n Rectangle at (   2.00000000     ,   3.00000000     ) size   4.00000000     x   6.00000000\n Circle at (   1.00000000     ,   1.00000000     ) with radius   5.00000000\n Rectangle at (   2.00000000     ,   3.00000000     ) size   4.00000000     x   6.00000000\n Circle area:   78.5398178\n Rectangle area:   24.0000000\n```\n\n### **Standard**\n\nFortran 2003\n\n**Compatibility Notes:**\n- gfortran 4.5+, Intel Fortran 12.0+, NAG 5.3+\n- Only single inheritance supported\n- Use EXTENDS keyword to inherit from parent type\n\n### **See Also**\n\n[**type**](#type),\n[**class**](#class),\n[**select_type**](#select_type),\n[**abstract_type**](#abstract_type),\n[**procedure**](#procedure)",
  "typedestructor": "## type_destructor\n\n### **Name**\n\n**type_destructor** - \\[STRUCTURE:TYPE\\] Subroutine for derived type cleanup and resource deallocation\n\n### **Synopsis**\n```fortran\n    call type_name_destructor(self)\n```\n```fortran\n     subroutine type_name_destructor(self)\n\n      type(type_name), intent(inout) :: self\n```\n\n### **Characteristics**\n\n - **self** is a derived type instance to be cleaned up.\n - The subroutine deallocates allocatable components to prevent memory leaks.\n - Can be bound to the type as a FINAL procedure for automatic cleanup.\n - Intent(inout) allows modification of the object during cleanup.\n\n### **Description**\n\n **type_destructor** performs cleanup operations on a derived type instance,\n deallocating any allocatable components and releasing resources. When bound\n as a FINAL procedure, it is automatically called when the object goes out\n of scope or is explicitly deallocated.\n\n### **Options**\n\n- **self**\n  : The derived type instance to be destroyed. All allocatable components\n  will be deallocated. The object should not be used after destruction\n  unless reinitialized.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_type_destructor\nimplicit none\n\n  type :: container\n    integer, allocatable :: data(:)\n    character(len=:), allocatable :: name\n  contains\n    final :: container_destructor\n  end type container\n\n  type(container) :: obj\n\n  ! Allocate components\n  allocate(obj%data(100))\n  obj%data = 42\n  obj%name = 'test_container'\n\n  print *, 'Data allocated:', allocated(obj%data)\n  print *, 'Name allocated:', allocated(obj%name)\n\n  ! Manual cleanup (or automatic when obj goes out of scope)\n  call container_destructor(obj)\n\n  print *, 'After destructor:'\n  print *, 'Data allocated:', allocated(obj%data)\n  print *, 'Name allocated:', allocated(obj%name)\n\ncontains\n\n  subroutine container_destructor(self)\n    type(container), intent(inout) :: self\n\n    if (allocated(self%data)) then\n      deallocate(self%data)\n    end if\n\n    if (allocated(self%name)) then\n      deallocate(self%name)\n    end if\n\n  end subroutine container_destructor\n\nend program demo_type_destructor\n```\nResults:\n```text\n Data allocated: T\n Name allocated: T\n After destructor:\n Data allocated: F\n Name allocated: F\n```\n\n### **Standard**\n\nFortran 90 (FINAL procedures: Fortran 2003)\n\n**Compatibility Notes:**\n- gfortran 4.9+, Intel Fortran 15.0+, NAG 6.0+\n- Use FINAL procedures for cleanup\n- Called automatically when variable goes out of scope\n\n### **See Also**\n\n[**type_constructor**(3)](#type_constructor),\n[**allocate**(3)](#allocate),\n[**deallocate**(3)](#deallocate),\n[**derived_type**(3)](#derived_type)",
  "associated": "## associated\n\n### **Name**\n\n**associated** - \\[POINTER:INQUIRY\\] Determine the association status of a pointer\n\n### **Synopsis**\n```fortran\n    result = associated(pointer)\n    result = associated(pointer, target)\n```\n```fortran\n     function associated(pointer, target) result(res)\n\n      type(*), pointer, intent(in) :: pointer(..)\n      type(*), intent(in), target, optional :: target(..)\n      logical :: res\n```\n\n### **Characteristics**\n\n - **pointer** must have the POINTER attribute; it can be of any type and any rank.\n - **target** is optional; if present, it must be a pointer or have the TARGET attribute.\n - **target** must have the same type, kind type parameters, and rank as **pointer**.\n - The association status of neither **pointer** nor **target** shall be undefined.\n - Returns a default logical scalar value.\n\n### **Description**\n\n **associated** determines the association status of a pointer, or tests whether\n a pointer is associated with a specific target. When called with only the\n **pointer** argument, it returns .TRUE. if the pointer is currently associated\n with any target, and .FALSE. if the pointer has been nullified or was never\n associated. When the optional **target** argument is present, it returns .TRUE.\n only if **pointer** is associated with that specific target.\n\n This intrinsic is essential for safe pointer operations in Fortran, as\n dereferencing a disassociated or undefined pointer is not allowed. It is good\n practice to nullify pointers that are not immediately associated and to test\n their status before use.\n\n### **Options**\n\n- **pointer**\n  : A pointer of any type and rank whose association status is to be queried.\n  The pointer must not have undefined association status (i.e., it should be\n  either associated with a target or explicitly nullified).\n\n- **target**\n  : (Optional) A variable with the TARGET attribute or a pointer. If present,\n  the function tests whether **pointer** is specifically associated with this\n  target. Must have the same type, kind, and rank as **pointer**.\n\n### **Result**\n\n  A default logical scalar. The result is determined as follows:\n\n  - If **target** is absent: .TRUE. if **pointer** is associated with any target,\n    .FALSE. if **pointer** is disassociated (nullified).\n\n  - If **target** is present and is not a pointer: .TRUE. if **pointer** is\n    associated with **target** and both occupy the same storage; for arrays,\n    they must have the same shape and occupy the same storage units.\n\n  - If **target** is present and is a pointer: .TRUE. if both pointers are\n    associated with the same target, or both are disassociated; .FALSE. otherwise.\n\n  - For zero-sized arrays: The result is .FALSE. because there are no storage\n    units to compare.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_associated\n  implicit none\n  real, target  :: tgt(2) = [1.0, 2.0]\n  real, target  :: other(2) = [3.0, 4.0]\n  real, pointer :: ptr(:)\n  real, pointer :: ptr2(:)\n\n  ! Initially nullify pointers for safe testing\n  nullify(ptr)\n  nullify(ptr2)\n\n  ! Test unassociated pointer\n  print '(A,L1)', 'ptr associated (before): ', associated(ptr)\n\n  ! Associate pointer with target\n  ptr => tgt\n  print '(A,L1)', 'ptr associated (after): ', associated(ptr)\n\n  ! Test association with specific target\n  print '(A,L1)', 'ptr associated with tgt: ', associated(ptr, tgt)\n  print '(A,L1)', 'ptr associated with other: ', associated(ptr, other)\n\n  ! Test two pointers to same target\n  ptr2 => tgt\n  print '(A,L1)', 'ptr associated with ptr2 target: ', associated(ptr, ptr2)\n\n  ! Point ptr2 to different target\n  ptr2 => other\n  print '(A,L1)', 'ptr associated with ptr2 (different): ', associated(ptr, ptr2)\n\n  ! Nullify and test again\n  nullify(ptr)\n  print '(A,L1)', 'ptr associated (after nullify): ', associated(ptr)\n\nend program demo_associated\n```\nResults:\n```text\nptr associated (before): F\nptr associated (after): T\nptr associated with tgt: T\nptr associated with other: F\nptr associated with ptr2 target: T\nptr associated with ptr2 (different): F\nptr associated (after nullify): F\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**null**(3)](#null),\n[**pointer**(7)](#pointer),\n[**target**(7)](#target),\n[**nullify**(7)](#nullify)",
  "omp_parallel_do_simd": "## omp_parallel_do_simd\n\n### **Name**\n\n**omp_parallel_do_simd** - \\[PARALLEL:OPENMP\\] Combined parallel worksharing-loop SIMD construct\n\n### **Synopsis**\n\n```fortran\n    !$omp parallel do simd [clause [[,] clause] ...]\n    do i = start, end [, step]\n      ! loop body (vectorizable operations)\n    end do\n    !$omp end parallel do simd\n```\n\n```fortran\n    !$omp parallel do simd private(list) shared(list) reduction(operator:list)\n    !$omp& simdlen(length) safelen(length) aligned(list:alignment)\n    !$omp& schedule(type [, chunk]) collapse(n) linear(list:step)\n    do index = lower, upper [, stride]\n      ! loop body - distributed across threads and vectorized\n    end do\n    !$omp end parallel do simd\n```\n\n### **Characteristics**\n\n - **private(list)** creates thread-private copies of listed variables.\n - **shared(list)** specifies variables shared among all threads.\n - **reduction(operator:list)** performs a reduction with SIMD-aware implementation.\n - **simdlen(length)** specifies the preferred number of concurrent SIMD lanes.\n - **safelen(length)** specifies the maximum distance for loop-carried dependencies.\n - **aligned(list:alignment)** specifies that list variables have the given alignment.\n - **linear(list:step)** specifies variables that increase linearly with each iteration.\n - **schedule(type [, chunk])** controls how iterations are distributed among threads.\n - **collapse(n)** combines n nested loops before distributing and vectorizing.\n - The loop body must be suitable for SIMD vectorization.\n - An implicit barrier exists at the end of the construct.\n\n### **Description**\n\n **!$omp parallel do simd** creates a parallel region containing a combined worksharing-loop and SIMD construct. Loop iterations are first distributed across threads, then each thread's iterations are vectorized using SIMD instructions. This provides two levels of parallelism: thread-level parallelism from the parallel do and data-level parallelism from SIMD vectorization.\n\n The loop body must be suitable for vectorization: no function calls (unless declared as simd), no I/O operations, no dependencies between SIMD lanes beyond what safelen allows, and operations should be uniform or linear.\n\n### **Options**\n\n- **private(list)**\n  : Creates thread-private copies of listed variables. Within each thread, SIMD lanes may share or privatize these variables depending on the implementation.\n\n- **shared(list)**\n  : Specifies variables shared among all threads. Arrays accessed with the loop index are typically shared.\n\n- **reduction(operator:list)**\n  : Performs a reduction operation. The implementation combines both thread-level and SIMD-level reductions efficiently. Operators: +, -, *, .and., .or., .eqv., .neqv., max, min, iand, ior, ieor.\n\n- **simdlen(length)**\n  : Specifies the preferred number of SIMD lanes. Should match the hardware vector width for best performance (e.g., 4 for SSE with double, 8 for AVX with single).\n\n- **safelen(length)**\n  : Maximum number of iterations that can be executed concurrently without violating dependencies. If there are no loop-carried dependencies, this can be omitted.\n\n- **aligned(list:alignment)**\n  : Declares that array addresses are aligned to the specified byte boundary. Enables aligned vector load/store instructions. Common values: 16 (SSE), 32 (AVX), 64 (AVX-512).\n\n- **linear(list:step)**\n  : Specifies that listed variables have a linear relationship with the loop iteration, incrementing by step each iteration.\n\n- **collapse(n)**\n  : Combines n nested loops into a single iteration space before distributing and vectorizing.\n\n### **Result**\n\n  The parallel do simd construct achieves both thread-level parallelism and SIMD vectorization. Loop iterations are distributed across threads, and each thread processes its iterations using vector instructions. Upon completion, any reduction variables contain the fully combined result from all threads and all SIMD lanes.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_omp_parallel_do_simd\n  use omp_lib\n  implicit none\n  integer, parameter :: n = 10000\n  real(8), allocatable :: a(:), b(:), c(:)\n  real(8) :: sum_val, dot_product_val\n  integer :: i\n\n  allocate(a(n), b(n), c(n))\n\n  ! Initialize arrays\n  do i = 1, n\n    a(i) = real(i, 8) * 0.001d0\n    b(i) = real(n - i + 1, 8) * 0.001d0\n  end do\n\n  ! Parallel do simd: array addition with SIMD vectorization\n  !$omp parallel do simd private(i) shared(a, b, c) simdlen(8)\n  do i = 1, n\n    c(i) = a(i) + b(i)\n  end do\n  !$omp end parallel do simd\n\n  print '(A,F12.6)', 'c(1)   = ', c(1)\n  print '(A,F12.6)', 'c(n)   = ', c(n)\n  print '(A,F12.6)', 'c(n/2) = ', c(n/2)\n\n  ! Parallel do simd with reduction: sum\n  sum_val = 0.0d0\n  !$omp parallel do simd private(i) reduction(+:sum_val)\n  do i = 1, n\n    sum_val = sum_val + c(i)\n  end do\n  !$omp end parallel do simd\n\n  print '(A,F15.6)', 'Sum of c: ', sum_val\n\n  ! Parallel do simd: dot product\n  dot_product_val = 0.0d0\n  !$omp parallel do simd private(i) reduction(+:dot_product_val)\n  do i = 1, n\n    dot_product_val = dot_product_val + a(i) * b(i)\n  end do\n  !$omp end parallel do simd\n\n  print '(A,F15.6)', 'Dot product a.b: ', dot_product_val\n\n  deallocate(a, b, c)\n\nend program demo_omp_parallel_do_simd\n```\n\nCompile with:\n```text\ngfortran -fopenmp -march=native demo_omp_parallel_do_simd.f90 -o demo\nifort -qopenmp -xHost demo_omp_parallel_do_simd.f90 -o demo\n```\n\nResults:\n```text\nc(1)   =    10.001000\nc(n)   =    10.001000\nc(n/2) =    10.001000\nSum of c:   100010.000000\nDot product a.b:   166716.670000\n```\n\n### **Standard**\n\nOpenMP 4.0 (SIMD constructs introduced)\n\n### **See Also**\n\n[**!$omp parallel do**(3)](#omp_parallel_do),\n[**!$omp simd**(3)](#omp_simd),\n[**!$omp declare simd**(3)](#omp_declare_simd),\n[**!$omp parallel**(3)](#omp_parallel),\n[**!$omp do**(3)](#omp_do)\n\n### **Resources**\n\n- [OpenMP 5.0 SIMD Construct](https://www.openmp.org/spec-html/5.0/openmpsu42.html)\n- [Intel OpenMP SIMD Vectorization Guide](https://www.intel.com/content/www/us/en/docs/cpp-compiler/developer-guide-reference/)\n- [OpenMP Official Site](https://www.openmp.org/)",
  "final": "## final_procedure\n\n### **Name**\n\n**final** - \\[STRUCTURE:TYPE\\] Declare a finalizer procedure for automatic cleanup when derived type objects go out of scope\n\n### **Synopsis**\n```fortran\n    type :: type_name\n    contains\n      final :: finalizer_subroutine\n    end type\n```\n```fortran\n     type :: type_name\n\n      type(component) :: comp\n     contains\n      final :: finalizer_subroutine\n     end type type_name\n\n     subroutine finalizer_subroutine(self)\n\n      type(type_name), intent(inout) :: self\n```\n\n### **Characteristics**\n\n - **final** declares a type-bound finalizer procedure.\n - Finalizers are called automatically when objects are deallocated or go out of scope.\n - Multiple finalizers can be defined for different ranks (scalar, array).\n - Finalizers must be subroutines with a single argument of the derived type.\n - Finalizer argument must have intent(inout) and be non-polymorphic (TYPE, not CLASS).\n\n### **Description**\n\n **final** declares a finalizer procedure that is automatically invoked when\n a derived type object is about to be destroyed. This occurs when an allocatable\n object is deallocated, when a local variable goes out of scope, or when an\n object is defined by intrinsic assignment. Finalizers enable RAII (Resource\n Acquisition Is Initialization) patterns for automatic resource cleanup,\n preventing memory leaks and resource exhaustion.\n\n### **Options**\n\n- **finalizer_subroutine**\n  : The name of a subroutine that performs cleanup. Must be accessible in\n  the type definition scope. The subroutine takes a single argument of the\n  derived type (non-polymorphic).\n\n- **self**\n  : The object being finalized. Declared as TYPE(type_name), not CLASS.\n  Intent must be INOUT to allow modification during cleanup.\n\n### **Result**\n\n  Automatic invocation of the finalizer when objects are destroyed, ensuring\n  proper cleanup of allocated memory, file handles, and other resources.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_final\nimplicit none\n\n  type :: managed_array\n    real, allocatable :: data(:)\n    integer :: id = 0\n  contains\n    final :: cleanup_array\n  end type managed_array\n\n  call test_finalization()\n  print '(a)', 'Main program: test_finalization returned'\n  print '(a)', 'Program complete'\n\ncontains\n\n  subroutine test_finalization()\n    type(managed_array) :: local_obj\n    type(managed_array), allocatable :: alloc_obj\n\n    ! Create local object\n    local_obj%id = 1\n    allocate(local_obj%data(100))\n    local_obj%data = 1.0\n    print '(a,i0,a,i0)', 'Created local_obj id=', local_obj%id, &\n          ', size=', size(local_obj%data)\n\n    ! Create allocatable object\n    allocate(alloc_obj)\n    alloc_obj%id = 2\n    allocate(alloc_obj%data(200))\n    alloc_obj%data = 2.0\n    print '(a,i0,a,i0)', 'Created alloc_obj id=', alloc_obj%id, &\n          ', size=', size(alloc_obj%data)\n\n    ! Explicit deallocation triggers finalizer\n    print '(a)', 'Deallocating alloc_obj explicitly...'\n    deallocate(alloc_obj)\n\n    print '(a)', 'Leaving test_finalization (local_obj will be finalized)...'\n    ! local_obj finalizer called automatically when subroutine returns\n  end subroutine test_finalization\n\n  subroutine cleanup_array(self)\n    type(managed_array), intent(inout) :: self\n    print '(a,i0)', 'Finalizer called for object id=', self%id\n    if (allocated(self%data)) then\n      print '(a,i0,a)', '  Deallocating data array (', size(self%data), ' elements)'\n      deallocate(self%data)\n    end if\n  end subroutine cleanup_array\n\nend program demo_final\n```\nResults:\n```text\nCreated local_obj id=1, size=100\nCreated alloc_obj id=2, size=200\nDeallocating alloc_obj explicitly...\nFinalizer called for object id=2\n  Deallocating data array (200 elements)\nLeaving test_finalization (local_obj will be finalized)...\nFinalizer called for object id=1\n  Deallocating data array (100 elements)\nMain program: test_finalization returned\nProgram complete\n```\n\n### **Standard**\n\nFortran 2003\n\n**Compatibility Notes:**\n- gfortran 4.9+, Intel Fortran 15.0+, NAG 6.0+\n- Called automatically when variable goes out of scope\n- Multiple FINAL procedures can be defined for different ranks\n\n### **See Also**\n\n[**type**(3)](#type),\n[**type_destructor**(3)](#type_destructor),\n[**allocate**(3)](#allocate),\n[**deallocate**(3)](#deallocate)",
  "finalizer": "## final_procedure\n\n### **Name**\n\n**final** - \\[STRUCTURE:TYPE\\] Declare a finalizer procedure for automatic cleanup when derived type objects go out of scope\n\n### **Synopsis**\n```fortran\n    type :: type_name\n    contains\n      final :: finalizer_subroutine\n    end type\n```\n```fortran\n     type :: type_name\n\n      type(component) :: comp\n     contains\n      final :: finalizer_subroutine\n     end type type_name\n\n     subroutine finalizer_subroutine(self)\n\n      type(type_name), intent(inout) :: self\n```\n\n### **Characteristics**\n\n - **final** declares a type-bound finalizer procedure.\n - Finalizers are called automatically when objects are deallocated or go out of scope.\n - Multiple finalizers can be defined for different ranks (scalar, array).\n - Finalizers must be subroutines with a single argument of the derived type.\n - Finalizer argument must have intent(inout) and be non-polymorphic (TYPE, not CLASS).\n\n### **Description**\n\n **final** declares a finalizer procedure that is automatically invoked when\n a derived type object is about to be destroyed. This occurs when an allocatable\n object is deallocated, when a local variable goes out of scope, or when an\n object is defined by intrinsic assignment. Finalizers enable RAII (Resource\n Acquisition Is Initialization) patterns for automatic resource cleanup,\n preventing memory leaks and resource exhaustion.\n\n### **Options**\n\n- **finalizer_subroutine**\n  : The name of a subroutine that performs cleanup. Must be accessible in\n  the type definition scope. The subroutine takes a single argument of the\n  derived type (non-polymorphic).\n\n- **self**\n  : The object being finalized. Declared as TYPE(type_name), not CLASS.\n  Intent must be INOUT to allow modification during cleanup.\n\n### **Result**\n\n  Automatic invocation of the finalizer when objects are destroyed, ensuring\n  proper cleanup of allocated memory, file handles, and other resources.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_final\nimplicit none\n\n  type :: managed_array\n    real, allocatable :: data(:)\n    integer :: id = 0\n  contains\n    final :: cleanup_array\n  end type managed_array\n\n  call test_finalization()\n  print '(a)', 'Main program: test_finalization returned'\n  print '(a)', 'Program complete'\n\ncontains\n\n  subroutine test_finalization()\n    type(managed_array) :: local_obj\n    type(managed_array), allocatable :: alloc_obj\n\n    ! Create local object\n    local_obj%id = 1\n    allocate(local_obj%data(100))\n    local_obj%data = 1.0\n    print '(a,i0,a,i0)', 'Created local_obj id=', local_obj%id, &\n          ', size=', size(local_obj%data)\n\n    ! Create allocatable object\n    allocate(alloc_obj)\n    alloc_obj%id = 2\n    allocate(alloc_obj%data(200))\n    alloc_obj%data = 2.0\n    print '(a,i0,a,i0)', 'Created alloc_obj id=', alloc_obj%id, &\n          ', size=', size(alloc_obj%data)\n\n    ! Explicit deallocation triggers finalizer\n    print '(a)', 'Deallocating alloc_obj explicitly...'\n    deallocate(alloc_obj)\n\n    print '(a)', 'Leaving test_finalization (local_obj will be finalized)...'\n    ! local_obj finalizer called automatically when subroutine returns\n  end subroutine test_finalization\n\n  subroutine cleanup_array(self)\n    type(managed_array), intent(inout) :: self\n    print '(a,i0)', 'Finalizer called for object id=', self%id\n    if (allocated(self%data)) then\n      print '(a,i0,a)', '  Deallocating data array (', size(self%data), ' elements)'\n      deallocate(self%data)\n    end if\n  end subroutine cleanup_array\n\nend program demo_final\n```\nResults:\n```text\nCreated local_obj id=1, size=100\nCreated alloc_obj id=2, size=200\nDeallocating alloc_obj explicitly...\nFinalizer called for object id=2\n  Deallocating data array (200 elements)\nLeaving test_finalization (local_obj will be finalized)...\nFinalizer called for object id=1\n  Deallocating data array (100 elements)\nMain program: test_finalization returned\nProgram complete\n```\n\n### **Standard**\n\nFortran 2003\n\n**Compatibility Notes:**\n- gfortran 4.9+, Intel Fortran 15.0+, NAG 6.0+\n- Finalizers called in reverse order of construction\n- Not called for INTENT(OUT) dummy arguments in some compilers\n\n### **See Also**\n\n[**type**(3)](#type),\n[**type_destructor**(3)](#type_destructor),\n[**allocate**(3)](#allocate),\n[**deallocate**(3)](#deallocate)",
  "readfmt": "## read_formatted\n\n### **Name**\n\n**read** - \\[IO:FORMATTED\\] Read formatted data from a file or standard input\n\n### **Synopsis**\n```fortran\n    read(unit, fmt) var1, var2, ...\n```\n```fortran\n     read(unit=unit_num, fmt=format_spec, iostat=ios, iomsg=msg) var_list\n\n      integer, intent(in)            :: unit_num     ! File unit or * for stdin\n      character(len=*), intent(in)   :: format_spec  ! Format string or *\n      integer, intent(out), optional :: ios          ! I/O status\n      character(len=*), intent(inout), optional :: msg  ! Error message\n```\n\n### **Characteristics**\n\n - **unit** is an integer representing the file unit number, or * for standard input.\n - **fmt** is a format specification (character string, statement label, or * for list-directed).\n - **var** is one or more variables to receive the input data.\n - The types of variables must match the format descriptors provided.\n - Unit 5 is typically standard input; * can also be used for keyboard input.\n\n### **Description**\n\n **read** transfers formatted data from an external file or standard input into program variables. The format specifier controls how characters in the input record are interpreted and converted to internal representation. Format descriptors like I (integer), F (real), E (exponential), A (character), and L (logical) define the conversion rules.\n\n### **Options**\n\n- **unit**\n  : An integer expression specifying the unit number connected to the input file.\n  Use * for standard input (typically keyboard). Unit 5 is conventionally stdin.\n\n- **fmt**\n  : Format specification controlling input interpretation. Can be:\n  - `*` for list-directed (free-format) reading\n  - A character expression with format descriptors like '(I5,F10.3)'\n  - A statement label referencing a FORMAT statement\n\n- **iostat=**\n  : Integer variable set to zero on success, positive on error, negative on end-of-file.\n\n- **iomsg=**\n  : Character variable that receives a descriptive error message if an error occurs.\n\n- **advance=**\n  : 'YES' (default) or 'NO' to control whether to advance to the next record.\n\n### **Result**\n\n  The variables in the input list receive values converted from the external character representation according to the format specification. On error, variables may have undefined values unless iostat is used.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_read_formatted\nimplicit none\n  integer :: unit_num, ios\n  integer :: id\n  real :: temperature, pressure\n  character(len=20) :: name\n  character(len=100) :: errmsg\n  \n  ! Example 1: Read from standard input with list-directed format\n  print *, 'Enter an integer and a real:'\n  read(*, *) id, temperature\n  print *, 'Read id:', id, ' temperature:', temperature\n  \n  ! Example 2: Read with explicit format from standard input\n  print *, 'Enter value in I5,F10.2 format:'\n  read(*, '(I5,F10.2)', iostat=ios) id, temperature\n  if (ios /= 0) then\n    print *, 'Format error on input'\n  else\n    print *, 'Formatted read: id=', id, ' temp=', temperature\n  end if\n  \n  ! Example 3: Read from a file with error handling\n  open(newunit=unit_num, file='data.txt', status='old', &\n       action='read', iostat=ios, iomsg=errmsg)\n  if (ios == 0) then\n    read(unit_num, '(A20,I5,F10.3)', iostat=ios) name, id, pressure\n    if (ios == 0) then\n      print *, 'Name:', trim(name)\n      print *, 'ID:', id\n      print *, 'Pressure:', pressure\n    end if\n    close(unit_num)\n  else\n    print *, 'Error opening file:', trim(errmsg)\n  end if\n\nend program demo_read_formatted\n```\nResults:\n```text\n Enter an integer and a real:\n Read id:          42  temperature:   98.6000000\n Enter value in I5,F10.2 format:\n Formatted read: id=   42  temp=   98.6000000\n Name:John Smith           \n ID:          25\n Pressure:   101.325000\n```\n\n### **Standard**\n\nFortran 77 (enhanced in Fortran 90/95/2003 with IOSTAT, IOMSG, ADVANCE)\n\n### **See Also**\n\n[**write**(3)](#write),\n[**open**(3)](#open),\n[**close**(3)](#close),\n[**format**(3)](#format),\n[**read_internal**(3)](#read_internal)",
  "ompparallel": "## omp_parallel\n\n### **Name**\n\n**omp parallel** - \\[PARALLEL:OPENMP\\] Creates a team of threads to execute a parallel region\n\n### **Synopsis**\n\n```fortran\n    !$omp parallel [clause [[,] clause] ...]\n       structured-block\n    !$omp end parallel\n```\n\n```fortran\n    !$omp parallel private(list) shared(list) default(none|shared|private|firstprivate)\n    !$omp& firstprivate(list) copyin(list) reduction(operator:list)\n    !$omp& if(scalar-logical-expr) num_threads(scalar-integer-expr)\n    !$omp& proc_bind(master|close|spread) allocate([allocator:]list)\n       structured-block\n    !$omp end parallel\n```\n\n### **Characteristics**\n\n - **private(list)** specifies variables that are private to each thread.\n - **shared(list)** specifies variables that are shared among all threads.\n - **default(none|shared|private|firstprivate)** sets the default data-sharing attribute.\n - **firstprivate(list)** specifies private variables initialized from the original.\n - **copyin(list)** copies master thread's THREADPRIVATE data to all threads.\n - **reduction(operator:list)** performs a reduction operation across threads.\n - **if(expr)** conditionally executes in parallel; serial if false.\n - **num_threads(expr)** specifies the number of threads to use.\n - **proc_bind(policy)** specifies thread-to-place binding policy.\n - An implicit barrier exists at the end of the parallel region.\n\n### **Description**\n\n **!$omp parallel** creates a team of threads that execute the enclosed\n structured block in parallel. When a thread encounters a parallel construct,\n a team of threads is created. The thread that encountered the construct\n becomes the master thread (thread number 0) of the new team. All threads\n in the team, including the master thread, execute the parallel region.\n Once the team is created, the number of threads remains constant for\n the duration of that parallel region. At the end of the parallel region,\n an implicit barrier synchronizes all threads before only the master\n thread continues execution.\n\n### **Options**\n\n- **private(list)**\n  : Creates a new instance of each listed variable for each thread. The\n  initial value is undefined. Variables must be definable.\n\n- **shared(list)**\n  : Specifies that listed variables are shared among all threads in the\n  team. All threads access the same storage location.\n\n- **default(none|shared|private|firstprivate)**\n  : Sets the default data-sharing attribute for variables referenced in\n  the parallel region. Using `none` requires explicit specification of\n  all variables. Only one DEFAULT clause is allowed per directive.\n\n- **firstprivate(list)**\n  : Like private, but each thread's copy is initialized from the original\n  variable's value before the parallel region.\n\n- **copyin(list)**\n  : Copies the master thread's THREADPRIVATE common block data to the\n  thread-private copies at the start of the parallel region.\n\n- **reduction([modifier,]operator:list)**\n  : Performs a reduction operation. Each thread has a private copy\n  initialized appropriately. At region end, values are combined using\n  the specified operator (+, *, -, .and., .or., .eqv., .neqv., max, min,\n  iand, ior, ieor).\n\n- **if([parallel:]scalar-logical-expression)**\n  : If the expression evaluates to .false., the region executes serially\n  with a single thread.\n\n- **num_threads(scalar-integer-expression)**\n  : Specifies the number of threads in the team. Must evaluate to a\n  positive integer. Overrides OMP_NUM_THREADS environment variable.\n\n- **proc_bind(master|close|spread)**\n  : Specifies the mapping of threads to places. `master` binds threads\n  to the master's place, `close` binds to places close to the master,\n  `spread` distributes threads across available places.\n\n- **allocate([allocator:]list)**\n  : Specifies the memory allocator for private variables.\n\n### **Result**\n\n  The parallel construct creates a team of threads that execute the structured block concurrently. Upon completion of the parallel region, all threads synchronize at an implicit barrier, ensuring all parallel work is complete. Only the master thread (thread 0) continues execution after the parallel region. Any reduction variables contain the combined result from all threads. Private variables go out of scope at the end of the region.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_omp_parallel\n  use omp_lib\n  implicit none\n  integer :: thread_id, num_threads\n  integer :: i, n\n  real :: sum_val, local_sum\n  real, allocatable :: array(:)\n\n  n = 1000\n  allocate(array(n))\n  array = [(real(i), i=1,n)]\n  sum_val = 0.0\n\n  ! Basic parallel region\n  !$omp parallel private(thread_id) shared(num_threads)\n    thread_id = omp_get_thread_num()\n    if (thread_id == 0) then\n      num_threads = omp_get_num_threads()\n      print *, 'Number of threads:', num_threads\n    end if\n    print *, 'Hello from thread', thread_id\n  !$omp end parallel\n\n  ! Parallel region with reduction\n  !$omp parallel default(none) shared(array, n) &\n  !$omp& private(i, local_sum) reduction(+:sum_val)\n    local_sum = 0.0\n    !$omp do\n    do i = 1, n\n      local_sum = local_sum + array(i)\n    end do\n    !$omp end do\n    sum_val = sum_val + local_sum\n  !$omp end parallel\n\n  print *, 'Sum of array:', sum_val\n\n  ! Parallel region with conditional execution\n  !$omp parallel if(n > 100) num_threads(4)\n    print *, 'Executing with specified thread count'\n  !$omp end parallel\n\n  deallocate(array)\nend program demo_omp_parallel\n```\n\nCompile with:\n```text\ngfortran -fopenmp demo_omp_parallel.f90 -o demo_omp_parallel\nifort -qopenmp demo_omp_parallel.f90 -o demo_omp_parallel\n```\n\nResults:\n```text\nNumber of threads: 4\nHello from thread 0\nHello from thread 1\nHello from thread 2\nHello from thread 3\nSum of array: 500500.0\nExecuting with specified thread count\n```\n\n### **Standard**\n\nOpenMP 1.0 (October 1997), with enhancements in subsequent versions:\n - OpenMP 2.5: Added copyin clause\n - OpenMP 3.0: Added IF clause with directive-name-modifier\n - OpenMP 4.0: Added proc_bind clause\n - OpenMP 5.0: Added allocate clause, default(firstprivate) for Fortran\n\n### **See Also**\n\n[**!$omp parallel do**(3)](#omp_parallel_do),\n[**!$omp critical**(3)](#omp_critical),\n[**!$omp barrier**(3)](#omp_barrier),\n[**!$omp single**(3)](#omp_single),\n[**!$omp master**(3)](#omp_master),\n[**!$omp sections**(3)](#omp_sections)\n\n### **Resources**\n\n- [OpenMP 5.0 Parallel Construct](https://www.openmp.org/spec-html/5.0/openmpsu35.html)\n- [LLNL OpenMP Tutorial](https://hpc-tutorials.llnl.gov/openmp/)\n- [OpenMP Official Site](https://www.openmp.org/)",
  "whereelse": "## where_elsewhere\n\n### **Name**\n\n**where_elsewhere** - \\[CONTROL:CONDITIONAL\\] Perform masked array assignment with alternative for non-matching elements\n\n### **Synopsis**\n```fortran\n    where (mask)\n      array = expression\n    elsewhere\n      array = other_expression\n    end where\n```\n```fortran\n     where (logical_array_expression)\n\n       ! Assignments for elements where mask is .TRUE.\n       array = expression\n     elsewhere\n       ! Assignments for elements where mask is .FALSE.\n       array = other_expression\n     end where\n```\n\n### **Characteristics**\n\n - **mask** is a logical array expression.\n - **array** is an array variable conformable with the mask.\n - **expression** and **other_expression** are array expressions conformable with the mask.\n - The WHERE clause handles elements where mask is .TRUE.\n - The ELSEWHERE clause handles elements where mask is .FALSE.\n - Can include nested WHERE constructs and multiple assignment statements.\n\n### **Description**\n\n **where_elsewhere** provides conditional element-wise array assignment based\n on a logical mask. Elements of the array where the mask is .TRUE. are assigned\n from the WHERE block, while elements where the mask is .FALSE. are assigned\n from the ELSEWHERE block. This is more readable and often more efficient than\n equivalent element-wise conditional logic, especially for complex masking\n conditions.\n\n### **Options**\n\n- **mask**\n  : A logical array expression that determines which elements are assigned\n  by the WHERE clause (where .TRUE.) versus the ELSEWHERE clause (where .FALSE.).\n\n- **array**\n  : The target array being assigned. Must be conformable with the mask.\n  Can have multiple assignment statements in each clause.\n\n- **expression**\n  : Array expression providing values for elements where mask is .TRUE.\n  Must be conformable with the array and mask.\n\n- **other_expression**\n  : Array expression providing values for elements where mask is .FALSE.\n  Must be conformable with the array and mask.\n\n### **Result**\n\n  Element-wise conditional assignment where each array element receives a\n  value from either the WHERE or ELSEWHERE clause based on the corresponding\n  mask value.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_where_elsewhere\nimplicit none\n  real :: values(10)\n  real :: results(10)\n  real :: categorized(10)\n  integer :: i\n\n  ! Initialize with test values including negatives and zeros\n  values = [-5.0, 0.0, 3.0, -2.0, 7.0, 0.0, -1.0, 4.0, -8.0, 2.0]\n\n  ! Example 1: Replace negatives with zero, keep positives\n  where (values < 0.0)\n    results = 0.0\n  elsewhere\n    results = values\n  end where\n\n  print '(a)', 'Original values:'\n  print '(10f6.1)', values\n  print '(a)', 'Negatives replaced with zero:'\n  print '(10f6.1)', results\n\n  ! Example 2: Safe division - avoid divide by zero\n  where (values /= 0.0)\n    results = 1.0 / values\n  elsewhere\n    results = 0.0  ! Or any sentinel value\n  end where\n\n  print '(a)', 'Reciprocals (0 where undefined):'\n  print '(10f6.2)', results\n\n  ! Example 3: Categorization using WHERE-ELSEWHERE(mask)-ELSEWHERE\n  where (values > 0.0)\n    categorized = 1.0   ! Positive indicator\n  elsewhere (values < 0.0)\n    categorized = -1.0  ! Negative indicator\n  elsewhere\n    categorized = 0.0   ! Zero indicator\n  end where\n\n  print '(a)', 'Categorized (sign function):'\n  print '(10f6.1)', categorized\n\n  ! Example 4: Multiple assignments in each clause\n  where (values >= 0.0)\n    results = sqrt(values)\n  elsewhere\n    results = -sqrt(-values)  ! Signed square root\n  end where\n\n  print '(a)', 'Signed square roots:'\n  print '(10f6.2)', results\n\nend program demo_where_elsewhere\n```\nResults:\n```text\nOriginal values:\n  -5.0   0.0   3.0  -2.0   7.0   0.0  -1.0   4.0  -8.0   2.0\nNegatives replaced with zero:\n   0.0   0.0   3.0   0.0   7.0   0.0   0.0   4.0   0.0   2.0\nReciprocals (0 where undefined):\n -0.20  0.00  0.33 -0.50  0.14  0.00 -1.00  0.25 -0.12  0.50\nCategorized (sign function):\n  -1.0   0.0   1.0  -1.0   1.0   0.0  -1.0   1.0  -1.0   1.0\nSigned square roots:\n -2.24  0.00  1.73 -1.41  2.65  0.00 -1.00  2.00 -2.83  1.41\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**where**(3)](#where),\n[**merge**(3)](#merge),\n[**pack**(3)](#pack),\n[**unpack**(3)](#unpack),\n[**forall**(3)](#forall)",
  "where_elsewhere": "## where_elsewhere\n\n### **Name**\n\n**where_elsewhere** - \\[CONTROL:CONDITIONAL\\] Perform masked array assignment with alternative for non-matching elements\n\n### **Synopsis**\n```fortran\n    where (mask)\n      array = expression\n    elsewhere\n      array = other_expression\n    end where\n```\n```fortran\n     where (logical_array_expression)\n\n       ! Assignments for elements where mask is .TRUE.\n       array = expression\n     elsewhere\n       ! Assignments for elements where mask is .FALSE.\n       array = other_expression\n     end where\n```\n\n### **Characteristics**\n\n - **mask** is a logical array expression.\n - **array** is an array variable conformable with the mask.\n - **expression** and **other_expression** are array expressions conformable with the mask.\n - The WHERE clause handles elements where mask is .TRUE.\n - The ELSEWHERE clause handles elements where mask is .FALSE.\n - Can include nested WHERE constructs and multiple assignment statements.\n\n### **Description**\n\n **where_elsewhere** provides conditional element-wise array assignment based\n on a logical mask. Elements of the array where the mask is .TRUE. are assigned\n from the WHERE block, while elements where the mask is .FALSE. are assigned\n from the ELSEWHERE block. This is more readable and often more efficient than\n equivalent element-wise conditional logic, especially for complex masking\n conditions.\n\n### **Options**\n\n- **mask**\n  : A logical array expression that determines which elements are assigned\n  by the WHERE clause (where .TRUE.) versus the ELSEWHERE clause (where .FALSE.).\n\n- **array**\n  : The target array being assigned. Must be conformable with the mask.\n  Can have multiple assignment statements in each clause.\n\n- **expression**\n  : Array expression providing values for elements where mask is .TRUE.\n  Must be conformable with the array and mask.\n\n- **other_expression**\n  : Array expression providing values for elements where mask is .FALSE.\n  Must be conformable with the array and mask.\n\n### **Result**\n\n  Element-wise conditional assignment where each array element receives a\n  value from either the WHERE or ELSEWHERE clause based on the corresponding\n  mask value.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_where_elsewhere\nimplicit none\n  real :: values(10)\n  real :: results(10)\n  real :: categorized(10)\n  integer :: i\n\n  ! Initialize with test values including negatives and zeros\n  values = [-5.0, 0.0, 3.0, -2.0, 7.0, 0.0, -1.0, 4.0, -8.0, 2.0]\n\n  ! Example 1: Replace negatives with zero, keep positives\n  where (values < 0.0)\n    results = 0.0\n  elsewhere\n    results = values\n  end where\n\n  print '(a)', 'Original values:'\n  print '(10f6.1)', values\n  print '(a)', 'Negatives replaced with zero:'\n  print '(10f6.1)', results\n\n  ! Example 2: Safe division - avoid divide by zero\n  where (values /= 0.0)\n    results = 1.0 / values\n  elsewhere\n    results = 0.0  ! Or any sentinel value\n  end where\n\n  print '(a)', 'Reciprocals (0 where undefined):'\n  print '(10f6.2)', results\n\n  ! Example 3: Categorization using WHERE-ELSEWHERE(mask)-ELSEWHERE\n  where (values > 0.0)\n    categorized = 1.0   ! Positive indicator\n  elsewhere (values < 0.0)\n    categorized = -1.0  ! Negative indicator\n  elsewhere\n    categorized = 0.0   ! Zero indicator\n  end where\n\n  print '(a)', 'Categorized (sign function):'\n  print '(10f6.1)', categorized\n\n  ! Example 4: Multiple assignments in each clause\n  where (values >= 0.0)\n    results = sqrt(values)\n  elsewhere\n    results = -sqrt(-values)  ! Signed square root\n  end where\n\n  print '(a)', 'Signed square roots:'\n  print '(10f6.2)', results\n\nend program demo_where_elsewhere\n```\nResults:\n```text\nOriginal values:\n  -5.0   0.0   3.0  -2.0   7.0   0.0  -1.0   4.0  -8.0   2.0\nNegatives replaced with zero:\n   0.0   0.0   3.0   0.0   7.0   0.0   0.0   4.0   0.0   2.0\nReciprocals (0 where undefined):\n -0.20  0.00  0.33 -0.50  0.14  0.00 -1.00  0.25 -0.12  0.50\nCategorized (sign function):\n  -1.0   0.0   1.0  -1.0   1.0   0.0  -1.0   1.0  -1.0   1.0\nSigned square roots:\n -2.24  0.00  1.73 -1.41  2.65  0.00 -1.00  2.00 -2.83  1.41\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**where**(3)](#where),\n[**merge**(3)](#merge),\n[**pack**(3)](#pack),\n[**unpack**(3)](#unpack),\n[**forall**(3)](#forall)",
  "ompreduce": "## omp_reduction\n\n### **Name**\n\n**omp_reduction** - \\[PARALLEL:OPENMP\\] Reduction clause for parallel accumulation operations\n\n### **Synopsis**\n\n```fortran\n    !$omp parallel do reduction(operator:variable_list)\n    do i = start, end\n      variable = variable operator expression\n    end do\n    !$omp end parallel do\n```\n\n```fortran\n    !$omp parallel do reduction(operator:var1, var2, ...)\n    !$omp parallel reduction(operator:var)\n    !$omp simd reduction(operator:var)\n    !$omp do reduction(operator:var)\n\n    ! Supported operators:\n    ! Arithmetic: +, -, *\n    ! Logical: .and., .or., .eqv., .neqv.\n    ! Intrinsic: max, min, iand, ior, ieor\n```\n\n### **Characteristics**\n\n - **operator** specifies the reduction operation to perform.\n - **variable_list** is one or more scalar variables to reduce.\n - Each thread receives a private copy initialized to the identity value.\n - At region end, private copies are combined using the operator.\n - The original variable receives the final combined result.\n - Reduction variables must be scalar (arrays require explicit loops or user-defined reductions).\n - The reduction operator must be associative for correct results.\n\n### **Description**\n\n **reduction(operator:list)** is a data-sharing clause that enables safe parallel accumulation of values into shared variables. Without reduction, multiple threads updating the same variable would cause a race condition. With reduction, each thread accumulates into its own private copy, and these copies are combined at the end of the parallel region.\n\n The private copies are initialized to the identity value for the operator: 0 for +, 1 for *, .true. for .and., .false. for .or., largest negative for max, largest positive for min, all bits set for iand, and zero for ior and ieor.\n\n### **Options**\n\n- **+ (addition)**\n  : Identity value: 0. Combines partial sums from all threads.\n\n- **- (subtraction)**\n  : Identity value: 0. Note: Subtraction is not truly associative; treated as addition of negated values.\n\n- ** * (multiplication)**\n  : Identity value: 1. Combines partial products from all threads.\n\n- **.and. (logical AND)**\n  : Identity value: .true.. Result is .true. only if all partial results are .true..\n\n- **.or. (logical OR)**\n  : Identity value: .false.. Result is .true. if any partial result is .true..\n\n- **.eqv. (logical equivalence)**\n  : Identity value: .true.. Tests if all partial results have the same logical value.\n\n- **.neqv. (logical non-equivalence)**\n  : Identity value: .false.. Logical XOR across all threads.\n\n- **max (maximum)**\n  : Identity value: smallest representable value for the type. Finds maximum across all threads.\n\n- **min (minimum)**\n  : Identity value: largest representable value for the type. Finds minimum across all threads.\n\n- **iand (bitwise AND)**\n  : Identity value: all bits set to 1. Performs bitwise AND across all threads.\n\n- **ior (bitwise OR)**\n  : Identity value: 0. Performs bitwise OR across all threads.\n\n- **ieor (bitwise XOR)**\n  : Identity value: 0. Performs bitwise XOR across all threads.\n\n### **Result**\n\n  After the parallel region completes, the reduction variable contains the combined result of the reduction operation applied across all threads. The order of combination is implementation-defined but mathematically equivalent to sequential execution for associative operators.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_omp_reduction\n  use omp_lib\n  implicit none\n  integer, parameter :: n = 10000\n  real(8) :: a(n)\n  real(8) :: sum_val, product_val, max_val, min_val\n  integer :: count_positive\n  logical :: all_positive, any_negative\n  integer :: i\n\n  ! Initialize array with mixed values\n  do i = 1, n\n    a(i) = real(i - n/2, 8)  ! Values from -5000 to 5000\n  end do\n\n  ! Reduction with + (sum)\n  sum_val = 0.0d0\n  !$omp parallel do reduction(+:sum_val)\n  do i = 1, n\n    sum_val = sum_val + a(i)\n  end do\n  !$omp end parallel do\n  print '(A,F15.2)', 'Sum:     ', sum_val\n\n  ! Reduction with max\n  max_val = -huge(max_val)\n  !$omp parallel do reduction(max:max_val)\n  do i = 1, n\n    max_val = max(max_val, a(i))\n  end do\n  !$omp end parallel do\n  print '(A,F15.2)', 'Maximum: ', max_val\n\n  ! Reduction with min\n  min_val = huge(min_val)\n  !$omp parallel do reduction(min:min_val)\n  do i = 1, n\n    min_val = min(min_val, a(i))\n  end do\n  !$omp end parallel do\n  print '(A,F15.2)', 'Minimum: ', min_val\n\n  ! Logical reduction: .and.\n  all_positive = .true.\n  !$omp parallel do reduction(.and.:all_positive)\n  do i = 1, n\n    all_positive = all_positive .and. (a(i) > 0.0d0)\n  end do\n  !$omp end parallel do\n  print '(A,L)', 'All positive: ', all_positive\n\n  ! Logical reduction: .or.\n  any_negative = .false.\n  !$omp parallel do reduction(.or.:any_negative)\n  do i = 1, n\n    any_negative = any_negative .or. (a(i) < 0.0d0)\n  end do\n  !$omp end parallel do\n  print '(A,L)', 'Any negative: ', any_negative\n\n  ! Integer reduction: count\n  count_positive = 0\n  !$omp parallel do reduction(+:count_positive)\n  do i = 1, n\n    if (a(i) > 0.0d0) count_positive = count_positive + 1\n  end do\n  !$omp end parallel do\n  print '(A,I0)', 'Count positive: ', count_positive\n\n  ! Multiple reductions in one directive\n  sum_val = 0.0d0\n  max_val = -huge(max_val)\n  min_val = huge(min_val)\n  !$omp parallel do reduction(+:sum_val) reduction(max:max_val) reduction(min:min_val)\n  do i = 1, n\n    sum_val = sum_val + a(i)\n    max_val = max(max_val, a(i))\n    min_val = min(min_val, a(i))\n  end do\n  !$omp end parallel do\n  print '(A)', 'Combined reductions:'\n  print '(A,F15.2)', '  Sum: ', sum_val\n  print '(A,F15.2)', '  Max: ', max_val\n  print '(A,F15.2)', '  Min: ', min_val\n\nend program demo_omp_reduction\n```\n\nCompile with:\n```text\ngfortran -fopenmp demo_omp_reduction.f90 -o demo_omp_reduction\n```\n\nResults:\n```text\nSum:            5000.00\nMaximum:        5000.00\nMinimum:       -4999.00\nAll positive: F\nAny negative: T\nCount positive: 5000\nCombined reductions:\n  Sum:          5000.00\n  Max:          5000.00\n  Min:         -4999.00\n```\n\n### **Standard**\n\nOpenMP 1.0 (1997 for Fortran), with extensions in later versions\n\n### **See Also**\n\n[**!$omp parallel do**(3)](#omp_parallel_do),\n[**!$omp parallel**(3)](#omp_parallel),\n[**!$omp atomic**(3)](#omp_atomic),\n[**!$omp critical**(3)](#omp_critical)\n\n### **Resources**\n\n- [OpenMP 5.0 Reduction Clause](https://www.openmp.org/spec-html/5.0/openmpsu107.html)\n- [OpenMP Reduction Tutorial](https://www.openmp.org/resources/tutorials-articles/)\n- [LLNL OpenMP Tutorial - Reduction](https://hpc-tutorials.llnl.gov/openmp/)",
  "whereelseif": "## whereelseif\n\n### **Name**\n\n**where-elsewhere-mask** - \\[ARRAY:CONSTRUCTION\\] Masked array assignment with multiple conditions.\n\n### **Synopsis**\n```fortran\n    where (mask1)\n      array = value1\n    elsewhere (mask2)\n      array = value2\n    elsewhere\n      array = value3\n    end where\n```\n```fortran\n     where (logical(kind=**), dimension(..))  ! primary mask\n       array = expression1\n     elsewhere (logical(kind=**), dimension(..))  ! secondary mask\n       array = expression2\n     elsewhere  ! default case\n       array = expression3\n     end where\n```\n\n### **Characteristics**\n\n - **mask1** is a logical array expression defining the primary condition.\n - **mask2** is a logical array expression defining the secondary condition.\n - **array** is an array variable that will be assigned values.\n - All masks must be conformable (same shape) with the array.\n - Masks are evaluated in order; each element is assigned by the first matching condition.\n - The final ELSEWHERE without a mask catches all remaining elements.\n\n### **Description**\n\n **where-elsewhere** provides conditional array assignment with multiple masks. Elements of the array are assigned based on the first mask condition that evaluates to .TRUE. for that element. The ELSEWHERE(mask2) clause handles elements where mask1 is .FALSE. but mask2 is .TRUE. The final ELSEWHERE without a mask handles all remaining elements where all previous masks were .FALSE.\n\n### **Options**\n\n- **mask1**\n  : Logical array expression. Elements where mask1 is .TRUE. receive value1.\n\n- **mask2**\n  : Logical array expression. Elements where mask1 is .FALSE. and mask2 is .TRUE. receive value2.\n\n- **array**\n  : The target array variable being assigned. Must be conformable with all masks.\n\n- **value1, value2, value3**\n  : Expressions conformable with array. Assigned to elements based on mask conditions.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_where_elsewhere_if\nimplicit none\n  integer :: i\n  real :: scores(10)\n  character(len=1) :: grades(10)\n  \n  ! Sample test scores\n  scores = [95.0, 82.0, 67.0, 91.0, 55.0, 78.0, 88.0, 42.0, 73.0, 99.0]\n  \n  ! Assign letter grades based on score ranges\n  where (scores >= 90.0)\n    grades = 'A'\n  elsewhere (scores >= 70.0)\n    grades = 'B'\n  elsewhere (scores >= 60.0)\n    grades = 'C'\n  elsewhere\n    grades = 'F'\n  end where\n  \n  ! Display results\n  print '(a)', 'Score  Grade'\n  print '(a)', '-----  -----'\n  do i = 1, 10\n    print '(f5.1, 4x, a1)', scores(i), grades(i)\n  end do\n  \nend program demo_where_elsewhere_if\n```\nResults:\n```text\nScore  Grade\n-----  -----\n 95.0    A\n 82.0    B\n 67.0    C\n 91.0    A\n 55.0    F\n 78.0    B\n 88.0    B\n 42.0    F\n 73.0    B\n 99.0    A\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**where**(3)](#where), [**elsewhere**(3)](#elsewhere), [**merge**(3)](#merge), [**pack**(3)](#pack), [**unpack**(3)](#unpack)",
  "writefmt": "## write_formatted\n\n### **Name**\n\n**write** - \\[IO:FORMATTED\\] Write formatted data to a file or standard output\n\n### **Synopsis**\n```fortran\n    write(unit, fmt) var1, var2, ...\n```\n```fortran\n     write(unit=unit_num, fmt=format_spec, iostat=ios, iomsg=msg) var_list\n\n      integer, intent(in)            :: unit_num     ! File unit or * for stdout\n      character(len=*), intent(in)   :: format_spec  ! Format string or *\n      integer, intent(out), optional :: ios          ! I/O status\n      character(len=*), intent(inout), optional :: msg  ! Error message\n```\n\n### **Characteristics**\n\n - **unit** is an integer representing the file unit number, or * for standard output.\n - **fmt** is a format specification (character string, statement label, or * for list-directed).\n - **var** is one or more expressions or variables to output.\n - The types of output items must match the format descriptors provided.\n - Unit 6 is typically standard output; * can also be used for screen output.\n\n### **Description**\n\n **write** transfers data from program variables to an external file or standard output in formatted form. The format specifier controls how internal values are converted to character representation. Format descriptors define field widths, decimal places, and other formatting options for human-readable output.\n\n### **Options**\n\n- **unit**\n  : An integer expression specifying the unit number connected to the output file.\n  Use * for standard output (typically screen). Unit 6 is conventionally stdout.\n\n- **fmt**\n  : Format specification controlling output appearance. Can be:\n  - `*` for list-directed (free-format) output\n  - A character expression with format descriptors like '(I5,F10.3)'\n  - A statement label referencing a FORMAT statement\n\n- **iostat=**\n  : Integer variable set to zero on success, positive on error.\n\n- **iomsg=**\n  : Character variable that receives a descriptive error message if an error occurs.\n\n- **advance=**\n  : 'YES' (default) or 'NO' to control whether to advance to the next record.\n\n### **Result**\n\n  Data is written to the specified unit in the format specified. The output record contains the character representation of the output list items.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_write_formatted\nimplicit none\n  integer :: unit_num, ios\n  integer :: count\n  real :: temperature, humidity\n  character(len=20) :: city\n  character(len=100) :: errmsg\n\n  ! Initialize data\n  city = 'New York'\n  count = 42\n  temperature = 72.5\n  humidity = 65.3\n\n  ! Example 1: List-directed output to standard output\n  write(*, *) 'Count:', count, 'Temp:', temperature\n\n  ! Example 2: Formatted output with explicit descriptors\n  write(*, '(A,I5)') 'The count is: ', count\n  write(*, '(A,F8.2,A)') 'Temperature: ', temperature, ' F'\n\n  ! Example 3: Multiple values with formatting\n  write(*, '(A20,A,F6.1,A,F5.1,A)') &\n        city, ': ', temperature, ' F, ', humidity, '% humidity'\n\n  ! Example 4: Write to file with error handling\n  open(newunit=unit_num, file='weather.txt', status='replace', &\n       iostat=ios, iomsg=errmsg)\n  if (ios /= 0) then\n    print *, 'Error:', trim(errmsg)\n  else\n    write(unit_num, '(A20,2F10.2)', iostat=ios) city, temperature, humidity\n    close(unit_num)\n    print *, 'Data written to weather.txt'\n  end if\n\nend program demo_write_formatted\n```\nResults:\n```text\n Count:          42 Temp:   72.5000000\nThe count is:    42\nTemperature:    72.50 F\nNew York            :   72.5 F,  65.3% humidity\n Data written to weather.txt\n```\n\n### **Standard**\n\nFortran 77 (enhanced in Fortran 90/95/2003 with IOSTAT, IOMSG, ADVANCE)\n\n### **See Also**\n\n[**read**(3)](#read),\n[**print**(3)](#print),\n[**open**(3)](#open),\n[**close**(3)](#close),\n[**format**(3)](#format)",
  "f2cstring": "## f_to_c_string\n\n### **Name**\n\n**f_to_c_string** - \\[INTEROP:C_BINDING\\] Convert Fortran string to null-terminated C string array\n\n### **Synopsis**\n```fortran\n    c_string = f_to_c_string(f_string)\n```\n```fortran\n     pure function f_to_c_string(f_string) result(c_string)\n\n      use iso_c_binding, only: c_char, c_null_char\n      character(len=*), intent(in)  :: f_string\n      character(kind=c_char, len=1) :: c_string(len_trim(f_string) + 1)\n```\n\n### **Characteristics**\n\n - **f_string** is a character scalar of any length.\n - The result is a rank-1 array of c_char characters with length len_trim(f_string) + 1.\n - The result array is null-terminated for C interoperability.\n - This is a pure function suitable for use in concurrent contexts.\n\n### **Description**\n\n **f_to_c_string** converts a Fortran character string to a null-terminated\n C-compatible character array. It trims trailing blanks from the input string\n and appends a C_NULL_CHAR to create a proper C string representation.\n\n### **Options**\n\n- **f_string**\n  : The Fortran character string to convert. May be of any length.\n  Trailing blanks are automatically trimmed before conversion.\n\n### **Result**\n\n  Returns a rank-1 array of single characters with kind c_char. The array\n  size is len_trim(f_string) + 1, where the final element is c_null_char.\n  Each character from the trimmed input string is copied to the corresponding\n  array element.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_f_to_c_string\n  use iso_c_binding, only: c_char, c_null_char, c_ptr, c_loc\n  implicit none\n\n  character(len=32) :: fortran_str\n  character(kind=c_char, len=1), allocatable :: c_str(:)\n  integer :: i\n\n  ! Define interface for the conversion function\n  interface\n    pure function f_to_c_string(f_string) result(c_string)\n      use iso_c_binding, only: c_char, c_null_char\n      character(len=*), intent(in) :: f_string\n      character(kind=c_char, len=1) :: c_string(len_trim(f_string) + 1)\n    end function f_to_c_string\n  end interface\n\n  ! Test with a simple string\n  fortran_str = 'Hello, C World!'\n  c_str = f_to_c_string(fortran_str)\n\n  print '(A)', 'Original Fortran string: \"' // trim(fortran_str) // '\"'\n  print '(A,I0)', 'C string array size: ', size(c_str)\n  print '(A)', 'C string contents (character by character):'\n\n  do i = 1, size(c_str)\n    if (c_str(i) == c_null_char) then\n      print '(A,I0,A)', '  c_str(', i, ') = NULL_CHAR (terminator)'\n    else\n      print '(A,I0,A,A,A)', '  c_str(', i, ') = \"', c_str(i), '\"'\n    end if\n  end do\n\n  deallocate(c_str)\n\nend program demo_f_to_c_string\n```\nResults:\n```text\nOriginal Fortran string: \"Hello, C World!\"\nC string array size: 16\nC string contents (character by character):\n  c_str(1) = \"H\"\n  c_str(2) = \"e\"\n  c_str(3) = \"l\"\n  c_str(4) = \"l\"\n  c_str(5) = \"o\"\n  c_str(6) = \",\"\n  c_str(7) = \" \"\n  c_str(8) = \"C\"\n  c_str(9) = \" \"\n  c_str(10) = \"W\"\n  c_str(11) = \"o\"\n  c_str(12) = \"r\"\n  c_str(13) = \"l\"\n  c_str(14) = \"d\"\n  c_str(15) = \"!\"\n  c_str(16) = NULL_CHAR (terminator)\n```\n\n### **Standard**\n\nFortran 2003 (iso_c_binding module)\n\n**Compatibility Notes:**\n- gfortran 4.3+, Intel Fortran 10.0+, NAG 5.1+\n- Append C_NULL_CHAR to Fortran string\n- Use TRIM() to remove trailing blanks\n\n### **See Also**\n\n[**c_f_pointer**(3)](#c_f_pointer),\n[**c_loc**(3)](#c_loc),\n[**c_null_char**(3)](#c_null_char),\n[**iso_c_binding**(3)](#iso_c_binding)",
  "writef": "## write_formatted\n\n### **Name**\n\n**write** - \\[IO:FORMATTED\\] Write formatted data to a file or standard output\n\n### **Synopsis**\n```fortran\n    write(unit, fmt) var1, var2, ...\n```\n```fortran\n     write(unit=unit_num, fmt=format_spec, iostat=ios, iomsg=msg) var_list\n\n      integer, intent(in)            :: unit_num     ! File unit or * for stdout\n      character(len=*), intent(in)   :: format_spec  ! Format string or *\n      integer, intent(out), optional :: ios          ! I/O status\n      character(len=*), intent(inout), optional :: msg  ! Error message\n```\n\n### **Characteristics**\n\n - **unit** is an integer representing the file unit number, or * for standard output.\n - **fmt** is a format specification (character string, statement label, or * for list-directed).\n - **var** is one or more expressions or variables to output.\n - The types of output items must match the format descriptors provided.\n - Unit 6 is typically standard output; * can also be used for screen output.\n\n### **Description**\n\n **write** transfers data from program variables to an external file or standard output in formatted form. The format specifier controls how internal values are converted to character representation. Format descriptors define field widths, decimal places, and other formatting options for human-readable output.\n\n### **Options**\n\n- **unit**\n  : An integer expression specifying the unit number connected to the output file.\n  Use * for standard output (typically screen). Unit 6 is conventionally stdout.\n\n- **fmt**\n  : Format specification controlling output appearance. Can be:\n  - `*` for list-directed (free-format) output\n  - A character expression with format descriptors like '(I5,F10.3)'\n  - A statement label referencing a FORMAT statement\n\n- **iostat=**\n  : Integer variable set to zero on success, positive on error.\n\n- **iomsg=**\n  : Character variable that receives a descriptive error message if an error occurs.\n\n- **advance=**\n  : 'YES' (default) or 'NO' to control whether to advance to the next record.\n\n### **Result**\n\n  Data is written to the specified unit in the format specified. The output record contains the character representation of the output list items.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_write_formatted\nimplicit none\n  integer :: unit_num, ios\n  integer :: count\n  real :: temperature, humidity\n  character(len=20) :: city\n  character(len=100) :: errmsg\n\n  ! Initialize data\n  city = 'New York'\n  count = 42\n  temperature = 72.5\n  humidity = 65.3\n\n  ! Example 1: List-directed output to standard output\n  write(*, *) 'Count:', count, 'Temp:', temperature\n\n  ! Example 2: Formatted output with explicit descriptors\n  write(*, '(A,I5)') 'The count is: ', count\n  write(*, '(A,F8.2,A)') 'Temperature: ', temperature, ' F'\n\n  ! Example 3: Multiple values with formatting\n  write(*, '(A20,A,F6.1,A,F5.1,A)') &\n        city, ': ', temperature, ' F, ', humidity, '% humidity'\n\n  ! Example 4: Write to file with error handling\n  open(newunit=unit_num, file='weather.txt', status='replace', &\n       iostat=ios, iomsg=errmsg)\n  if (ios /= 0) then\n    print *, 'Error:', trim(errmsg)\n  else\n    write(unit_num, '(A20,2F10.2)', iostat=ios) city, temperature, humidity\n    close(unit_num)\n    print *, 'Data written to weather.txt'\n  end if\n\nend program demo_write_formatted\n```\nResults:\n```text\n Count:          42 Temp:   72.5000000\nThe count is:    42\nTemperature:    72.50 F\nNew York            :   72.5 F,  65.3% humidity\n Data written to weather.txt\n```\n\n### **Standard**\n\nFortran 77 (enhanced in Fortran 90/95/2003 with IOSTAT, IOMSG, ADVANCE)\n\n### **See Also**\n\n[**read**(3)](#read),\n[**print**(3)](#print),\n[**open**(3)](#open),\n[**close**(3)](#close),\n[**format**(3)](#format)",
  "fstring": "## f_to_c_string\n\n### **Name**\n\n**f_to_c_string** - \\[INTEROP:C_BINDING\\] Convert Fortran string to null-terminated C string array\n\n### **Synopsis**\n```fortran\n    c_string = f_to_c_string(f_string)\n```\n```fortran\n     pure function f_to_c_string(f_string) result(c_string)\n\n      use iso_c_binding, only: c_char, c_null_char\n      character(len=*), intent(in)  :: f_string\n      character(kind=c_char, len=1) :: c_string(len_trim(f_string) + 1)\n```\n\n### **Characteristics**\n\n - **f_string** is a character scalar of any length.\n - The result is a rank-1 array of c_char characters with length len_trim(f_string) + 1.\n - The result array is null-terminated for C interoperability.\n - This is a pure function suitable for use in concurrent contexts.\n\n### **Description**\n\n **f_to_c_string** converts a Fortran character string to a null-terminated\n C-compatible character array. It trims trailing blanks from the input string\n and appends a C_NULL_CHAR to create a proper C string representation.\n\n### **Options**\n\n- **f_string**\n  : The Fortran character string to convert. May be of any length.\n  Trailing blanks are automatically trimmed before conversion.\n\n### **Result**\n\n  Returns a rank-1 array of single characters with kind c_char. The array\n  size is len_trim(f_string) + 1, where the final element is c_null_char.\n  Each character from the trimmed input string is copied to the corresponding\n  array element.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_f_to_c_string\n  use iso_c_binding, only: c_char, c_null_char, c_ptr, c_loc\n  implicit none\n\n  character(len=32) :: fortran_str\n  character(kind=c_char, len=1), allocatable :: c_str(:)\n  integer :: i\n\n  ! Define interface for the conversion function\n  interface\n    pure function f_to_c_string(f_string) result(c_string)\n      use iso_c_binding, only: c_char, c_null_char\n      character(len=*), intent(in) :: f_string\n      character(kind=c_char, len=1) :: c_string(len_trim(f_string) + 1)\n    end function f_to_c_string\n  end interface\n\n  ! Test with a simple string\n  fortran_str = 'Hello, C World!'\n  c_str = f_to_c_string(fortran_str)\n\n  print '(A)', 'Original Fortran string: \"' // trim(fortran_str) // '\"'\n  print '(A,I0)', 'C string array size: ', size(c_str)\n  print '(A)', 'C string contents (character by character):'\n\n  do i = 1, size(c_str)\n    if (c_str(i) == c_null_char) then\n      print '(A,I0,A)', '  c_str(', i, ') = NULL_CHAR (terminator)'\n    else\n      print '(A,I0,A,A,A)', '  c_str(', i, ') = \"', c_str(i), '\"'\n    end if\n  end do\n\n  deallocate(c_str)\n\nend program demo_f_to_c_string\n```\nResults:\n```text\nOriginal Fortran string: \"Hello, C World!\"\nC string array size: 16\nC string contents (character by character):\n  c_str(1) = \"H\"\n  c_str(2) = \"e\"\n  c_str(3) = \"l\"\n  c_str(4) = \"l\"\n  c_str(5) = \"o\"\n  c_str(6) = \",\"\n  c_str(7) = \" \"\n  c_str(8) = \"C\"\n  c_str(9) = \" \"\n  c_str(10) = \"W\"\n  c_str(11) = \"o\"\n  c_str(12) = \"r\"\n  c_str(13) = \"l\"\n  c_str(14) = \"d\"\n  c_str(15) = \"!\"\n  c_str(16) = NULL_CHAR (terminator)\n```\n\n### **Standard**\n\nFortran 2003 (iso_c_binding module)\n\n**Compatibility Notes:**\n- gfortran 4.3+, Intel Fortran 10.0+, NAG 5.1+\n- Fortran strings must be null-terminated for C interop\n- Use TRIM() and C_NULL_CHAR for conversion\n\n### **See Also**\n\n[**c_f_pointer**(3)](#c_f_pointer),\n[**c_loc**(3)](#c_loc),\n[**c_null_char**(3)](#c_null_char),\n[**iso_c_binding**(3)](#iso_c_binding)",
  "allocarr": "## allocate_array\n\n### **Name**\n\n**allocate** - \\[ARRAY:ALLOCATION\\] Dynamically allocate memory for allocatable arrays\n\n### **Synopsis**\n```fortran\n    allocate(object(lower:upper), stat=stat_var)\n```\n```fortran\n     allocate(alloc_list, stat=stat_var, errmsg=errmsg_var, source=source_expr, mold=mold_expr)\n\n      type(TYPE(kind=**)), allocatable :: object(..)\n      integer                          :: stat_var\n      character(len=*)                 :: errmsg_var\n      type(TYPE(kind=**))              :: source_expr(..)\n      type(TYPE(kind=**))              :: mold_expr(..)\n```\n\n### **Characteristics**\n\n - **object** must be an allocatable array or pointer that has been declared with the ALLOCATABLE or POINTER attribute.\n - **shape-spec** is a list of dimension bounds in the form [lower:]upper for each dimension.\n - **stat_var** is a scalar integer variable that receives the allocation status.\n - **errmsg_var** is a scalar character variable for error messages.\n - The object must not already be allocated when ALLOCATE is executed (unless using STAT=).\n - All dimension bounds must be scalar integer expressions.\n\n### **Description**\n\n **allocate** dynamically creates storage for allocatable arrays or pointer\n targets at runtime. The shape of the array is determined by the shape\n specification provided. If the optional STAT= specifier is present and\n allocation succeeds, the stat variable is set to zero. If allocation fails\n and STAT= is present, the stat variable receives a positive integer error\n code. If allocation fails without STAT=, program execution terminates.\n\n### **Options**\n\n- **alloc-object**\n  : The allocatable variable or pointer to be allocated. Can be an array\n  with explicit bounds or use mold/source for shape determination.\n\n- **stat**\n  : Optional. Integer variable set to zero on success, positive on error.\n  If absent, allocation failure terminates the program.\n\n- **errmsg**\n  : Optional. Character variable that receives a descriptive error message\n  if allocation fails. Unchanged if allocation succeeds.\n\n- **source**\n  : Optional. Expression whose value and shape are used to initialize and\n  shape the allocated object.\n\n- **mold**\n  : Optional. Expression whose type and shape are used for the allocation,\n  but values are not copied.\n\n### **Result**\n\n  The allocated object is created with the specified shape and type.\n  If SOURCE= is used, the object is initialized with the source value.\n  If MOLD= is used, the object has the same type and shape but undefined values.\n  The stat variable (if present) is set to zero on success.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_allocate\n  use, intrinsic :: iso_fortran_env, only: dp => real64\n  implicit none\n\n  integer :: ierr\n  character(len=100) :: errmsg\n  integer :: n\n  real(dp), allocatable :: arr(:)\n  real(dp), allocatable :: matrix(:,:)\n  integer, allocatable :: indices(:)\n\n  n = 100\n\n  ! Allocate a 1D array with error checking\n  allocate(arr(n), stat=ierr, errmsg=errmsg)\n  if (ierr /= 0) error stop errmsg\n\n  ! Allocate a 2D array with explicit bounds\n  allocate(matrix(0:9, -5:5), stat=ierr)\n  if (ierr /= 0) error stop 'Allocation of matrix failed'\n\n  ! Allocate with source initialization\n  allocate(indices, source=[1, 2, 3, 4, 5])\n\n  print *, 'arr size:', size(arr)\n  print *, 'matrix shape:', shape(matrix)\n  print *, 'matrix bounds:', lbound(matrix), ubound(matrix)\n  print *, 'indices:', indices\n\n  ! Clean up\n  deallocate(arr, matrix, indices)\n\nend program demo_allocate\n```\nResults:\n```text\n arr size:         100\n matrix shape:          10          11\n matrix bounds:           0          -5          9           5\n indices:           1           2           3           4           5\n```\n\n### **Standard**\n\nFortran 90 (basic), Fortran 2003 (SOURCE=, ERRMSG=), Fortran 2008 (MOLD=)\n\n**Compatibility Notes:**\n- gfortran 4.0+, Intel Fortran 9.0+, NAG 5.0+\n- Standard allocatable array since Fortran 90\n- Use STAT= and ERRMSG= for error handling\n\n### **See Also**\n\n[**deallocate**](#deallocate),\n[**allocate_source**](#allocate_source),\n[**allocate_mold**](#allocate_mold),\n[**allocated**](#allocated),\n[**move_alloc**](#move_alloc)",
  "readfmtmulti": "## read_formatted_multi\n\n### **Name**\n\n**read** - \\[IO:FORMATTED\\] Read multiple values with explicit format descriptors\n\n### **Synopsis**\n```fortran\n    read(unit, '(format_descriptors)') var1, var2, var3, ...\n```\n```fortran\n     read(unit=unit_num, fmt='(descriptors)', iostat=ios) var_list\n\n      integer, intent(in)            :: unit_num\n      integer, intent(out), optional :: ios\n      ! var_list: multiple variables matching format descriptors\n```\n\n### **Characteristics**\n\n - **unit** is an integer unit number or * for standard input.\n - **format** is a character string with multiple format descriptors.\n - **var_list** contains multiple variables to receive input values.\n - Format descriptors must match variable types in order and number.\n - Repeat counts can be used for groups of similar data types.\n\n### **Description**\n\n **read** with multiple format descriptors parses structured input records containing different data types. The format string specifies the exact layout of input data, including field widths, decimal positions, and spacing. This is essential for reading fixed-format data files where each column has a specific meaning.\n\n### **Options**\n\n- **unit**\n  : Integer unit number of an open file or * for standard input.\n\n- **format descriptors**\n  : Common descriptors include:\n  - **Iw** - Integer of width w characters\n  - **Fw.d** - Fixed-point real, width w, d decimal places\n  - **Ew.d** - Exponential notation real\n  - **Aw** - Character of width w (or A for length of variable)\n  - **Lw** - Logical of width w\n  - **nX** - Skip n positions\n  - **/** - Move to next record (line)\n  - **Tn** - Tab to column n\n\n- **var_list**\n  : Variables to receive values. Types must match corresponding format descriptors.\n\n### **Result**\n\n  Each variable in the input list receives a value parsed according to its corresponding format descriptor. Values are read from left to right in the input record.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_read_multi_format\nimplicit none\n  integer :: unit_num, ios\n  character(len=20) :: name\n  integer :: id, quantity\n  real :: price, total\n  logical :: in_stock\n\n  ! Create sample data file\n  open(newunit=unit_num, file='inventory.txt', status='replace')\n  write(unit_num, '(A20,I5,I8,F10.2,F12.2,L3)') &\n        'Widget A            ', 101, 50, 19.99, 999.50, .true.\n  write(unit_num, '(A20,I5,I8,F10.2,F12.2,L3)') &\n        'Gadget B            ', 102, 0, 49.99, 0.00, .false.\n  close(unit_num)\n\n  ! Read the structured data\n  open(newunit=unit_num, file='inventory.txt', status='old', iostat=ios)\n  if (ios /= 0) error stop 'Cannot open file'\n\n  print '(A)', 'Inventory Report:'\n  print '(A)', repeat('-', 60)\n\n  do\n    read(unit_num, '(A20,I5,I8,F10.2,F12.2,L3)', iostat=ios) &\n         name, id, quantity, price, total, in_stock\n    if (ios /= 0) exit\n\n    print '(A,A)',     'Product:   ', trim(name)\n    print '(A,I0)',    'ID:        ', id\n    print '(A,I0)',    'Quantity:  ', quantity\n    print '(A,F0.2)',  'Price:     $', price\n    print '(A,F0.2)',  'Total:     $', total\n    print '(A,L1)',    'In Stock:  ', in_stock\n    print '(A)', ''\n  end do\n\n  close(unit_num, status='delete')\n\nend program demo_read_multi_format\n```\nResults:\n```text\nInventory Report:\n------------------------------------------------------------\nProduct:   Widget A\nID:        101\nQuantity:  50\nPrice:     $19.99\nTotal:     $999.50\nIn Stock:  T\n\nProduct:   Gadget B\nID:        102\nQuantity:  0\nPrice:     $49.99\nTotal:     $.00\nIn Stock:  F\n```\n\n### **Standard**\n\nFortran 77\n\n### **See Also**\n\n[**read**(3)](#read),\n[**write**(3)](#write),\n[**format**(3)](#format),\n[**open**(3)](#open)",
  "allocate_array": "## allocate_array\n\n### **Name**\n\n**allocate** - \\[ARRAY:ALLOCATION\\] Dynamically allocate memory for allocatable arrays\n\n### **Synopsis**\n```fortran\n    allocate(object(lower:upper), stat=stat_var)\n```\n```fortran\n     allocate(alloc_list, stat=stat_var, errmsg=errmsg_var, source=source_expr, mold=mold_expr)\n\n      type(TYPE(kind=**)), allocatable :: object(..)\n      integer                          :: stat_var\n      character(len=*)                 :: errmsg_var\n      type(TYPE(kind=**))              :: source_expr(..)\n      type(TYPE(kind=**))              :: mold_expr(..)\n```\n\n### **Characteristics**\n\n - **object** must be an allocatable array or pointer that has been declared with the ALLOCATABLE or POINTER attribute.\n - **shape-spec** is a list of dimension bounds in the form [lower:]upper for each dimension.\n - **stat_var** is a scalar integer variable that receives the allocation status.\n - **errmsg_var** is a scalar character variable for error messages.\n - The object must not already be allocated when ALLOCATE is executed (unless using STAT=).\n - All dimension bounds must be scalar integer expressions.\n\n### **Description**\n\n **allocate** dynamically creates storage for allocatable arrays or pointer\n targets at runtime. The shape of the array is determined by the shape\n specification provided. If the optional STAT= specifier is present and\n allocation succeeds, the stat variable is set to zero. If allocation fails\n and STAT= is present, the stat variable receives a positive integer error\n code. If allocation fails without STAT=, program execution terminates.\n\n### **Options**\n\n- **alloc-object**\n  : The allocatable variable or pointer to be allocated. Can be an array\n  with explicit bounds or use mold/source for shape determination.\n\n- **stat**\n  : Optional. Integer variable set to zero on success, positive on error.\n  If absent, allocation failure terminates the program.\n\n- **errmsg**\n  : Optional. Character variable that receives a descriptive error message\n  if allocation fails. Unchanged if allocation succeeds.\n\n- **source**\n  : Optional. Expression whose value and shape are used to initialize and\n  shape the allocated object.\n\n- **mold**\n  : Optional. Expression whose type and shape are used for the allocation,\n  but values are not copied.\n\n### **Result**\n\n  The allocated object is created with the specified shape and type.\n  If SOURCE= is used, the object is initialized with the source value.\n  If MOLD= is used, the object has the same type and shape but undefined values.\n  The stat variable (if present) is set to zero on success.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_allocate\n  use, intrinsic :: iso_fortran_env, only: dp => real64\n  implicit none\n\n  integer :: ierr\n  character(len=100) :: errmsg\n  integer :: n\n  real(dp), allocatable :: arr(:)\n  real(dp), allocatable :: matrix(:,:)\n  integer, allocatable :: indices(:)\n\n  n = 100\n\n  ! Allocate a 1D array with error checking\n  allocate(arr(n), stat=ierr, errmsg=errmsg)\n  if (ierr /= 0) error stop errmsg\n\n  ! Allocate a 2D array with explicit bounds\n  allocate(matrix(0:9, -5:5), stat=ierr)\n  if (ierr /= 0) error stop 'Allocation of matrix failed'\n\n  ! Allocate with source initialization\n  allocate(indices, source=[1, 2, 3, 4, 5])\n\n  print *, 'arr size:', size(arr)\n  print *, 'matrix shape:', shape(matrix)\n  print *, 'matrix bounds:', lbound(matrix), ubound(matrix)\n  print *, 'indices:', indices\n\n  ! Clean up\n  deallocate(arr, matrix, indices)\n\nend program demo_allocate\n```\nResults:\n```text\n arr size:         100\n matrix shape:          10          11\n matrix bounds:           0          -5          9           5\n indices:           1           2           3           4           5\n```\n\n### **Standard**\n\nFortran 90 (basic), Fortran 2003 (SOURCE=, ERRMSG=), Fortran 2008 (MOLD=)\n\n**Compatibility Notes:**\n- gfortran 4.0+, Intel Fortran 9.0+, NAG 5.0+\n- Standard allocatable array since Fortran 90\n- Use STAT= and ERRMSG= for error handling\n\n### **See Also**\n\n[**deallocate**](#deallocate),\n[**allocate_source**](#allocate_source),\n[**allocate_mold**](#allocate_mold),\n[**allocated**](#allocated),\n[**move_alloc**](#move_alloc)",
  "donamedstep": "## named_do_loop_with_step\n\n### **Name**\n\n**named_do_loop_with_step** - \\[CONTROL:LOOP\\] Named do loop with explicit step increment\n\n### **Synopsis**\n```fortran\n    loop_name: do variable = start, end, step\n      ! loop body\n    end do loop_name\n```\n```fortran\n     loop_name: do variable = start, end, step\n\n      integer :: variable  ! loop control variable\n      integer :: start     ! initial value\n      integer :: end       ! terminal value\n      integer :: step      ! increment (positive or negative)\n```\n\n### **Characteristics**\n\n - **loop_name** is a user-defined identifier that labels the loop construct.\n - **variable** is a scalar integer variable (the loop control variable).\n - **start**, **end**, and **step** are scalar integer expressions.\n - **step** must be non-zero; positive for ascending loops, negative for descending.\n - The loop name must match between the do statement and end do statement.\n - Named loops can be referenced by EXIT and CYCLE statements for precise control.\n\n### **Description**\n\n **named_do_loop_with_step** creates a counted do loop with an explicit step value and a user-defined name. The loop variable is initialized to the start value and incremented by step after each iteration until it exceeds the end value (for positive step) or falls below it (for negative step). The loop name allows EXIT and CYCLE statements to target this specific loop when nested within other loops.\n\n### **Options**\n\n- **loop_name**\n  : A valid Fortran identifier that labels the loop. Must appear on both the do statement (followed by a colon) and the end do statement. Enables targeted EXIT and CYCLE statements.\n\n- **variable**\n  : The loop control variable. Must be a scalar integer variable. Its value is automatically managed by the loop construct and should not be modified within the loop body.\n\n- **start**\n  : An integer expression specifying the initial value of the loop variable.\n\n- **end**\n  : An integer expression specifying the terminal value. The loop continues while the variable has not passed this value (considering the sign of step).\n\n- **step**\n  : An integer expression specifying the increment added to the loop variable after each iteration. Must be non-zero. Use positive values for ascending sequences, negative values for descending sequences.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_named_do_loop_with_step\nimplicit none\n  integer :: i, j, sum\n\n  ! Example 1: Count by 2s (ascending with step)\n  print *, 'Even numbers from 2 to 10:'\n  evens: do i = 2, 10, 2\n    print *, i\n  end do evens\n\n  ! Example 2: Countdown (descending with negative step)\n  print *, 'Countdown from 5:'\n  countdown: do i = 5, 1, -1\n    print *, i\n  end do countdown\n\n  ! Example 3: Nested loops with targeted EXIT\n  print *, 'Nested loop example with targeted EXIT:'\n  sum = 0\n  outer: do i = 1, 100, 10\n    inner: do j = 1, 5, 1\n      sum = sum + i + j\n      if (sum > 50) exit outer  ! Exit outer loop by name\n    end do inner\n  end do outer\n  print *, 'Sum when exceeding 50:', sum\n\n  ! Example 4: Skip iterations with targeted CYCLE\n  print *, 'CYCLE example - skip j=2:'\n  row_loop: do i = 1, 2, 1\n    col_loop: do j = 1, 3, 1\n      if (j == 2) cycle col_loop  ! Skip to next j\n      print *, 'i=', i, ' j=', j\n    end do col_loop\n  end do row_loop\n\nend program demo_named_do_loop_with_step\n```\nResults:\n```text\n Even numbers from 2 to 10:\n           2\n           4\n           6\n           8\n          10\n Countdown from 5:\n           5\n           4\n           3\n           2\n           1\n Nested loop example with targeted EXIT:\n Sum when exceeding 50:          56\n CYCLE example - skip j=2:\n i=           1  j=           1\n i=           1  j=           3\n i=           2  j=           1\n i=           2  j=           3\n```\n\n### **Standard**\n\nFortran 77 (named constructs added in Fortran 90)\n\n### **See Also**\n\n[**do_loop**(3)](#do_loop),\n[**do_loop_with_step**(3)](#do_loop_with_step),\n[**named_do_loop**(3)](#named_do_loop),\n[**do_while**(3)](#do_while),\n[**do_concurrent**(3)](#do_concurrent),\n[**exit**(3)](#exit),\n[**cycle**(3)](#cycle)",
  "readstr": "## read_internal\n\n### **Name**\n\n**read** - \\[IO:INTERNAL\\] Read formatted data from an internal character variable\n\n### **Synopsis**\n```fortran\n    read(string, fmt) var1, var2, ...\n```\n```fortran\n     read(unit=string, fmt=format_spec, iostat=ios, iomsg=msg) var_list\n\n      character(len=*), intent(in)  :: string       ! Source string\n      character(len=*), intent(in)  :: format_spec  ! Format or *\n      integer, intent(out), optional :: ios         ! I/O status\n      character(len=*), intent(inout), optional :: msg  ! Error message\n```\n\n### **Characteristics**\n\n - **string** is a character variable or array containing the data to be read.\n - **fmt** is a format specification (character expression, label, or * for list-directed).\n - **var** is the variable(s) to receive the parsed data.\n - The internal file must contain valid formatted data matching the format specification.\n - No file unit number is used; the character variable serves as the \"file\".\n\n### **Description**\n\n **read** with an internal file (character variable) parses formatted data from a string into program variables. This is commonly used for:\n - Converting strings to numeric values\n - Parsing user input that was read as a character string\n - Processing data from non-file sources\n - Extracting values from formatted text buffers\n\n The character variable acts as an internal file, with each element of a character array treated as a separate record.\n\n### **Options**\n\n- **string**\n  : A character variable, substring, or array containing formatted data to be parsed. For arrays, each element is treated as a separate record (line).\n\n- **fmt**\n  : Format specification controlling how data is interpreted. Can be:\n  - `*` for list-directed (free-format) reading\n  - A character expression containing format descriptors\n  - A statement label referencing a FORMAT statement\n  - `'(format-descriptors)'` as a literal string\n\n- **var**\n  : One or more variables to receive the parsed values. Types must match the format specification.\n\n- **iostat=** (optional)\n  : Integer variable set to zero on success, positive on error, negative on end-of-record/file.\n\n- **iomsg=** (optional)\n  : Character variable that receives an error message if an error occurs.\n\n### **Result**\n\n  The variables in the input list receive values converted from the character string according to the format specification. This provides the Fortran equivalent of sscanf() in C for parsing strings into typed values.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_internal_read\nimplicit none\n  character(len=50) :: input_string\n  character(len=20) :: name\n  integer :: age, ios\n  real :: temperature, value\n  character(len=100) :: errmsg\n\n  ! Example 1: Simple numeric conversion from string\n  input_string = '42'\n  read(input_string, *) age\n  print *, 'Age:', age\n\n  ! Example 2: Reading multiple values\n  input_string = '98.6  37.0'\n  read(input_string, *) temperature, value\n  print *, 'Temperature F:', temperature, ' C:', value\n\n  ! Example 3: Using explicit format\n  input_string = 'John                  25'\n  read(input_string, '(A20, I5)') name, age\n  print *, 'Name:', trim(name), ' Age:', age\n\n  ! Example 4: Error handling with iostat\n  input_string = 'not_a_number'\n  read(input_string, *, iostat=ios, iomsg=errmsg) value\n  if (ios /= 0) then\n    print *, 'Read error:', trim(errmsg)\n  else\n    print *, 'Value:', value\n  end if\n\n  ! Example 5: Reading from string with complex format\n  input_string = '2024-01-15'\n  block\n    integer :: year, month, day\n    read(input_string, '(I4, 1X, I2, 1X, I2)') year, month, day\n    print *, 'Date: Year=', year, ' Month=', month, ' Day=', day\n  end block\n\nend program demo_internal_read\n```\nResults:\n```text\n Age:          42\n Temperature F:   98.5999985      C:   37.0000000\n Name:John                  Age:          25\n Read error: Invalid argument\n Date: Year=        2024  Month=           1  Day=          15\n```\n\n### **Standard**\n\nFortran 77 (internal files), Fortran 2003 (IOMSG)\n\n**Compatibility Notes:**\n- gfortran 4.0+, Intel Fortran 9.0+, NAG 5.0+\n- Use READ with internal file (character variable)\n- IOSTAT= for error handling\n\n### **See Also**\n\n[**write_internal**(3)](#write_internal),\n[**read**(3)](#read),\n[**open**(3)](#open),\n[**format**(3)](#format)",
  "namelist": "## namelist\n\n### **Name**\n\n**namelist** - \\[IO:NAMELIST\\] Define a named group of variables for namelist-directed I/O\n\n### **Synopsis**\n```fortran\n    namelist /group_name/ var1, var2, ...\n```\n```fortran\n     ! Namelist declaration and usage\n\n      namelist /params/ x, y, z, name\n      read(unit, nml=params)\n      write(unit, nml=params)\n```\n\n### **Characteristics**\n\n - Groups multiple variables under a single name.\n - Enables reading/writing variables by name in input files.\n - Variables can be read in any order in the input.\n - Input format is self-documenting with variable names.\n\n### **Description**\n\n **namelist** declares a named group of variables that can be read or written\n as a unit using namelist-directed I/O. This is particularly useful for\n configuration files and parameter input, as the input file format includes\n variable names and values can appear in any order.\n\n### **Options**\n\n- **group_name**\n  : The name of the namelist group, enclosed in slashes. Used in READ/WRITE\n  statements with the NML= specifier.\n\n- **var1, var2, ...**\n  : The list of variables included in the namelist group. Can include scalars,\n  arrays, and derived type components.\n\n### **Result**\n\n  A namelist group is declared that can be used with namelist-directed I/O\n  for flexible, self-documenting input/output.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_namelist\nimplicit none\n  ! Variables for the namelist\n  integer :: max_iterations = 100\n  real :: tolerance = 1.0e-6\n  real :: initial_value = 0.0\n  character(len=50) :: output_file = 'results.dat'\n  logical :: verbose = .false.\n  real :: coefficients(3) = [1.0, 2.0, 3.0]\n\n  ! Declare the namelist\n  namelist /simulation_params/ max_iterations, tolerance, initial_value, &\n                               output_file, verbose, coefficients\n\n  integer :: io_unit, ios\n\n  ! Write default values to a namelist file\n  open(newunit=io_unit, file='params.nml', status='replace', action='write')\n  write(io_unit, nml=simulation_params)\n  close(io_unit)\n  print '(A)', 'Default parameters written to params.nml'\n\n  ! Modify some values\n  max_iterations = 500\n  tolerance = 1.0e-10\n  verbose = .true.\n\n  ! Read parameters from file (would override modifications)\n  print '(A)', ''\n  print '(A)', 'Current parameter values:'\n  write(*, nml=simulation_params)\n\n  ! Example of what a namelist input file looks like:\n  print '(A)', ''\n  print '(A)', 'Example namelist input file format:'\n  print '(A)', '&simulation_params'\n  print '(A)', '  max_iterations = 200'\n  print '(A)', '  tolerance = 1.0e-8'\n  print '(A)', '  output_file = \"output.dat\"'\n  print '(A)', '  verbose = .true.'\n  print '(A)', '  coefficients = 1.5, 2.5, 3.5'\n  print '(A)', '/'\n\nend program demo_namelist\n```\nResults:\n```text\nDefault parameters written to params.nml\n\nCurrent parameter values:\n&SIMULATION_PARAMS\n MAX_ITERATIONS=         500,\n TOLERANCE=  1.00000001E-10,\n INITIAL_VALUE=  0.00000000    ,\n OUTPUT_FILE=\"results.dat                                         \",\n VERBOSE=T,\n COEFFICIENTS=  1.00000000    ,  2.00000000    ,  3.00000000    ,\n /\n\nExample namelist input file format:\n&simulation_params\n  max_iterations = 200\n  tolerance = 1.0e-8\n  output_file = \"output.dat\"\n  verbose = .true.\n  coefficients = 1.5, 2.5, 3.5\n/\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**read**(3)](#read),\n[**write**(3)](#write),\n[**open**(3)](#open)",
  "abstracttype": "## abstract_type\n\n### **Name**\n\n**abstract_type** - \\[STRUCTURE:TYPE\\] Define an abstract derived type that cannot be instantiated directly\n\n### **Synopsis**\n```fortran\n    type, abstract :: abstract_type_name\n```\n```fortran\n     type, abstract :: abstract_type_name\n\n      ! Component declarations\n      type(component_type) :: component\n     contains\n      procedure(interface_name), deferred :: deferred_method\n      procedure :: concrete_method\n     end type abstract_type_name\n```\n\n### **Characteristics**\n\n - **abstract** attribute prevents direct instantiation of the type.\n - Abstract types can contain both concrete and deferred (abstract) procedures.\n - **deferred** procedures must be implemented by non-abstract extending types.\n - Abstract types serve as base types for inheritance hierarchies.\n - Variables must be declared with CLASS (polymorphic) to hold extended types.\n\n### **Description**\n\n **abstract_type** defines a derived type that serves as a template or base\n class for type extension. An abstract type cannot be instantiated directly;\n instead, it must be extended by concrete (non-abstract) types that provide\n implementations for any deferred procedures. This enables object-oriented\n design patterns such as interfaces, abstract base classes, and polymorphic\n collections in Fortran.\n\n### **Options**\n\n- **abstract_type_name**\n  : A valid Fortran identifier for the abstract type. Must follow standard\n  naming conventions.\n\n- **deferred**\n  : Attribute for type-bound procedures that declares a method as abstract.\n  Deferred procedures have no implementation in the abstract type and must\n  be implemented by extending types. Requires an interface specification.\n\n- **procedure(interface_name)**\n  : Specifies the interface that deferred procedures must match. The\n  interface defines the argument types and return value.\n\n### **Result**\n\n  An abstract derived type that defines a contract for extending types,\n  ensuring they implement required methods while optionally providing\n  common functionality through concrete methods and shared components.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_abstract_type\nimplicit none\n\n  ! Abstract base type for shapes\n  type, abstract :: shape\n    real :: x = 0.0, y = 0.0  ! Position\n  contains\n    procedure(area_interface), deferred :: area\n    procedure(name_interface), deferred :: get_name\n    procedure :: move  ! Concrete method\n  end type shape\n\n  ! Abstract interfaces for deferred procedures\n  abstract interface\n    pure function area_interface(self) result(a)\n      import :: shape\n      class(shape), intent(in) :: self\n      real :: a\n    end function area_interface\n\n    pure function name_interface(self) result(n)\n      import :: shape\n      class(shape), intent(in) :: self\n      character(len=20) :: n\n    end function name_interface\n  end interface\n\n  ! Concrete type extending shape\n  type, extends(shape) :: circle\n    real :: radius = 1.0\n  contains\n    procedure :: area => circle_area\n    procedure :: get_name => circle_name\n  end type circle\n\n  ! Another concrete type extending shape\n  type, extends(shape) :: rectangle\n    real :: width = 1.0, height = 1.0\n  contains\n    procedure :: area => rectangle_area\n    procedure :: get_name => rectangle_name\n  end type rectangle\n\n  type(circle) :: c\n  type(rectangle) :: r\n  class(shape), allocatable :: shapes(:)\n\n  c = circle(x=0.0, y=0.0, radius=5.0)\n  r = rectangle(x=1.0, y=1.0, width=3.0, height=4.0)\n\n  print '(a,a,a,f8.3)', 'Shape: ', trim(c%get_name()), ', Area: ', c%area()\n  print '(a,a,a,f8.3)', 'Shape: ', trim(r%get_name()), ', Area: ', r%area()\n\n  call c%move(1.0, 2.0)\n  print '(a,2f6.2)', 'Circle moved to: ', c%x, c%y\n\ncontains\n\n  pure function circle_area(self) result(a)\n    class(circle), intent(in) :: self\n    real :: a\n    real, parameter :: pi = 3.14159265359\n    a = pi * self%radius**2\n  end function circle_area\n\n  pure function circle_name(self) result(n)\n    class(circle), intent(in) :: self\n    character(len=20) :: n\n    n = 'Circle'\n  end function circle_name\n\n  pure function rectangle_area(self) result(a)\n    class(rectangle), intent(in) :: self\n    real :: a\n    a = self%width * self%height\n  end function rectangle_area\n\n  pure function rectangle_name(self) result(n)\n    class(rectangle), intent(in) :: self\n    character(len=20) :: n\n    n = 'Rectangle'\n  end function rectangle_name\n\n  subroutine move(self, dx, dy)\n    class(shape), intent(inout) :: self\n    real, intent(in) :: dx, dy\n    self%x = self%x + dx\n    self%y = self%y + dy\n  end subroutine move\n\nend program demo_abstract_type\n```\nResults:\n```text\nShape: Circle              , Area:   78.540\nShape: Rectangle           , Area:   12.000\nCircle moved to:   1.00  2.00\n```\n\n### **Standard**\n\nFortran 2003\n\n**Compatibility Notes:**\n- gfortran 4.5+, Intel Fortran 12.0+, NAG 5.3+\n- Cannot be instantiated directly; must be extended\n- All deferred procedures must be implemented in concrete extensions\n\n### **See Also**\n\n[**type**(3)](#type),\n[**extends**(3)](#extends),\n[**deferred**(3)](#deferred),\n[**class**(3)](#class),\n[**select_type**(3)](#select_type)",
  "internalread": "## read_internal\n\n### **Name**\n\n**read** - \\[IO:INTERNAL\\] Read formatted data from an internal character variable\n\n### **Synopsis**\n```fortran\n    read(string, fmt) var1, var2, ...\n```\n```fortran\n     read(unit=string, fmt=format_spec, iostat=ios, iomsg=msg) var_list\n\n      character(len=*), intent(in)  :: string       ! Source string\n      character(len=*), intent(in)  :: format_spec  ! Format or *\n      integer, intent(out), optional :: ios         ! I/O status\n      character(len=*), intent(inout), optional :: msg  ! Error message\n```\n\n### **Characteristics**\n\n - **string** is a character variable or array containing the data to be read.\n - **fmt** is a format specification (character expression, label, or * for list-directed).\n - **var** is the variable(s) to receive the parsed data.\n - The internal file must contain valid formatted data matching the format specification.\n - No file unit number is used; the character variable serves as the \"file\".\n\n### **Description**\n\n **read** with an internal file (character variable) parses formatted data from a string into program variables. This is commonly used for:\n - Converting strings to numeric values\n - Parsing user input that was read as a character string\n - Processing data from non-file sources\n - Extracting values from formatted text buffers\n\n The character variable acts as an internal file, with each element of a character array treated as a separate record.\n\n### **Options**\n\n- **string**\n  : A character variable, substring, or array containing formatted data to be parsed. For arrays, each element is treated as a separate record (line).\n\n- **fmt**\n  : Format specification controlling how data is interpreted. Can be:\n  - `*` for list-directed (free-format) reading\n  - A character expression containing format descriptors\n  - A statement label referencing a FORMAT statement\n  - `'(format-descriptors)'` as a literal string\n\n- **var**\n  : One or more variables to receive the parsed values. Types must match the format specification.\n\n- **iostat=** (optional)\n  : Integer variable set to zero on success, positive on error, negative on end-of-record/file.\n\n- **iomsg=** (optional)\n  : Character variable that receives an error message if an error occurs.\n\n### **Result**\n\n  The variables in the input list receive values converted from the character string according to the format specification. This provides the Fortran equivalent of sscanf() in C for parsing strings into typed values.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_internal_read\nimplicit none\n  character(len=50) :: input_string\n  character(len=20) :: name\n  integer :: age, ios\n  real :: temperature, value\n  character(len=100) :: errmsg\n\n  ! Example 1: Simple numeric conversion from string\n  input_string = '42'\n  read(input_string, *) age\n  print *, 'Age:', age\n\n  ! Example 2: Reading multiple values\n  input_string = '98.6  37.0'\n  read(input_string, *) temperature, value\n  print *, 'Temperature F:', temperature, ' C:', value\n\n  ! Example 3: Using explicit format\n  input_string = 'John                  25'\n  read(input_string, '(A20, I5)') name, age\n  print *, 'Name:', trim(name), ' Age:', age\n\n  ! Example 4: Error handling with iostat\n  input_string = 'not_a_number'\n  read(input_string, *, iostat=ios, iomsg=errmsg) value\n  if (ios /= 0) then\n    print *, 'Read error:', trim(errmsg)\n  else\n    print *, 'Value:', value\n  end if\n\n  ! Example 5: Reading from string with complex format\n  input_string = '2024-01-15'\n  block\n    integer :: year, month, day\n    read(input_string, '(I4, 1X, I2, 1X, I2)') year, month, day\n    print *, 'Date: Year=', year, ' Month=', month, ' Day=', day\n  end block\n\nend program demo_internal_read\n```\nResults:\n```text\n Age:          42\n Temperature F:   98.5999985      C:   37.0000000\n Name:John                  Age:          25\n Read error: Invalid argument\n Date: Year=        2024  Month=           1  Day=          15\n```\n\n### **Standard**\n\nFortran 77 (internal files), Fortran 2003 (IOMSG)\n\n**Compatibility Notes:**\n- gfortran 4.0+, Intel Fortran 9.0+, NAG 5.0+\n- Internal files (character variables) are standard Fortran\n- Useful for string to number conversion\n\n### **See Also**\n\n[**write_internal**(3)](#write_internal),\n[**read**(3)](#read),\n[**open**(3)](#open),\n[**format**(3)](#format)",
  "abstract": "## abstract_type\n\n### **Name**\n\n**abstract_type** - \\[STRUCTURE:TYPE\\] Define an abstract derived type that cannot be instantiated directly\n\n### **Synopsis**\n```fortran\n    type, abstract :: abstract_type_name\n```\n```fortran\n     type, abstract :: abstract_type_name\n\n      ! Component declarations\n      type(component_type) :: component\n     contains\n      procedure(interface_name), deferred :: deferred_method\n      procedure :: concrete_method\n     end type abstract_type_name\n```\n\n### **Characteristics**\n\n - **abstract** attribute prevents direct instantiation of the type.\n - Abstract types can contain both concrete and deferred (abstract) procedures.\n - **deferred** procedures must be implemented by non-abstract extending types.\n - Abstract types serve as base types for inheritance hierarchies.\n - Variables must be declared with CLASS (polymorphic) to hold extended types.\n\n### **Description**\n\n **abstract_type** defines a derived type that serves as a template or base\n class for type extension. An abstract type cannot be instantiated directly;\n instead, it must be extended by concrete (non-abstract) types that provide\n implementations for any deferred procedures. This enables object-oriented\n design patterns such as interfaces, abstract base classes, and polymorphic\n collections in Fortran.\n\n### **Options**\n\n- **abstract_type_name**\n  : A valid Fortran identifier for the abstract type. Must follow standard\n  naming conventions.\n\n- **deferred**\n  : Attribute for type-bound procedures that declares a method as abstract.\n  Deferred procedures have no implementation in the abstract type and must\n  be implemented by extending types. Requires an interface specification.\n\n- **procedure(interface_name)**\n  : Specifies the interface that deferred procedures must match. The\n  interface defines the argument types and return value.\n\n### **Result**\n\n  An abstract derived type that defines a contract for extending types,\n  ensuring they implement required methods while optionally providing\n  common functionality through concrete methods and shared components.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_abstract_type\nimplicit none\n\n  ! Abstract base type for shapes\n  type, abstract :: shape\n    real :: x = 0.0, y = 0.0  ! Position\n  contains\n    procedure(area_interface), deferred :: area\n    procedure(name_interface), deferred :: get_name\n    procedure :: move  ! Concrete method\n  end type shape\n\n  ! Abstract interfaces for deferred procedures\n  abstract interface\n    pure function area_interface(self) result(a)\n      import :: shape\n      class(shape), intent(in) :: self\n      real :: a\n    end function area_interface\n\n    pure function name_interface(self) result(n)\n      import :: shape\n      class(shape), intent(in) :: self\n      character(len=20) :: n\n    end function name_interface\n  end interface\n\n  ! Concrete type extending shape\n  type, extends(shape) :: circle\n    real :: radius = 1.0\n  contains\n    procedure :: area => circle_area\n    procedure :: get_name => circle_name\n  end type circle\n\n  ! Another concrete type extending shape\n  type, extends(shape) :: rectangle\n    real :: width = 1.0, height = 1.0\n  contains\n    procedure :: area => rectangle_area\n    procedure :: get_name => rectangle_name\n  end type rectangle\n\n  type(circle) :: c\n  type(rectangle) :: r\n  class(shape), allocatable :: shapes(:)\n\n  c = circle(x=0.0, y=0.0, radius=5.0)\n  r = rectangle(x=1.0, y=1.0, width=3.0, height=4.0)\n\n  print '(a,a,a,f8.3)', 'Shape: ', trim(c%get_name()), ', Area: ', c%area()\n  print '(a,a,a,f8.3)', 'Shape: ', trim(r%get_name()), ', Area: ', r%area()\n\n  call c%move(1.0, 2.0)\n  print '(a,2f6.2)', 'Circle moved to: ', c%x, c%y\n\ncontains\n\n  pure function circle_area(self) result(a)\n    class(circle), intent(in) :: self\n    real :: a\n    real, parameter :: pi = 3.14159265359\n    a = pi * self%radius**2\n  end function circle_area\n\n  pure function circle_name(self) result(n)\n    class(circle), intent(in) :: self\n    character(len=20) :: n\n    n = 'Circle'\n  end function circle_name\n\n  pure function rectangle_area(self) result(a)\n    class(rectangle), intent(in) :: self\n    real :: a\n    a = self%width * self%height\n  end function rectangle_area\n\n  pure function rectangle_name(self) result(n)\n    class(rectangle), intent(in) :: self\n    character(len=20) :: n\n    n = 'Rectangle'\n  end function rectangle_name\n\n  subroutine move(self, dx, dy)\n    class(shape), intent(inout) :: self\n    real, intent(in) :: dx, dy\n    self%x = self%x + dx\n    self%y = self%y + dy\n  end subroutine move\n\nend program demo_abstract_type\n```\nResults:\n```text\nShape: Circle              , Area:   78.540\nShape: Rectangle           , Area:   12.000\nCircle moved to:   1.00  2.00\n```\n\n### **Standard**\n\nFortran 2003\n\n**Compatibility Notes:**\n- gfortran 4.5+, Intel Fortran 12.0+, NAG 5.3+\n- Cannot be instantiated directly; must be extended\n- All deferred procedures must be implemented in concrete extensions\n\n### **See Also**\n\n[**type**(3)](#type),\n[**extends**(3)](#extends),\n[**deferred**(3)](#deferred),\n[**class**(3)](#class),\n[**select_type**(3)](#select_type)",
  "c_loc": "## c_loc\n\n### **Name**\n\n**c_loc** - \\[INTEROP:C_BINDING\\] Get the C address of a Fortran data object\n\n### **Synopsis**\n```fortran\n    cptr = c_loc(x)\n```\n```fortran\n     function c_loc(x) result(cptr)\n\n      type(*), intent(in), target :: x\n      type(c_ptr)                 :: cptr\n```\n\n### **Characteristics**\n\n - **x** must have the TARGET attribute or be a pointer.\n - **x** must be interoperable (scalar or contiguous array of interoperable type).\n - Returns a C_PTR containing the C address of x.\n - If x is an array, returns address of first element.\n - The target must remain valid while the pointer is used.\n\n### **Description**\n\n **c_loc** returns the C address of a Fortran data object as a C_PTR value.\n This enables passing Fortran data to C functions that expect pointers.\n The result can be passed to C functions or used with C_F_POINTER to\n associate other Fortran pointers with the same memory.\n\n### **Options**\n\n- **x**\n  : A Fortran variable with the TARGET attribute, or a Fortran pointer that\n  is associated with a target. Must be an interoperable type: intrinsic types\n  with interoperable kinds, or BIND(C) derived types. For arrays, must be\n  contiguous (no strides).\n\n### **Result**\n\n  A scalar of type C_PTR containing the C address of x. This is equivalent\n  to &x in C. For arrays, returns the address of element x(1) or x(1,1,...).\n  If x is a disassociated pointer or has undefined status, behavior is undefined.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_c_loc\n  use iso_c_binding\n  implicit none\n\n  interface\n    ! C function: void print_address(void* ptr)\n    subroutine print_address(ptr) bind(c, name='print_address')\n      import :: c_ptr\n      type(c_ptr), intent(in), value :: ptr\n    end subroutine print_address\n\n    ! C function: void modify_value(double* ptr, double val)\n    subroutine modify_value(ptr, val) bind(c, name='modify_value')\n      import :: c_ptr, c_double\n      type(c_ptr), intent(in), value :: ptr\n      real(c_double), intent(in), value :: val\n    end subroutine modify_value\n  end interface\n\n  real(c_double), target :: scalar_val\n  real(c_double), target :: array_val(5)\n  type(c_ptr) :: ptr\n  integer :: i\n\n  ! Example 1: Get address of scalar\n  scalar_val = 3.14159_c_double\n  ptr = c_loc(scalar_val)\n  print '(A)', 'Address of scalar obtained'\n\n  ! Example 2: Get address of array (returns address of first element)\n  array_val = [(real(i, c_double), i = 1, 5)]\n  ptr = c_loc(array_val)\n  print '(A)', 'Address of array[1] obtained'\n\n  ! Alternatively, get address of specific element\n  ptr = c_loc(array_val(3))\n  print '(A)', 'Address of array[3] obtained'\n\n  ! Example 3: Pass address to C function\n  ptr = c_loc(scalar_val)\n  call modify_value(ptr, 2.71828_c_double)\n  print '(A,F10.5)', 'Modified scalar: ', scalar_val\n\n  ! Example 4: Use with c_f_pointer for memory aliasing\n  block\n    real(c_double), pointer :: alias_ptr\n    ptr = c_loc(scalar_val)\n    call c_f_pointer(ptr, alias_ptr)\n    alias_ptr = 100.0_c_double\n    print '(A,F10.2)', 'Value via alias: ', scalar_val\n  end block\n\nend program demo_c_loc\n```\n\nResults:\n```text\nAddress of scalar obtained\nAddress of array[1] obtained\nAddress of array[3] obtained\nModified scalar:   2.71828\nValue via alias:     100.00\n```\n\n### **Standard**\n\nFortran 2003 (ISO/IEC 1539-1:2004)\n\n**Compatibility Notes:**\n- gfortran 4.3+, Intel Fortran 10.0+, NAG 5.1+\n- Requires USE ISO_C_BINDING\n- Target must have the TARGET attribute or be interoperable\n\n### **See Also**\n\n[**c_f_pointer**(3)](#c_f_pointer),\n[**c_funloc**(3)](#c_funloc),\n[**c_ptr**(3)](#c_ptr),\n[**c_null_ptr**(3)](#c_null_ptr),\n[**iso_c_binding**(3)](#iso_c_binding)",
  "array1d": "## array1d\n\n### **Name**\n\n**assumed_shape_1d** - \\[ARRAY:DECLARATION\\] Declare a 1D assumed-shape dummy argument\n\n### **Synopsis**\n```fortran\n    type, intent(in) :: array(:)\n```\n```fortran\n     subroutine proc(array)\n\n      type(TYPE(kind=**)), intent(in|out|inout) :: array(:)\n```\n\n### **Characteristics**\n\n - **array** is a rank-1 dummy argument with assumed shape, indicated by `(:)`.\n - The extent is determined from the actual argument at runtime.\n - The procedure must have an explicit interface.\n - Lower bound defaults to 1 unless explicitly specified.\n - Array inquiry intrinsics (SIZE, LBOUND, UBOUND) work correctly.\n - No array copying occurs; the descriptor is passed by reference.\n\n### **Description**\n\n **assumed_shape_1d** declares a one-dimensional array dummy argument whose\n shape is determined by the actual argument at the time of procedure\n invocation. The array inherits the size and extent from the calling code,\n allowing procedures to operate on arrays of any size without requiring\n explicit size arguments. This is the modern and recommended approach for\n passing arrays in Fortran.\n\n### **Options**\n\n- **type**\n  : Any intrinsic or derived type (integer, real, complex, logical, character,\n  or user-defined type).\n\n- **kind**\n  : Optional kind parameter for the type.\n\n- **intent**\n  : Data flow direction: in (read-only), out (write-only), or inout (read-write).\n\n- **array**\n  : The dummy argument name. The `(:)` syntax indicates assumed shape.\n\n### **Result**\n\n  The dummy argument references the actual argument with size information\n  available. The procedure can use SIZE, LBOUND, and UBOUND to query\n  dimensions.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_array1d\n  use, intrinsic :: iso_fortran_env, only: dp => real64\n  implicit none\n\n  real(dp) :: small(5)\n  real(dp) :: large(1000)\n  real(dp), allocatable :: dynamic(:)\n  real(dp) :: result\n\n  small = [1.0_dp, 2.0_dp, 3.0_dp, 4.0_dp, 5.0_dp]\n  large = 1.0_dp\n\n  allocate(dynamic(50))\n  dynamic = 2.0_dp\n\n  ! Same function works with any size 1D array\n  result = compute_mean(small)\n  print *, 'Mean of small:', result\n\n  result = compute_mean(large)\n  print *, 'Mean of large:', result\n\n  result = compute_mean(dynamic)\n  print *, 'Mean of dynamic:', result\n\n  ! Demonstrate size inquiry\n  call print_array_info(small)\n  call print_array_info(dynamic)\n\n  deallocate(dynamic)\n\ncontains\n\n  function compute_mean(arr) result(mean)\n    real(dp), intent(in) :: arr(:)  ! Assumed-shape 1D\n    real(dp) :: mean\n\n    mean = sum(arr) / size(arr)\n  end function compute_mean\n\n  subroutine print_array_info(arr)\n    real(dp), intent(in) :: arr(:)\n\n    print *, 'Size:', size(arr)\n    print *, 'Bounds:', lbound(arr, 1), 'to', ubound(arr, 1)\n  end subroutine print_array_info\n\nend program demo_array1d\n```\nResults:\n```text\n Mean of small:   3.0000000000000000\n Mean of large:   1.0000000000000000\n Mean of dynamic:   2.0000000000000000\n Size:           5\n Bounds:           1 to           5\n Size:          50\n Bounds:           1 to          50\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**assumed2d**](#assumed2d),\n[**assumed3d**](#assumed3d),\n[**size**](#size),\n[**shape**](#shape),\n[**contiguous**](#contiguous)",
  "readcheck": "## read_with_check\n\n### **Name**\n\n**read_with_check** - \\[IO:FORMATTED\\] Read data with error checking via IOSTAT\n\n### **Synopsis**\n```fortran\n    read(unit, fmt, iostat=ierr) var\n    if (ierr /= 0) error stop 'Read failed'\n```\n```fortran\n     read(unit=unit_num, fmt=format_spec, iostat=ierr, iomsg=msg) var_list\n\n      integer, intent(in)             :: unit_num\n      character(len=*), intent(in)    :: format_spec\n      integer, intent(out)            :: ierr      ! 0=success, >0=error, <0=EOF\n      character(len=*), intent(inout) :: msg       ! Error description\n```\n\n### **Characteristics**\n\n - **unit** is an integer unit number or * for standard input.\n - **fmt** is a format specification or * for list-directed.\n - **iostat** receives the I/O status code after the operation.\n - **iomsg** receives a descriptive error message on failure.\n - The pattern provides robust error handling for production code.\n\n### **Description**\n\n **read_with_check** demonstrates the standard pattern for reading data with proper error handling. The IOSTAT specifier prevents program termination on I/O errors, allowing the program to detect and respond to error conditions, end-of-file, or end-of-record situations gracefully.\n\n### **Options**\n\n- **unit**\n  : File unit number or * for standard input.\n\n- **fmt**\n  : Format specification for data interpretation.\n\n- **iostat=**\n  : Integer variable receiving status:\n  - Zero (0): Successful completion\n  - Positive: An error occurred (processor-dependent value)\n  - Negative: End-of-file (-1) or end-of-record (-2) condition\n\n- **iomsg=**\n  : Character variable receiving descriptive error text when iostat is nonzero.\n\n### **Result**\n\n  On success (iostat=0), variables contain valid data. On error (iostat>0), an error occurred and variables may be undefined. On end-of-file (iostat<0), no more data is available.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_read_check\nimplicit none\n  integer :: unit_num, ierr, line_count\n  real :: value\n  character(len=256) :: errmsg\n  character(len=100) :: line\n\n  ! Create test file with mixed valid/invalid data\n  open(newunit=unit_num, file='test_data.txt', status='replace')\n  write(unit_num, '(A)') '123.45'\n  write(unit_num, '(A)') '678.90'\n  write(unit_num, '(A)') 'not_a_number'\n  write(unit_num, '(A)') '111.11'\n  close(unit_num)\n\n  ! Read with error checking\n  open(newunit=unit_num, file='test_data.txt', status='old', iostat=ierr)\n  if (ierr /= 0) error stop 'Cannot open file'\n\n  line_count = 0\n  do\n    line_count = line_count + 1\n    read(unit_num, *, iostat=ierr, iomsg=errmsg) value\n\n    if (ierr < 0) then\n      print '(A)', 'End of file reached'\n      exit\n    else if (ierr > 0) then\n      print '(A,I0,A,A)', 'Error on line ', line_count, ': ', trim(errmsg)\n      ! Skip to next line and continue\n      cycle\n    else\n      print '(A,I0,A,F10.4)', 'Line ', line_count, ': value = ', value\n    end if\n  end do\n\n  close(unit_num, status='delete')\n  print '(A,I0,A)', 'Processed ', line_count, ' lines'\n\nend program demo_read_check\n```\nResults:\n```text\nLine 1: value =   123.4500\nLine 2: value =   678.9000\nError on line 3: Invalid argument\nLine 4: value =   111.1100\nEnd of file reached\nProcessed 5 lines\n```\n\n### **Standard**\n\nFortran 90 (IOSTAT), Fortran 2003 (IOMSG)\n\n**Compatibility Notes:**\n- gfortran 4.0+, Intel Fortran 9.0+, NAG 5.0+\n- Use IOSTAT= for error detection\n- Check for IOSTAT_END and IOSTAT_EOR\n\n### **See Also**\n\n[**read**(3)](#read),\n[**write**(3)](#write),\n[**open**(3)](#open),\n[**iostat_end**(3)](#iostat_end),\n[**iostat_eor**(3)](#iostat_eor)",
  "allocatable1d": "## allocatable1d\n\n### **Name**\n\n**allocatable_1d** - \\[ARRAY:ALLOCATION\\] Declare a one-dimensional allocatable array\n\n### **Synopsis**\n```fortran\n    type, allocatable :: array_name(:)\n```\n```fortran\n     type(TYPE(kind=**)), allocatable :: array_name(:)\n\n      type  :: Any valid Fortran type\n      kind  :: Optional kind parameter\n```\n\n### **Characteristics**\n\n - **type** can be any intrinsic type or derived type.\n - **kind** specifies the kind type parameter (e.g., dp for double precision).\n - **array_name** must be a valid Fortran identifier.\n - The array has deferred shape indicated by `(:)` with one dimension.\n - The array is initially unallocated; it must be allocated before use.\n - The ALLOCATED intrinsic can query allocation status.\n - Allocatable arrays are automatically deallocated when they go out of scope.\n\n### **Description**\n\n **allocatable_1d** declares a one-dimensional array with the ALLOCATABLE\n attribute. The array has deferred shape, meaning its bounds are not\n specified at declaration time but are determined dynamically at runtime\n through the ALLOCATE statement. This provides flexible memory management\n where array size can depend on input data or computed values.\n\n### **Options**\n\n- **type**\n  : The data type of array elements. Can be integer, real, complex,\n  logical, character, or any derived type.\n\n- **kind**\n  : Optional kind parameter specifying precision or storage size.\n\n- **array_name**\n  : The identifier for the array variable.\n\n### **Result**\n\n  A variable that can hold a 1D array of any size, determined at runtime.\n  Must be allocated before use and can be reallocated with different sizes.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_allocatable1d\n  use, intrinsic :: iso_fortran_env, only: dp => real64\n  implicit none\n\n  real(dp), allocatable :: values(:)\n  integer, allocatable :: indices(:)\n  character(len=20), allocatable :: names(:)\n  integer :: n, ierr\n\n  ! Check initial state\n  print *, 'Initially allocated:', allocated(values)\n\n  ! Allocate based on runtime value\n  n = 10\n  allocate(values(n), stat=ierr)\n  if (ierr /= 0) error stop 'Allocation failed'\n\n  print *, 'After allocate:', allocated(values)\n  print *, 'Size:', size(values)\n\n  values = [(real(i, dp)**2, i=1, n)]\n  print *, 'Values:', values(1:5), '...'\n\n  ! Reallocate with different size\n  deallocate(values)\n  allocate(values(5), source=[1.0_dp, 2.0_dp, 3.0_dp, 4.0_dp, 5.0_dp])\n  print *, 'After reallocation:', size(values)\n  print *, 'Values:', values\n\n  ! Character array\n  allocate(names(3))\n  names = ['Alice  ', 'Bob    ', 'Charlie']\n  print *, 'Names:', names\n\n  ! Automatic deallocation at end of scope\n  ! (explicit deallocation is optional but good practice)\n  deallocate(values, names)\n\nend program demo_allocatable1d\n```\nResults:\n```text\n Initially allocated: F\n After allocate: T\n Size:          10\n Values:   1.0000000000000000   4.0000000000000000   9.0000000000000000   16.000000000000000   25.000000000000000  ...\n After reallocation:           5\n Values:   1.0000000000000000   2.0000000000000000   3.0000000000000000   4.0000000000000000   5.0000000000000000\n Names:Alice               Bob                 Charlie\n```\n\n### **Standard**\n\nFortran 90 (ISO/IEC 1539:1991, sections 5.2.6, 6.3.1, 6.3.3)\n\n### **See Also**\n\n[**allocate**](#allocate),\n[**deallocate**](#deallocate),\n[**allocated**](#allocated),\n[**move_alloc**](#move_alloc)",
  "allocstr": "## allocate_string\n\n### **Name**\n\n**allocate_string** - \\[ARRAY:ALLOCATION\\] Allocate a deferred-length character variable\n\n### **Synopsis**\n```fortran\n    allocate(character(len=n) :: str)\n```\n```fortran\n     allocate(character(len=length_expr) :: char_var, stat=stat_var, errmsg=errmsg_var)\n\n      character(len=:), allocatable :: char_var\n      integer                       :: length_expr\n      integer                       :: stat_var\n      character(len=*)              :: errmsg_var\n```\n\n### **Characteristics**\n\n - **char_var** must be declared with deferred length `character(len=:), allocatable`.\n - **length_expr** is a scalar integer expression specifying the string length.\n - **stat_var** is an optional integer variable for allocation status.\n - **errmsg_var** is an optional character variable for error messages.\n - The allocated string has exactly the specified length.\n - The string content is undefined after allocation until assigned.\n\n### **Description**\n\n **allocate** with a type-spec of `character(len=n)` dynamically allocates\n storage for a deferred-length allocatable character variable. The length\n is determined at runtime, allowing strings to be sized according to program\n needs. This is essential for modern Fortran string handling where the length\n of text data is not known at compile time.\n\n### **Options**\n\n- **char_var**\n  : The allocatable character variable. Must be declared with deferred length\n  using `character(len=:), allocatable`.\n\n- **len**\n  : The length specification for the character variable. Must be a non-negative\n  integer expression. A length of zero creates a valid zero-length string.\n\n- **stat**\n  : Optional. Integer variable set to zero on success, positive on error.\n\n- **errmsg**\n  : Optional. Character variable for descriptive error message on failure.\n\n### **Result**\n\n  The character variable is allocated with exactly the specified length.\n  The content is undefined and should be assigned before use. If stat\n  is present and allocation succeeds, it is set to zero.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_allocate_string\n  implicit none\n\n  character(len=:), allocatable :: greeting\n  character(len=:), allocatable :: buffer\n  character(len=:), allocatable :: filename\n  integer :: n, ierr\n  character(len=100) :: errmsg\n\n  ! Allocate a string of specific length\n  allocate(character(len=20) :: greeting, stat=ierr)\n  if (ierr /= 0) error stop 'Allocation failed'\n  greeting = 'Hello, World!'\n  print *, 'Greeting: \"', greeting, '\"'\n  print *, 'Length:', len(greeting)\n\n  ! Allocate based on runtime value\n  n = 256\n  allocate(character(len=n) :: buffer, stat=ierr, errmsg=errmsg)\n  if (ierr /= 0) error stop errmsg\n  print *, 'Buffer length:', len(buffer)\n\n  ! Reallocate with different length\n  deallocate(greeting)\n  allocate(character(len=50) :: greeting)\n  greeting = 'This is a longer greeting message'\n  print *, 'New greeting length:', len(greeting)\n\n  ! Allocate filename from expression\n  allocate(character(len=len_trim('output_') + 4) :: filename)\n  filename = 'output_.dat'\n  print *, 'Filename: ', filename\n\n  deallocate(greeting, buffer, filename)\n\nend program demo_allocate_string\n```\nResults:\n```text\n Greeting: \"Hello, World!       \"\n Length:          20\n Buffer length:         256\n New greeting length:          50\n Filename: output_.dat\n```\n\n### **Standard**\n\nFortran 2003\n\n**Compatibility Notes:**\n- gfortran 4.5+, Intel Fortran 11.0+, NAG 5.2+\n- Deferred-length character strings require F2003\n- Use CHARACTER(LEN=:), ALLOCATABLE\n\n### **See Also**\n\n[**allocate**](#allocate),\n[**len**](#len),\n[**len_trim**](#len_trim),\n[**trim**](#trim)",
  "gccattr": "## gcc_attributes\n\n### **Name**\n\n**gcc_attributes** - \\[COMPILER:DIRECTIVE\\] Apply GCC-specific attributes to procedures or variables\n\n### **Synopsis**\n```fortran\n    !GCC$ ATTRIBUTES attr :: name\n```\n```fortran\n     ! GCC-specific attribute directive\n\n      !GCC$ ATTRIBUTES STDCALL :: subroutine_name\n      !GCC$ ATTRIBUTES DLLEXPORT :: function_name\n```\n\n### **Characteristics**\n\n - GCC/gfortran-specific extension.\n - Affects calling conventions, symbol visibility, and optimization.\n - Ignored by other compilers (treated as comment).\n - Must appear before the procedure or variable declaration.\n\n### **Description**\n\n **gcc_attributes** applies GCC-specific attributes to procedures, variables,\n or types. These attributes control calling conventions for Windows DLL\n interoperability, symbol visibility for shared libraries, and various\n optimization hints. The directive is specific to GNU Fortran (gfortran).\n\n### **Options**\n\n- **STDCALL**\n  : Use the Windows stdcall calling convention. Arguments passed on stack,\n  callee cleans up. Required for some Windows API calls.\n\n- **CDECL**\n  : Use the C calling convention (default on most platforms).\n\n- **DLLEXPORT**\n  : Export symbol from a Windows DLL.\n\n- **DLLIMPORT**\n  : Import symbol from a Windows DLL.\n\n- **NO_ARG_CHECK**\n  : Disable type checking for dummy arguments. Useful for generic interfaces\n  to C functions.\n\n- **FASTCALL**\n  : Use the fastcall convention (first arguments in registers).\n\n### **Result**\n\n  The specified attribute is applied to the named entity, affecting its\n  behavior at link time or runtime.\n\n### **Examples**\n\nSample program:\n```fortran\nmodule windows_interop\n  implicit none\n\n  ! Export this subroutine from a DLL\n  !GCC$ ATTRIBUTES DLLEXPORT :: exported_sub\n  interface\n    subroutine exported_sub(x, y) bind(c)\n      use iso_c_binding\n      real(c_float), intent(in) :: x\n      real(c_float), intent(out) :: y\n    end subroutine\n  end interface\n\ncontains\n\n  !GCC$ ATTRIBUTES STDCALL :: win_callback\n  subroutine win_callback(hwnd, msg)\n    use iso_c_binding\n    integer(c_intptr_t), intent(in) :: hwnd\n    integer(c_int), intent(in) :: msg\n    ! Windows callback implementation\n    print '(A,I0,A,I0)', 'Callback: hwnd=', hwnd, ' msg=', msg\n  end subroutine win_callback\n\nend module windows_interop\n\nprogram demo_gcc_attributes\n  implicit none\n\n  print '(A)', 'GCC attributes demonstration'\n  print '(A)', 'Note: This feature is gfortran-specific.'\n  print '(A)', 'Attributes like STDCALL and DLLEXPORT are used'\n  print '(A)', 'for Windows DLL interoperability.'\n\nend program demo_gcc_attributes\n```\nResults:\n```text\nGCC attributes demonstration\nNote: This feature is gfortran-specific.\nAttributes like STDCALL and DLLEXPORT are used\nfor Windows DLL interoperability.\n```\n\n### **Standard**\n\nGCC extension (not Fortran standard)\n\n### **See Also**\n\n[**bind(c)**(3)](#bind_c),\n[**!DIR$**(3)](#directive),\n[**iso_c_binding**(3)](#iso_c_binding)",
  "allocate_string": "## allocate_string\n\n### **Name**\n\n**allocate_string** - \\[ARRAY:ALLOCATION\\] Allocate a deferred-length character variable\n\n### **Synopsis**\n```fortran\n    allocate(character(len=n) :: str)\n```\n```fortran\n     allocate(character(len=length_expr) :: char_var, stat=stat_var, errmsg=errmsg_var)\n\n      character(len=:), allocatable :: char_var\n      integer                       :: length_expr\n      integer                       :: stat_var\n      character(len=*)              :: errmsg_var\n```\n\n### **Characteristics**\n\n - **char_var** must be declared with deferred length `character(len=:), allocatable`.\n - **length_expr** is a scalar integer expression specifying the string length.\n - **stat_var** is an optional integer variable for allocation status.\n - **errmsg_var** is an optional character variable for error messages.\n - The allocated string has exactly the specified length.\n - The string content is undefined after allocation until assigned.\n\n### **Description**\n\n **allocate** with a type-spec of `character(len=n)` dynamically allocates\n storage for a deferred-length allocatable character variable. The length\n is determined at runtime, allowing strings to be sized according to program\n needs. This is essential for modern Fortran string handling where the length\n of text data is not known at compile time.\n\n### **Options**\n\n- **char_var**\n  : The allocatable character variable. Must be declared with deferred length\n  using `character(len=:), allocatable`.\n\n- **len**\n  : The length specification for the character variable. Must be a non-negative\n  integer expression. A length of zero creates a valid zero-length string.\n\n- **stat**\n  : Optional. Integer variable set to zero on success, positive on error.\n\n- **errmsg**\n  : Optional. Character variable for descriptive error message on failure.\n\n### **Result**\n\n  The character variable is allocated with exactly the specified length.\n  The content is undefined and should be assigned before use. If stat\n  is present and allocation succeeds, it is set to zero.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_allocate_string\n  implicit none\n\n  character(len=:), allocatable :: greeting\n  character(len=:), allocatable :: buffer\n  character(len=:), allocatable :: filename\n  integer :: n, ierr\n  character(len=100) :: errmsg\n\n  ! Allocate a string of specific length\n  allocate(character(len=20) :: greeting, stat=ierr)\n  if (ierr /= 0) error stop 'Allocation failed'\n  greeting = 'Hello, World!'\n  print *, 'Greeting: \"', greeting, '\"'\n  print *, 'Length:', len(greeting)\n\n  ! Allocate based on runtime value\n  n = 256\n  allocate(character(len=n) :: buffer, stat=ierr, errmsg=errmsg)\n  if (ierr /= 0) error stop errmsg\n  print *, 'Buffer length:', len(buffer)\n\n  ! Reallocate with different length\n  deallocate(greeting)\n  allocate(character(len=50) :: greeting)\n  greeting = 'This is a longer greeting message'\n  print *, 'New greeting length:', len(greeting)\n\n  ! Allocate filename from expression\n  allocate(character(len=len_trim('output_') + 4) :: filename)\n  filename = 'output_.dat'\n  print *, 'Filename: ', filename\n\n  deallocate(greeting, buffer, filename)\n\nend program demo_allocate_string\n```\nResults:\n```text\n Greeting: \"Hello, World!       \"\n Length:          20\n Buffer length:         256\n New greeting length:          50\n Filename: output_.dat\n```\n\n### **Standard**\n\nFortran 2003\n\n**Compatibility Notes:**\n- gfortran 4.5+, Intel Fortran 11.0+, NAG 5.2+\n- Deferred-length character strings require F2003\n- Use CHARACTER(LEN=:), ALLOCATABLE\n\n### **See Also**\n\n[**allocate**](#allocate),\n[**len**](#len),\n[**len_trim**](#len_trim),\n[**trim**](#trim)",
  "gccattributes": "## gcc_attributes\n\n### **Name**\n\n**gcc_attributes** - \\[COMPILER:DIRECTIVE\\] Apply GCC-specific attributes to procedures or variables\n\n### **Synopsis**\n```fortran\n    !GCC$ ATTRIBUTES attr :: name\n```\n```fortran\n     ! GCC-specific attribute directive\n\n      !GCC$ ATTRIBUTES STDCALL :: subroutine_name\n      !GCC$ ATTRIBUTES DLLEXPORT :: function_name\n```\n\n### **Characteristics**\n\n - GCC/gfortran-specific extension.\n - Affects calling conventions, symbol visibility, and optimization.\n - Ignored by other compilers (treated as comment).\n - Must appear before the procedure or variable declaration.\n\n### **Description**\n\n **gcc_attributes** applies GCC-specific attributes to procedures, variables,\n or types. These attributes control calling conventions for Windows DLL\n interoperability, symbol visibility for shared libraries, and various\n optimization hints. The directive is specific to GNU Fortran (gfortran).\n\n### **Options**\n\n- **STDCALL**\n  : Use the Windows stdcall calling convention. Arguments passed on stack,\n  callee cleans up. Required for some Windows API calls.\n\n- **CDECL**\n  : Use the C calling convention (default on most platforms).\n\n- **DLLEXPORT**\n  : Export symbol from a Windows DLL.\n\n- **DLLIMPORT**\n  : Import symbol from a Windows DLL.\n\n- **NO_ARG_CHECK**\n  : Disable type checking for dummy arguments. Useful for generic interfaces\n  to C functions.\n\n- **FASTCALL**\n  : Use the fastcall convention (first arguments in registers).\n\n### **Result**\n\n  The specified attribute is applied to the named entity, affecting its\n  behavior at link time or runtime.\n\n### **Examples**\n\nSample program:\n```fortran\nmodule windows_interop\n  implicit none\n\n  ! Export this subroutine from a DLL\n  !GCC$ ATTRIBUTES DLLEXPORT :: exported_sub\n  interface\n    subroutine exported_sub(x, y) bind(c)\n      use iso_c_binding\n      real(c_float), intent(in) :: x\n      real(c_float), intent(out) :: y\n    end subroutine\n  end interface\n\ncontains\n\n  !GCC$ ATTRIBUTES STDCALL :: win_callback\n  subroutine win_callback(hwnd, msg)\n    use iso_c_binding\n    integer(c_intptr_t), intent(in) :: hwnd\n    integer(c_int), intent(in) :: msg\n    ! Windows callback implementation\n    print '(A,I0,A,I0)', 'Callback: hwnd=', hwnd, ' msg=', msg\n  end subroutine win_callback\n\nend module windows_interop\n\nprogram demo_gcc_attributes\n  implicit none\n\n  print '(A)', 'GCC attributes demonstration'\n  print '(A)', 'Note: This feature is gfortran-specific.'\n  print '(A)', 'Attributes like STDCALL and DLLEXPORT are used'\n  print '(A)', 'for Windows DLL interoperability.'\n\nend program demo_gcc_attributes\n```\nResults:\n```text\nGCC attributes demonstration\nNote: This feature is gfortran-specific.\nAttributes like STDCALL and DLLEXPORT are used\nfor Windows DLL interoperability.\n```\n\n### **Standard**\n\nGCC extension (not Fortran standard)\n\n### **See Also**\n\n[**bind(c)**(3)](#bind_c),\n[**!DIR$**(3)](#directive),\n[**iso_c_binding**(3)](#iso_c_binding)",
  "bindcsub": "## bind_c_subroutine\n\n### **Name**\n\n**bind_c_subroutine** - \\[INTEROP:C_BINDING\\] Declare a Fortran subroutine interoperable with C\n\n### **Synopsis**\n```fortran\n    call fortran_sub(arg1, arg2)\n```\n```fortran\n     subroutine fortran_sub(arg1, arg2) bind(c, name='c_func_name')\n\n      use iso_c_binding, only: c_int, c_double, c_ptr\n      integer(c_int), intent(in), value :: arg1\n      real(c_double), intent(inout)     :: arg2\n```\n\n### **Characteristics**\n\n - **bind(c)** makes the subroutine callable from C with C calling conventions.\n - **name='c_func_name'** specifies the external C name (optional, defaults to lowercase Fortran name).\n - All dummy arguments must be interoperable C types from ISO_C_BINDING.\n - Arguments passed by value use the **value** attribute.\n - Arguments passed by reference (C pointers) omit the value attribute.\n - Subroutines correspond to C void functions.\n\n### **Description**\n\n **bind_c_subroutine** creates a Fortran subroutine that can be called from C code\n or that implements a C void function interface. The BIND(C) attribute ensures the\n subroutine uses C calling conventions and name mangling. The NAME= specifier\n allows controlling the exact symbol name visible to the C linker.\n\n### **Options**\n\n- **bind(c)**\n  : Required attribute that specifies C interoperability. The subroutine will\n  use C calling conventions and be callable from C code.\n\n- **name='c_name'**\n  : Optional. Specifies the exact C symbol name for the subroutine. If omitted,\n  the Fortran name is used in lowercase. Use this to match existing C APIs.\n\n- **value**\n  : Attribute for dummy arguments that should be passed by value (like C\n  scalar arguments). Without this attribute, arguments are passed by reference.\n\n- **intent(in/out/inout)**\n  : Specifies argument intent. For value arguments, only intent(in) is valid.\n  For reference arguments, any intent may be used.\n\n### **Result**\n\n  The subroutine has no return value (corresponds to void in C). All output\n  is through intent(out) or intent(inout) arguments passed by reference.\n\n### **Examples**\n\nSample program (Fortran side):\n```fortran\nmodule c_interface_module\n  use iso_c_binding\n  implicit none\ncontains\n\n  ! Subroutine callable from C as: void scale_array(double* arr, int n, double factor)\n  subroutine scale_array(arr, n, factor) bind(c, name='scale_array')\n    integer(c_int), intent(in), value :: n\n    real(c_double), intent(inout)     :: arr(n)\n    real(c_double), intent(in), value :: factor\n\n    arr = arr * factor\n  end subroutine scale_array\n\n  ! Subroutine callable from C as: void swap_values(int* a, int* b)\n  subroutine swap_values(a, b) bind(c, name='swap_values')\n    integer(c_int), intent(inout) :: a, b\n    integer(c_int) :: temp\n\n    temp = a\n    a = b\n    b = temp\n  end subroutine swap_values\n\n  ! Subroutine callable from C as: void init_array(double* arr, int n, double val)\n  subroutine init_array(arr, n, val) bind(c, name='init_array')\n    integer(c_int), intent(in), value :: n\n    real(c_double), intent(out)       :: arr(n)\n    real(c_double), intent(in), value :: val\n\n    arr = val\n  end subroutine init_array\n\nend module c_interface_module\n\nprogram demo_bind_c_subroutine\n  use c_interface_module\n  use iso_c_binding\n  implicit none\n\n  real(c_double) :: data(5)\n  integer(c_int) :: x, y\n\n  ! Initialize array\n  call init_array(data, 5_c_int, 2.0_c_double)\n  print '(A,5F8.2)', 'After init: ', data\n\n  ! Scale array\n  call scale_array(data, 5_c_int, 3.0_c_double)\n  print '(A,5F8.2)', 'After scale:', data\n\n  ! Swap values\n  x = 10\n  y = 20\n  print '(A,I0,A,I0)', 'Before swap: x=', x, ', y=', y\n  call swap_values(x, y)\n  print '(A,I0,A,I0)', 'After swap:  x=', x, ', y=', y\n\nend program demo_bind_c_subroutine\n```\n\nCorresponding C header:\n```c\n/* c_interface.h */\nvoid scale_array(double* arr, int n, double factor);\nvoid swap_values(int* a, int* b);\nvoid init_array(double* arr, int n, double val);\n```\n\nResults:\n```text\nAfter init:     2.00    2.00    2.00    2.00    2.00\nAfter scale:    6.00    6.00    6.00    6.00    6.00\nBefore swap: x=10, y=20\nAfter swap:  x=20, y=10\n```\n\n### **Standard**\n\nFortran 2003 (ISO/IEC 1539-1:2004)\n\n**Compatibility Notes:**\n- gfortran 4.3+, Intel Fortran 10.0+, NAG 5.1+\n- Subroutine corresponds to void C function\n- Use VALUE attribute for pass-by-value arguments\n\n### **See Also**\n\n[**bind_c_function**(3)](#bind_c_function),\n[**bind_c_type**(3)](#bind_c_type),\n[**c_loc**(3)](#c_loc),\n[**c_f_pointer**(3)](#c_f_pointer),\n[**iso_c_binding**(3)](#iso_c_binding)",
  "arraycon": "## arraycon\n\n### **Name**\n\n**arraycon** - \\[ARRAY:CONSTRUCTION\\] Construct a rank-one array using an implied-do loop\n\n### **Synopsis**\n```fortran\n    array = [(expr, var = start, end, step)]\n```\n```fortran\n     array_1d = [(expression(var), var = start, end [, step])]\n\n      type(TYPE(kind=**))             :: array_1d(:)\n      type(TYPE(kind=**))             :: expression\n      integer                         :: var, start, end, step\n```\n\n### **Characteristics**\n\n - **array_1d** is a rank-1 array of any intrinsic or derived type.\n - **expression** is evaluated for each iteration of the implied loop.\n - **var** is the do-variable that iterates from start to end.\n - **step** is optional and defaults to 1.\n - The resulting array length is (end - start + step) / step.\n - Array constructors create compile-time or runtime arrays.\n\n### **Description**\n\n **Array constructor implied-do** creates a rank-one array by evaluating\n an expression for each iteration of an implied loop. The do-variable\n iterates from start to end with an optional step, and the expression\n is evaluated at each iteration to produce the corresponding array element.\n This provides a concise way to initialize arrays with computed values,\n arithmetic sequences, or function results.\n\n### **Options**\n\n- **expression**\n  : Any expression involving the loop variable. Can be a formula,\n  function call, array element, or any valid Fortran expression.\n\n- **var**\n  : Loop variable (integer) that takes values from start to end.\n\n- **start**\n  : Initial value of the loop variable.\n\n- **end**\n  : Final value of the loop variable.\n\n- **step**\n  : Optional increment (default 1). Can be negative for descending sequences.\n\n### **Result**\n\n  A rank-1 array containing the evaluated expression for each value of\n  the loop variable. The array type matches the expression type.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_arraycon\n  use, intrinsic :: iso_fortran_env, only: dp => real64\n  implicit none\n\n  integer :: i\n  integer :: sequence(10)\n  real(dp) :: squares(5)\n  real(dp) :: inverse(4)\n  integer :: evens(10)\n  integer :: descending(5)\n  character(len=10) :: labels(3)\n\n  ! Simple sequence 1 to 10\n  sequence = [(i, i = 1, 10)]\n  print *, 'Sequence:', sequence\n\n  ! Squares\n  squares = [(real(i, dp)**2, i = 1, 5)]\n  print *, 'Squares:', squares\n\n  ! Inverse values\n  inverse = [(1.0_dp / real(i, dp), i = 1, 4)]\n  print *, 'Inverse:', inverse\n\n  ! Even numbers with step\n  evens = [(i, i = 2, 20, 2)]\n  print *, 'Evens:', evens\n\n  ! Descending sequence\n  descending = [(i, i = 5, 1, -1)]\n  print *, 'Descending:', descending\n\n  ! Using functions in expression\n  print *, 'Factorials:', [(factorial(i), i = 1, 6)]\n\ncontains\n\n  pure function factorial(n) result(f)\n    integer, intent(in) :: n\n    integer :: f\n    integer :: j\n    f = 1\n    do j = 2, n\n      f = f * j\n    end do\n  end function factorial\n\nend program demo_arraycon\n```\nResults:\n```text\n Sequence:           1           2           3           4           5           6           7           8           9          10\n Squares:   1.0000000000000000   4.0000000000000000   9.0000000000000000   16.000000000000000   25.000000000000000\n Inverse:   1.0000000000000000  0.50000000000000000  0.33333333333333331  0.25000000000000000\n Evens:           2           4           6           8          10          12          14          16          18          20\n Descending:           5           4           3           2           1\n Factorials:           1           2           6          24         120         720\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**arraycon2d**](#arraycon2d),\n[**reshape**](#reshape),\n[**spread**](#spread),\n[**pack**](#pack)",
  "reshapeorder": "## reshape_order\n\n### **Name**\n\n**reshape_order** - \\[ARRAY:TRANSFORMATIONAL\\] Reshape an array with specified dimension ordering\n\n### **Synopsis**\n```fortran\n    result = reshape(source, shape [,pad] [,order])\n```\n```fortran\n     function reshape(source, shape, pad, order) result(array)\n\n      type(TYPE(kind=**)), intent(in) :: source(..)\n      integer, intent(in)             :: shape(:)\n      type(TYPE(kind=**)), intent(in), optional :: pad(..)\n      integer, intent(in), optional   :: order(:)\n      type(TYPE(kind=**))             :: array(shape)\n```\n\n### **Characteristics**\n\n - **source** is an array of any type and rank.\n - **shape** is a rank-1 integer array specifying the result shape.\n - **pad** is optional; provides values if source has fewer elements.\n - **order** is optional; specifies the dimension permutation.\n\n### **Description**\n\n **reshape** constructs an array with a specified shape from the elements\n of a source array. The optional order argument controls which dimensions\n vary fastest during element assignment. Without order, elements are taken\n column-major (Fortran order); with order, the dimension permutation can\n produce row-major or other orderings.\n\n### **Options**\n\n- **source**\n  : The array providing elements for the result.\n\n- **shape**\n  : Integer array specifying dimensions of the result. The product of shape\n  elements determines the total size.\n\n- **pad**\n  : Optional. Array providing additional elements if source is too small.\n  Elements are used repeatedly if needed.\n\n- **order**\n  : Optional. Integer array specifying dimension permutation. order(i)\n  gives the dimension that varies in position i. Default is [1, 2, ..., n].\n\n### **Result**\n\n  An array with the specified shape, filled with elements from source\n  (and pad if needed) in the order determined by the order argument.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_reshape_order\nimplicit none\n  integer :: source(6) = [1, 2, 3, 4, 5, 6]\n  integer :: matrix_col(2, 3)\n  integer :: matrix_row(2, 3)\n  integer :: i\n\n  ! Default (column-major): fills columns first\n  ! Elements placed as: (1,1), (2,1), (1,2), (2,2), (1,3), (2,3)\n  matrix_col = reshape(source, [2, 3])\n\n  print '(A)', 'Column-major (default):'\n  do i = 1, 2\n    print '(3I4)', matrix_col(i, :)\n  end do\n\n  ! Row-major: fills rows first using order=[2,1]\n  ! Dimension 2 (columns) varies fastest\n  ! Elements placed as: (1,1), (1,2), (1,3), (2,1), (2,2), (2,3)\n  matrix_row = reshape(source, [2, 3], order=[2, 1])\n\n  print '(A)', 'Row-major (order=[2,1]):'\n  do i = 1, 2\n    print '(3I4)', matrix_row(i, :)\n  end do\n\n  ! 3D example\n  block\n    integer :: data(24)\n    integer :: cube_col(2, 3, 4), cube_custom(2, 3, 4)\n    integer :: j, k\n\n    data = [(i, i=1,24)]\n\n    ! Default order: varies dim 1 fastest, then 2, then 3\n    cube_col = reshape(data, [2, 3, 4])\n\n    ! Custom order: varies dim 3 fastest, then 2, then 1\n    cube_custom = reshape(data, [2, 3, 4], order=[3, 2, 1])\n\n    print '(A)', ''\n    print '(A)', '3D default order - slice cube(:,:,1):'\n    do i = 1, 2\n      print '(3I4)', cube_col(i, :, 1)\n    end do\n\n    print '(A)', '3D custom order [3,2,1] - slice cube(:,:,1):'\n    do i = 1, 2\n      print '(3I4)', cube_custom(i, :, 1)\n    end do\n  end block\n\n  ! Using pad for insufficient source\n  block\n    integer :: small(4) = [1, 2, 3, 4]\n    integer :: padded(3, 3)\n\n    padded = reshape(small, [3, 3], pad=[0])\n    print '(A)', ''\n    print '(A)', 'Padded array (source too small):'\n    do i = 1, 3\n      print '(3I4)', padded(i, :)\n    end do\n  end block\n\nend program demo_reshape_order\n```\nResults:\n```text\nColumn-major (default):\n   1   3   5\n   2   4   6\nRow-major (order=[2,1]):\n   1   2   3\n   4   5   6\n\n3D default order - slice cube(:,:,1):\n   1   3   5\n   2   4   6\n3D custom order [3,2,1] - slice cube(:,:,1):\n   1   7  13\n   2   8  14\n\nPadded array (source too small):\n   1   4   0\n   2   0   0\n   3   0   0\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**shape**(3)](#shape),\n[**transpose**(3)](#transpose),\n[**spread**(3)](#spread),\n[**pack**(3)](#pack)",
  "acimplied": "## implied_do_array_constructor\n\n### **Name**\n\n**implied_do_array_constructor** - \\[CONTROL:LOOP\\] Construct a rank-one array using an implied-do loop\n\n### **Synopsis**\n```fortran\n    array = [(expr, var = start, end [, step])]\n```\n```fortran\n     ! Implied-do loop in array constructor\n\n      type :: array(size)\n      array = [(expression, index = start, end, step)]\n```\n\n### **Characteristics**\n\n - Creates a rank-one (1D) array from an expression evaluated over an index range.\n - **expr** is any expression, typically involving the loop variable **var**.\n - **var** is an integer loop control variable.\n - **start**, **end**, and optional **step** define the iteration range.\n - The array size is determined by the number of iterations.\n\n### **Description**\n\n **implied_do_array_constructor** creates an array by evaluating an expression\n for each value of the loop index. The expression can involve the index variable,\n constants, or previously defined values. Implied-do loops can be nested for\n more complex array construction patterns.\n\n### **Options**\n\n- **expr**\n  : The expression evaluated for each iteration. Can be a scalar value,\n  a function call, or any expression involving the loop variable.\n\n- **var**\n  : The loop control variable (integer). Its scope is limited to the\n  implied-do construct.\n\n- **start**\n  : The initial value of the loop variable.\n\n- **end**\n  : The terminal value of the loop variable.\n\n- **step**\n  : Optional increment (default is 1). Can be negative for counting down.\n\n### **Result**\n\n  A rank-one array containing the values of **expr** for each value of\n  **var** from **start** to **end** with increment **step**.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_implied_do\nimplicit none\n  integer :: i, j\n  integer :: squares(10)\n  real    :: angles(5)\n  real, parameter :: pi = 3.14159265\n\n  ! Simple sequence: 1, 2, 3, ..., 10\n  print '(A,10I4)', 'Sequence: ', [(i, i=1,10)]\n\n  ! Squares: 1, 4, 9, 16, ...\n  squares = [(i**2, i=1,10)]\n  print '(A,10I4)', 'Squares:  ', squares\n\n  ! Even numbers: 2, 4, 6, 8, 10\n  print '(A,5I4)', 'Evens:    ', [(i, i=2,10,2)]\n\n  ! Countdown: 5, 4, 3, 2, 1\n  print '(A,5I4)', 'Countdown:', [(i, i=5,1,-1)]\n\n  ! Angles in radians: 0, pi/4, pi/2, 3pi/4, pi\n  angles = [(i*pi/4.0, i=0,4)]\n  print '(A,5F8.4)', 'Angles:   ', angles\n\n  ! Nested implied-do: creates 3x3 = 9 elements\n  print '(A,9I4)', 'Nested:   ', [((i*10+j, j=1,3), i=1,3)]\n\n  ! Initialize with repeated value\n  print '(A,5I4)', 'Fives:    ', [(5, i=1,5)]\n\nend program demo_implied_do\n```\nResults:\n```text\nSequence:    1   2   3   4   5   6   7   8   9  10\nSquares:     1   4   9  16  25  36  49  64  81 100\nEvens:       2   4   6   8  10\nCountdown:   5   4   3   2   1\nAngles:     0.0000  0.7854  1.5708  2.3562  3.1416\nNested:     11  12  13  21  22  23  31  32  33\nFives:       5   5   5   5   5\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**reshape**(3)](#reshape),\n[**spread**(3)](#spread),\n[**pack**(3)](#pack)",
  "present": "## present\n\n### **Name**\n\n**present** - \\[PROCEDURE:ARGUMENT\\] Determine whether an optional dummy argument is present\n\n### **Synopsis**\n```fortran\n    result = present(a)\n```\n```fortran\n     function present(a) result(res)\n\n      type(*), intent(in), optional :: a\n      logical                       :: res\n```\n\n### **Characteristics**\n\n - **a** must be an optional dummy argument in the current procedure.\n - Returns .TRUE. if the argument was provided by the caller.\n - Returns .FALSE. if the argument was omitted.\n - Must be called before referencing the optional argument.\n - This is an inquiry function.\n\n### **Description**\n\n **present** determines whether an optional dummy argument was provided by\n the caller. This intrinsic must be used to check the presence of optional\n arguments before they can be safely referenced, as using an absent optional\n argument is not allowed and results in undefined behavior.\n\n An important feature is that an absent optional argument can be passed to\n another procedure that also declares it as optional, without first checking\n with PRESENT. The \"absent-ness\" is propagated to the called procedure.\n\n### **Options**\n\n- **a**\n  : An optional dummy argument of the current procedure. May be of any type,\n  any rank, and may have any other attributes such as POINTER, ALLOCATABLE,\n  or TARGET. The argument **a** must be declared with the OPTIONAL attribute\n  in the procedure where PRESENT is called.\n\n### **Result**\n\n  A default logical value: .TRUE. if the actual argument corresponding to\n  **a** was provided in the procedure call, .FALSE. if the argument was\n  omitted. The result is always a scalar, even if **a** is an array.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_present\n  implicit none\n\n  ! Call with different argument combinations\n  call example_sub(10)\n  print '(A)', '---'\n  call example_sub(10, 20)\n  print '(A)', '---'\n  call example_sub(10, c=30)\n  print '(A)', '---'\n  call example_sub(10, 20, 30)\n\ncontains\n\n  subroutine example_sub(a, b, c)\n    integer, intent(in) :: a\n    integer, intent(in), optional :: b, c\n\n    print '(A,I0)', 'a = ', a\n    print '(A,L1)', 'b is present: ', present(b)\n    print '(A,L1)', 'c is present: ', present(c)\n\n    ! Safe to use b only if present\n    if (present(b)) then\n      print '(A,I0)', 'b = ', b\n    else\n      print '(A)', 'b was not provided'\n    end if\n\n    ! Safe to use c only if present\n    if (present(c)) then\n      print '(A,I0)', 'c = ', c\n    else\n      print '(A)', 'c was not provided'\n    end if\n\n    ! Compute sum based on what is present\n    if (present(b) .and. present(c)) then\n      print '(A,I0)', 'a + b + c = ', a + b + c\n    else if (present(b)) then\n      print '(A,I0)', 'a + b = ', a + b\n    else if (present(c)) then\n      print '(A,I0)', 'a + c = ', a + c\n    else\n      print '(A,I0)', 'Just a = ', a\n    end if\n\n  end subroutine example_sub\n\nend program demo_present\n```\nResults:\n```text\na = 10\nb is present: F\nc is present: F\nb was not provided\nc was not provided\nJust a = 10\n---\na = 10\nb is present: T\nc is present: F\nb = 20\nc was not provided\na + b = 30\n---\na = 10\nb is present: F\nc is present: T\nb was not provided\nc = 30\na + c = 40\n---\na = 10\nb is present: T\nc is present: T\nb = 20\nc = 30\na + b + c = 60\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**optional**(7)](#optional),\n[**intent**(7)](#intent)",
  "selectrank": "## select_rank\n\n### **Name**\n\n**select_rank** - \\[CONTROL:CONDITIONAL\\] Select code block based on the rank of an assumed-rank array\n\n### **Synopsis**\n```fortran\n    select rank (array-name)\n      rank (0)\n        ! scalar case\n      rank (n)\n        ! rank-n array handling\n      rank default\n        ! handle other ranks\n    end select\n```\n```fortran\n     select rank (selector)\n\n      type(*), dimension(..) :: selector  ! assumed-rank array\n      ! Inside rank(n) block, selector has rank n\n      ! Inside rank(*), selector is assumed-size\n      ! Inside rank default, selector is assumed-rank\n```\n\n### **Characteristics**\n\n - **selector** is an assumed-rank variable (declared with `dimension(..)`).\n - Each **rank (n)** block receives the variable with the specified rank.\n - **rank (*)** handles assumed-size arrays passed from older code.\n - **rank default** catches all unspecified ranks; selector remains assumed-rank.\n - Only one rank block executes based on the actual rank at runtime.\n\n### **Description**\n\n **select_rank** provides a mechanism to handle assumed-rank dummy arguments\n by selecting code blocks based on the actual rank of the array at runtime.\n This construct is essential for writing generic procedures that accept\n arrays of any rank while providing type-safe, rank-specific implementations.\n Within each rank block, the assumed-rank variable becomes a regular array\n with the specified rank, enabling standard array operations.\n\n### **Options**\n\n- **selector**\n  : The assumed-rank dummy argument to inspect. Must be declared with\n  `dimension(..)`. Can optionally include an associate-name using\n  `select rank (name => selector)` syntax.\n\n- **rank (n)**\n  : Executes when selector has rank n (0 for scalar, 1-15 for arrays).\n  Inside this block, the selector has the specified fixed rank.\n\n- **rank (*)**\n  : Executes when an assumed-size array is passed. The selector becomes\n  assumed-size `dimension(*)` inside this block.\n\n- **rank default**\n  : Executes when no other rank case matches. The selector remains\n  assumed-rank inside this block (limited operations available).\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_select_rank\nimplicit none\n  real :: scalar_val = 3.14\n  real :: array_1d(5) = [1.0, 2.0, 3.0, 4.0, 5.0]\n  real :: array_2d(2,3) = reshape([1.0,2.0,3.0,4.0,5.0,6.0], [2,3])\n  real :: array_3d(2,2,2) = 1.0\n\n  print '(a)', 'Testing scalar:'\n  call print_rank(scalar_val)\n\n  print '(a)', 'Testing rank-1 array:'\n  call print_rank(array_1d)\n\n  print '(a)', 'Testing rank-2 array:'\n  call print_rank(array_2d)\n\n  print '(a)', 'Testing rank-3 array:'\n  call print_rank(array_3d)\n\ncontains\n\n  subroutine print_rank(arr)\n    real, dimension(..), intent(in) :: arr\n\n    select rank (arr)\n      rank (0)\n        print '(a,f6.2)', '  Scalar value: ', arr\n      rank (1)\n        print '(a,i0)', '  Rank-1 array, size: ', size(arr)\n        print '(a,*(f6.2,1x))', '  Elements: ', arr\n      rank (2)\n        print '(a,i0,a,i0)', '  Rank-2 array, shape: ', &\n              size(arr,1), ' x ', size(arr,2)\n        print '(a,f6.2)', '  First element: ', arr(1,1)\n      rank default\n        print '(a,i0)', '  Higher rank array, rank: ', rank(arr)\n    end select\n  end subroutine print_rank\n\nend program demo_select_rank\n```\nResults:\n```text\nTesting scalar:\n  Scalar value:   3.14\nTesting rank-1 array:\n  Rank-1 array, size: 5\n  Elements:   1.00   2.00   3.00   4.00   5.00\nTesting rank-2 array:\n  Rank-2 array, shape: 2 x 3\n  First element:   1.00\nTesting rank-3 array:\n  Higher rank array, rank: 3\n```\n\n### **Standard**\n\nFortran 2018\n\n**Compatibility Notes:**\n- gfortran 8.0+, Intel Fortran 16.0+, NAG 6.2+\n- Works with assumed-rank dummy arguments\n- Allows rank-specific processing in generic procedures\n\n### **See Also**\n\n[**select_type**(3)](#select_type),\n[**select_case**(3)](#select_case),\n[**rank**(3)](#rank),\n[**assumed_rank**(3)](#assumed_rank)",
  "move_alloc": "## move_alloc\n\n### **Name**\n\n**move_alloc** - \\[ARRAY:ALLOCATION\\] Move an allocation from one object to another\n\n### **Synopsis**\n```fortran\n    call move_alloc(from, to)\n```\n```fortran\n     subroutine move_alloc(from, to)\n\n      type(TYPE(kind=**)), allocatable, intent(inout) :: from(..)\n      type(TYPE(kind=**)), allocatable, intent(out)   :: to(..)\n```\n\n### **Characteristics**\n\n - **from** is an allocatable variable of any type and rank.\n - **to** is an allocatable variable with the same type and rank as from.\n - After the call, from becomes deallocated.\n - After the call, to has the allocation that was in from.\n - This is an intrinsic subroutine, not a function.\n - No data copying occurs; only the allocation is transferred.\n - If to was already allocated, it is deallocated before the move.\n\n### **Description**\n\n **move_alloc** transfers an allocation from one allocatable object to\n another without copying the data. After the call, the from variable\n becomes deallocated and the to variable holds what was previously in\n from. This is useful for efficiently resizing arrays or transferring\n ownership of allocated memory. The operation is much faster than\n allocating, copying, and deallocating separately.\n\n### **Options**\n\n- **from**\n  : The source allocatable variable. After the call, it will be deallocated.\n  Must be allocatable but can be currently unallocated.\n\n- **to**\n  : The destination allocatable variable. After the call, it will hold the\n  allocation from from. If it was already allocated, that allocation is\n  first deallocated.\n\n### **Result**\n\n  After execution:\n  - from is deallocated (allocated(from) returns .false.)\n  - to has the allocation and data that was in from\n  - No data copying occurs; the operation is O(1)\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_move_alloc\n  use, intrinsic :: iso_fortran_env, only: dp => real64\n  implicit none\n\n  real(dp), allocatable :: small(:), large(:), temp(:)\n  integer :: i\n\n  ! Allocate and initialize small array\n  allocate(small(5))\n  small = [(real(i, dp), i=1, 5)]\n  print *, 'Initial small:', small\n\n  ! Resize by moving to temp, reallocating, and moving back\n  call move_alloc(from=small, to=temp)\n  print *, 'After move: small allocated?', allocated(small)\n  print *, 'After move: temp allocated?', allocated(temp)\n  print *, 'Temp values:', temp\n\n  ! Allocate larger array and copy data\n  allocate(small(10))\n  small(1:5) = temp\n  small(6:10) = 0.0_dp\n  deallocate(temp)\n  print *, 'Resized small:', small\n\n  ! Demonstrate transfer of ownership\n  allocate(large(1000))\n  large = 42.0_dp\n  print *, 'large sum before move:', sum(large)\n\n  ! Transfer ownership - no copying!\n  allocate(temp(0))  ! Allocate empty first\n  deallocate(temp)\n  call move_alloc(large, temp)\n  print *, 'large allocated after move?', allocated(large)\n  print *, 'temp sum after move:', sum(temp)\n\n  deallocate(small, temp)\n\nend program demo_move_alloc\n```\nResults:\n```text\n Initial small:   1.0000000000000000   2.0000000000000000   3.0000000000000000   4.0000000000000000   5.0000000000000000\n After move: small allocated? F\n After move: temp allocated? T\n Temp values:   1.0000000000000000   2.0000000000000000   3.0000000000000000   4.0000000000000000   5.0000000000000000\n Resized small:   1.0000000000000000   2.0000000000000000   3.0000000000000000   4.0000000000000000   5.0000000000000000   0.0000000000000000   0.0000000000000000   0.0000000000000000   0.0000000000000000   0.0000000000000000\n large sum before move:   42000.000000000000\n large allocated after move? F\n temp sum after move:   42000.000000000000\n```\n\n### **Standard**\n\nFortran 2003\n\n**Compatibility Notes:**\n- gfortran 4.5+, Intel Fortran 11.0+, NAG 5.3+\n- For Fortran 95 compatibility, use manual allocation/deallocation\n- Thread-safe; both FROM and TO must have the same declared type\n\n### **See Also**\n\n[**allocate**](#allocate),\n[**deallocate**](#deallocate),\n[**allocated**](#allocated),\n[**allocate_source**](#allocate_source)",
  "inquireexists": "## inquire_exists\n\n### **Name**\n\n**inquire_exists** - \\[IO:FILE\\] Check whether a file exists in the filesystem\n\n### **Synopsis**\n```fortran\n    inquire(file=filename, exist=exists)\n```\n```fortran\n     ! File existence check\n\n      character(len=*) :: filename\n      logical          :: exists\n\n      inquire(file=filename, exist=exists)\n```\n\n### **Characteristics**\n\n - Uses the INQUIRE statement with EXIST specifier.\n - **exists** is a logical variable set to .true. or .false.\n - The file need not be open to check existence.\n - Works with any valid filename string.\n\n### **Description**\n\n **inquire_exists** uses the INQUIRE statement to check whether a file\n exists in the filesystem. This is useful for validating input files\n before opening them, checking for output file conflicts, or conditional\n file processing.\n\n### **Options**\n\n- **file=filename**\n  : A character expression specifying the file path to check. Can be a\n  relative or absolute path.\n\n- **exist=exists**\n  : A logical variable that receives .true. if the file exists, .false.\n  otherwise.\n\n### **Result**\n\n  The logical variable is set to .true. if the file exists, .false. otherwise.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_inquire_exists\nimplicit none\n  character(len=256) :: filename\n  logical :: exists\n\n  ! Check for a specific file\n  filename = 'input.dat'\n  inquire(file=filename, exist=exists)\n\n  if (exists) then\n    print '(A,A,A)', 'File \"', trim(filename), '\" exists.'\n  else\n    print '(A,A,A)', 'File \"', trim(filename), '\" does not exist.'\n  end if\n\n  ! Check before opening\n  filename = 'config.txt'\n  inquire(file=filename, exist=exists)\n\n  if (exists) then\n    open(unit=10, file=filename, status='old', action='read')\n    print '(A)', 'Configuration file opened successfully.'\n    close(10)\n  else\n    print '(A)', 'Warning: Configuration file not found, using defaults.'\n  end if\n\n  ! Prevent overwriting existing file\n  filename = 'output.dat'\n  inquire(file=filename, exist=exists)\n\n  if (exists) then\n    print '(A)', 'Output file already exists. Overwrite? (y/n)'\n    ! In real code, read user response here\n  else\n    open(unit=20, file=filename, status='new', action='write')\n    write(20, '(A)') 'Data output'\n    close(20)\n    print '(A)', 'Output file created.'\n  end if\n\nend program demo_inquire_exists\n```\nResults:\n```text\nFile \"input.dat\" does not exist.\nWarning: Configuration file not found, using defaults.\nOutput file created.\n```\n\n### **Standard**\n\nFortran 77\n\n### **See Also**\n\n[**inquire**(3)](#inquire),\n[**open**(3)](#open),\n[**close**(3)](#close)",
  "assumedrank": "## assumed_rank\n\n### **Name**\n\n**assumed_rank** - \\[ARRAY:INQUIRY\\] Declare an assumed-rank dummy argument\n\n### **Synopsis**\n```fortran\n    type, intent(in) :: array(..)\n```\n```fortran\n     subroutine proc(array)\n\n      type(TYPE(kind=**)), intent(in|out|inout) :: array(..)\n```\n\n### **Characteristics**\n\n - **array** is a dummy argument with assumed rank, indicated by `(..)`.\n - The actual argument can be of any rank from 0 (scalar) to 15.\n - The procedure must have an explicit interface.\n - Assumed-rank arguments can only be used in specific contexts.\n - The RANK intrinsic returns the actual rank at runtime.\n - SELECT RANK construct provides rank-specific handling.\n\n### **Description**\n\n **Assumed-rank** dummy arguments accept actual arguments of any rank,\n including scalars. The rank is determined at runtime from the actual\n argument. This feature enables writing generic procedures that work\n with arrays of any dimensionality, commonly used for interfaces to\n C libraries and generic debugging/utility routines. Use the SELECT RANK\n construct to handle different ranks with specific code paths.\n\n### **Options**\n\n- **type**\n  : Any intrinsic or derived type. The type must match the actual argument.\n\n- **kind**\n  : Optional kind parameter. Must match the actual argument.\n\n- **intent**\n  : Data flow direction: in (read-only), out (write-only), or inout (read-write).\n\n- **array**\n  : The dummy argument name. The `(..)` syntax indicates assumed rank.\n\n### **Result**\n\n  The dummy argument takes on the rank of the actual argument at runtime.\n  Within the procedure, only specific operations are allowed on assumed-rank\n  objects until their rank is resolved via SELECT RANK.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_assumed_rank\n  use, intrinsic :: iso_fortran_env, only: dp => real64\n  implicit none\n\n  real(dp) :: scalar\n  real(dp) :: vector(5)\n  real(dp) :: matrix(3, 4)\n  real(dp) :: cube(2, 3, 4)\n\n  scalar = 42.0_dp\n  vector = [1.0_dp, 2.0_dp, 3.0_dp, 4.0_dp, 5.0_dp]\n  matrix = 1.0_dp\n  cube = 2.0_dp\n\n  ! Same subroutine handles all ranks\n  call describe_array(scalar)\n  call describe_array(vector)\n  call describe_array(matrix)\n  call describe_array(cube)\n\ncontains\n\n  subroutine describe_array(arr)\n    real(dp), intent(in) :: arr(..)  ! Assumed-rank\n\n    print *, 'Rank:', rank(arr)\n\n    select rank(arr)\n      rank(0)\n        print *, '  Scalar value:', arr\n      rank(1)\n        print *, '  Vector size:', size(arr)\n        print *, '  First element:', arr(1)\n      rank(2)\n        print *, '  Matrix shape:', shape(arr)\n      rank default\n        print *, '  Higher rank array, size:', size(arr)\n    end select\n  end subroutine describe_array\n\nend program demo_assumed_rank\n```\nResults:\n```text\n Rank:           0\n   Scalar value:   42.000000000000000\n Rank:           1\n   Vector size:           5\n   First element:   1.0000000000000000\n Rank:           2\n   Matrix shape:           3           4\n Rank:           3\n   Higher rank array, size:          24\n```\n\n### **Standard**\n\nFortran 2018 (Technical Specification ISO/IEC TS 29113:2012)\n\n**Compatibility Notes:**\n- gfortran 8.0+, Intel Fortran 16.0+, NAG 6.2+\n- Declared with (..) dimension specifier\n- Use SELECT RANK for rank-specific code\n\n### **See Also**\n\n[**rank**](#rank),\n[**select_rank**](#select_rank),\n[**size**](#size),\n[**shape**](#shape)",
  "fileexists": "## inquire_exists\n\n### **Name**\n\n**inquire_exists** - \\[IO:FILE\\] Check whether a file exists in the filesystem\n\n### **Synopsis**\n```fortran\n    inquire(file=filename, exist=exists)\n```\n```fortran\n     ! File existence check\n\n      character(len=*) :: filename\n      logical          :: exists\n\n      inquire(file=filename, exist=exists)\n```\n\n### **Characteristics**\n\n - Uses the INQUIRE statement with EXIST specifier.\n - **exists** is a logical variable set to .true. or .false.\n - The file need not be open to check existence.\n - Works with any valid filename string.\n\n### **Description**\n\n **inquire_exists** uses the INQUIRE statement to check whether a file\n exists in the filesystem. This is useful for validating input files\n before opening them, checking for output file conflicts, or conditional\n file processing.\n\n### **Options**\n\n- **file=filename**\n  : A character expression specifying the file path to check. Can be a\n  relative or absolute path.\n\n- **exist=exists**\n  : A logical variable that receives .true. if the file exists, .false.\n  otherwise.\n\n### **Result**\n\n  The logical variable is set to .true. if the file exists, .false. otherwise.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_inquire_exists\nimplicit none\n  character(len=256) :: filename\n  logical :: exists\n\n  ! Check for a specific file\n  filename = 'input.dat'\n  inquire(file=filename, exist=exists)\n\n  if (exists) then\n    print '(A,A,A)', 'File \"', trim(filename), '\" exists.'\n  else\n    print '(A,A,A)', 'File \"', trim(filename), '\" does not exist.'\n  end if\n\n  ! Check before opening\n  filename = 'config.txt'\n  inquire(file=filename, exist=exists)\n\n  if (exists) then\n    open(unit=10, file=filename, status='old', action='read')\n    print '(A)', 'Configuration file opened successfully.'\n    close(10)\n  else\n    print '(A)', 'Warning: Configuration file not found, using defaults.'\n  end if\n\n  ! Prevent overwriting existing file\n  filename = 'output.dat'\n  inquire(file=filename, exist=exists)\n\n  if (exists) then\n    print '(A)', 'Output file already exists. Overwrite? (y/n)'\n    ! In real code, read user response here\n  else\n    open(unit=20, file=filename, status='new', action='write')\n    write(20, '(A)') 'Data output'\n    close(20)\n    print '(A)', 'Output file created.'\n  end if\n\nend program demo_inquire_exists\n```\nResults:\n```text\nFile \"input.dat\" does not exist.\nWarning: Configuration file not found, using defaults.\nOutput file created.\n```\n\n### **Standard**\n\nFortran 77\n\n### **See Also**\n\n[**inquire**(3)](#inquire),\n[**open**(3)](#open),\n[**close**(3)](#close)",
  "assumed_rank": "## assumed_rank\n\n### **Name**\n\n**assumed_rank** - \\[ARRAY:INQUIRY\\] Declare an assumed-rank dummy argument\n\n### **Synopsis**\n```fortran\n    type, intent(in) :: array(..)\n```\n```fortran\n     subroutine proc(array)\n\n      type(TYPE(kind=**)), intent(in|out|inout) :: array(..)\n```\n\n### **Characteristics**\n\n - **array** is a dummy argument with assumed rank, indicated by `(..)`.\n - The actual argument can be of any rank from 0 (scalar) to 15.\n - The procedure must have an explicit interface.\n - Assumed-rank arguments can only be used in specific contexts.\n - The RANK intrinsic returns the actual rank at runtime.\n - SELECT RANK construct provides rank-specific handling.\n\n### **Description**\n\n **Assumed-rank** dummy arguments accept actual arguments of any rank,\n including scalars. The rank is determined at runtime from the actual\n argument. This feature enables writing generic procedures that work\n with arrays of any dimensionality, commonly used for interfaces to\n C libraries and generic debugging/utility routines. Use the SELECT RANK\n construct to handle different ranks with specific code paths.\n\n### **Options**\n\n- **type**\n  : Any intrinsic or derived type. The type must match the actual argument.\n\n- **kind**\n  : Optional kind parameter. Must match the actual argument.\n\n- **intent**\n  : Data flow direction: in (read-only), out (write-only), or inout (read-write).\n\n- **array**\n  : The dummy argument name. The `(..)` syntax indicates assumed rank.\n\n### **Result**\n\n  The dummy argument takes on the rank of the actual argument at runtime.\n  Within the procedure, only specific operations are allowed on assumed-rank\n  objects until their rank is resolved via SELECT RANK.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_assumed_rank\n  use, intrinsic :: iso_fortran_env, only: dp => real64\n  implicit none\n\n  real(dp) :: scalar\n  real(dp) :: vector(5)\n  real(dp) :: matrix(3, 4)\n  real(dp) :: cube(2, 3, 4)\n\n  scalar = 42.0_dp\n  vector = [1.0_dp, 2.0_dp, 3.0_dp, 4.0_dp, 5.0_dp]\n  matrix = 1.0_dp\n  cube = 2.0_dp\n\n  ! Same subroutine handles all ranks\n  call describe_array(scalar)\n  call describe_array(vector)\n  call describe_array(matrix)\n  call describe_array(cube)\n\ncontains\n\n  subroutine describe_array(arr)\n    real(dp), intent(in) :: arr(..)  ! Assumed-rank\n\n    print *, 'Rank:', rank(arr)\n\n    select rank(arr)\n      rank(0)\n        print *, '  Scalar value:', arr\n      rank(1)\n        print *, '  Vector size:', size(arr)\n        print *, '  First element:', arr(1)\n      rank(2)\n        print *, '  Matrix shape:', shape(arr)\n      rank default\n        print *, '  Higher rank array, size:', size(arr)\n    end select\n  end subroutine describe_array\n\nend program demo_assumed_rank\n```\nResults:\n```text\n Rank:           0\n   Scalar value:   42.000000000000000\n Rank:           1\n   Vector size:           5\n   First element:   1.0000000000000000\n Rank:           2\n   Matrix shape:           3           4\n Rank:           3\n   Higher rank array, size:          24\n```\n\n### **Standard**\n\nFortran 2018 (Technical Specification ISO/IEC TS 29113:2012)\n\n**Compatibility Notes:**\n- gfortran 8.0+, Intel Fortran 16.0+, NAG 6.2+\n- Declared with (..) dimension specifier\n- Use SELECT RANK for rank-specific code\n\n### **See Also**\n\n[**rank**](#rank),\n[**select_rank**](#select_rank),\n[**size**](#size),\n[**shape**](#shape)",
  "binaryopen": "## stream_open\n\n### **Name**\n\n**open** - \\[IO:STREAM\\] Open a file for stream (binary) I/O access\n\n### **Synopsis**\n```fortran\n    open(newunit=unit, file='filename', access='stream', form='unformatted', iostat=ierr)\n```\n```fortran\n     open(newunit=unit, file=filename, access='stream', &\n          form='unformatted', status=file_status, &\n          action=io_action, iostat=ierr, iomsg=errmsg)\n\n      integer, intent(out)           :: unit       ! Assigned unit number\n      character(len=*), intent(in)   :: filename   ! File path\n      character(len=*), intent(in)   :: file_status  ! 'old', 'new', 'replace', etc.\n      character(len=*), intent(in)   :: io_action    ! 'read', 'write', 'readwrite'\n      integer, intent(out)           :: ierr         ! I/O status\n      character(len=*), intent(inout) :: errmsg      ! Error message\n```\n\n### **Characteristics**\n\n - **newunit** receives an automatically assigned unit number.\n - **file** is a character expression specifying the file path.\n - **access='stream'** enables byte-addressable I/O without record structure.\n - **form='unformatted'** specifies binary (non-text) data transfer.\n - The unit can be used for random access via the POS= specifier.\n\n### **Description**\n\n **open** with ACCESS='STREAM' prepares a file for stream I/O, which provides direct byte-addressable access without the record structure of traditional Fortran sequential or direct-access files. Stream I/O is ideal for:\n - Reading/writing binary files compatible with C or other languages\n - Processing files without Fortran record markers\n - Random access to specific byte positions\n - Efficient large-scale binary data I/O\n\n### **Options**\n\n- **newunit=**\n  : Integer variable that receives an automatically assigned unit number.\n  Preferred over hardcoded unit numbers to avoid conflicts.\n\n- **file=**\n  : Character expression specifying the file path (absolute or relative).\n\n- **access=**\n  : Must be 'STREAM' for stream I/O. Enables byte-addressable access.\n\n- **form=**\n  : 'UNFORMATTED' for binary data, 'FORMATTED' for text stream access.\n\n- **status=**\n  : File existence handling:\n  - 'OLD': File must exist\n  - 'NEW': File must not exist, will be created\n  - 'REPLACE': Overwrite if exists, create if not\n  - 'UNKNOWN': Processor-dependent (typically like 'REPLACE')\n\n- **action=**\n  : Access mode: 'READ', 'WRITE', or 'READWRITE'.\n\n- **iostat=**\n  : Integer variable set to 0 on success, positive on error.\n\n- **iomsg=**\n  : Character variable receiving error description on failure.\n\n### **Result**\n\n  On success, the file is connected to the assigned unit number and ready for stream I/O operations. The iostat variable is set to zero.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_stream_open\nimplicit none\n  integer :: unit_wr, unit_rd, ierr\n  real(8) :: data_out(100), data_in(100)\n  integer :: i\n  character(len=256) :: errmsg\n\n  ! Initialize test data\n  data_out = [(real(i, 8), i = 1, 100)]\n\n  ! Open file for writing\n  open(newunit=unit_wr, file='stream_demo.bin', access='stream', &\n       form='unformatted', status='replace', action='write', &\n       iostat=ierr, iomsg=errmsg)\n  if (ierr /= 0) then\n    print *, 'Write open error: ', trim(errmsg)\n    error stop\n  end if\n\n  write(unit_wr) data_out\n  close(unit_wr)\n  print *, 'Data written successfully'\n\n  ! Open file for reading\n  open(newunit=unit_rd, file='stream_demo.bin', access='stream', &\n       form='unformatted', status='old', action='read', &\n       iostat=ierr, iomsg=errmsg)\n  if (ierr /= 0) then\n    print *, 'Read open error: ', trim(errmsg)\n    error stop\n  end if\n\n  read(unit_rd) data_in\n  close(unit_rd, status='delete')\n\n  ! Verify\n  if (all(abs(data_in - data_out) < 1.0d-10)) then\n    print *, 'SUCCESS: Data integrity verified'\n    print '(A,5F8.1)', ' First 5 values:', data_in(1:5)\n    print '(A,5F8.1)', ' Last 5 values: ', data_in(96:100)\n  else\n    print *, 'ERROR: Data mismatch'\n  end if\n\nend program demo_stream_open\n```\nResults:\n```text\n Data written successfully\n SUCCESS: Data integrity verified\n First 5 values:     1.0     2.0     3.0     4.0     5.0\n Last 5 values:     96.0    97.0    98.0    99.0   100.0\n```\n\n### **Standard**\n\nFortran 2003\n\n**Compatibility Notes:**\n- gfortran 4.0+, Intel Fortran 9.1+, NAG 5.0+\n- Use FORM='UNFORMATTED', ACCESS='STREAM' for binary\n- Portable across platforms with stream access\n\n### **See Also**\n\n[**close**(3)](#close),\n[**read_stream**(3)](#read_stream),\n[**write_stream**(3)](#write_stream),\n[**inquire**(3)](#inquire)",
  "mpiallreduce": "## MPI_Allreduce\n\n### **Name**\n\n**MPI_Allreduce** - \\[PARALLEL:MPI\\] Combines values from all processes and distributes the result back to all processes\n\n### **Synopsis**\n\n```fortran\n    call MPI_Allreduce(sendbuf, recvbuf, count, datatype, op, comm, ierr)\n```\n\n```fortran\n    USE mpi_f08\n    MPI_Allreduce(sendbuf, recvbuf, count, datatype, op, comm, ierror)\n\n        TYPE(*), DIMENSION(..), INTENT(IN)  :: sendbuf\n        TYPE(*), DIMENSION(..)              :: recvbuf\n        INTEGER, INTENT(IN)                 :: count\n        TYPE(MPI_Datatype), INTENT(IN)      :: datatype\n        TYPE(MPI_Op), INTENT(IN)            :: op\n        TYPE(MPI_Comm), INTENT(IN)          :: comm\n        INTEGER, OPTIONAL, INTENT(OUT)      :: ierror\n```\n\n### **Characteristics**\n\n- **sendbuf** is a buffer of any type with `count` elements to be reduced\n- **recvbuf** is a buffer of the same type as `sendbuf` to receive the result\n- **count** is a non-negative integer specifying the number of elements\n- **datatype** must match the type of data in `sendbuf` and `recvbuf`\n- **op** must be a valid reduction operation compatible with `datatype`\n- **comm** is a valid MPI communicator (intracommunicator or intercommunicator)\n- **ierr** returns the error status (0 for success)\n- All processes in the communicator must call this routine\n- The result is distributed to all processes (unlike MPI_Reduce)\n\n### **Description**\n\n**MPI_Allreduce** performs a global reduction operation (sum, max, min, etc.) on data from all processes in a communicator and distributes the result to all processes. This is equivalent to an MPI_Reduce followed by an MPI_Bcast, but is typically more efficient. All processes contribute data and all processes receive the final result.\n\n### **Options**\n\n- **sendbuf**\n  : Starting address of the send buffer containing `count` elements of type `datatype`. Use MPI_IN_PLACE for in-place operations on intracommunicators.\n\n- **recvbuf**\n  : Starting address of the receive buffer where the reduction result will be stored. Must be distinct from `sendbuf` unless using MPI_IN_PLACE.\n\n- **count**\n  : Number of elements in `sendbuf` and `recvbuf`. Must be non-negative and identical on all processes.\n\n- **datatype**\n  : MPI datatype of elements. Common Fortran types:\n  - MPI_INTEGER, MPI_REAL, MPI_DOUBLE_PRECISION\n  - MPI_COMPLEX, MPI_DOUBLE_COMPLEX\n  - MPI_LOGICAL, MPI_CHARACTER\n\n- **op**\n  : Reduction operation to perform. Predefined operations:\n  - Arithmetic: MPI_SUM, MPI_PROD\n  - Comparison: MPI_MAX, MPI_MIN\n  - Logical: MPI_LAND, MPI_LOR, MPI_LXOR\n  - Bitwise: MPI_BAND, MPI_BOR, MPI_BXOR\n  - Location: MPI_MAXLOC, MPI_MINLOC\n\n- **comm**\n  : MPI communicator defining the group of processes participating. Typically MPI_COMM_WORLD for all processes.\n\n- **ierr**\n  : Integer error code. Returns MPI_SUCCESS (0) on successful completion.\n\n\n\n### **Result**\n\n  On all processes, **recvbuf** contains the combined result of applying\n  the reduction operation to the corresponding elements from all processes.\n  Unlike MPI_Reduce, every process receives the same result. The operation\n  is applied element-wise for arrays (when count > 1). This is equivalent\n  to an MPI_Reduce followed by an MPI_Bcast but may be implemented more\n  efficiently.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_mpi_allreduce\n  use mpi\n  implicit none\n  integer :: ierr, rank, nprocs\n  real(8) :: local_sum, global_sum\n  real(8) :: local_max, global_max\n  real(8) :: local_array(3), global_array(3)\n\n  ! Initialize MPI\n  call MPI_Init(ierr)\n  call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierr)\n  call MPI_Comm_size(MPI_COMM_WORLD, nprocs, ierr)\n\n  ! Example 1: Sum of scalar values across all processes\n  local_sum = real(rank + 1, 8)  ! Each process has value rank+1\n  call MPI_Allreduce(local_sum, global_sum, 1, MPI_DOUBLE_PRECISION, &\n                     MPI_SUM, MPI_COMM_WORLD, ierr)\n  if (rank == 0) then\n    print '(A,F8.2)', 'Global sum: ', global_sum\n  end if\n\n  ! Example 2: Maximum value across all processes\n  local_max = real(rank * 10, 8)\n  call MPI_Allreduce(local_max, global_max, 1, MPI_DOUBLE_PRECISION, &\n                     MPI_MAX, MPI_COMM_WORLD, ierr)\n  if (rank == 0) then\n    print '(A,F8.2)', 'Global max: ', global_max\n  end if\n\n  ! Example 3: Element-wise reduction of arrays\n  local_array = [real(rank, 8), real(rank*2, 8), real(rank*3, 8)]\n  call MPI_Allreduce(local_array, global_array, 3, MPI_DOUBLE_PRECISION, &\n                     MPI_SUM, MPI_COMM_WORLD, ierr)\n  if (rank == 0) then\n    print '(A,3F8.2)', 'Global array sum: ', global_array\n  end if\n\n  ! Example 4: In-place reduction (result overwrites sendbuf)\n  local_sum = real(rank + 1, 8)\n  call MPI_Allreduce(MPI_IN_PLACE, local_sum, 1, MPI_DOUBLE_PRECISION, &\n                     MPI_SUM, MPI_COMM_WORLD, ierr)\n  if (rank == 0) then\n    print '(A,F8.2)', 'In-place sum: ', local_sum\n  end if\n\n  call MPI_Finalize(ierr)\nend program demo_mpi_allreduce\n```\n\nResults (with 4 processes):\n\n```text\n    Global sum:    10.00\n    Global max:    30.00\n    Global array sum:     6.00   12.00   18.00\n    In-place sum:    10.00\n```\n\n### **Standard**\n\nMPI-1.0 (introduced in the original MPI standard, 1994)\n\n### **See Also**\n\n[**MPI_Reduce**(3)](#mpi_reduce),\n[**MPI_Bcast**(3)](#mpi_bcast),\n[**MPI_Scatter**(3)](#mpi_scatter),\n[**MPI_Gather**(3)](#mpi_gather),\n[**MPI_Allgather**(3)](#mpi_allgather),\n[**MPI_Reduce_scatter**(3)](#mpi_reduce_scatter),\n[**MPI_Iallreduce**(3)](#mpi_iallreduce)\n\n### **Resources**\n\n- [Open MPI 5.0.x MPI_Allreduce Documentation](https://docs.open-mpi.org/en/v5.0.x/man-openmpi/man3/MPI_Allreduce.3.html)\n- [MPI Tutorial: MPI Reduce and Allreduce](https://mpitutorial.com/tutorials/mpi-reduce-and-allreduce/)\n- [MPI Forum Predefined Reduce Operations](https://www.mpi-forum.org/docs/mpi-1.1/mpi-11-html/node78.html)",
  "streamopen": "## stream_open\n\n### **Name**\n\n**open** - \\[IO:STREAM\\] Open a file for stream (binary) I/O access\n\n### **Synopsis**\n```fortran\n    open(newunit=unit, file='filename', access='stream', form='unformatted', iostat=ierr)\n```\n```fortran\n     open(newunit=unit, file=filename, access='stream', &\n          form='unformatted', status=file_status, &\n          action=io_action, iostat=ierr, iomsg=errmsg)\n\n      integer, intent(out)           :: unit       ! Assigned unit number\n      character(len=*), intent(in)   :: filename   ! File path\n      character(len=*), intent(in)   :: file_status  ! 'old', 'new', 'replace', etc.\n      character(len=*), intent(in)   :: io_action    ! 'read', 'write', 'readwrite'\n      integer, intent(out)           :: ierr         ! I/O status\n      character(len=*), intent(inout) :: errmsg      ! Error message\n```\n\n### **Characteristics**\n\n - **newunit** receives an automatically assigned unit number.\n - **file** is a character expression specifying the file path.\n - **access='stream'** enables byte-addressable I/O without record structure.\n - **form='unformatted'** specifies binary (non-text) data transfer.\n - The unit can be used for random access via the POS= specifier.\n\n### **Description**\n\n **open** with ACCESS='STREAM' prepares a file for stream I/O, which provides direct byte-addressable access without the record structure of traditional Fortran sequential or direct-access files. Stream I/O is ideal for:\n - Reading/writing binary files compatible with C or other languages\n - Processing files without Fortran record markers\n - Random access to specific byte positions\n - Efficient large-scale binary data I/O\n\n### **Options**\n\n- **newunit=**\n  : Integer variable that receives an automatically assigned unit number.\n  Preferred over hardcoded unit numbers to avoid conflicts.\n\n- **file=**\n  : Character expression specifying the file path (absolute or relative).\n\n- **access=**\n  : Must be 'STREAM' for stream I/O. Enables byte-addressable access.\n\n- **form=**\n  : 'UNFORMATTED' for binary data, 'FORMATTED' for text stream access.\n\n- **status=**\n  : File existence handling:\n  - 'OLD': File must exist\n  - 'NEW': File must not exist, will be created\n  - 'REPLACE': Overwrite if exists, create if not\n  - 'UNKNOWN': Processor-dependent (typically like 'REPLACE')\n\n- **action=**\n  : Access mode: 'READ', 'WRITE', or 'READWRITE'.\n\n- **iostat=**\n  : Integer variable set to 0 on success, positive on error.\n\n- **iomsg=**\n  : Character variable receiving error description on failure.\n\n### **Result**\n\n  On success, the file is connected to the assigned unit number and ready for stream I/O operations. The iostat variable is set to zero.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_stream_open\nimplicit none\n  integer :: unit_wr, unit_rd, ierr\n  real(8) :: data_out(100), data_in(100)\n  integer :: i\n  character(len=256) :: errmsg\n\n  ! Initialize test data\n  data_out = [(real(i, 8), i = 1, 100)]\n\n  ! Open file for writing\n  open(newunit=unit_wr, file='stream_demo.bin', access='stream', &\n       form='unformatted', status='replace', action='write', &\n       iostat=ierr, iomsg=errmsg)\n  if (ierr /= 0) then\n    print *, 'Write open error: ', trim(errmsg)\n    error stop\n  end if\n\n  write(unit_wr) data_out\n  close(unit_wr)\n  print *, 'Data written successfully'\n\n  ! Open file for reading\n  open(newunit=unit_rd, file='stream_demo.bin', access='stream', &\n       form='unformatted', status='old', action='read', &\n       iostat=ierr, iomsg=errmsg)\n  if (ierr /= 0) then\n    print *, 'Read open error: ', trim(errmsg)\n    error stop\n  end if\n\n  read(unit_rd) data_in\n  close(unit_rd, status='delete')\n\n  ! Verify\n  if (all(abs(data_in - data_out) < 1.0d-10)) then\n    print *, 'SUCCESS: Data integrity verified'\n    print '(A,5F8.1)', ' First 5 values:', data_in(1:5)\n    print '(A,5F8.1)', ' Last 5 values: ', data_in(96:100)\n  else\n    print *, 'ERROR: Data mismatch'\n  end if\n\nend program demo_stream_open\n```\nResults:\n```text\n Data written successfully\n SUCCESS: Data integrity verified\n First 5 values:     1.0     2.0     3.0     4.0     5.0\n Last 5 values:     96.0    97.0    98.0    99.0   100.0\n```\n\n### **Standard**\n\nFortran 2003\n\n**Compatibility Notes:**\n- gfortran 4.0+, Intel Fortran 9.1+, NAG 5.0+\n- ACCESS='STREAM' enables byte-addressable I/O\n- Use POS= specifier for random access\n\n### **See Also**\n\n[**close**(3)](#close),\n[**read_stream**(3)](#read_stream),\n[**write_stream**(3)](#write_stream),\n[**inquire**(3)](#inquire)",
  "optional": "## optional\n\n### **Name**\n\n**optional** - \\[PROCEDURE:ARGUMENT\\] Declare an optional dummy argument\n\n### **Synopsis**\n```fortran\n    type, intent(in), optional :: arg\n```\n```fortran\n     ! Optional argument declaration\n\n      subroutine sub(required_arg, optional_arg)\n        integer, intent(in)           :: required_arg\n        integer, intent(in), optional :: optional_arg\n```\n\n### **Characteristics**\n\n - **OPTIONAL** attribute marks arguments that may be omitted.\n - Must use PRESENT intrinsic to check if argument was provided.\n - Cannot reference absent optional arguments directly.\n - Caller can use keyword arguments or positional arguments.\n\n### **Description**\n\n **optional** declares a dummy argument that the caller may omit. The procedure\n must check with PRESENT whether the argument was provided before using it.\n Optional arguments enable flexible procedure interfaces without requiring\n multiple procedure definitions.\n\n### **Options**\n\n- **OPTIONAL**\n  : Attribute indicating the argument may be absent. Combined with type\n  and INTENT specifications.\n\n### **Result**\n\n  The argument can be omitted in calls to the procedure. If omitted, the\n  argument is considered \"not present\" and PRESENT returns .false.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_optional\nimplicit none\n  integer :: result\n\n  ! Call with all arguments\n  result = add_values(1, 2, 3)\n  print '(A,I0)', 'add_values(1, 2, 3) = ', result\n\n  ! Omit optional argument\n  result = add_values(1, 2)\n  print '(A,I0)', 'add_values(1, 2) = ', result\n\n  ! Use keyword argument\n  result = add_values(1, c=5)\n  print '(A,I0)', 'add_values(1, c=5) = ', result\n\n  ! Subroutine with optional output\n  call describe_value(10)\n  call describe_value(10, verbose=.true.)\n\ncontains\n\n  function add_values(a, b, c) result(sum)\n    integer, intent(in) :: a\n    integer, intent(in), optional :: b, c\n    integer :: sum\n\n    sum = a\n\n    if (present(b)) then\n      sum = sum + b\n    end if\n\n    if (present(c)) then\n      sum = sum + c\n    end if\n\n  end function add_values\n\n  subroutine describe_value(x, verbose)\n    integer, intent(in) :: x\n    logical, intent(in), optional :: verbose\n\n    print '(A,I0)', 'Value: ', x\n\n    if (present(verbose)) then\n      if (verbose) then\n        print '(A,I0)', '  Binary: ', x\n        print '(A,L1)', '  Positive: ', x > 0\n        print '(A,L1)', '  Even: ', mod(x, 2) == 0\n      end if\n    end if\n\n  end subroutine describe_value\n\nend program demo_optional\n```\nResults:\n```text\nadd_values(1, 2, 3) = 6\nadd_values(1, 2) = 3\nadd_values(1, c=5) = 6\nValue: 10\nValue: 10\n  Binary: 10\n  Positive: T\n  Even: T\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**present**(3)](#present),\n[**intent**(3)](#intent)",
  "cbind": "## bind_c_function\n\n### **Name**\n\n**bind_c_function** - \\[INTEROP:C_BINDING\\] Declare a Fortran function interoperable with C\n\n### **Synopsis**\n```fortran\n    result = fortran_func(arg1, arg2)\n```\n```fortran\n     function fortran_func(arg1, arg2) result(res) bind(c, name='c_func_name')\n\n      use iso_c_binding, only: c_int, c_double, c_ptr\n      integer(c_int), intent(in), value :: arg1\n      real(c_double), intent(in)        :: arg2\n      integer(c_int)                    :: res\n```\n\n### **Characteristics**\n\n - **bind(c)** makes the function callable from C with C calling conventions.\n - **name='c_func_name'** specifies the external C name (optional, defaults to lowercase Fortran name).\n - All dummy arguments must be interoperable C types from ISO_C_BINDING.\n - Arguments passed by value use the **value** attribute.\n - Arguments passed by reference (C pointers) omit the value attribute.\n - The result type must be an interoperable scalar type or c_ptr.\n\n### **Description**\n\n **bind_c_function** creates a Fortran function that can be called from C code\n or that implements a C function interface. The BIND(C) attribute ensures the\n function uses C calling conventions and name mangling. The NAME= specifier\n allows controlling the exact symbol name visible to the C linker.\n\n### **Options**\n\n- **bind(c)**\n  : Required attribute that specifies C interoperability. The function will\n  use C calling conventions and be callable from C code.\n\n- **name='c_name'**\n  : Optional. Specifies the exact C symbol name for the function. If omitted,\n  the Fortran name is used in lowercase. Use this to match existing C APIs\n  or avoid name conflicts.\n\n- **value**\n  : Attribute for dummy arguments that should be passed by value (like C\n  scalar arguments). Without this attribute, arguments are passed by reference.\n\n- **intent(in/out/inout)**\n  : Specifies argument intent. For value arguments, only intent(in) is valid.\n  For reference arguments, any intent may be used.\n\n### **Result**\n\n  The function result must be an interoperable type: integer(c_int),\n  real(c_float), real(c_double), type(c_ptr), type(c_funptr), or other\n  C-compatible types. The result is returned to C as specified by the\n  platform's C ABI.\n\n### **Examples**\n\nSample program (Fortran side):\n```fortran\nmodule c_interface_module\n  use iso_c_binding\n  implicit none\ncontains\n\n  ! Function callable from C as: int add_integers(int a, int b)\n  function add_integers(a, b) result(sum) bind(c, name='add_integers')\n    integer(c_int), intent(in), value :: a, b\n    integer(c_int) :: sum\n    sum = a + b\n  end function add_integers\n\n  ! Function callable from C as: double compute_distance(double* x, double* y, int n)\n  function compute_distance(x, y, n) result(dist) bind(c, name='compute_distance')\n    integer(c_int), intent(in), value :: n\n    real(c_double), intent(in) :: x(n), y(n)\n    real(c_double) :: dist\n    dist = sqrt(sum((x - y)**2))\n  end function compute_distance\n\n  ! Function returning a C pointer\n  function get_data_pointer(arr, n) result(ptr) bind(c, name='get_data_pointer')\n    integer(c_int), intent(in), value :: n\n    real(c_double), intent(in), target :: arr(n)\n    type(c_ptr) :: ptr\n    ptr = c_loc(arr(1))\n  end function get_data_pointer\n\nend module c_interface_module\n\nprogram demo_bind_c_function\n  use c_interface_module\n  use iso_c_binding\n  implicit none\n\n  integer(c_int) :: result_int\n  real(c_double) :: x(3), y(3), dist\n\n  ! Test the functions from Fortran (they work both ways)\n  result_int = add_integers(10_c_int, 25_c_int)\n  print '(A,I0)', 'add_integers(10, 25) = ', result_int\n\n  x = [1.0_c_double, 2.0_c_double, 3.0_c_double]\n  y = [4.0_c_double, 6.0_c_double, 8.0_c_double]\n  dist = compute_distance(x, y, 3_c_int)\n  print '(A,F10.6)', 'Distance between vectors: ', dist\n\nend program demo_bind_c_function\n```\n\nCorresponding C header:\n```c\n/* c_interface.h */\n#ifndef C_INTERFACE_H\n#define C_INTERFACE_H\n\nint add_integers(int a, int b);\ndouble compute_distance(double* x, double* y, int n);\ndouble* get_data_pointer(double* arr, int n);\n\n#endif\n```\n\nResults:\n```text\nadd_integers(10, 25) = 35\nDistance between vectors:   7.071068\n```\n\n### **Standard**\n\nFortran 2003 (ISO/IEC 1539-1:2004)\n\n**Compatibility Notes:**\n- gfortran 4.3+, Intel Fortran 10.0+, NAG 5.1+\n- Requires USE ISO_C_BINDING for interoperable types\n- C function names are case-sensitive\n\n### **See Also**\n\n[**bind_c_subroutine**(3)](#bind_c_subroutine),\n[**bind_c_type**(3)](#bind_c_type),\n[**c_loc**(3)](#c_loc),\n[**c_f_pointer**(3)](#c_f_pointer),\n[**iso_c_binding**(3)](#iso_c_binding)",
  "int32": "## int32\n\n### **Name**\n\n**int32** - \\[NUMERIC:KIND\\] Declare a 32-bit integer variable\n\n### **Synopsis**\n```fortran\n    use, intrinsic :: iso_fortran_env, only: int32\n    integer(int32) :: variable_name\n```\n```fortran\n     ! 32-bit integer declaration\n\n      use, intrinsic :: iso_fortran_env, only: int32\n      integer(int32) :: variable_name\n```\n\n### **Characteristics**\n\n - **int32** is an integer constant from ISO_FORTRAN_ENV.\n - Provides exactly 32 bits of storage.\n - Range: -2,147,483,648 to 2,147,483,647.\n - Equivalent to C int32_t type.\n\n### **Description**\n\n **int32** declares a 32-bit integer variable using the ISO_FORTRAN_ENV\n kind constant. This provides a portable way to specify exact integer sizes,\n ensuring consistent behavior across different platforms and compilers.\n\n### **Options**\n\n- **int32**\n  : The kind constant for 32-bit integers from ISO_FORTRAN_ENV. Must be\n  accessed via the USE statement.\n\n- **variable_name**\n  : The name of the integer variable being declared.\n\n### **Result**\n\n  An integer variable with exactly 32 bits of storage is declared.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_int32\nuse, intrinsic :: iso_fortran_env, only: int32, int64, int16, int8\nimplicit none\n\n  integer(int32) :: i32\n  integer(int32) :: max_val, min_val\n\n  ! Verify storage size\n  print '(A,I0)', 'int32 kind value: ', int32\n  print '(A,I0,A)', 'Storage size: ', storage_size(i32), ' bits'\n\n  ! Range\n  max_val = huge(i32)\n  min_val = -huge(i32) - 1\n  print '(A,I0)', 'Maximum value: ', max_val\n  print '(A,I0)', 'Minimum value: ', min_val\n\n  ! Compare with other integer kinds\n  print '(A)', 'Available integer kinds:'\n  print '(A,I0,A,I0,A)', '  int8:  kind=', int8, ', bits=', storage_size(int(0,int8)), ''\n  print '(A,I0,A,I0,A)', '  int16: kind=', int16, ', bits=', storage_size(int(0,int16)), ''\n  print '(A,I0,A,I0,A)', '  int32: kind=', int32, ', bits=', storage_size(int(0,int32)), ''\n  print '(A,I0,A,I0,A)', '  int64: kind=', int64, ', bits=', storage_size(int(0,int64)), ''\n\n  ! Example calculation\n  i32 = 1000000\n  print '(A,I0)', '1000000 squared = ', i32 * i32\n\nend program demo_int32\n```\nResults:\n```text\nint32 kind value: 4\nStorage size: 32 bits\nMaximum value: 2147483647\nMinimum value: -2147483648\nAvailable integer kinds:\n  int8:  kind=1, bits=8\n  int16: kind=2, bits=16\n  int32: kind=4, bits=32\n  int64: kind=8, bits=64\n1000000 squared = 1000000000000\n```\n\n### **Standard**\n\nFortran 2008\n\n**Compatibility Notes:**\n- gfortran 4.4+, Intel Fortran 10.0+, NAG 5.2+\n- From ISO_FORTRAN_ENV module\n- Guaranteed 32-bit integer\n\n### **See Also**\n\n[**iso_fortran_env**(3)](#iso_fortran_env),\n[**int64**(3)](#int64),\n[**int16**(3)](#int16),\n[**selected_int_kind**(3)](#selected_int_kind)",
  "assumed2d": "## arr2d\n\n### **Name**\n\n**assumed_shape_2d** - \\[ARRAY:DECLARATION\\] Declare a two-dimensional assumed-shape array argument\n\n### **Synopsis**\n```fortran\n    type, intent(in) :: array(:,:)\n```\n```fortran\n     subroutine proc(array)\n\n      type(TYPE(kind=**)), intent(in|out|inout) :: array(:,:)\n```\n\n### **Characteristics**\n\n - **array** is a rank-2 dummy argument with assumed shape, indicated by `(:,:)`.\n - The extents are determined from the actual argument at runtime.\n - The procedure must have an explicit interface.\n - Lower bounds default to 1 unless explicitly specified.\n - Array inquiry intrinsics (SIZE, SHAPE, LBOUND, UBOUND) work correctly.\n - No array copying occurs; the descriptor is passed by reference.\n\n### **Description**\n\n **Assumed-shape arrays** allow dummy arguments to accept arrays of any\n extent without requiring explicit size parameters. The bounds are\n automatically determined from the actual argument at runtime. This is\n the recommended method for passing arrays in modern Fortran as it provides\n type safety, bounds checking capability, and simplifies procedure interfaces.\n The shape information is passed automatically through the array descriptor,\n and intrinsic functions like SIZE, SHAPE, LBOUND, and UBOUND can query\n the dimensions.\n\n### **Options**\n\n- **type**\n  : Any intrinsic or derived type (integer, real, complex, logical, character,\n  or user-defined type).\n\n- **kind**\n  : Optional kind parameter for the type.\n\n- **intent**\n  : Data flow direction: in (read-only), out (write-only), or inout (read-write).\n\n- **array**\n  : The dummy argument name. The `(:,:)` syntax indicates assumed shape with rank 2.\n\n### **Result**\n\n  The dummy argument references the actual argument with full shape\n  information available. The procedure can use SIZE, SHAPE, LBOUND,\n  and UBOUND to query dimensions.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_arr2d\n  use, intrinsic :: iso_fortran_env, only: dp => real64\n  implicit none\n\n  real(dp) :: small_matrix(2, 3)\n  real(dp) :: large_matrix(100, 200)\n  real(dp), allocatable :: dynamic_matrix(:,:)\n\n  ! Initialize test matrices\n  small_matrix = reshape([1, 2, 3, 4, 5, 6], [2, 3])\n  large_matrix = 0.0_dp\n  \n  allocate(dynamic_matrix(50, 75))\n  dynamic_matrix = 1.0_dp\n\n  ! Same subroutine works with any 2D array size\n  call print_matrix_info(small_matrix)\n  call print_matrix_info(large_matrix)\n  call print_matrix_info(dynamic_matrix)\n\n  ! Demonstrate intent(inout) - modify in place\n  call scale_matrix(small_matrix, 2.0_dp)\n  print *, 'Scaled matrix(1,1):', small_matrix(1,1)\n\n  deallocate(dynamic_matrix)\n\ncontains\n\n  subroutine print_matrix_info(mat)\n    real(dp), intent(in) :: mat(:,:)  ! Assumed-shape 2D\n    \n    print *, 'Matrix shape:', size(mat, 1), 'x', size(mat, 2)\n    print *, 'Total elements:', size(mat)\n    print *, 'Bounds: [', lbound(mat, 1), ':', ubound(mat, 1), ', ', &\n                         lbound(mat, 2), ':', ubound(mat, 2), ']'\n  end subroutine print_matrix_info\n\n  subroutine scale_matrix(mat, factor)\n    real(dp), intent(inout) :: mat(:,:)  ! Assumed-shape 2D\n    real(dp), intent(in) :: factor\n    \n    mat = mat * factor\n  end subroutine scale_matrix\n\nend program demo_arr2d\n```\nResults:\n```text\n Matrix shape:           2 x           3\n Total elements:           6\n Bounds: [           1 :           2 ,            1 :           3 ]\n Matrix shape:         100 x         200\n Total elements:       20000\n Bounds: [           1 :         100 ,            1 :         200 ]\n Matrix shape:          50 x          75\n Total elements:        3750\n Bounds: [           1 :          50 ,            1 :          75 ]\n Scaled matrix(1,1):   2.0000000000000000\n```\n\n### **Standard**\n\nFortran 90 (ISO/IEC 1539:1991)\n\n### **See Also**\n\n[**assumed_shape_1d**](#assumed_shape_1d),\n[**assumed3d**](#assumed3d),\n[**assumed_rank**](#assumed_rank),\n[**contiguous**](#contiguous)",
  "allocate_mold": "## allocate_mold\n\n### **Name**\n\n**allocate_mold** - \\[ARRAY:ALLOCATION\\] Allocate with shape and type from a mold expression\n\n### **Synopsis**\n```fortran\n    allocate(alloc_var, mold=source_expr)\n```\n```fortran\n     allocate(alloc_var, mold=source_expr, stat=stat_var, errmsg=errmsg_var)\n\n      type(TYPE(kind=**)), allocatable :: alloc_var(..)\n      type(TYPE(kind=**))              :: source_expr(..)\n      integer                          :: stat_var\n      character(len=*)                 :: errmsg_var\n```\n\n### **Characteristics**\n\n - **alloc_var** is an allocatable variable of any type and rank.\n - **source_expr** provides the type and shape for allocation but not values.\n - **stat_var** is an optional integer variable that receives the allocation status.\n - **errmsg_var** is an optional character variable that receives an error message.\n - The allocated variable has the same dynamic type and shape as the mold.\n - Unlike SOURCE=, the values from mold are NOT copied to the allocated variable.\n - The allocated variable is left undefined (or processor-dependent for pointers).\n\n### **Description**\n\n **allocate** with the **mold=** specifier dynamically allocates storage for\n an allocatable variable or pointer, giving it the same dynamic type and shape\n as the mold expression without copying the mold's values. This is particularly\n useful for allocating polymorphic variables to match another object's type,\n or for creating arrays with the same shape as an existing array when you\n intend to fill the values independently.\n\n### **Options**\n\n- **alloc_var**\n  : The allocatable variable or pointer to be allocated. Must have the\n  ALLOCATABLE or POINTER attribute. Must not already be allocated.\n\n- **mold**\n  : An expression that determines the type and shape of the allocation.\n  For arrays, the allocated object gets the same shape. For polymorphic\n  types, the allocated object gets the same dynamic type.\n\n- **stat**\n  : Optional. Integer variable set to zero on success, positive on error.\n  If absent, allocation failure causes program termination.\n\n- **errmsg**\n  : Optional. Character variable that receives a descriptive error message\n  if allocation fails. Unchanged if allocation succeeds.\n\n### **Result**\n\n  The allocated variable has the same dynamic type and shape as the mold\n  expression. The values are undefined and must be assigned before use.\n  If stat is present and allocation succeeds, it is set to zero.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_allocate_mold\n  use, intrinsic :: iso_fortran_env, only: dp => real64\n  implicit none\n\n  real(dp) :: template(3, 4)\n  real(dp), allocatable :: matrix(:,:)\n  real(dp), allocatable :: vector(:)\n  integer :: ierr\n  character(len=100) :: errmsg\n\n  ! Allocate matrix with same shape as template\n  allocate(matrix, mold=template, stat=ierr, errmsg=errmsg)\n  if (ierr /= 0) error stop errmsg\n\n  print *, 'Matrix shape:', shape(matrix)  ! [3, 4]\n\n  ! Allocate vector with shape from array section\n  allocate(vector, mold=template(:,1))\n  print *, 'Vector size:', size(vector)    ! 3\n\n  ! Fill with values (mold does not copy values)\n  matrix = 1.0_dp\n  vector = 2.0_dp\n\n  print *, 'Matrix(1,1):', matrix(1,1)\n  print *, 'Vector(1):', vector(1)\n\n  deallocate(matrix, vector)\n\nend program demo_allocate_mold\n```\nResults:\n```text\n Matrix shape:           3           4\n Vector size:           3\n Matrix(1,1):   1.0000000000000000\n Vector(1):   2.0000000000000000\n```\n\n### **Standard**\n\nFortran 2003\n\n**Compatibility Notes:**\n- gfortran 4.6+, Intel Fortran 12.0+, NAG 5.3+\n- MOLD= creates same type/shape but uninitialized\n- Useful for allocating polymorphic variables\n\n### **See Also**\n\n[**allocate**](#allocate),\n[**allocate_source**](#allocate_source),\n[**move_alloc**](#move_alloc),\n[**deallocate**](#deallocate)",
  "arr2d": "## arr2d\n\n### **Name**\n\n**assumed_shape_2d** - \\[ARRAY:DECLARATION\\] Declare a two-dimensional assumed-shape array argument\n\n### **Synopsis**\n```fortran\n    type, intent(in) :: array(:,:)\n```\n```fortran\n     subroutine proc(array)\n\n      type(TYPE(kind=**)), intent(in|out|inout) :: array(:,:)\n```\n\n### **Characteristics**\n\n - **array** is a rank-2 dummy argument with assumed shape, indicated by `(:,:)`.\n - The extents are determined from the actual argument at runtime.\n - The procedure must have an explicit interface.\n - Lower bounds default to 1 unless explicitly specified.\n - Array inquiry intrinsics (SIZE, SHAPE, LBOUND, UBOUND) work correctly.\n - No array copying occurs; the descriptor is passed by reference.\n\n### **Description**\n\n **Assumed-shape arrays** allow dummy arguments to accept arrays of any\n extent without requiring explicit size parameters. The bounds are\n automatically determined from the actual argument at runtime. This is\n the recommended method for passing arrays in modern Fortran as it provides\n type safety, bounds checking capability, and simplifies procedure interfaces.\n The shape information is passed automatically through the array descriptor,\n and intrinsic functions like SIZE, SHAPE, LBOUND, and UBOUND can query\n the dimensions.\n\n### **Options**\n\n- **type**\n  : Any intrinsic or derived type (integer, real, complex, logical, character,\n  or user-defined type).\n\n- **kind**\n  : Optional kind parameter for the type.\n\n- **intent**\n  : Data flow direction: in (read-only), out (write-only), or inout (read-write).\n\n- **array**\n  : The dummy argument name. The `(:,:)` syntax indicates assumed shape with rank 2.\n\n### **Result**\n\n  The dummy argument references the actual argument with full shape\n  information available. The procedure can use SIZE, SHAPE, LBOUND,\n  and UBOUND to query dimensions.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_arr2d\n  use, intrinsic :: iso_fortran_env, only: dp => real64\n  implicit none\n\n  real(dp) :: small_matrix(2, 3)\n  real(dp) :: large_matrix(100, 200)\n  real(dp), allocatable :: dynamic_matrix(:,:)\n\n  ! Initialize test matrices\n  small_matrix = reshape([1, 2, 3, 4, 5, 6], [2, 3])\n  large_matrix = 0.0_dp\n  \n  allocate(dynamic_matrix(50, 75))\n  dynamic_matrix = 1.0_dp\n\n  ! Same subroutine works with any 2D array size\n  call print_matrix_info(small_matrix)\n  call print_matrix_info(large_matrix)\n  call print_matrix_info(dynamic_matrix)\n\n  ! Demonstrate intent(inout) - modify in place\n  call scale_matrix(small_matrix, 2.0_dp)\n  print *, 'Scaled matrix(1,1):', small_matrix(1,1)\n\n  deallocate(dynamic_matrix)\n\ncontains\n\n  subroutine print_matrix_info(mat)\n    real(dp), intent(in) :: mat(:,:)  ! Assumed-shape 2D\n    \n    print *, 'Matrix shape:', size(mat, 1), 'x', size(mat, 2)\n    print *, 'Total elements:', size(mat)\n    print *, 'Bounds: [', lbound(mat, 1), ':', ubound(mat, 1), ', ', &\n                         lbound(mat, 2), ':', ubound(mat, 2), ']'\n  end subroutine print_matrix_info\n\n  subroutine scale_matrix(mat, factor)\n    real(dp), intent(inout) :: mat(:,:)  ! Assumed-shape 2D\n    real(dp), intent(in) :: factor\n    \n    mat = mat * factor\n  end subroutine scale_matrix\n\nend program demo_arr2d\n```\nResults:\n```text\n Matrix shape:           2 x           3\n Total elements:           6\n Bounds: [           1 :           2 ,            1 :           3 ]\n Matrix shape:         100 x         200\n Total elements:       20000\n Bounds: [           1 :         100 ,            1 :         200 ]\n Matrix shape:          50 x          75\n Total elements:        3750\n Bounds: [           1 :          50 ,            1 :          75 ]\n Scaled matrix(1,1):   2.0000000000000000\n```\n\n### **Standard**\n\nFortran 90 (ISO/IEC 1539:1991)\n\n### **See Also**\n\n[**assumed_shape_1d**](#assumed_shape_1d),\n[**assumed3d**](#assumed3d),\n[**assumed_rank**](#assumed_rank),\n[**contiguous**](#contiguous)",
  "mat": "## mat\n\n### **Name**\n\n**mat** - \\[ARRAY:DECLARATION\\] Declare a two-dimensional assumed-shape array dummy argument\n\n### **Synopsis**\n\n```fortran\n    type, intent(in|out|inout) :: array_name(:,:)\n```\n\n```fortran\n     subroutine process_matrix(matrix)\n\n      real, intent(in) :: matrix(:,:)  ! 2D assumed-shape array\n```\n\n### **Characteristics**\n\n - **type** is any intrinsic or derived type (integer, real, complex, logical, character, or user-defined type).\n - **intent** specifies the data flow direction: in (read-only), out (write-only), or inout (read-write).\n - **name** is the dummy argument name that will reference the passed array.\n - The array rank must match the actual argument (both must be rank-2).\n - The array kind must match the actual argument.\n - Lower bounds default to 1 unless explicitly specified.\n - The procedure must have an explicit interface (module procedure or interface block).\n\n### **Description**\n\n **Assumed-shape arrays** allow dummy arguments to accept arrays of any extent without\n requiring explicit size parameters. The bounds are automatically determined from the\n actual argument at runtime. This is the recommended method for passing arrays in\n modern Fortran as it provides type safety, bounds checking capability, and simplifies\n procedure interfaces.\n\n### **Options**\n\n- **type**\n  : The Fortran data type of the array elements. Can be any intrinsic type (integer,\n  real, complex, logical, character) with optional kind specifier, or a derived type.\n\n- **intent(in|out|inout)**\n  : Specifies how the array is used:\n  - `intent(in)` - Array is read-only; procedure cannot modify it\n  - `intent(out)` - Array receives output; initial values undefined\n  - `intent(inout)` - Array is both read and modified\n\n- **array_name(:,:)**\n  : The dummy argument name followed by assumed-shape specifier. The colons indicate\n  that bounds are determined at runtime from the actual argument.\n\n### **Result**\n\n The assumed-shape array declaration does not produce a result value. It establishes\n how the dummy argument receives and accesses the actual argument's data. The array\n descriptor provides shape information accessible via SIZE, SHAPE, LBOUND, and UBOUND.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_assumed_shape_2d\n  use, intrinsic :: iso_fortran_env, only: dp => real64\n  implicit none\n\n  real(dp) :: small_matrix(2, 3)\n  real(dp) :: large_matrix(5, 4)\n\n  ! Initialize test matrices\n  small_matrix = reshape([1, 2, 3, 4, 5, 6], [2, 3])\n  large_matrix = reshape([(real(i, dp), i = 1, 20)], [5, 4])\n\n  ! Same subroutine works with any 2D array size\n  call print_matrix_info(small_matrix)\n  call print_matrix_info(large_matrix)\n\ncontains\n\n  subroutine print_matrix_info(matrix)\n    real(dp), intent(in) :: matrix(:,:)  ! Assumed-shape 2D array\n\n    print '(A,I0,A,I0)', 'Matrix dimensions: ', size(matrix, 1), ' x ', size(matrix, 2)\n    print '(A,I0)', 'Total elements: ', size(matrix)\n    print '(A,G12.4)', 'Sum of elements: ', sum(matrix)\n    print *\n  end subroutine print_matrix_info\n\nend program demo_assumed_shape_2d\n```\n\nResults:\n\n```text\nMatrix dimensions: 2 x 3\nTotal elements: 6\nSum of elements:     21.00\n\nMatrix dimensions: 5 x 4\nTotal elements: 20\nSum of elements:     210.0\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**assumed_shape_1d**(3)](#assumed_shape_1d),\n[**assumed_rank**(3)](#assumed_rank),\n[**contiguous**(3)](#contiguous),\n[**size**(3)](#size),\n[**shape**(3)](#shape)",
  "mpi_bcast": "## MPI_Bcast\n\n### **Name**\n\n**MPI_Bcast** - \\[PARALLEL:MPI\\] Broadcast a message from root to all processes in a communicator\n\n### **Synopsis**\n\n```fortran\n    call MPI_Bcast(buffer, count, datatype, root, comm, ierror)\n```\n\n```fortran\n     subroutine MPI_Bcast(buffer, count, datatype, root, comm, ierror)\n\n      type(*), dimension(..)    :: buffer\n      integer, intent(in)       :: count\n      type(MPI_Datatype), intent(in) :: datatype\n      integer, intent(in)       :: root\n      type(MPI_Comm), intent(in)     :: comm\n      integer, intent(out)      :: ierror\n```\n\n### **Characteristics**\n\n - **buffer** is a data buffer of any type and rank\n - **count** is an integer specifying the number of elements\n - **datatype** is an MPI datatype handle (e.g., MPI_DOUBLE_PRECISION, MPI_INTEGER)\n - **root** is an integer rank of the broadcasting process\n - **comm** is an MPI communicator handle\n - **ierror** returns the error status (0 for success)\n - All processes in the communicator must call this routine with identical arguments\n\n### **Description**\n\n **MPI_Bcast** broadcasts a message from the process with rank **root** to all\n other processes in the group, including itself. After the call, all processes\n in the communicator have identical copies of the buffer data. This is a\n collective operation that must be called by all processes in the communicator.\n\n### **Options**\n\n- **buffer**\n  : Starting address of the data buffer. On the root process, this contains\n  the data to be broadcast. On all other processes, this is where the\n  received data will be stored.\n\n- **count**\n  : Number of elements in the buffer. Must be non-negative and identical\n  on all processes.\n\n- **datatype**\n  : MPI datatype of each buffer element. Common values include:\n  MPI_INTEGER, MPI_REAL, MPI_DOUBLE_PRECISION, MPI_COMPLEX,\n  MPI_LOGICAL, MPI_CHARACTER. Must match on all processes.\n\n- **root**\n  : Rank of the process sending the broadcast (0 to comm_size-1).\n  Must be identical on all processes in the communicator.\n\n- **comm**\n  : MPI communicator defining the process group. Typically MPI_COMM_WORLD\n  for all processes, or a custom communicator for subgroups.\n\n- **ierror**\n  : Error status. Returns MPI_SUCCESS (0) on successful completion,\n  or an MPI error code on failure.\n\n\n\n### **Result**\n\n  After the call completes, all processes in the communicator have\n  identical copies of the data that was in the root process's buffer.\n  The buffer on the root process is unchanged; the buffers on all other\n  processes contain the broadcast data. This is a collective operation\n  that synchronizes all participating processes.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_mpi_bcast\n  use mpi\n  implicit none\n\n  integer :: ierr, rank, nprocs\n  integer :: root\n  real(8) :: value\n  real(8), dimension(4) :: array\n\n  ! Initialize MPI\n  call MPI_Init(ierr)\n  call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierr)\n  call MPI_Comm_size(MPI_COMM_WORLD, nprocs, ierr)\n\n  root = 0\n\n  ! Example 1: Broadcast a scalar\n  if (rank == root) then\n    value = 3.14159265358979d0\n    print '(A,I2,A,F12.8)', 'Process ', rank, ' (root) sending value: ', value\n  else\n    value = 0.0d0\n  end if\n\n  call MPI_Bcast(value, 1, MPI_DOUBLE_PRECISION, root, MPI_COMM_WORLD, ierr)\n\n  print '(A,I2,A,F12.8)', 'Process ', rank, ' received value: ', value\n\n  ! Example 2: Broadcast an array\n  if (rank == root) then\n    array = [1.0d0, 2.0d0, 3.0d0, 4.0d0]\n    print '(A,I2,A)', 'Process ', rank, ' (root) broadcasting array'\n  else\n    array = 0.0d0\n  end if\n\n  call MPI_Bcast(array, 4, MPI_DOUBLE_PRECISION, root, MPI_COMM_WORLD, ierr)\n\n  print '(A,I2,A,4F8.2)', 'Process ', rank, ' array: ', array\n\n  call MPI_Finalize(ierr)\nend program demo_mpi_bcast\n```\n\nResults (with 4 processes):\n\n```text\nProcess  0 (root) sending value:   3.14159265\nProcess  0 received value:   3.14159265\nProcess  1 received value:   3.14159265\nProcess  2 received value:   3.14159265\nProcess  3 received value:   3.14159265\nProcess  0 (root) broadcasting array\nProcess  0 array:     1.00    2.00    3.00    4.00\nProcess  1 array:     1.00    2.00    3.00    4.00\nProcess  2 array:     1.00    2.00    3.00    4.00\nProcess  3 array:     1.00    2.00    3.00    4.00\n```\n\nCompile with: `mpif90 demo_mpi_bcast.f90 -o demo_mpi_bcast`\n\nRun with: `mpirun -np 4 ./demo_mpi_bcast`\n\n### **Standard**\n\nMPI-1.0\n\n### **See Also**\n\n[**MPI_Ibcast**(3)](#mpi_ibcast),\n[**MPI_Scatter**(3)](#mpi_scatter),\n[**MPI_Gather**(3)](#mpi_gather),\n[**MPI_Allgather**(3)](#mpi_allgather),\n[**MPI_Reduce**(3)](#mpi_reduce),\n[**MPI_Allreduce**(3)](#mpi_allreduce),\n[**MPI_Comm_rank**(3)](#mpi_comm_rank),\n[**MPI_Comm_size**(3)](#mpi_comm_size)",
  "writestr": "## write_internal\n\n### **Name**\n\n**write** - \\[IO:INTERNAL\\] Write formatted data to an internal character variable\n\n### **Synopsis**\n```fortran\n    write(string, fmt) var1, var2, ...\n```\n```fortran\n     write(unit=string, fmt=format_spec, iostat=ios, iomsg=msg) var_list\n\n      character(len=*), intent(out)   :: string       ! Destination string\n      character(len=*), intent(in)    :: format_spec  ! Format or *\n      integer, intent(out), optional  :: ios          ! I/O status\n      character(len=*), intent(inout), optional :: msg  ! Error message\n```\n\n### **Characteristics**\n\n - **string** is a character variable that receives the formatted output.\n - **fmt** is a format specification (character expression, label, or * for list-directed).\n - **var_list** contains expressions or variables to convert to character representation.\n - The string must be long enough to hold the formatted result.\n - No file unit number is used; the character variable serves as the \"file\".\n\n### **Description**\n\n **write** with an internal file (character variable) converts numeric or other data types to their character representation. This is the Fortran equivalent of sprintf() in C or string formatting in other languages. Internal writes are commonly used for:\n - Converting numbers to strings for concatenation\n - Building formatted output strings dynamically\n - Creating file names with embedded numeric values\n - Preparing data for character-based processing\n\n### **Options**\n\n- **string**\n  : A character variable, substring, or array that receives the formatted output. For arrays, each element receives one record (line) of output.\n\n- **fmt**\n  : Format specification controlling how values are converted. Can be:\n  - `*` for list-directed (free-format) conversion\n  - A character expression containing format descriptors\n  - A statement label referencing a FORMAT statement\n\n- **var_list**\n  : One or more expressions to convert to character representation.\n\n- **iostat=** (optional)\n  : Integer variable set to zero on success, positive on error.\n\n- **iomsg=** (optional)\n  : Character variable that receives an error message if an error occurs.\n\n### **Result**\n\n  The string variable contains the character representation of the output list items formatted according to the format specification.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_write_internal\nimplicit none\n  character(len=50) :: result_str\n  character(len=100) :: filename\n  character(len=20) :: num_str\n  integer :: i, ios\n  real :: value\n  character(len=256) :: errmsg\n\n  ! Example 1: Simple number to string conversion\n  i = 42\n  write(num_str, '(I0)') i\n  print *, 'Integer as string: \"', trim(num_str), '\"'\n\n  ! Example 2: Formatted real conversion\n  value = 3.14159\n  write(result_str, '(F10.4)') value\n  print *, 'Real as string: \"', trim(adjustl(result_str)), '\"'\n\n  ! Example 3: Building a filename with number\n  i = 5\n  write(filename, '(A,I3.3,A)') 'output_', i, '.dat'\n  print *, 'Filename: ', trim(filename)\n\n  ! Example 4: Complex formatting\n  write(result_str, '(A,I0,A,F6.2,A)') 'Item ', i, ' costs $', 19.99, ' each'\n  print *, trim(result_str)\n\n  ! Example 5: Scientific notation\n  value = 6.022e23\n  write(result_str, '(A,ES12.4)') 'Avogadro: ', value\n  print *, trim(result_str)\n\n  ! Example 6: With error handling\n  write(num_str, '(I5)', iostat=ios, iomsg=errmsg) 123456789\n  if (ios /= 0) then\n    print *, 'Conversion error: ', trim(errmsg)\n  else\n    print *, 'Converted: ', trim(num_str)\n  end if\n\nend program demo_write_internal\n```\nResults:\n```text\n Integer as string: \"42\"\n Real as string: \"3.1416\"\n Filename: output_005.dat\n Item 5 costs $ 19.99 each\n Avogadro: 6.0220E+23\n Conversion error: Output statement overflows record\n```\n\n### **Standard**\n\nFortran 77 (internal files), Fortran 2003 (IOMSG)\n\n**Compatibility Notes:**\n- gfortran 4.0+, Intel Fortran 9.0+, NAG 5.0+\n- Use WRITE with internal file (character variable)\n- Ensure target string is long enough\n\n### **See Also**\n\n[**read_internal**(3)](#read_internal),\n[**write**(3)](#write),\n[**format**(3)](#format),\n[**trim**(3)](#trim),\n[**adjustl**(3)](#adjustl)",
  "assumedshape1d": "## array1d\n\n### **Name**\n\n**assumed_shape_1d** - \\[ARRAY:DECLARATION\\] Declare a 1D assumed-shape dummy argument\n\n### **Synopsis**\n```fortran\n    type, intent(in) :: array(:)\n```\n```fortran\n     subroutine proc(array)\n\n      type(TYPE(kind=**)), intent(in|out|inout) :: array(:)\n```\n\n### **Characteristics**\n\n - **array** is a rank-1 dummy argument with assumed shape, indicated by `(:)`.\n - The extent is determined from the actual argument at runtime.\n - The procedure must have an explicit interface.\n - Lower bound defaults to 1 unless explicitly specified.\n - Array inquiry intrinsics (SIZE, LBOUND, UBOUND) work correctly.\n - No array copying occurs; the descriptor is passed by reference.\n\n### **Description**\n\n **assumed_shape_1d** declares a one-dimensional array dummy argument whose\n shape is determined by the actual argument at the time of procedure\n invocation. The array inherits the size and extent from the calling code,\n allowing procedures to operate on arrays of any size without requiring\n explicit size arguments. This is the modern and recommended approach for\n passing arrays in Fortran.\n\n### **Options**\n\n- **type**\n  : Any intrinsic or derived type (integer, real, complex, logical, character,\n  or user-defined type).\n\n- **kind**\n  : Optional kind parameter for the type.\n\n- **intent**\n  : Data flow direction: in (read-only), out (write-only), or inout (read-write).\n\n- **array**\n  : The dummy argument name. The `(:)` syntax indicates assumed shape.\n\n### **Result**\n\n  The dummy argument references the actual argument with size information\n  available. The procedure can use SIZE, LBOUND, and UBOUND to query\n  dimensions.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_array1d\n  use, intrinsic :: iso_fortran_env, only: dp => real64\n  implicit none\n\n  real(dp) :: small(5)\n  real(dp) :: large(1000)\n  real(dp), allocatable :: dynamic(:)\n  real(dp) :: result\n\n  small = [1.0_dp, 2.0_dp, 3.0_dp, 4.0_dp, 5.0_dp]\n  large = 1.0_dp\n\n  allocate(dynamic(50))\n  dynamic = 2.0_dp\n\n  ! Same function works with any size 1D array\n  result = compute_mean(small)\n  print *, 'Mean of small:', result\n\n  result = compute_mean(large)\n  print *, 'Mean of large:', result\n\n  result = compute_mean(dynamic)\n  print *, 'Mean of dynamic:', result\n\n  ! Demonstrate size inquiry\n  call print_array_info(small)\n  call print_array_info(dynamic)\n\n  deallocate(dynamic)\n\ncontains\n\n  function compute_mean(arr) result(mean)\n    real(dp), intent(in) :: arr(:)  ! Assumed-shape 1D\n    real(dp) :: mean\n\n    mean = sum(arr) / size(arr)\n  end function compute_mean\n\n  subroutine print_array_info(arr)\n    real(dp), intent(in) :: arr(:)\n\n    print *, 'Size:', size(arr)\n    print *, 'Bounds:', lbound(arr, 1), 'to', ubound(arr, 1)\n  end subroutine print_array_info\n\nend program demo_array1d\n```\nResults:\n```text\n Mean of small:   3.0000000000000000\n Mean of large:   1.0000000000000000\n Mean of dynamic:   2.0000000000000000\n Size:           5\n Bounds:           1 to           5\n Size:          50\n Bounds:           1 to          50\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**assumed2d**](#assumed2d),\n[**assumed3d**](#assumed3d),\n[**size**](#size),\n[**shape**](#shape),\n[**contiguous**](#contiguous)",
  "nmlread": "## namelist_read\n\n### **Name**\n\n**read** - \\[IO:NAMELIST\\] Read a namelist from a file unit with error handling\n\n### **Synopsis**\n```fortran\n    read(unit, nml=nml_name, iostat=ierr)\n```\n```fortran\n     read(unit=unit_num, nml=nml_name, iostat=ierr, iomsg=errmsg)\n\n      integer, intent(in)             :: unit_num    ! Connected file unit\n      namelist /nml_name/             :: variables   ! Namelist group\n      integer, intent(out), optional  :: ierr        ! I/O status\n      character(len=*), intent(inout), optional :: errmsg  ! Error message\n```\n\n### **Characteristics**\n\n - **unit** is a scalar integer representing an open file unit connected for formatted input.\n - **nml_name** is the name of a previously declared namelist group.\n - **ierr** is an optional integer variable that receives the I/O status code.\n - The file must be connected for formatted sequential access.\n - All variables in the namelist group can be read from the input.\n\n### **Description**\n\n **read** with the NML= specifier reads values from a formatted file into variables belonging to a namelist group. The input file must contain the namelist data in the standard namelist format beginning with `&nml_name` and ending with `/`. Variables not present in the input retain their previous values. This format is ideal for configuration files, parameter input, and restart files.\n\n### **Options**\n\n- **unit**\n  : The logical unit number of a file opened for formatted sequential reading.\n\n- **nml=**\n  : The name of a namelist group previously defined with the NAMELIST statement. Variables in the input file are matched by name to namelist members.\n\n- **iostat=** (optional)\n  : Integer variable receiving I/O status. Zero indicates success, positive indicates error, negative indicates end-of-file.\n\n- **iomsg=** (optional)\n  : Character variable receiving error description when iostat is nonzero.\n\n### **Result**\n\n  Variables in the namelist group receive values from the input file. Variables not specified in the input retain their prior values. The namelist format allows selective updating of configuration parameters.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_namelist_read\nimplicit none\n  ! Declare variables for namelist\n  integer :: max_iterations = 100\n  real    :: tolerance = 1.0e-6\n  logical :: verbose = .false.\n  character(len=64) :: output_file = 'output.dat'\n\n  ! Define namelist group\n  namelist /settings/ max_iterations, tolerance, verbose, output_file\n\n  integer :: unit_num, ierr\n  character(len=256) :: errmsg\n\n  ! Create a sample input file\n  open(newunit=unit_num, file='settings.nml', status='replace', action='write')\n  write(unit_num, '(A)') '&settings'\n  write(unit_num, '(A)') '  max_iterations = 500'\n  write(unit_num, '(A)') '  tolerance = 1.0e-8'\n  write(unit_num, '(A)') '  verbose = .true.'\n  write(unit_num, '(A)') '  output_file = \"results.dat\"'\n  write(unit_num, '(A)') '/'\n  close(unit_num)\n\n  ! Read namelist from file\n  open(newunit=unit_num, file='settings.nml', status='old', action='read', &\n       iostat=ierr, iomsg=errmsg)\n  if (ierr /= 0) then\n    print *, 'Cannot open file: ', trim(errmsg)\n    error stop\n  end if\n\n  read(unit_num, nml=settings, iostat=ierr, iomsg=errmsg)\n  if (ierr /= 0) then\n    print *, 'Namelist read error: ', trim(errmsg)\n    error stop\n  end if\n  close(unit_num)\n\n  ! Display read values\n  print '(A)',       'Namelist values read:'\n  print '(A,I0)',    '  max_iterations = ', max_iterations\n  print '(A,ES10.3)','  tolerance      = ', tolerance\n  print '(A,L1)',    '  verbose        = ', verbose\n  print '(A,A)',     '  output_file    = ', trim(output_file)\n\n  ! Clean up\n  open(newunit=unit_num, file='settings.nml', status='old')\n  close(unit_num, status='delete')\n\nend program demo_namelist_read\n```\nResults:\n```text\nNamelist values read:\n  max_iterations = 500\n  tolerance      = 1.000E-08\n  verbose        = T\n  output_file    = results.dat\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**namelist_write**(3)](#namelist_write),\n[**open**(3)](#open),\n[**read**(3)](#read),\n[**inquire**(3)](#inquire)",
  "complex_kind": "## complex_kind\n\n### **Name**\n\n**complex_kind** - \\[NUMERIC:KIND\\] Declare a complex variable with specified precision\n\n### **Synopsis**\n```fortran\n    complex(kind) :: variable_name\n```\n```fortran\n     ! Complex variable declaration with kind parameter\n\n      integer, parameter :: dp = selected_real_kind(15, 307)\n      complex(dp)        :: z\n```\n\n### **Characteristics**\n\n - **kind** specifies the precision of both real and imaginary parts.\n - Each part has the same precision as a real of that kind.\n - Storage is twice the size of the corresponding real kind.\n - Supports all standard arithmetic operations.\n\n### **Description**\n\n **complex_kind** declares a complex variable with a specified kind parameter.\n The kind determines the precision of both the real and imaginary components.\n Using kind parameters ensures portability across different compilers and\n platforms.\n\n### **Options**\n\n- **kind**\n  : The kind parameter specifying precision. Should be defined using\n  selected_real_kind for portability, or use iso_fortran_env constants.\n\n- **variable_name**\n  : The name of the complex variable being declared.\n\n### **Result**\n\n  A complex variable is declared with the specified precision for both\n  real and imaginary components.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_complex_kind\nimplicit none\n  integer, parameter :: sp = selected_real_kind(6, 37)\n  integer, parameter :: dp = selected_real_kind(15, 307)\n\n  complex(sp) :: z_single\n  complex(dp) :: z_double\n  complex(dp) :: z1, z2, result\n\n  ! Initialize complex numbers\n  z_single = (1.0, 2.0)\n  z_double = (1.0_dp, 2.0_dp)\n\n  print '(A,2F10.6)', 'Single precision: ', z_single\n  print '(A,2F15.10)', 'Double precision: ', z_double\n\n  ! Complex arithmetic\n  z1 = (3.0_dp, 4.0_dp)\n  z2 = (1.0_dp, -1.0_dp)\n\n  print '(A,2F15.10)', 'z1 = ', z1\n  print '(A,2F15.10)', 'z2 = ', z2\n  print '(A,2F15.10)', 'z1 + z2 = ', z1 + z2\n  print '(A,2F15.10)', 'z1 * z2 = ', z1 * z2\n  print '(A,F15.10)', '|z1| = ', abs(z1)\n  print '(A,2F15.10)', 'conjg(z1) = ', conjg(z1)\n\n  ! Euler's identity: e^(i*pi) + 1 = 0\n  result = exp(cmplx(0.0_dp, acos(-1.0_dp), dp)) + 1.0_dp\n  print '(A,2ES15.7)', 'e^(i*pi) + 1 = ', result\n\nend program demo_complex_kind\n```\nResults:\n```text\nSingle precision:   1.000000  2.000000\nDouble precision:    1.0000000000   2.0000000000\nz1 =    3.0000000000   4.0000000000\nz2 =    1.0000000000  -1.0000000000\nz1 + z2 =    4.0000000000   3.0000000000\nz1 * z2 =    7.0000000000   1.0000000000\n|z1| =    5.0000000000\nconjg(z1) =    3.0000000000  -4.0000000000\ne^(i*pi) + 1 =    0.0000000E+00   1.2246468E-16\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**cmplx**(3)](#cmplx),\n[**real**(3)](#real),\n[**aimag**(3)](#aimag),\n[**conjg**(3)](#conjg),\n[**abs**(3)](#abs)",
  "complexdp": "## complex_kind\n\n### **Name**\n\n**complex_dp** - \\[NUMERIC:KIND\\] Declare a double precision complex variable\n\n### **Synopsis**\n```fortran\n    complex(dp) :: variable_name\n```\n```fortran\n     ! Double precision complex declaration\n\n      integer, parameter :: dp = selected_real_kind(15, 307)\n      complex(dp)        :: z\n```\n\n### **Characteristics**\n\n - **dp** is the kind parameter for double precision.\n - Both real and imaginary parts have double precision.\n - Storage is typically 16 bytes (two 8-byte doubles).\n - Provides approximately 15-17 significant decimal digits per component.\n\n### **Description**\n\n **complex_dp** declares a double precision complex variable. The kind\n parameter dp should be defined using selected_real_kind(15, 307) to ensure\n portability. Both the real and imaginary components have the same precision.\n\n### **Options**\n\n- **dp**\n  : The kind parameter for double precision, typically defined as\n  `integer, parameter :: dp = selected_real_kind(15, 307)`.\n\n- **variable_name**\n  : The name of the complex variable being declared.\n\n### **Result**\n\n  A complex variable with double precision real and imaginary components.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_complex_dp\nimplicit none\n  integer, parameter :: dp = selected_real_kind(15, 307)\n\n  complex(dp) :: z, w, result\n  real(dp) :: r, theta\n\n  ! Initialize using various methods\n  z = (3.0_dp, 4.0_dp)\n  w = cmplx(1.0_dp, -2.0_dp, dp)\n\n  print '(A,2F18.14)', 'z = ', z\n  print '(A,2F18.14)', 'w = ', w\n\n  ! Polar form: z = r * e^(i*theta)\n  r = abs(z)\n  theta = atan2(aimag(z), real(z))\n  print '(A,F18.14)', 'r = |z| = ', r\n  print '(A,F18.14)', 'theta = ', theta\n\n  ! Verify: z = r * (cos(theta) + i*sin(theta))\n  result = r * cmplx(cos(theta), sin(theta), dp)\n  print '(A,2F18.14)', 'Reconstructed z = ', result\n\n  ! Storage size\n  print '(A,I0,A)', 'Storage size: ', storage_size(z), ' bits'\n  print '(A,I0)', 'Kind value: ', kind(z)\n\nend program demo_complex_dp\n```\nResults:\n```text\nz =  3.00000000000000  4.00000000000000\nw =  1.00000000000000 -2.00000000000000\nr = |z| =  5.00000000000000\ntheta =  0.92729521800161\nReconstructed z =  3.00000000000000  4.00000000000000\nStorage size: 128 bits\nKind value: 8\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**cmplx**(3)](#cmplx),\n[**real**(3)](#real),\n[**aimag**(3)](#aimag),\n[**conjg**(3)](#conjg)",
  "omp barrier": "## barrier\n\n### **Name**\n\n**barrier** - \\[PARALLEL:OPENMP\\] Explicit thread synchronization barrier\n\n### **Synopsis**\n\n```fortran\n    !$omp barrier\n```\n\n```fortran\n    ! Stand-alone directive (no clauses)\n    !$omp barrier\n```\n\n### **Characteristics**\n\n - **Stand-alone directive** that takes no clauses or arguments.\n - **Binding** is to the innermost enclosing parallel region.\n - **All threads** in the current team must encounter the barrier.\n - **Implicit tasks** and explicit tasks bound to the parallel region must complete before any thread continues.\n\n### **Description**\n\n **barrier** specifies an explicit synchronization point at which all threads in the current team must wait. When a thread reaches the barrier directive, it halts execution until all other threads in the team have also reached the barrier. Once all threads arrive and complete any pending explicit tasks bound to the parallel region, they resume parallel execution of subsequent code.\n\n The barrier construct ensures that all work performed by threads before the barrier is visible to all threads after the barrier. This is essential for maintaining data consistency when threads need to share results from parallel computations.\n\n### **Options**\\n\\nNone. This is a stand-alone synchronization construct that accepts no clauses or arguments.\n\n### **Result**\n\n  When all threads have reached the barrier, the synchronization is complete. All memory operations performed before the barrier by any thread are guaranteed to be visible to all threads after the barrier. Execution resumes with all threads synchronized at the same point in the program. The barrier establishes a happens-before relationship between code preceding and following the barrier across all threads.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_omp_barrier\n  use omp_lib\n  implicit none\n  integer :: thread_id\n  integer, parameter :: n = 4\n  integer :: partial_sums(n)\n  integer :: total_sum\n  integer :: i\n\n  total_sum = 0\n\n  !$omp parallel num_threads(n) private(thread_id) shared(partial_sums, total_sum)\n    thread_id = omp_get_thread_num()\n\n    ! Each thread computes its partial sum\n    partial_sums(thread_id + 1) = (thread_id + 1) * 10\n    print '(A,I0,A,I0)', 'Thread ', thread_id, ' computed partial sum: ', partial_sums(thread_id + 1)\n\n    ! Wait for all threads to finish computing\n    !$omp barrier\n\n    ! Only thread 0 computes the total after all partial sums are ready\n    !$omp single\n      do i = 1, n\n        total_sum = total_sum + partial_sums(i)\n      end do\n      print '(A,I0)', 'Total sum after barrier: ', total_sum\n    !$omp end single\n  !$omp end parallel\n\nend program demo_omp_barrier\n```\n\nResults:\n```text\nThread 0 computed partial sum: 10\nThread 1 computed partial sum: 20\nThread 2 computed partial sum: 30\nThread 3 computed partial sum: 40\nTotal sum after barrier: 100\n```\n\n### **Standard**\n\nOpenMP 1.0 (1997 for Fortran)\n\n### **See Also**\n\n[**!$omp parallel**(3)](#omp_parallel),\n[**!$omp critical**(3)](#omp_critical),\n[**!$omp single**(3)](#omp_single),\n[**!$omp atomic**(3)](#omp_atomic),\n[**omp_get_thread_num**(3)](#omp_get_thread_num)\n\n### **Resources**\n\n- [OpenMP 5.0 Barrier Construct Specification](https://www.openmp.org/spec-html/5.0/openmpsu90.html)\n- [LLNL OpenMP Tutorial - Barrier Directive](https://hpc-tutorials.llnl.gov/openmp/barrier_directive/)\n- [OpenMP Official Site](https://www.openmp.org/)",
  "mpibcast": "## MPI_Bcast\n\n### **Name**\n\n**MPI_Bcast** - \\[PARALLEL:MPI\\] Broadcast a message from root to all processes in a communicator\n\n### **Synopsis**\n\n```fortran\n    call MPI_Bcast(buffer, count, datatype, root, comm, ierror)\n```\n\n```fortran\n     subroutine MPI_Bcast(buffer, count, datatype, root, comm, ierror)\n\n      type(*), dimension(..)    :: buffer\n      integer, intent(in)       :: count\n      type(MPI_Datatype), intent(in) :: datatype\n      integer, intent(in)       :: root\n      type(MPI_Comm), intent(in)     :: comm\n      integer, intent(out)      :: ierror\n```\n\n### **Characteristics**\n\n - **buffer** is a data buffer of any type and rank\n - **count** is an integer specifying the number of elements\n - **datatype** is an MPI datatype handle (e.g., MPI_DOUBLE_PRECISION, MPI_INTEGER)\n - **root** is an integer rank of the broadcasting process\n - **comm** is an MPI communicator handle\n - **ierror** returns the error status (0 for success)\n - All processes in the communicator must call this routine with identical arguments\n\n### **Description**\n\n **MPI_Bcast** broadcasts a message from the process with rank **root** to all\n other processes in the group, including itself. After the call, all processes\n in the communicator have identical copies of the buffer data. This is a\n collective operation that must be called by all processes in the communicator.\n\n### **Options**\n\n- **buffer**\n  : Starting address of the data buffer. On the root process, this contains\n  the data to be broadcast. On all other processes, this is where the\n  received data will be stored.\n\n- **count**\n  : Number of elements in the buffer. Must be non-negative and identical\n  on all processes.\n\n- **datatype**\n  : MPI datatype of each buffer element. Common values include:\n  MPI_INTEGER, MPI_REAL, MPI_DOUBLE_PRECISION, MPI_COMPLEX,\n  MPI_LOGICAL, MPI_CHARACTER. Must match on all processes.\n\n- **root**\n  : Rank of the process sending the broadcast (0 to comm_size-1).\n  Must be identical on all processes in the communicator.\n\n- **comm**\n  : MPI communicator defining the process group. Typically MPI_COMM_WORLD\n  for all processes, or a custom communicator for subgroups.\n\n- **ierror**\n  : Error status. Returns MPI_SUCCESS (0) on successful completion,\n  or an MPI error code on failure.\n\n\n\n### **Result**\n\n  After the call completes, all processes in the communicator have\n  identical copies of the data that was in the root process's buffer.\n  The buffer on the root process is unchanged; the buffers on all other\n  processes contain the broadcast data. This is a collective operation\n  that synchronizes all participating processes.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_mpi_bcast\n  use mpi\n  implicit none\n\n  integer :: ierr, rank, nprocs\n  integer :: root\n  real(8) :: value\n  real(8), dimension(4) :: array\n\n  ! Initialize MPI\n  call MPI_Init(ierr)\n  call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierr)\n  call MPI_Comm_size(MPI_COMM_WORLD, nprocs, ierr)\n\n  root = 0\n\n  ! Example 1: Broadcast a scalar\n  if (rank == root) then\n    value = 3.14159265358979d0\n    print '(A,I2,A,F12.8)', 'Process ', rank, ' (root) sending value: ', value\n  else\n    value = 0.0d0\n  end if\n\n  call MPI_Bcast(value, 1, MPI_DOUBLE_PRECISION, root, MPI_COMM_WORLD, ierr)\n\n  print '(A,I2,A,F12.8)', 'Process ', rank, ' received value: ', value\n\n  ! Example 2: Broadcast an array\n  if (rank == root) then\n    array = [1.0d0, 2.0d0, 3.0d0, 4.0d0]\n    print '(A,I2,A)', 'Process ', rank, ' (root) broadcasting array'\n  else\n    array = 0.0d0\n  end if\n\n  call MPI_Bcast(array, 4, MPI_DOUBLE_PRECISION, root, MPI_COMM_WORLD, ierr)\n\n  print '(A,I2,A,4F8.2)', 'Process ', rank, ' array: ', array\n\n  call MPI_Finalize(ierr)\nend program demo_mpi_bcast\n```\n\nResults (with 4 processes):\n\n```text\nProcess  0 (root) sending value:   3.14159265\nProcess  0 received value:   3.14159265\nProcess  1 received value:   3.14159265\nProcess  2 received value:   3.14159265\nProcess  3 received value:   3.14159265\nProcess  0 (root) broadcasting array\nProcess  0 array:     1.00    2.00    3.00    4.00\nProcess  1 array:     1.00    2.00    3.00    4.00\nProcess  2 array:     1.00    2.00    3.00    4.00\nProcess  3 array:     1.00    2.00    3.00    4.00\n```\n\nCompile with: `mpif90 demo_mpi_bcast.f90 -o demo_mpi_bcast`\n\nRun with: `mpirun -np 4 ./demo_mpi_bcast`\n\n### **Standard**\n\nMPI-1.0\n\n### **See Also**\n\n[**MPI_Ibcast**(3)](#mpi_ibcast),\n[**MPI_Scatter**(3)](#mpi_scatter),\n[**MPI_Gather**(3)](#mpi_gather),\n[**MPI_Allgather**(3)](#mpi_allgather),\n[**MPI_Reduce**(3)](#mpi_reduce),\n[**MPI_Allreduce**(3)](#mpi_allreduce),\n[**MPI_Comm_rank**(3)](#mpi_comm_rank),\n[**MPI_Comm_size**(3)](#mpi_comm_size)",
  "paramdp": "## parameter_dp\n\n### **Name**\n\n**parameter_dp** - \\[NUMERIC:KIND\\] Declare a named constant with double precision\n\n### **Synopsis**\n```fortran\n    real(dp), parameter :: name = value_dp\n```\n```fortran\n     ! Double precision parameter declaration\n\n      integer, parameter :: dp = selected_real_kind(15, 307)\n      real(dp), parameter :: PI = 3.14159265358979_dp\n```\n\n### **Characteristics**\n\n - Combines PARAMETER attribute with double precision kind.\n - Value must use _dp suffix to maintain full precision.\n - Cannot be modified after declaration.\n - Useful for mathematical and physical constants.\n\n### **Description**\n\n **parameter_dp** declares a named constant with double precision. The _dp\n suffix on the literal value is essential to ensure the constant is stored\n with full double precision rather than being truncated to single precision\n before conversion.\n\n### **Options**\n\n- **dp**\n  : The kind parameter for double precision, typically defined as\n  `selected_real_kind(15, 307)`.\n\n- **name**\n  : The identifier for the named constant.\n\n- **value_dp**\n  : The constant value with the _dp kind suffix to ensure full precision.\n\n### **Result**\n\n  A double precision named constant is declared with full 15-17 digit precision.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_parameter_dp\nimplicit none\n  integer, parameter :: dp = selected_real_kind(15, 307)\n\n  ! Mathematical constants with full precision\n  real(dp), parameter :: PI = 3.14159265358979323846_dp\n  real(dp), parameter :: E = 2.71828182845904523536_dp\n  real(dp), parameter :: SQRT2 = 1.41421356237309504880_dp\n  real(dp), parameter :: LN2 = 0.69314718055994530942_dp\n\n  ! Physical constants (SI units)\n  real(dp), parameter :: SPEED_OF_LIGHT = 299792458.0_dp        ! m/s\n  real(dp), parameter :: PLANCK = 6.62607015e-34_dp             ! J*s\n  real(dp), parameter :: BOLTZMANN = 1.380649e-23_dp            ! J/K\n  real(dp), parameter :: AVOGADRO = 6.02214076e23_dp            ! 1/mol\n\n  ! Derived constants\n  real(dp), parameter :: TWO_PI = 2.0_dp * PI\n  real(dp), parameter :: PI_SQUARED = PI * PI\n  real(dp), parameter :: HBAR = PLANCK / TWO_PI\n\n  real(dp) :: x, result\n\n  print '(A)', 'Mathematical constants:'\n  print '(A,F25.20)', 'PI      = ', PI\n  print '(A,F25.20)', 'e       = ', E\n  print '(A,F25.20)', 'sqrt(2) = ', SQRT2\n  print '(A,F25.20)', 'ln(2)   = ', LN2\n\n  print '(A)', ''\n  print '(A)', 'Physical constants:'\n  print '(A,ES15.8)', 'c (m/s)     = ', SPEED_OF_LIGHT\n  print '(A,ES15.8)', 'h (J*s)     = ', PLANCK\n  print '(A,ES15.8)', 'k_B (J/K)   = ', BOLTZMANN\n  print '(A,ES15.8)', 'N_A (1/mol) = ', AVOGADRO\n\n  ! Use in calculation\n  x = 1.0_dp\n  result = E ** x\n  print '(A,F20.16)', 'e^1 = ', result\n\nend program demo_parameter_dp\n```\nResults:\n```text\nMathematical constants:\nPI      =  3.14159265358979311600\ne       =  2.71828182845904509080\nsqrt(2) =  1.41421356237309514547\nln(2)   =  0.69314718055994528623\n\nPhysical constants:\nc (m/s)     =   2.99792458E+08\nh (J*s)     =   6.62607015E-34\nk_B (J/K)   =   1.38064900E-23\nN_A (1/mol) =   6.02214076E+23\ne^1 =  2.7182818284590451\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**parameter**(3)](#parameter),\n[**selected_real_kind**(3)](#selected_real_kind),\n[**kind**(3)](#kind)",
  "nmlwrite": "## namelist_write\n\n### **Name**\n\n**write** - \\[IO:NAMELIST\\] Write namelist group variables to a file or output unit\n\n### **Synopsis**\n```fortran\n    write(unit, nml=nml_name, iostat=ierr)\n```\n```fortran\n     write(unit=unit_num, nml=nml_name, iostat=ierr, iomsg=errmsg)\n\n      integer, intent(in)             :: unit_num  ! Output unit number\n      namelist /nml_name/             :: variables ! Namelist group\n      integer, intent(out), optional  :: ierr      ! I/O status\n      character(len=*), intent(inout), optional :: errmsg  ! Error message\n```\n\n### **Characteristics**\n\n - **unit** is a scalar integer representing an open file unit or * for stdout.\n - **nml_name** is the name of a previously declared namelist group.\n - **ierr** is an optional integer variable that receives the I/O status.\n - The file must be connected for formatted sequential access.\n - All variables in the namelist group are written to the output.\n\n### **Description**\n\n **write** with the NML= specifier outputs all variables in a namelist group in the standard namelist format. The output begins with `&nml_name`, lists each variable with its current value, and ends with `/`. This format can be read back using namelist READ, making it ideal for configuration files, checkpoints, and debugging output.\n\n### **Options**\n\n- **unit**\n  : The logical unit number of a file opened for formatted sequential writing, or * for standard output.\n\n- **nml=**\n  : The name of a namelist group previously defined with the NAMELIST statement.\n\n- **iostat=** (optional)\n  : Integer variable receiving I/O status. Zero indicates success.\n\n- **iomsg=** (optional)\n  : Character variable receiving error description on failure.\n\n### **Result**\n\n  The namelist group is written in standard namelist format that can be read back with namelist READ. Variable names and values are output in a human-readable and editable format.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_namelist_write\nimplicit none\n  ! Configuration variables\n  integer :: max_iterations\n  real :: tolerance\n  logical :: debug_mode\n  character(len=64) :: output_file\n  real :: grid_spacing(3)\n\n  ! Define namelist group\n  namelist /config/ max_iterations, tolerance, debug_mode, output_file, grid_spacing\n\n  integer :: unit_num, ierr\n  character(len=256) :: errmsg\n\n  ! Set values\n  max_iterations = 1000\n  tolerance = 1.0e-8\n  debug_mode = .true.\n  output_file = 'results.dat'\n  grid_spacing = [0.1, 0.1, 0.05]\n\n  ! Write namelist to standard output\n  print '(A)', 'Namelist output to screen:'\n  write(*, nml=config)\n\n  ! Write namelist to file\n  open(newunit=unit_num, file='config.nml', status='replace', &\n       action='write', iostat=ierr, iomsg=errmsg)\n  if (ierr /= 0) then\n    print *, 'Error opening file: ', trim(errmsg)\n    error stop\n  end if\n\n  write(unit_num, nml=config, iostat=ierr)\n  if (ierr /= 0) then\n    print *, 'Error writing namelist'\n  else\n    print '(A)', 'Namelist written to config.nml'\n  end if\n\n  close(unit_num)\n\n  ! Display file contents\n  print '(A)', 'File contents:'\n  open(newunit=unit_num, file='config.nml', status='old', action='read')\n  block\n    character(len=200) :: line\n    do\n      read(unit_num, '(A)', iostat=ierr) line\n      if (ierr /= 0) exit\n      print '(A)', trim(line)\n    end do\n  end block\n  close(unit_num, status='delete')\n\nend program demo_namelist_write\n```\nResults:\n```text\nNamelist output to screen:\n&CONFIG\n MAX_ITERATIONS=        1000,\n TOLERANCE=  1.00000001E-08,\n DEBUG_MODE=T,\n OUTPUT_FILE=\"results.dat\",\n GRID_SPACING= 0.100000001    , 0.100000001    , 5.00000007E-02,\n /\nNamelist written to config.nml\nFile contents:\n&CONFIG\n MAX_ITERATIONS=        1000,\n TOLERANCE=  1.00000001E-08,\n DEBUG_MODE=T,\n OUTPUT_FILE=\"results.dat\",\n GRID_SPACING= 0.100000001    , 0.100000001    , 5.00000007E-02,\n /\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**namelist_read**(3)](#namelist_read),\n[**write**(3)](#write),\n[**open**(3)](#open),\n[**inquire**(3)](#inquire)",
  "mpiinit": "## MPI_Init\n\n### **Name**\n\n**MPI_Init** - \\[PARALLEL:MPI\\] Initialize the MPI execution environment\n\n### **Synopsis**\n\n```fortran\n    call MPI_Init(ierror)\n```\n\n```fortran\n     subroutine MPI_Init(ierror)\n\n      integer, intent(out), optional :: ierror\n```\n\n### **Characteristics**\n\n - **ierror** is an optional integer that returns the error status (0 for success).\n - Must be called before any other MPI routine except MPI_Initialized.\n - Can only be called once per program execution.\n - All MPI programs must call MPI_Init before using MPI functionality.\n - The MPI_F08 module provides the modern Fortran interface with optional ierror.\n\n### **Description**\n\n **MPI_Init** initializes the MPI execution environment. This function must\n be called before any other MPI function (except MPI_Initialized and\n MPI_Get_library_version). It establishes the MPI execution environment,\n including setting up internal data structures, establishing communication\n with other MPI processes, and preparing for message passing operations.\n\n### **Options**\n\n- **ierror**\n  : Integer error code. Returns MPI_SUCCESS (0) on successful initialization.\n  In the mpi_f08 module, this argument is optional. If omitted and an error\n  occurs, the program will abort.\n\n### **Result**\n\n  After successful completion, the MPI environment is initialized and ready\n  for use. The program can then call MPI_Comm_rank, MPI_Comm_size, and other\n  MPI routines. The predefined communicator MPI_COMM_WORLD becomes available,\n  containing all processes in the MPI job.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_mpi_init\n  use mpi_f08\n  implicit none\n  integer :: rank, nprocs, ierr\n\n  ! Initialize MPI environment\n  call MPI_Init(ierr)\n  if (ierr /= MPI_SUCCESS) then\n    print *, 'Error initializing MPI'\n    stop 1\n  end if\n\n  ! Get process rank and total number of processes\n  call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierr)\n  call MPI_Comm_size(MPI_COMM_WORLD, nprocs, ierr)\n\n  print '(A,I0,A,I0)', 'Hello from process ', rank, ' of ', nprocs\n\n  ! Finalize MPI environment\n  call MPI_Finalize(ierr)\n\nend program demo_mpi_init\n```\n\nResults (with 4 processes):\n\n```text\nHello from process 0 of 4\nHello from process 1 of 4\nHello from process 2 of 4\nHello from process 3 of 4\n```\n\n### **Standard**\n\nMPI-1.0\n\n### **See Also**\n\n[**MPI_Finalize**(3)](#mpi_finalize),\n[**MPI_Initialized**(3)](#mpi_initialized),\n[**MPI_Comm_rank**(3)](#mpi_comm_rank),\n[**MPI_Comm_size**(3)](#mpi_comm_size),\n[**MPI_Abort**(3)](#mpi_abort)",
  "arraycon2d": "## arraycon2d\n\n### **Name**\n\n**arraycon2d** - \\[ARRAY:CONSTRUCTION\\] Construct a 2D array using nested implied-do loops\n\n### **Synopsis**\n```fortran\n    array = reshape([((expr, i=1,m), j=1,n)], [m, n])\n```\n```fortran\n     array_2d = reshape([((expression(i,j), i=1,rows), j=1,cols)], [rows, cols])\n\n      type(TYPE(kind=**))             :: array_2d(rows, cols)\n      type(TYPE(kind=**))             :: expression\n      integer                         :: i, j, rows, cols\n```\n\n### **Characteristics**\n\n - **array_2d** is a rank-2 array of any intrinsic or derived type.\n - **expression** is evaluated for each combination of loop indices.\n - **i, j** are the implied-do loop variables.\n - **rows, cols** are the array dimensions.\n - The inner loop (i) varies fastest, filling columns.\n - RESHAPE reorders the rank-1 constructor result into rank-2.\n\n### **Description**\n\n **Array constructor 2D** creates a two-dimensional array by combining\n an array constructor with nested implied-do loops and the RESHAPE\n intrinsic. The implied-do loops generate a rank-1 sequence of values,\n which RESHAPE then arranges into a rank-2 array with the specified shape.\n The inner loop index varies fastest (column-major order), matching\n Fortran's native array storage.\n\n### **Options**\n\n- **expression**\n  : Any expression involving the loop indices i and j. Can be a formula,\n  function call, or any valid Fortran expression.\n\n- **i**\n  : Inner loop variable, controls row position. Varies from 1 to rows.\n\n- **j**\n  : Outer loop variable, controls column position. Varies from 1 to cols.\n\n- **rows**\n  : Number of rows in the resulting array (first dimension).\n\n- **cols**\n  : Number of columns in the resulting array (second dimension).\n\n### **Result**\n\n  A rank-2 array with shape [rows, cols] containing the evaluated\n  expression for each index pair. Elements are stored in column-major\n  order (Fortran default).\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_arraycon2d\n  use, intrinsic :: iso_fortran_env, only: dp => real64\n  implicit none\n\n  integer :: i, j\n  integer :: int_matrix(3, 4)\n  real(dp) :: real_matrix(4, 5)\n  real(dp) :: identity(3, 3)\n\n  ! Create matrix with values i*10 + j\n  int_matrix = reshape([((i*10 + j, i=1,3), j=1,4)], [3, 4])\n\n  print *, 'Integer matrix (3x4):'\n  do i = 1, 3\n    print '(4I5)', int_matrix(i, :)\n  end do\n\n  ! Create matrix with real values\n  real_matrix = reshape([((real(i, dp) / real(j, dp), i=1,4), j=1,5)], [4, 5])\n\n  print *\n  print *, 'Real matrix (4x5):'\n  do i = 1, 4\n    print '(5F8.3)', real_matrix(i, :)\n  end do\n\n  ! Create identity matrix using merge\n  identity = reshape([((merge(1.0_dp, 0.0_dp, i==j), i=1,3), j=1,3)], [3, 3])\n\n  print *\n  print *, 'Identity matrix (3x3):'\n  do i = 1, 3\n    print '(3F6.1)', identity(i, :)\n  end do\n\nend program demo_arraycon2d\n```\nResults:\n```text\n Integer matrix (3x4):\n   11   12   13   14\n   21   22   23   24\n   31   32   33   34\n\n Real matrix (4x5):\n   1.000   0.500   0.333   0.250   0.200\n   2.000   1.000   0.667   0.500   0.400\n   3.000   1.500   1.000   0.750   0.600\n   4.000   2.000   1.333   1.000   0.800\n\n Identity matrix (3x3):\n   1.0   0.0   0.0\n   0.0   1.0   0.0\n   0.0   0.0   1.0\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**reshape**](#reshape),\n[**arraycon**](#arraycon),\n[**spread**](#spread),\n[**merge**](#merge)",
  "mpi_init": "## MPI_Init\n\n### **Name**\n\n**MPI_Init** - \\[PARALLEL:MPI\\] Initialize the MPI execution environment\n\n### **Synopsis**\n\n```fortran\n    call MPI_Init(ierror)\n```\n\n```fortran\n     subroutine MPI_Init(ierror)\n\n      integer, intent(out), optional :: ierror\n```\n\n### **Characteristics**\n\n - **ierror** is an optional integer that returns the error status (0 for success).\n - Must be called before any other MPI routine except MPI_Initialized.\n - Can only be called once per program execution.\n - All MPI programs must call MPI_Init before using MPI functionality.\n - The MPI_F08 module provides the modern Fortran interface with optional ierror.\n\n### **Description**\n\n **MPI_Init** initializes the MPI execution environment. This function must\n be called before any other MPI function (except MPI_Initialized and\n MPI_Get_library_version). It establishes the MPI execution environment,\n including setting up internal data structures, establishing communication\n with other MPI processes, and preparing for message passing operations.\n\n### **Options**\n\n- **ierror**\n  : Integer error code. Returns MPI_SUCCESS (0) on successful initialization.\n  In the mpi_f08 module, this argument is optional. If omitted and an error\n  occurs, the program will abort.\n\n### **Result**\n\n  After successful completion, the MPI environment is initialized and ready\n  for use. The program can then call MPI_Comm_rank, MPI_Comm_size, and other\n  MPI routines. The predefined communicator MPI_COMM_WORLD becomes available,\n  containing all processes in the MPI job.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_mpi_init\n  use mpi_f08\n  implicit none\n  integer :: rank, nprocs, ierr\n\n  ! Initialize MPI environment\n  call MPI_Init(ierr)\n  if (ierr /= MPI_SUCCESS) then\n    print *, 'Error initializing MPI'\n    stop 1\n  end if\n\n  ! Get process rank and total number of processes\n  call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierr)\n  call MPI_Comm_size(MPI_COMM_WORLD, nprocs, ierr)\n\n  print '(A,I0,A,I0)', 'Hello from process ', rank, ' of ', nprocs\n\n  ! Finalize MPI environment\n  call MPI_Finalize(ierr)\n\nend program demo_mpi_init\n```\n\nResults (with 4 processes):\n\n```text\nHello from process 0 of 4\nHello from process 1 of 4\nHello from process 2 of 4\nHello from process 3 of 4\n```\n\n### **Standard**\n\nMPI-1.0\n\n### **See Also**\n\n[**MPI_Finalize**(3)](#mpi_finalize),\n[**MPI_Initialized**(3)](#mpi_initialized),\n[**MPI_Comm_rank**(3)](#mpi_comm_rank),\n[**MPI_Comm_size**(3)](#mpi_comm_size),\n[**MPI_Abort**(3)](#mpi_abort)",
  "getenv": "## get_environment_variable\n\n### **Name**\n\n**get_environment_variable** - \\[SYSTEM:ENVIRONMENT\\] Retrieve the value of an environment variable\n\n### **Synopsis**\n```fortran\n    call get_environment_variable(name [,value] [,length] [,status] [,trim_name] [,errmsg])\n```\n```fortran\n     subroutine get_environment_variable(name, value, length, status, trim_name, errmsg)\n\n      character(len=*), intent(in)            :: name\n      character(len=*), intent(out), optional :: value\n      integer, intent(out), optional          :: length\n      integer, intent(out), optional          :: status\n      logical, intent(in), optional           :: trim_name\n      character(len=*), intent(inout), optional :: errmsg\n```\n\n### **Characteristics**\n\n - **name** is the environment variable name to query.\n - **value** receives the variable's value if it exists.\n - **status** indicates success or type of failure.\n - Returns empty string if variable is not set.\n\n### **Description**\n\n **get_environment_variable** retrieves the value of an environment variable\n from the operating system. This is useful for configuration, reading paths,\n and adapting program behavior to the environment.\n\n### **Options**\n\n- **name**\n  : Character string specifying the environment variable name.\n\n- **value**\n  : Optional. Character variable to receive the value. If variable doesn't\n  exist, receives blanks.\n\n- **length**\n  : Optional. Returns the actual length of the value, or 0 if not set.\n\n- **status**\n  : Optional. Returns: 0 = success, 1 = variable not set, 2 = processor doesn't\n  support environment variables, -1 = value was truncated.\n\n- **trim_name**\n  : Optional. If .true., trailing blanks in name are significant. Default .true.\n\n- **errmsg**\n  : Optional. Returns error message on failure.\n\n### **Result**\n\n  The environment variable value is returned in the value argument.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_get_environment_variable\nimplicit none\n  character(len=256) :: value\n  character(len=256) :: errmsg\n  integer :: length, status\n\n  ! Get HOME directory\n  call get_environment_variable('HOME', value, length, status)\n  if (status == 0) then\n    print '(A,A)', 'HOME = ', trim(value)\n    print '(A,I0)', 'Length = ', length\n  else if (status == 1) then\n    print '(A)', 'HOME is not set'\n  end if\n\n  ! Get PATH\n  call get_environment_variable('PATH', value, length, status)\n  if (status == 0) then\n    print '(A,I0,A)', 'PATH has ', length, ' characters'\n    print '(A,A,A)', 'PATH = ', value(1:min(50,length)), '...'\n  else if (status == -1) then\n    print '(A)', 'PATH was truncated (very long)'\n  end if\n\n  ! Check for optional variable\n  call get_environment_variable('MY_APP_CONFIG', value, status=status)\n  select case (status)\n  case (0)\n    print '(A,A)', 'MY_APP_CONFIG = ', trim(value)\n  case (1)\n    print '(A)', 'MY_APP_CONFIG not set, using defaults'\n  case (2)\n    print '(A)', 'Environment variables not supported'\n  end select\n\n  ! Get current user\n  call get_environment_variable('USER', value, status=status)\n  if (status == 0) then\n    print '(A,A)', 'Current user: ', trim(value)\n  end if\n\nend program demo_get_environment_variable\n```\nResults:\n```text\nHOME = /home/user\nLength = 10\nPATH has 1500 characters\nPATH = /usr/local/bin:/usr/bin:/bin:/usr/local/games...\nMY_APP_CONFIG not set, using defaults\nCurrent user: user\n```\n\n### **Standard**\n\nFortran 2003\n\n**Compatibility Notes:**\n- gfortran 4.0+, Intel Fortran 9.0+, NAG 5.0+\n- Use STATUS= to detect undefined variables\n- Variable names are case-sensitive on Unix\n\n### **See Also**\n\n[**command_argument_count**(3)](#command_argument_count),\n[**get_command_argument**(3)](#get_command_argument)",
  "null": "## null\n\n### **Name**\n\n**null** - \\[TYPE:POINTER\\] Return a disassociated pointer or unallocated allocatable\n\n### **Synopsis**\n```fortran\n    pointer => null()\n    pointer => null(mold)\n```\n```fortran\n     function null(mold) result(ptr)\n\n      type(*), pointer, optional :: mold\n      type(*), pointer           :: ptr\n```\n\n### **Characteristics**\n\n - Returns a disassociated pointer of the appropriate type.\n - **mold** argument determines the type if needed for resolution.\n - Commonly used for pointer initialization.\n - Can initialize pointer components in derived types.\n\n### **Description**\n\n **null** returns a disassociated pointer. It is primarily used to initialize\n pointers to a known disassociated state, either in declarations or executable\n statements. The optional mold argument allows type specification when needed\n for generic resolution.\n\n### **Options**\n\n- **mold**\n  : Optional. A pointer of the desired type. Only the type is used; the\n  association status and value are irrelevant. Used to resolve ambiguous\n  generic interfaces.\n\n### **Result**\n\n  A disassociated pointer of the appropriate type. The pointer's association\n  status is \"disassociated\" (not \"undefined\").\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_null\nimplicit none\n  ! Pointer declarations with null initialization\n  integer, pointer :: int_ptr => null()\n  real, pointer :: real_ptr => null()\n  real, pointer :: array_ptr(:) => null()\n\n  ! Derived type with pointer component\n  type :: linked_node\n    integer :: value\n    type(linked_node), pointer :: next => null()\n  end type linked_node\n\n  type(linked_node), pointer :: head => null()\n  type(linked_node), pointer :: current\n\n  ! Targets\n  integer, target :: i = 42\n  real, target :: x = 3.14\n  real, target :: arr(5) = [1.0, 2.0, 3.0, 4.0, 5.0]\n\n  ! Check initial association status\n  print '(A,L1)', 'int_ptr initially associated: ', associated(int_ptr)\n  print '(A,L1)', 'real_ptr initially associated: ', associated(real_ptr)\n\n  ! Associate pointers with targets\n  int_ptr => i\n  real_ptr => x\n  array_ptr => arr\n\n  print '(A,L1)', 'int_ptr now associated: ', associated(int_ptr)\n  print '(A,I0)', 'int_ptr value: ', int_ptr\n\n  ! Disassociate using null()\n  int_ptr => null()\n  print '(A,L1)', 'int_ptr after null(): ', associated(int_ptr)\n\n  ! Create linked list\n  allocate(head)\n  head%value = 1\n  head%next => null()  ! Explicit null for clarity\n\n  allocate(head%next)\n  head%next%value = 2\n  head%next%next => null()\n\n  ! Traverse list\n  print '(A)', 'Linked list values:'\n  current => head\n  do while (associated(current))\n    print '(I3)', current%value\n    current => current%next\n  end do\n\n  ! Cleanup\n  deallocate(head%next)\n  deallocate(head)\n\nend program demo_null\n```\nResults:\n```text\nint_ptr initially associated: F\nreal_ptr initially associated: F\nint_ptr now associated: T\nint_ptr value: 42\nint_ptr after null(): F\nLinked list values:\n  1\n  2\n```\n\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**associated**(3)](#associated),\n[**nullify**(3)](#nullify),\n[**pointer**(3)](#pointer)",
  "allocmat": "## alloc2d\n\n### **Name**\n\n**allocate_2d** - \\[ARRAY:ALLOCATION\\] Dynamically allocate a rank-2 (matrix) array with error handling\n\n### **Synopsis**\n```fortran\n    allocate(array_name(rows, cols), stat=status_variable)\n    if (status_variable /= 0) error stop 'Allocation failed'\n```\n```fortran\n     allocate(matrix(lower1:upper1, lower2:upper2), stat=ierr, errmsg=msg)\n\n      type(TYPE(kind=**)), allocatable :: matrix(:,:)\n      integer                          :: ierr\n      character(len=*)                 :: msg\n```\n\n### **Characteristics**\n\n - **array_name** must be declared with the ALLOCATABLE attribute and assumed-shape bounds (:,:).\n - **rows** and **cols** (or lower:upper bounds) must be scalar integer expressions.\n - **status_variable** must be a scalar default integer variable.\n - The array must not already be allocated when ALLOCATE is executed.\n - Custom lower bounds can be specified using lower:upper syntax.\n - Allocatable arrays are automatically deallocated when they go out of scope.\n\n### **Description**\n\n **allocate** for 2D arrays creates a rank-2 array with specified row and\n column dimensions. This is the standard pattern for dynamically sized\n matrices in Fortran. Always use STAT= for production code to handle\n potential allocation failures gracefully. The error stop with a message\n provides immediate feedback if allocation fails.\n\n### **Options**\n\n- **array_name**\n  : The 2D allocatable array to be allocated. Must be declared as\n  `type, allocatable :: name(:,:)`.\n\n- **rows, cols**\n  : Integer expressions specifying the extent of each dimension.\n  Use lower:upper syntax for custom bounds.\n\n- **stat**\n  : Optional but recommended. Integer variable set to zero on success.\n\n- **errmsg**\n  : Optional. Character variable for descriptive error message.\n\n### **Result**\n\n  A rank-2 array is allocated with the specified shape. The array elements\n  are undefined until assigned. If stat is present and allocation succeeds,\n  it is set to zero.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_alloc2d\n  use, intrinsic :: iso_fortran_env, only: dp => real64\n  implicit none\n\n  real(dp), allocatable :: matrix(:,:)\n  real(dp), allocatable :: grid(:,:)\n  integer :: rows, cols, ierr, i, j\n  character(len=100) :: errmsg\n\n  rows = 3\n  cols = 4\n\n  ! Basic allocation\n  allocate(matrix(rows, cols), stat=ierr)\n  if (ierr /= 0) error stop 'Matrix allocation failed'\n\n  ! Initialize with values\n  matrix = reshape([((i*10 + j, i=1,rows), j=1,cols)], [rows, cols])\n\n  print *, 'Matrix shape:', shape(matrix)\n  print *, 'Matrix contents:'\n  do i = 1, rows\n    print '(4F8.1)', matrix(i, :)\n  end do\n\n  ! Allocation with custom bounds\n  allocate(grid(-1:1, 0:5), stat=ierr, errmsg=errmsg)\n  if (ierr /= 0) error stop errmsg\n\n  print *, 'Grid bounds:', lbound(grid), 'to', ubound(grid)\n\n  deallocate(matrix, grid)\n\nend program demo_alloc2d\n```\nResults:\n```text\n Matrix shape:           3           4\n Matrix contents:\n    11.0    12.0    13.0    14.0\n    21.0    22.0    23.0    24.0\n    31.0    32.0    33.0    34.0\n Grid bounds:          -1           0 to           1           5\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**allocate**](#allocate),\n[**deallocate**](#deallocate),\n[**shape**](#shape),\n[**size**](#size),\n[**allocated**](#allocated)",
  "nullptr": "## null\n\n### **Name**\n\n**null** - \\[TYPE:POINTER\\] Return a disassociated pointer or unallocated allocatable\n\n### **Synopsis**\n```fortran\n    pointer => null()\n    pointer => null(mold)\n```\n```fortran\n     function null(mold) result(ptr)\n\n      type(*), pointer, optional :: mold\n      type(*), pointer           :: ptr\n```\n\n### **Characteristics**\n\n - Returns a disassociated pointer of the appropriate type.\n - **mold** argument determines the type if needed for resolution.\n - Commonly used for pointer initialization.\n - Can initialize pointer components in derived types.\n\n### **Description**\n\n **null** returns a disassociated pointer. It is primarily used to initialize\n pointers to a known disassociated state, either in declarations or executable\n statements. The optional mold argument allows type specification when needed\n for generic resolution.\n\n### **Options**\n\n- **mold**\n  : Optional. A pointer of the desired type. Only the type is used; the\n  association status and value are irrelevant. Used to resolve ambiguous\n  generic interfaces.\n\n### **Result**\n\n  A disassociated pointer of the appropriate type. The pointer's association\n  status is \"disassociated\" (not \"undefined\").\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_null\nimplicit none\n  ! Pointer declarations with null initialization\n  integer, pointer :: int_ptr => null()\n  real, pointer :: real_ptr => null()\n  real, pointer :: array_ptr(:) => null()\n\n  ! Derived type with pointer component\n  type :: linked_node\n    integer :: value\n    type(linked_node), pointer :: next => null()\n  end type linked_node\n\n  type(linked_node), pointer :: head => null()\n  type(linked_node), pointer :: current\n\n  ! Targets\n  integer, target :: i = 42\n  real, target :: x = 3.14\n  real, target :: arr(5) = [1.0, 2.0, 3.0, 4.0, 5.0]\n\n  ! Check initial association status\n  print '(A,L1)', 'int_ptr initially associated: ', associated(int_ptr)\n  print '(A,L1)', 'real_ptr initially associated: ', associated(real_ptr)\n\n  ! Associate pointers with targets\n  int_ptr => i\n  real_ptr => x\n  array_ptr => arr\n\n  print '(A,L1)', 'int_ptr now associated: ', associated(int_ptr)\n  print '(A,I0)', 'int_ptr value: ', int_ptr\n\n  ! Disassociate using null()\n  int_ptr => null()\n  print '(A,L1)', 'int_ptr after null(): ', associated(int_ptr)\n\n  ! Create linked list\n  allocate(head)\n  head%value = 1\n  head%next => null()  ! Explicit null for clarity\n\n  allocate(head%next)\n  head%next%value = 2\n  head%next%next => null()\n\n  ! Traverse list\n  print '(A)', 'Linked list values:'\n  current => head\n  do while (associated(current))\n    print '(I3)', current%value\n    current => current%next\n  end do\n\n  ! Cleanup\n  deallocate(head%next)\n  deallocate(head)\n\nend program demo_null\n```\nResults:\n```text\nint_ptr initially associated: F\nreal_ptr initially associated: F\nint_ptr now associated: T\nint_ptr value: 42\nint_ptr after null(): F\nLinked list values:\n  1\n  2\n```\n\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**associated**(3)](#associated),\n[**nullify**(3)](#nullify),\n[**pointer**(3)](#pointer)",
  "alloc2d": "## alloc2d\n\n### **Name**\n\n**allocate_2d** - \\[ARRAY:ALLOCATION\\] Dynamically allocate a rank-2 (matrix) array with error handling\n\n### **Synopsis**\n```fortran\n    allocate(array_name(rows, cols), stat=status_variable)\n    if (status_variable /= 0) error stop 'Allocation failed'\n```\n```fortran\n     allocate(matrix(lower1:upper1, lower2:upper2), stat=ierr, errmsg=msg)\n\n      type(TYPE(kind=**)), allocatable :: matrix(:,:)\n      integer                          :: ierr\n      character(len=*)                 :: msg\n```\n\n### **Characteristics**\n\n - **array_name** must be declared with the ALLOCATABLE attribute and assumed-shape bounds (:,:).\n - **rows** and **cols** (or lower:upper bounds) must be scalar integer expressions.\n - **status_variable** must be a scalar default integer variable.\n - The array must not already be allocated when ALLOCATE is executed.\n - Custom lower bounds can be specified using lower:upper syntax.\n - Allocatable arrays are automatically deallocated when they go out of scope.\n\n### **Description**\n\n **allocate** for 2D arrays creates a rank-2 array with specified row and\n column dimensions. This is the standard pattern for dynamically sized\n matrices in Fortran. Always use STAT= for production code to handle\n potential allocation failures gracefully. The error stop with a message\n provides immediate feedback if allocation fails.\n\n### **Options**\n\n- **array_name**\n  : The 2D allocatable array to be allocated. Must be declared as\n  `type, allocatable :: name(:,:)`.\n\n- **rows, cols**\n  : Integer expressions specifying the extent of each dimension.\n  Use lower:upper syntax for custom bounds.\n\n- **stat**\n  : Optional but recommended. Integer variable set to zero on success.\n\n- **errmsg**\n  : Optional. Character variable for descriptive error message.\n\n### **Result**\n\n  A rank-2 array is allocated with the specified shape. The array elements\n  are undefined until assigned. If stat is present and allocation succeeds,\n  it is set to zero.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_alloc2d\n  use, intrinsic :: iso_fortran_env, only: dp => real64\n  implicit none\n\n  real(dp), allocatable :: matrix(:,:)\n  real(dp), allocatable :: grid(:,:)\n  integer :: rows, cols, ierr, i, j\n  character(len=100) :: errmsg\n\n  rows = 3\n  cols = 4\n\n  ! Basic allocation\n  allocate(matrix(rows, cols), stat=ierr)\n  if (ierr /= 0) error stop 'Matrix allocation failed'\n\n  ! Initialize with values\n  matrix = reshape([((i*10 + j, i=1,rows), j=1,cols)], [rows, cols])\n\n  print *, 'Matrix shape:', shape(matrix)\n  print *, 'Matrix contents:'\n  do i = 1, rows\n    print '(4F8.1)', matrix(i, :)\n  end do\n\n  ! Allocation with custom bounds\n  allocate(grid(-1:1, 0:5), stat=ierr, errmsg=errmsg)\n  if (ierr /= 0) error stop errmsg\n\n  print *, 'Grid bounds:', lbound(grid), 'to', ubound(grid)\n\n  deallocate(matrix, grid)\n\nend program demo_alloc2d\n```\nResults:\n```text\n Matrix shape:           3           4\n Matrix contents:\n    11.0    12.0    13.0    14.0\n    21.0    22.0    23.0    24.0\n    31.0    32.0    33.0    34.0\n Grid bounds:          -1           0 to           1           5\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**allocate**](#allocate),\n[**deallocate**](#deallocate),\n[**shape**](#shape),\n[**size**](#size),\n[**allocated**](#allocated)",
  "modprivate": "## module_private\n\n### **Name**\n\n**module_private** - \\[STRUCTURE:MODULE\\] Module with private default and explicit public exports\n\n### **Synopsis**\n```fortran\n    module module_name\n      implicit none\n      private\n      public :: public_entity\n      ! declarations\n    contains\n      ! procedures\n    end module module_name\n```\n```fortran\n     module module_name\n\n      implicit none\n      private                    ! Default visibility is private\n      public :: exported_var     ! Explicitly export public entities\n      public :: exported_type\n      public :: exported_proc\n\n      integer :: internal_var    ! Private by default\n      integer :: exported_var    ! Public via explicit declaration\n\n     contains\n\n      subroutine exported_proc() ! Public via explicit declaration\n      end subroutine\n\n      subroutine internal_proc() ! Private by default\n      end subroutine\n\n     end module module_name\n```\n\n### **Characteristics**\n\n - **module_name** is a valid Fortran identifier for the module.\n - **private** statement sets default visibility to private for all entities.\n - **public** statement explicitly exports selected entities.\n - All module entities are private unless explicitly declared public.\n - Provides encapsulation by hiding implementation details.\n\n### **Description**\n\n **module_private** creates a module with private default visibility where\n all module entities (variables, types, procedures) are private unless\n explicitly exported via the `public` statement. This pattern follows the\n principle of information hiding and encapsulation, exposing only the\n intended public interface while keeping implementation details hidden\n from module users.\n\n### **Options**\n\n- **module_name**\n  : The identifier for the module. Must be a valid Fortran name starting\n  with a letter and containing only letters, digits, and underscores.\n\n- **public_entity**\n  : One or more entities to export from the module. Can be variables,\n  parameters, derived types, or procedure names. Multiple entities can\n  be listed comma-separated or in multiple public statements.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_module_private\n  use vector_math, only: vector_t, vector_add, vector_magnitude\n  implicit none\n\n  type(vector_t) :: v1, v2, v3\n\n  ! Initialize vectors using public constructor\n  v1 = vector_t(1.0, 2.0, 3.0)\n  v2 = vector_t(4.0, 5.0, 6.0)\n\n  ! Use public procedures\n  v3 = vector_add(v1, v2)\n  print '(A,3F8.3)', 'Sum vector: ', v3%x, v3%y, v3%z\n  print '(A,F8.3)', 'Magnitude:  ', vector_magnitude(v3)\n\nend program demo_module_private\n\nmodule vector_math\n  implicit none\n  private\n  public :: vector_t, vector_add, vector_magnitude\n\n  type :: vector_t\n    real :: x = 0.0\n    real :: y = 0.0\n    real :: z = 0.0\n  end type vector_t\n\n  ! Internal constant - not exported\n  real, parameter :: tolerance = 1.0e-10\n\ncontains\n\n  pure function vector_add(a, b) result(c)\n    type(vector_t), intent(in) :: a, b\n    type(vector_t) :: c\n    c%x = a%x + b%x\n    c%y = a%y + b%y\n    c%z = a%z + b%z\n  end function vector_add\n\n  pure function vector_magnitude(v) result(mag)\n    type(vector_t), intent(in) :: v\n    real :: mag\n    mag = sqrt(v%x**2 + v%y**2 + v%z**2)\n  end function vector_magnitude\n\n  ! Internal helper - not exported\n  pure function is_zero_vector(v) result(is_zero)\n    type(vector_t), intent(in) :: v\n    logical :: is_zero\n    is_zero = vector_magnitude(v) < tolerance\n  end function is_zero_vector\n\nend module vector_math\n```\nResults:\n```text\n    Sum vector:    5.000   7.000   9.000\n    Magnitude:    12.449\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**module**(3)](#module),\n[**use**(3)](#use),\n[**private**(3)](#private),\n[**public**(3)](#public),\n[**protected**(3)](#protected)",
  "enum": "## enum\n\n### **Name**\n\n**enum** - \\[STRUCTURE:TYPE\\] Define a C-interoperable enumeration type\n\n### **Synopsis**\n```fortran\n    enum, bind(c)\n      enumerator :: name1 = value\n      enumerator :: name2\n    end enum\n```\n```fortran\n     enum, bind(c)\n\n      enumerator :: name1 = value    ! Explicit value assignment\n      enumerator :: name2            ! Auto-incremented value\n      enumerator :: name3, name4     ! Multiple enumerators\n     end enum\n```\n\n### **Characteristics**\n\n - **enum, bind(c)** declares a C-interoperable enumeration block.\n - **enumerator** declares named integer constants within the enum.\n - Each enumerator has type integer with a kind that is interoperable with a C enumeration type.\n - Values auto-increment from the previous enumerator if not explicitly assigned.\n - The first enumerator defaults to 0 if no value is specified.\n\n### **Description**\n\n **enum** defines an enumeration type that is interoperable with C enum types. The `bind(c)` attribute is required and ensures the enumerators have compatible integer kinds with C. Enumerators are named constants whose values can be explicitly set or automatically assigned by incrementing from the previous value.\n\n### **Options**\n\n- **bind(c)**\n  : Required attribute that specifies C interoperability. Ensures the enumeration uses an integer kind compatible with C enum types.\n\n- **enumerator**\n  : Keyword used to declare each named constant in the enumeration. Multiple enumerators can be declared on a single line separated by commas.\n\n- **name = value**\n  : Assigns an explicit integer value to the enumerator. If omitted, the value is one greater than the previous enumerator (or 0 for the first).\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_enum\nimplicit none\n\n  ! Define color enumeration\n  enum, bind(c)\n    enumerator :: RED = 1\n    enumerator :: GREEN = 2\n    enumerator :: BLUE = 4\n  end enum\n\n  ! Define status codes with auto-increment\n  enum, bind(c)\n    enumerator :: STATUS_OK = 0\n    enumerator :: STATUS_WARNING      ! = 1 (auto)\n    enumerator :: STATUS_ERROR        ! = 2 (auto)\n    enumerator :: STATUS_CRITICAL     ! = 3 (auto)\n  end enum\n\n  ! Define multiple enumerators on one line\n  enum, bind(c)\n    enumerator :: NORTH = 0, EAST = 90, SOUTH = 180, WEST = 270\n  end enum\n\n  integer :: current_color\n  integer :: status\n  integer :: direction\n\n  current_color = GREEN\n  status = STATUS_WARNING\n  direction = EAST\n\n  print '(A,I0)', 'Color value: ', current_color\n  print '(A,I0)', 'Status value: ', status\n  print '(A,I0)', 'Direction value: ', direction\n\n  ! Use in conditional\n  if (status > STATUS_OK) then\n    print '(A)', 'Non-OK status detected'\n  end if\n\nend program demo_enum\n```\nResults:\n```text\nColor value: 2\nStatus value: 1\nDirection value: 90\nNon-OK status detected\n```\n\n### **Standard**\n\nFortran 2003\n\n**Compatibility Notes:**\n- gfortran 4.4+, Intel Fortran 10.0+, NAG 5.2+\n- BIND(C) enums are interoperable with C enums\n- Enumerator values default to 0, 1, 2, ... unless explicitly set\n\n### **See Also**\n\n[**integer**(3)](#integer),\n[**parameter**(3)](#parameter),\n[**iso_c_binding**(3)](#iso_c_binding)",
  "mpi_f08": "## MPI_F08\n\n### **Name**\n\n**MPI_F08** - \\[PARALLEL:MPI\\] Modern Fortran MPI bindings module with type-safe interfaces\n\n### **Synopsis**\n\n```fortran\n    use mpi_f08\n```\n\n```fortran\n     use mpi_f08\n\n      ! Provides derived types for MPI handles:\n      type(MPI_Comm)     :: comm\n      type(MPI_Datatype) :: datatype\n      type(MPI_Status)   :: status\n      type(MPI_Request)  :: request\n      type(MPI_Op)       :: op\n```\n\n### **Characteristics**\n\n - **mpi_f08** is the modern Fortran MPI bindings module introduced in MPI-3.0.\n - Provides derived types for all MPI handles (MPI_Comm, MPI_Datatype, etc.).\n - Uses assumed-type and assumed-rank for type-safe buffer arguments.\n - The ierror argument is optional in all routines.\n - Provides better compile-time error checking than the older mpi module.\n - Recommended for all new MPI Fortran code.\n\n### **Description**\n\n **mpi_f08** is the recommended MPI module for modern Fortran programs. It\n provides type-safe interfaces using Fortran 2008 features including derived\n types for MPI handles, assumed-type (`TYPE(*)`) for choice buffers, and\n optional error arguments. This module replaces the older `use mpi` and\n `include 'mpif.h'` approaches with improved type safety and better\n compiler error messages.\n\n### **Options**\n\n- **MPI_Comm**\n  : Derived type for communicator handles. The predefined communicator\n  MPI_COMM_WORLD is of this type.\n\n- **MPI_Datatype**\n  : Derived type for datatype handles. Predefined types include\n  MPI_INTEGER, MPI_REAL, MPI_DOUBLE_PRECISION, MPI_COMPLEX, etc.\n\n- **MPI_Status**\n  : Derived type for status information returned by receive operations.\n  Contains source, tag, and error fields.\n\n- **MPI_Request**\n  : Derived type for nonblocking operation handles.\n\n- **MPI_Op**\n  : Derived type for reduction operation handles. Predefined operations\n  include MPI_SUM, MPI_MAX, MPI_MIN, MPI_PROD, etc.\n\n### **Result**\n\n  After `use mpi_f08`, all MPI routines, constants, and derived types become\n  available in the current scope. The module provides the complete MPI\n  interface with modern Fortran features.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_mpi_f08\n  use mpi_f08\n  implicit none\n  type(MPI_Comm) :: comm\n  type(MPI_Status) :: status\n  integer :: rank, nprocs, ierr\n  real(8) :: sendbuf, recvbuf\n\n  call MPI_Init(ierr)\n\n  comm = MPI_COMM_WORLD\n  call MPI_Comm_rank(comm, rank, ierr)\n  call MPI_Comm_size(comm, nprocs, ierr)\n\n  sendbuf = real(rank, 8)\n\n  ! Use MPI_Allreduce with derived type handles\n  call MPI_Allreduce(sendbuf, recvbuf, 1, MPI_DOUBLE_PRECISION, &\n                     MPI_SUM, comm, ierr)\n\n  if (rank == 0) then\n    print '(A,F8.2)', 'Sum of all ranks: ', recvbuf\n  end if\n\n  ! Point-to-point with status\n  if (nprocs >= 2) then\n    if (rank == 0) then\n      call MPI_Send(sendbuf, 1, MPI_DOUBLE_PRECISION, 1, 100, comm, ierr)\n    else if (rank == 1) then\n      call MPI_Recv(recvbuf, 1, MPI_DOUBLE_PRECISION, 0, 100, comm, status, ierr)\n      print '(A,I0,A,I0)', 'Received from rank ', status%MPI_SOURCE, &\n            ' with tag ', status%MPI_TAG\n    end if\n  end if\n\n  call MPI_Finalize(ierr)\n\nend program demo_mpi_f08\n```\n\nResults (with 4 processes):\n\n```text\nSum of all ranks:     6.00\nReceived from rank 0 with tag 100\n```\n\n### **Standard**\n\nMPI-3.0\n\n### **See Also**\n\n[**MPI_Init**(3)](#mpi_init),\n[**MPI_Finalize**(3)](#mpi_finalize),\n[**MPI_Comm_rank**(3)](#mpi_comm_rank),\n[**MPI_Send**(3)](#mpi_send),\n[**MPI_Recv**(3)](#mpi_recv),\n[**MPI_Allreduce**(3)](#mpi_allreduce)",
  "internal": "## internal_procedure\n\n### **Name**\n\n**internal_procedure** - \\[STRUCTURE:PROCEDURE\\] Define a contained (internal) subprogram with host association\n\n### **Synopsis**\n```fortran\n    program/subroutine/function host\n      ! declarations\n    contains\n      subroutine internal_sub()\n      end subroutine\n    end program/subroutine/function\n```\n```fortran\n     program host_program\n\n      ! host declarations\n      type(data_type) :: host_var\n     contains\n      subroutine internal_sub()\n        ! Can access host_var via host association\n      end subroutine internal_sub\n\n      function internal_func() result(res)\n        ! Can access host_var via host association\n      end function internal_func\n     end program host_program\n```\n\n### **Characteristics**\n\n - **contains** separates the main program/procedure from internal subprograms.\n - Internal procedures have access to host's variables via host association.\n - Internal procedures are only visible within the host scoping unit.\n - Cannot be passed as actual arguments (except in certain contexts).\n - Can access and modify the host's local variables directly.\n\n### **Description**\n\n **internal_procedure** creates subprograms contained within a program unit\n (program, subroutine, function, or module procedure). Internal procedures\n automatically have access to all variables, types, and named constants of\n their host through host association. This enables helper routines that\n operate on the host's data without requiring explicit argument passing,\n while keeping the helpers private to the host scope.\n\n### **Options**\n\n- **contains**\n  : Keyword that introduces the internal procedure section. Must appear\n  after all executable statements of the host and before any internal\n  procedure definitions.\n\n- **host association**\n  : Mechanism by which internal procedures access host scope entities.\n  Variables from the host are accessible by their name without explicit\n  declaration (unless shadowed by a local declaration).\n\n- **internal subprogram**\n  : A subroutine or function defined after CONTAINS within a host program\n  unit. Has full access to host scope and can modify host variables.\n\n### **Result**\n\n  Private helper procedures that can directly access and modify the host\n  program unit's variables without explicit argument passing.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_internal_procedure\nimplicit none\n  real :: data(100)\n  real :: result_sum, result_mean, result_std\n  integer :: n\n\n  ! Initialize data\n  n = 100\n  call random_number(data)\n  data = data * 100.0  ! Scale to 0-100\n\n  ! Call internal procedures - they access 'data' and 'n' directly\n  call compute_statistics()\n\n  print '(a,f10.3)', 'Sum:             ', result_sum\n  print '(a,f10.3)', 'Mean:            ', result_mean\n  print '(a,f10.3)', 'Std deviation:   ', result_std\n\ncontains\n\n  subroutine compute_statistics()\n    ! Access host variables: data, n, result_*\n\n    result_sum = calculate_sum()\n    result_mean = result_sum / real(n)\n    result_std = calculate_std()\n  end subroutine compute_statistics\n\n  pure function calculate_sum() result(s)\n    real :: s\n    ! Access host variable 'data' and 'n'\n    s = sum(data(1:n))\n  end function calculate_sum\n\n  pure function calculate_std() result(std)\n    real :: std\n    real :: mean, variance\n    ! Access host variables\n    mean = sum(data(1:n)) / real(n)\n    variance = sum((data(1:n) - mean)**2) / real(n)\n    std = sqrt(variance)\n  end function calculate_std\n\nend program demo_internal_procedure\n```\nResults:\n```text\nSum:               4987.234\nMean:                49.872\nStd deviation:       28.614\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**contains**(3)](#contains),\n[**module**(3)](#module),\n[**subroutine**(3)](#subroutine),\n[**function**(3)](#function),\n[**host_association**(3)](#host_association)",
  "mpisendrecv": "## MPI_Sendrecv\n\n### **Name**\n\n**MPI_Sendrecv** - \\[PARALLEL:MPI\\] Blocking send and receive operation\n\n### **Synopsis**\n\n```fortran\n    call MPI_Sendrecv(sendbuf, sendcount, sendtype, dest, sendtag, &\n                      recvbuf, recvcount, recvtype, source, recvtag, &\n                      comm, status, ierror)\n```\n\n```fortran\n     subroutine MPI_Sendrecv(sendbuf, sendcount, sendtype, dest, sendtag, &\n                             recvbuf, recvcount, recvtype, source, recvtag, &\n                             comm, status, ierror)\n\n      type(*), dimension(..), intent(in)    :: sendbuf\n      integer, intent(in)                   :: sendcount\n      type(MPI_Datatype), intent(in)        :: sendtype\n      integer, intent(in)                   :: dest\n      integer, intent(in)                   :: sendtag\n      type(*), dimension(..)                :: recvbuf\n      integer, intent(in)                   :: recvcount\n      type(MPI_Datatype), intent(in)        :: recvtype\n      integer, intent(in)                   :: source\n      integer, intent(in)                   :: recvtag\n      type(MPI_Comm), intent(in)            :: comm\n      type(MPI_Status), intent(out)         :: status\n      integer, intent(out), optional        :: ierror\n```\n\n### **Characteristics**\n\n - **sendbuf** is the send buffer containing data to be sent.\n - **sendcount** is an integer specifying the number of elements to send.\n - **sendtype** is an MPI datatype handle for send buffer elements.\n - **dest** is an integer rank of the destination process.\n - **sendtag** is an integer message tag for the send.\n - **recvbuf** is the receive buffer for incoming data.\n - **recvcount** is an integer specifying the maximum elements to receive.\n - **recvtype** is an MPI datatype handle for receive buffer elements.\n - **source** is an integer rank of the source process, or MPI_ANY_SOURCE.\n - **recvtag** is an integer message tag for the receive, or MPI_ANY_TAG.\n - **comm** is an MPI communicator handle.\n - **status** returns information about the received message.\n - **ierror** is an optional integer error code.\n\n### **Description**\n\n **MPI_Sendrecv** executes a blocking send and receive operation in a single\n call. It sends data from sendbuf to the destination process and receives\n data into recvbuf from the source process. This routine is useful for\n avoiding deadlocks that can occur with separate send and receive calls,\n particularly in ring or shift communication patterns.\n\n### **Options**\n\n- **sendbuf**\n  : Starting address of the send buffer containing sendcount elements of\n  type sendtype to be sent to the destination process.\n\n- **sendcount**\n  : Number of elements to send. Must be non-negative.\n\n- **sendtype**\n  : MPI datatype of each send buffer element.\n\n- **dest**\n  : Rank of destination process within comm. Can be MPI_PROC_NULL for no send.\n\n- **sendtag**\n  : Message tag for the send operation. Must be non-negative.\n\n- **recvbuf**\n  : Starting address of the receive buffer with room for recvcount elements.\n\n- **recvcount**\n  : Maximum number of elements to receive.\n\n- **recvtype**\n  : MPI datatype of each receive buffer element.\n\n- **source**\n  : Rank of source process, or MPI_ANY_SOURCE to receive from any process.\n\n- **recvtag**\n  : Message tag for matching, or MPI_ANY_TAG to match any tag.\n\n- **comm**\n  : MPI communicator for the operation.\n\n- **status**\n  : Status object containing source rank, tag, and message size information.\n\n- **ierror**\n  : Error code. Returns MPI_SUCCESS (0) on success.\n\n### **Result**\n\n  The send buffer data is transmitted to the destination process and the\n  receive buffer is filled with data from the source process. The status\n  object contains information about the received message including the\n  actual source rank and tag.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_mpi_sendrecv\n  use mpi_f08\n  implicit none\n  integer :: rank, nprocs, ierr\n  integer :: left, right\n  real(8) :: sendbuf, recvbuf\n  type(MPI_Status) :: status\n\n  call MPI_Init(ierr)\n  call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierr)\n  call MPI_Comm_size(MPI_COMM_WORLD, nprocs, ierr)\n\n  ! Set up ring topology\n  left = mod(rank - 1 + nprocs, nprocs)\n  right = mod(rank + 1, nprocs)\n\n  ! Each process sends its rank to the right neighbor\n  ! and receives from the left neighbor\n  sendbuf = real(rank, 8)\n\n  call MPI_Sendrecv(sendbuf, 1, MPI_DOUBLE_PRECISION, right, 100, &\n                    recvbuf, 1, MPI_DOUBLE_PRECISION, left, 100, &\n                    MPI_COMM_WORLD, status, ierr)\n\n  print '(A,I0,A,F4.1,A,I0)', 'Rank ', rank, ' received ', recvbuf, &\n        ' from rank ', status%MPI_SOURCE\n\n  call MPI_Finalize(ierr)\n\nend program demo_mpi_sendrecv\n```\n\nResults (with 4 processes):\n\n```text\nRank 0 received  3.0 from rank 3\nRank 1 received  0.0 from rank 0\nRank 2 received  1.0 from rank 1\nRank 3 received  2.0 from rank 2\n```\n\n### **Standard**\n\nMPI-1.0\n\n### **See Also**\n\n[**MPI_Send**(3)](#mpi_send),\n[**MPI_Recv**(3)](#mpi_recv),\n[**MPI_Sendrecv_replace**(3)](#mpi_sendrecv_replace),\n[**MPI_Isend**(3)](#mpi_isend),\n[**MPI_Irecv**(3)](#mpi_irecv)",
  "contained": "## internal_procedure\n\n### **Name**\n\n**internal_procedure** - \\[STRUCTURE:PROCEDURE\\] Define a contained (internal) subprogram with host association\n\n### **Synopsis**\n```fortran\n    program/subroutine/function host\n      ! declarations\n    contains\n      subroutine internal_sub()\n      end subroutine\n    end program/subroutine/function\n```\n```fortran\n     program host_program\n\n      ! host declarations\n      type(data_type) :: host_var\n     contains\n      subroutine internal_sub()\n        ! Can access host_var via host association\n      end subroutine internal_sub\n\n      function internal_func() result(res)\n        ! Can access host_var via host association\n      end function internal_func\n     end program host_program\n```\n\n### **Characteristics**\n\n - **contains** separates the main program/procedure from internal subprograms.\n - Internal procedures have access to host's variables via host association.\n - Internal procedures are only visible within the host scoping unit.\n - Cannot be passed as actual arguments (except in certain contexts).\n - Can access and modify the host's local variables directly.\n\n### **Description**\n\n **internal_procedure** creates subprograms contained within a program unit\n (program, subroutine, function, or module procedure). Internal procedures\n automatically have access to all variables, types, and named constants of\n their host through host association. This enables helper routines that\n operate on the host's data without requiring explicit argument passing,\n while keeping the helpers private to the host scope.\n\n### **Options**\n\n- **contains**\n  : Keyword that introduces the internal procedure section. Must appear\n  after all executable statements of the host and before any internal\n  procedure definitions.\n\n- **host association**\n  : Mechanism by which internal procedures access host scope entities.\n  Variables from the host are accessible by their name without explicit\n  declaration (unless shadowed by a local declaration).\n\n- **internal subprogram**\n  : A subroutine or function defined after CONTAINS within a host program\n  unit. Has full access to host scope and can modify host variables.\n\n### **Result**\n\n  Private helper procedures that can directly access and modify the host\n  program unit's variables without explicit argument passing.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_internal_procedure\nimplicit none\n  real :: data(100)\n  real :: result_sum, result_mean, result_std\n  integer :: n\n\n  ! Initialize data\n  n = 100\n  call random_number(data)\n  data = data * 100.0  ! Scale to 0-100\n\n  ! Call internal procedures - they access 'data' and 'n' directly\n  call compute_statistics()\n\n  print '(a,f10.3)', 'Sum:             ', result_sum\n  print '(a,f10.3)', 'Mean:            ', result_mean\n  print '(a,f10.3)', 'Std deviation:   ', result_std\n\ncontains\n\n  subroutine compute_statistics()\n    ! Access host variables: data, n, result_*\n\n    result_sum = calculate_sum()\n    result_mean = result_sum / real(n)\n    result_std = calculate_std()\n  end subroutine compute_statistics\n\n  pure function calculate_sum() result(s)\n    real :: s\n    ! Access host variable 'data' and 'n'\n    s = sum(data(1:n))\n  end function calculate_sum\n\n  pure function calculate_std() result(std)\n    real :: std\n    real :: mean, variance\n    ! Access host variables\n    mean = sum(data(1:n)) / real(n)\n    variance = sum((data(1:n) - mean)**2) / real(n)\n    std = sqrt(variance)\n  end function calculate_std\n\nend program demo_internal_procedure\n```\nResults:\n```text\nSum:               4987.234\nMean:                49.872\nStd deviation:       28.614\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**contains**(3)](#contains),\n[**module**(3)](#module),\n[**subroutine**(3)](#subroutine),\n[**function**(3)](#function),\n[**host_association**(3)](#host_association)",
  "mpi_sendrecv": "## MPI_Sendrecv\n\n### **Name**\n\n**MPI_Sendrecv** - \\[PARALLEL:MPI\\] Blocking send and receive operation\n\n### **Synopsis**\n\n```fortran\n    call MPI_Sendrecv(sendbuf, sendcount, sendtype, dest, sendtag, &\n                      recvbuf, recvcount, recvtype, source, recvtag, &\n                      comm, status, ierror)\n```\n\n```fortran\n     subroutine MPI_Sendrecv(sendbuf, sendcount, sendtype, dest, sendtag, &\n                             recvbuf, recvcount, recvtype, source, recvtag, &\n                             comm, status, ierror)\n\n      type(*), dimension(..), intent(in)    :: sendbuf\n      integer, intent(in)                   :: sendcount\n      type(MPI_Datatype), intent(in)        :: sendtype\n      integer, intent(in)                   :: dest\n      integer, intent(in)                   :: sendtag\n      type(*), dimension(..)                :: recvbuf\n      integer, intent(in)                   :: recvcount\n      type(MPI_Datatype), intent(in)        :: recvtype\n      integer, intent(in)                   :: source\n      integer, intent(in)                   :: recvtag\n      type(MPI_Comm), intent(in)            :: comm\n      type(MPI_Status), intent(out)         :: status\n      integer, intent(out), optional        :: ierror\n```\n\n### **Characteristics**\n\n - **sendbuf** is the send buffer containing data to be sent.\n - **sendcount** is an integer specifying the number of elements to send.\n - **sendtype** is an MPI datatype handle for send buffer elements.\n - **dest** is an integer rank of the destination process.\n - **sendtag** is an integer message tag for the send.\n - **recvbuf** is the receive buffer for incoming data.\n - **recvcount** is an integer specifying the maximum elements to receive.\n - **recvtype** is an MPI datatype handle for receive buffer elements.\n - **source** is an integer rank of the source process, or MPI_ANY_SOURCE.\n - **recvtag** is an integer message tag for the receive, or MPI_ANY_TAG.\n - **comm** is an MPI communicator handle.\n - **status** returns information about the received message.\n - **ierror** is an optional integer error code.\n\n### **Description**\n\n **MPI_Sendrecv** executes a blocking send and receive operation in a single\n call. It sends data from sendbuf to the destination process and receives\n data into recvbuf from the source process. This routine is useful for\n avoiding deadlocks that can occur with separate send and receive calls,\n particularly in ring or shift communication patterns.\n\n### **Options**\n\n- **sendbuf**\n  : Starting address of the send buffer containing sendcount elements of\n  type sendtype to be sent to the destination process.\n\n- **sendcount**\n  : Number of elements to send. Must be non-negative.\n\n- **sendtype**\n  : MPI datatype of each send buffer element.\n\n- **dest**\n  : Rank of destination process within comm. Can be MPI_PROC_NULL for no send.\n\n- **sendtag**\n  : Message tag for the send operation. Must be non-negative.\n\n- **recvbuf**\n  : Starting address of the receive buffer with room for recvcount elements.\n\n- **recvcount**\n  : Maximum number of elements to receive.\n\n- **recvtype**\n  : MPI datatype of each receive buffer element.\n\n- **source**\n  : Rank of source process, or MPI_ANY_SOURCE to receive from any process.\n\n- **recvtag**\n  : Message tag for matching, or MPI_ANY_TAG to match any tag.\n\n- **comm**\n  : MPI communicator for the operation.\n\n- **status**\n  : Status object containing source rank, tag, and message size information.\n\n- **ierror**\n  : Error code. Returns MPI_SUCCESS (0) on success.\n\n### **Result**\n\n  The send buffer data is transmitted to the destination process and the\n  receive buffer is filled with data from the source process. The status\n  object contains information about the received message including the\n  actual source rank and tag.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_mpi_sendrecv\n  use mpi_f08\n  implicit none\n  integer :: rank, nprocs, ierr\n  integer :: left, right\n  real(8) :: sendbuf, recvbuf\n  type(MPI_Status) :: status\n\n  call MPI_Init(ierr)\n  call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierr)\n  call MPI_Comm_size(MPI_COMM_WORLD, nprocs, ierr)\n\n  ! Set up ring topology\n  left = mod(rank - 1 + nprocs, nprocs)\n  right = mod(rank + 1, nprocs)\n\n  ! Each process sends its rank to the right neighbor\n  ! and receives from the left neighbor\n  sendbuf = real(rank, 8)\n\n  call MPI_Sendrecv(sendbuf, 1, MPI_DOUBLE_PRECISION, right, 100, &\n                    recvbuf, 1, MPI_DOUBLE_PRECISION, left, 100, &\n                    MPI_COMM_WORLD, status, ierr)\n\n  print '(A,I0,A,F4.1,A,I0)', 'Rank ', rank, ' received ', recvbuf, &\n        ' from rank ', status%MPI_SOURCE\n\n  call MPI_Finalize(ierr)\n\nend program demo_mpi_sendrecv\n```\n\nResults (with 4 processes):\n\n```text\nRank 0 received  3.0 from rank 3\nRank 1 received  0.0 from rank 0\nRank 2 received  1.0 from rank 1\nRank 3 received  2.0 from rank 2\n```\n\n### **Standard**\n\nMPI-1.0\n\n### **See Also**\n\n[**MPI_Send**(3)](#mpi_send),\n[**MPI_Recv**(3)](#mpi_recv),\n[**MPI_Sendrecv_replace**(3)](#mpi_sendrecv_replace),\n[**MPI_Isend**(3)](#mpi_isend),\n[**MPI_Irecv**(3)](#mpi_irecv)",
  "usempif08": "## MPI_F08\n\n### **Name**\n\n**MPI_F08** - \\[PARALLEL:MPI\\] Modern Fortran MPI bindings module with type-safe interfaces\n\n### **Synopsis**\n\n```fortran\n    use mpi_f08\n```\n\n```fortran\n     use mpi_f08\n\n      ! Provides derived types for MPI handles:\n      type(MPI_Comm)     :: comm\n      type(MPI_Datatype) :: datatype\n      type(MPI_Status)   :: status\n      type(MPI_Request)  :: request\n      type(MPI_Op)       :: op\n```\n\n### **Characteristics**\n\n - **mpi_f08** is the modern Fortran MPI bindings module introduced in MPI-3.0.\n - Provides derived types for all MPI handles (MPI_Comm, MPI_Datatype, etc.).\n - Uses assumed-type and assumed-rank for type-safe buffer arguments.\n - The ierror argument is optional in all routines.\n - Provides better compile-time error checking than the older mpi module.\n - Recommended for all new MPI Fortran code.\n\n### **Description**\n\n **mpi_f08** is the recommended MPI module for modern Fortran programs. It\n provides type-safe interfaces using Fortran 2008 features including derived\n types for MPI handles, assumed-type (`TYPE(*)`) for choice buffers, and\n optional error arguments. This module replaces the older `use mpi` and\n `include 'mpif.h'` approaches with improved type safety and better\n compiler error messages.\n\n### **Options**\n\n- **MPI_Comm**\n  : Derived type for communicator handles. The predefined communicator\n  MPI_COMM_WORLD is of this type.\n\n- **MPI_Datatype**\n  : Derived type for datatype handles. Predefined types include\n  MPI_INTEGER, MPI_REAL, MPI_DOUBLE_PRECISION, MPI_COMPLEX, etc.\n\n- **MPI_Status**\n  : Derived type for status information returned by receive operations.\n  Contains source, tag, and error fields.\n\n- **MPI_Request**\n  : Derived type for nonblocking operation handles.\n\n- **MPI_Op**\n  : Derived type for reduction operation handles. Predefined operations\n  include MPI_SUM, MPI_MAX, MPI_MIN, MPI_PROD, etc.\n\n### **Result**\n\n  After `use mpi_f08`, all MPI routines, constants, and derived types become\n  available in the current scope. The module provides the complete MPI\n  interface with modern Fortran features.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_mpi_f08\n  use mpi_f08\n  implicit none\n  type(MPI_Comm) :: comm\n  type(MPI_Status) :: status\n  integer :: rank, nprocs, ierr\n  real(8) :: sendbuf, recvbuf\n\n  call MPI_Init(ierr)\n\n  comm = MPI_COMM_WORLD\n  call MPI_Comm_rank(comm, rank, ierr)\n  call MPI_Comm_size(comm, nprocs, ierr)\n\n  sendbuf = real(rank, 8)\n\n  ! Use MPI_Allreduce with derived type handles\n  call MPI_Allreduce(sendbuf, recvbuf, 1, MPI_DOUBLE_PRECISION, &\n                     MPI_SUM, comm, ierr)\n\n  if (rank == 0) then\n    print '(A,F8.2)', 'Sum of all ranks: ', recvbuf\n  end if\n\n  ! Point-to-point with status\n  if (nprocs >= 2) then\n    if (rank == 0) then\n      call MPI_Send(sendbuf, 1, MPI_DOUBLE_PRECISION, 1, 100, comm, ierr)\n    else if (rank == 1) then\n      call MPI_Recv(recvbuf, 1, MPI_DOUBLE_PRECISION, 0, 100, comm, status, ierr)\n      print '(A,I0,A,I0)', 'Received from rank ', status%MPI_SOURCE, &\n            ' with tag ', status%MPI_TAG\n    end if\n  end if\n\n  call MPI_Finalize(ierr)\n\nend program demo_mpi_f08\n```\n\nResults (with 4 processes):\n\n```text\nSum of all ranks:     6.00\nReceived from rank 0 with tag 100\n```\n\n### **Standard**\n\nMPI-3.0\n\n### **See Also**\n\n[**MPI_Init**(3)](#mpi_init),\n[**MPI_Finalize**(3)](#mpi_finalize),\n[**MPI_Comm_rank**(3)](#mpi_comm_rank),\n[**MPI_Send**(3)](#mpi_send),\n[**MPI_Recv**(3)](#mpi_recv),\n[**MPI_Allreduce**(3)](#mpi_allreduce)",
  "usempi": "## MPI_F08\n\n### **Name**\n\n**MPI_F08** - \\[PARALLEL:MPI\\] Modern Fortran MPI bindings module with type-safe interfaces\n\n### **Synopsis**\n\n```fortran\n    use mpi_f08\n```\n\n```fortran\n     use mpi_f08\n\n      ! Provides derived types for MPI handles:\n      type(MPI_Comm)     :: comm\n      type(MPI_Datatype) :: datatype\n      type(MPI_Status)   :: status\n      type(MPI_Request)  :: request\n      type(MPI_Op)       :: op\n```\n\n### **Characteristics**\n\n - **mpi_f08** is the modern Fortran MPI bindings module introduced in MPI-3.0.\n - Provides derived types for all MPI handles (MPI_Comm, MPI_Datatype, etc.).\n - Uses assumed-type and assumed-rank for type-safe buffer arguments.\n - The ierror argument is optional in all routines.\n - Provides better compile-time error checking than the older mpi module.\n - Recommended for all new MPI Fortran code.\n\n### **Description**\n\n **mpi_f08** is the recommended MPI module for modern Fortran programs. It\n provides type-safe interfaces using Fortran 2008 features including derived\n types for MPI handles, assumed-type (`TYPE(*)`) for choice buffers, and\n optional error arguments. This module replaces the older `use mpi` and\n `include 'mpif.h'` approaches with improved type safety and better\n compiler error messages.\n\n### **Options**\n\n- **MPI_Comm**\n  : Derived type for communicator handles. The predefined communicator\n  MPI_COMM_WORLD is of this type.\n\n- **MPI_Datatype**\n  : Derived type for datatype handles. Predefined types include\n  MPI_INTEGER, MPI_REAL, MPI_DOUBLE_PRECISION, MPI_COMPLEX, etc.\n\n- **MPI_Status**\n  : Derived type for status information returned by receive operations.\n  Contains source, tag, and error fields.\n\n- **MPI_Request**\n  : Derived type for nonblocking operation handles.\n\n- **MPI_Op**\n  : Derived type for reduction operation handles. Predefined operations\n  include MPI_SUM, MPI_MAX, MPI_MIN, MPI_PROD, etc.\n\n### **Result**\n\n  After `use mpi_f08`, all MPI routines, constants, and derived types become\n  available in the current scope. The module provides the complete MPI\n  interface with modern Fortran features.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_mpi_f08\n  use mpi_f08\n  implicit none\n  type(MPI_Comm) :: comm\n  type(MPI_Status) :: status\n  integer :: rank, nprocs, ierr\n  real(8) :: sendbuf, recvbuf\n\n  call MPI_Init(ierr)\n\n  comm = MPI_COMM_WORLD\n  call MPI_Comm_rank(comm, rank, ierr)\n  call MPI_Comm_size(comm, nprocs, ierr)\n\n  sendbuf = real(rank, 8)\n\n  ! Use MPI_Allreduce with derived type handles\n  call MPI_Allreduce(sendbuf, recvbuf, 1, MPI_DOUBLE_PRECISION, &\n                     MPI_SUM, comm, ierr)\n\n  if (rank == 0) then\n    print '(A,F8.2)', 'Sum of all ranks: ', recvbuf\n  end if\n\n  ! Point-to-point with status\n  if (nprocs >= 2) then\n    if (rank == 0) then\n      call MPI_Send(sendbuf, 1, MPI_DOUBLE_PRECISION, 1, 100, comm, ierr)\n    else if (rank == 1) then\n      call MPI_Recv(recvbuf, 1, MPI_DOUBLE_PRECISION, 0, 100, comm, status, ierr)\n      print '(A,I0,A,I0)', 'Received from rank ', status%MPI_SOURCE, &\n            ' with tag ', status%MPI_TAG\n    end if\n  end if\n\n  call MPI_Finalize(ierr)\n\nend program demo_mpi_f08\n```\n\nResults (with 4 processes):\n\n```text\nSum of all ranks:     6.00\nReceived from rank 0 with tag 100\n```\n\n### **Standard**\n\nMPI-3.0\n\n### **See Also**\n\n[**MPI_Init**(3)](#mpi_init),\n[**MPI_Finalize**(3)](#mpi_finalize),\n[**MPI_Comm_rank**(3)](#mpi_comm_rank),\n[**MPI_Send**(3)](#mpi_send),\n[**MPI_Recv**(3)](#mpi_recv),\n[**MPI_Allreduce**(3)](#mpi_allreduce)",
  "namedloop": "## named_do_loop\n\n### **Name**\n\n**named_do_loop** - \\[CONTROL:LOOP\\] Named iterative loop construct with explicit label\n\n### **Synopsis**\n```fortran\n    loop_name: do variable = start, end\n      ! loop body\n    end do loop_name\n```\n```fortran\n     construct named_do_loop(loop_name, variable, start, end)\n\n      character(len=*)      :: loop_name  ! construct name/label\n      integer, intent(in)   :: variable   ! loop counter\n      integer, intent(in)   :: start      ! initial value\n      integer, intent(in)   :: end        ! final value\n```\n\n### **Characteristics**\n\n - **loop_name** is a valid Fortran identifier used to label the construct.\n - **variable** is a scalar integer variable serving as the loop counter.\n - **start** is a scalar integer expression for the initial counter value.\n - **end** is a scalar integer expression for the final counter value.\n - The loop name must appear on both the DO statement and the END DO statement.\n - Named loops enable targeted EXIT and CYCLE statements for nested loop control.\n\n### **Description**\n\n **named_do_loop** creates a labeled iterative construct that executes a block\n of statements repeatedly while incrementing a counter variable from a starting\n value to an ending value. The explicit name provides self-documenting code and\n enables precise control flow in nested loop structures using EXIT loop_name\n and CYCLE loop_name statements.\n\n### **Options**\n\n- **loop_name**\n  : A valid Fortran identifier that labels the construct. Must be unique within\n  the scoping unit. The same name must appear after END DO. Enables targeted\n  EXIT and CYCLE statements when loops are nested.\n\n- **variable**\n  : A scalar integer variable that serves as the loop counter. It is incremented\n  automatically at the end of each iteration. Should not be modified within the\n  loop body.\n\n- **start**\n  : A scalar integer expression specifying the initial value of the loop counter.\n  Evaluated once before the first iteration.\n\n- **end**\n  : A scalar integer expression specifying the final value of the loop counter.\n  The loop executes while variable <= end (for positive increment).\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_named_do_loop\nimplicit none\n  integer :: i, j, k\n  integer :: matrix(3,3)\n  integer :: sum_total\n\n  ! Basic named loop - useful for documentation\n  row_loop: do i = 1, 3\n    print *, 'Processing row:', i\n  end do row_loop\n\n  ! Nested named loops with targeted EXIT\n  sum_total = 0\n  outer: do i = 1, 10\n    inner: do j = 1, 10\n      sum_total = sum_total + 1\n      if (sum_total > 50) exit outer  ! Exit outer loop directly\n    end do inner\n  end do outer\n  print *, 'Sum stopped at:', sum_total\n\n  ! Named loops with targeted CYCLE\n  matrix = 0\n  fill_rows: do i = 1, 3\n    fill_cols: do j = 1, 3\n      if (i == j) cycle fill_cols  ! Skip diagonal elements\n      matrix(i,j) = i * j\n    end do fill_cols\n  end do fill_rows\n  print *, 'Matrix (diagonal skipped):'\n  do i = 1, 3\n    print '(3I4)', matrix(i,:)\n  end do\n\n  ! Triple nested loop demonstrating precise control\n  search: do i = 1, 5\n    level2: do j = 1, 5\n      level3: do k = 1, 5\n        if (i*j*k == 30) then\n          print *, 'Found product 30 at:', i, j, k\n          exit search  ! Exit all three loops at once\n        end if\n      end do level3\n    end do level2\n  end do search\n\nend program demo_named_do_loop\n```\nResults:\n```text\n Processing row:           1\n Processing row:           2\n Processing row:           3\n Sum stopped at:          51\n Matrix (diagonal skipped):\n   0   2   3\n   2   0   6\n   3   6   0\n Found product 30 at:           2           3           5\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**do**(3)](#do),\n[**do_while**(3)](#do_while),\n[**do_concurrent**(3)](#do_concurrent),\n[**exit**(3)](#exit),\n[**cycle**(3)](#cycle)",
  "mpirecv": "## MPI_Recv\n\n### **Name**\n\n**MPI_Recv** - \\[PARALLEL:MPI\\] Blocking receive for a message\n\n### **Synopsis**\n\n```fortran\n    call MPI_Recv(buf, count, datatype, source, tag, comm, status, ierror)\n```\n\n```fortran\n     subroutine MPI_Recv(buf, count, datatype, source, tag, comm, status, ierror)\n\n      type(*), dimension(..)         :: buf\n      integer, intent(in)            :: count\n      type(MPI_Datatype), intent(in) :: datatype\n      integer, intent(in)            :: source\n      integer, intent(in)            :: tag\n      type(MPI_Comm), intent(in)     :: comm\n      type(MPI_Status), intent(out)  :: status\n      integer, intent(out), optional :: ierror\n```\n\n### **Characteristics**\n\n - **buf** is the receive buffer where incoming data will be stored; can be any Fortran data type.\n - **count** is a non-negative integer specifying the maximum number of elements to receive.\n - **datatype** must be a valid MPI datatype handle (e.g., MPI_INTEGER, MPI_REAL, MPI_DOUBLE_PRECISION).\n - **source** is an integer rank of the sending process, or MPI_ANY_SOURCE to accept from any sender.\n - **tag** is a non-negative integer message tag, or MPI_ANY_TAG to accept any tag.\n - **comm** is a valid MPI communicator handle.\n - **status** returns message metadata; use MPI_STATUS_IGNORE if not needed.\n - **ierror** is the output error status; returns MPI_SUCCESS on success.\n - This is a **blocking** operation that returns only after the message has been received into the buffer.\n\n### **Description**\n\n **MPI_Recv** performs a standard-mode blocking receive operation. It blocks\n until the receive buffer contains the newly received message from the\n specified source. The actual length of the received message can be\n determined using MPI_Get_count on the returned status. The received\n message length must be less than or equal to the buffer length specified\n by count; otherwise, an MPI_ERR_TRUNCATE error occurs.\n\n### **Options**\n\n- **buf**\n  : Starting address of the receive buffer with room for count elements.\n  The received data is stored starting at this address.\n\n- **count**\n  : Maximum number of elements to receive. The actual message may be\n  shorter but not longer than this count.\n\n- **datatype**\n  : MPI datatype handle describing each buffer element.\n\n- **source**\n  : Rank of the sending process within comm, or MPI_ANY_SOURCE to receive\n  from any process. MPI_PROC_NULL is allowed for a null receive.\n\n- **tag**\n  : Message tag for matching, or MPI_ANY_TAG to match any tag.\n\n- **comm**\n  : MPI communicator defining the process group.\n\n- **status**\n  : Status object that receives information about the message:\n  status%MPI_SOURCE contains the source rank, status%MPI_TAG contains\n  the tag, and MPI_Get_count can determine the message length.\n\n- **ierror**\n  : Error code. Returns MPI_SUCCESS (0) on successful completion.\n\n### **Result**\n\n  The receive buffer is filled with data from the matching send operation.\n  The status object contains metadata about the received message including\n  the actual source rank and tag used.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_mpi_recv\n  use mpi_f08\n  implicit none\n  integer :: rank, nprocs, ierr\n  real(8) :: data(100)\n  type(MPI_Status) :: status\n  integer :: recv_count, i\n\n  call MPI_Init(ierr)\n  call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierr)\n  call MPI_Comm_size(MPI_COMM_WORLD, nprocs, ierr)\n\n  if (nprocs < 2) then\n    print *, 'This example requires at least 2 processes'\n    call MPI_Abort(MPI_COMM_WORLD, 1, ierr)\n  end if\n\n  if (rank == 0) then\n    ! Send 50 elements to process 1\n    data(1:50) = [(real(i, 8), i = 1, 50)]\n    call MPI_Send(data, 50, MPI_DOUBLE_PRECISION, 1, 99, MPI_COMM_WORLD, ierr)\n    print *, 'Process 0 sent 50 elements'\n  else if (rank == 1) then\n    ! Receive into buffer with room for 100 elements\n    call MPI_Recv(data, 100, MPI_DOUBLE_PRECISION, 0, 99, &\n                  MPI_COMM_WORLD, status, ierr)\n\n    ! Query actual received count\n    call MPI_Get_count(status, MPI_DOUBLE_PRECISION, recv_count, ierr)\n\n    print '(A,I0)', 'Process 1 received elements: ', recv_count\n    print '(A,I0)', 'Source rank: ', status%MPI_SOURCE\n    print '(A,I0)', 'Message tag: ', status%MPI_TAG\n    print '(A,5F6.1)', 'First 5 values: ', data(1:5)\n  end if\n\n  call MPI_Finalize(ierr)\n\nend program demo_mpi_recv\n```\n\nResults (with 2+ processes):\n\n```text\n Process 0 sent 50 elements\n Process 1 received elements: 50\n Source rank: 0\n Message tag: 99\n First 5 values:    1.0   2.0   3.0   4.0   5.0\n```\n\n### **Standard**\n\nMPI-1.0\n\n### **See Also**\n\n[**MPI_Send**(3)](#mpi_send),\n[**MPI_Irecv**(3)](#mpi_irecv),\n[**MPI_Probe**(3)](#mpi_probe),\n[**MPI_Get_count**(3)](#mpi_get_count),\n[**MPI_Sendrecv**(3)](#mpi_sendrecv),\n[**MPI_ANY_SOURCE**(3)](#mpi_any_source)",
  "donamed": "## named_do_loop\n\n### **Name**\n\n**named_do_loop** - \\[CONTROL:LOOP\\] Named iterative loop construct with explicit label\n\n### **Synopsis**\n```fortran\n    loop_name: do variable = start, end\n      ! loop body\n    end do loop_name\n```\n```fortran\n     construct named_do_loop(loop_name, variable, start, end)\n\n      character(len=*)      :: loop_name  ! construct name/label\n      integer, intent(in)   :: variable   ! loop counter\n      integer, intent(in)   :: start      ! initial value\n      integer, intent(in)   :: end        ! final value\n```\n\n### **Characteristics**\n\n - **loop_name** is a valid Fortran identifier used to label the construct.\n - **variable** is a scalar integer variable serving as the loop counter.\n - **start** is a scalar integer expression for the initial counter value.\n - **end** is a scalar integer expression for the final counter value.\n - The loop name must appear on both the DO statement and the END DO statement.\n - Named loops enable targeted EXIT and CYCLE statements for nested loop control.\n\n### **Description**\n\n **named_do_loop** creates a labeled iterative construct that executes a block\n of statements repeatedly while incrementing a counter variable from a starting\n value to an ending value. The explicit name provides self-documenting code and\n enables precise control flow in nested loop structures using EXIT loop_name\n and CYCLE loop_name statements.\n\n### **Options**\n\n- **loop_name**\n  : A valid Fortran identifier that labels the construct. Must be unique within\n  the scoping unit. The same name must appear after END DO. Enables targeted\n  EXIT and CYCLE statements when loops are nested.\n\n- **variable**\n  : A scalar integer variable that serves as the loop counter. It is incremented\n  automatically at the end of each iteration. Should not be modified within the\n  loop body.\n\n- **start**\n  : A scalar integer expression specifying the initial value of the loop counter.\n  Evaluated once before the first iteration.\n\n- **end**\n  : A scalar integer expression specifying the final value of the loop counter.\n  The loop executes while variable <= end (for positive increment).\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_named_do_loop\nimplicit none\n  integer :: i, j, k\n  integer :: matrix(3,3)\n  integer :: sum_total\n\n  ! Basic named loop - useful for documentation\n  row_loop: do i = 1, 3\n    print *, 'Processing row:', i\n  end do row_loop\n\n  ! Nested named loops with targeted EXIT\n  sum_total = 0\n  outer: do i = 1, 10\n    inner: do j = 1, 10\n      sum_total = sum_total + 1\n      if (sum_total > 50) exit outer  ! Exit outer loop directly\n    end do inner\n  end do outer\n  print *, 'Sum stopped at:', sum_total\n\n  ! Named loops with targeted CYCLE\n  matrix = 0\n  fill_rows: do i = 1, 3\n    fill_cols: do j = 1, 3\n      if (i == j) cycle fill_cols  ! Skip diagonal elements\n      matrix(i,j) = i * j\n    end do fill_cols\n  end do fill_rows\n  print *, 'Matrix (diagonal skipped):'\n  do i = 1, 3\n    print '(3I4)', matrix(i,:)\n  end do\n\n  ! Triple nested loop demonstrating precise control\n  search: do i = 1, 5\n    level2: do j = 1, 5\n      level3: do k = 1, 5\n        if (i*j*k == 30) then\n          print *, 'Found product 30 at:', i, j, k\n          exit search  ! Exit all three loops at once\n        end if\n      end do level3\n    end do level2\n  end do search\n\nend program demo_named_do_loop\n```\nResults:\n```text\n Processing row:           1\n Processing row:           2\n Processing row:           3\n Sum stopped at:          51\n Matrix (diagonal skipped):\n   0   2   3\n   2   0   6\n   3   6   0\n Found product 30 at:           2           3           5\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**do**(3)](#do),\n[**do_while**(3)](#do_while),\n[**do_concurrent**(3)](#do_concurrent),\n[**exit**(3)](#exit),\n[**cycle**(3)](#cycle)",
  "mpi_recv": "## MPI_Recv\n\n### **Name**\n\n**MPI_Recv** - \\[PARALLEL:MPI\\] Blocking receive for a message\n\n### **Synopsis**\n\n```fortran\n    call MPI_Recv(buf, count, datatype, source, tag, comm, status, ierror)\n```\n\n```fortran\n     subroutine MPI_Recv(buf, count, datatype, source, tag, comm, status, ierror)\n\n      type(*), dimension(..)         :: buf\n      integer, intent(in)            :: count\n      type(MPI_Datatype), intent(in) :: datatype\n      integer, intent(in)            :: source\n      integer, intent(in)            :: tag\n      type(MPI_Comm), intent(in)     :: comm\n      type(MPI_Status), intent(out)  :: status\n      integer, intent(out), optional :: ierror\n```\n\n### **Characteristics**\n\n - **buf** is the receive buffer where incoming data will be stored; can be any Fortran data type.\n - **count** is a non-negative integer specifying the maximum number of elements to receive.\n - **datatype** must be a valid MPI datatype handle (e.g., MPI_INTEGER, MPI_REAL, MPI_DOUBLE_PRECISION).\n - **source** is an integer rank of the sending process, or MPI_ANY_SOURCE to accept from any sender.\n - **tag** is a non-negative integer message tag, or MPI_ANY_TAG to accept any tag.\n - **comm** is a valid MPI communicator handle.\n - **status** returns message metadata; use MPI_STATUS_IGNORE if not needed.\n - **ierror** is the output error status; returns MPI_SUCCESS on success.\n - This is a **blocking** operation that returns only after the message has been received into the buffer.\n\n### **Description**\n\n **MPI_Recv** performs a standard-mode blocking receive operation. It blocks\n until the receive buffer contains the newly received message from the\n specified source. The actual length of the received message can be\n determined using MPI_Get_count on the returned status. The received\n message length must be less than or equal to the buffer length specified\n by count; otherwise, an MPI_ERR_TRUNCATE error occurs.\n\n### **Options**\n\n- **buf**\n  : Starting address of the receive buffer with room for count elements.\n  The received data is stored starting at this address.\n\n- **count**\n  : Maximum number of elements to receive. The actual message may be\n  shorter but not longer than this count.\n\n- **datatype**\n  : MPI datatype handle describing each buffer element.\n\n- **source**\n  : Rank of the sending process within comm, or MPI_ANY_SOURCE to receive\n  from any process. MPI_PROC_NULL is allowed for a null receive.\n\n- **tag**\n  : Message tag for matching, or MPI_ANY_TAG to match any tag.\n\n- **comm**\n  : MPI communicator defining the process group.\n\n- **status**\n  : Status object that receives information about the message:\n  status%MPI_SOURCE contains the source rank, status%MPI_TAG contains\n  the tag, and MPI_Get_count can determine the message length.\n\n- **ierror**\n  : Error code. Returns MPI_SUCCESS (0) on successful completion.\n\n### **Result**\n\n  The receive buffer is filled with data from the matching send operation.\n  The status object contains metadata about the received message including\n  the actual source rank and tag used.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_mpi_recv\n  use mpi_f08\n  implicit none\n  integer :: rank, nprocs, ierr\n  real(8) :: data(100)\n  type(MPI_Status) :: status\n  integer :: recv_count, i\n\n  call MPI_Init(ierr)\n  call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierr)\n  call MPI_Comm_size(MPI_COMM_WORLD, nprocs, ierr)\n\n  if (nprocs < 2) then\n    print *, 'This example requires at least 2 processes'\n    call MPI_Abort(MPI_COMM_WORLD, 1, ierr)\n  end if\n\n  if (rank == 0) then\n    ! Send 50 elements to process 1\n    data(1:50) = [(real(i, 8), i = 1, 50)]\n    call MPI_Send(data, 50, MPI_DOUBLE_PRECISION, 1, 99, MPI_COMM_WORLD, ierr)\n    print *, 'Process 0 sent 50 elements'\n  else if (rank == 1) then\n    ! Receive into buffer with room for 100 elements\n    call MPI_Recv(data, 100, MPI_DOUBLE_PRECISION, 0, 99, &\n                  MPI_COMM_WORLD, status, ierr)\n\n    ! Query actual received count\n    call MPI_Get_count(status, MPI_DOUBLE_PRECISION, recv_count, ierr)\n\n    print '(A,I0)', 'Process 1 received elements: ', recv_count\n    print '(A,I0)', 'Source rank: ', status%MPI_SOURCE\n    print '(A,I0)', 'Message tag: ', status%MPI_TAG\n    print '(A,5F6.1)', 'First 5 values: ', data(1:5)\n  end if\n\n  call MPI_Finalize(ierr)\n\nend program demo_mpi_recv\n```\n\nResults (with 2+ processes):\n\n```text\n Process 0 sent 50 elements\n Process 1 received elements: 50\n Source rank: 0\n Message tag: 99\n First 5 values:    1.0   2.0   3.0   4.0   5.0\n```\n\n### **Standard**\n\nMPI-1.0\n\n### **See Also**\n\n[**MPI_Send**(3)](#mpi_send),\n[**MPI_Irecv**(3)](#mpi_irecv),\n[**MPI_Probe**(3)](#mpi_probe),\n[**MPI_Get_count**(3)](#mpi_get_count),\n[**MPI_Sendrecv**(3)](#mpi_sendrecv),\n[**MPI_ANY_SOURCE**(3)](#mpi_any_source)",
  "ompbarrier": "## barrier\n\n### **Name**\n\n**barrier** - \\[PARALLEL:OPENMP\\] Explicit thread synchronization barrier\n\n### **Synopsis**\n\n```fortran\n    !$omp barrier\n```\n\n```fortran\n    ! Stand-alone directive (no clauses)\n    !$omp barrier\n```\n\n### **Characteristics**\n\n - **Stand-alone directive** that takes no clauses or arguments.\n - **Binding** is to the innermost enclosing parallel region.\n - **All threads** in the current team must encounter the barrier.\n - **Implicit tasks** and explicit tasks bound to the parallel region must complete before any thread continues.\n\n### **Description**\n\n **barrier** specifies an explicit synchronization point at which all threads in the current team must wait. When a thread reaches the barrier directive, it halts execution until all other threads in the team have also reached the barrier. Once all threads arrive and complete any pending explicit tasks bound to the parallel region, they resume parallel execution of subsequent code.\n\n The barrier construct ensures that all work performed by threads before the barrier is visible to all threads after the barrier. This is essential for maintaining data consistency when threads need to share results from parallel computations.\n\n### **Options**\\n\\nNone. This is a stand-alone synchronization construct that accepts no clauses or arguments.\n\n### **Result**\n\n  When all threads have reached the barrier, the synchronization is complete. All memory operations performed before the barrier by any thread are guaranteed to be visible to all threads after the barrier. Execution resumes with all threads synchronized at the same point in the program. The barrier establishes a happens-before relationship between code preceding and following the barrier across all threads.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_omp_barrier\n  use omp_lib\n  implicit none\n  integer :: thread_id\n  integer, parameter :: n = 4\n  integer :: partial_sums(n)\n  integer :: total_sum\n  integer :: i\n\n  total_sum = 0\n\n  !$omp parallel num_threads(n) private(thread_id) shared(partial_sums, total_sum)\n    thread_id = omp_get_thread_num()\n\n    ! Each thread computes its partial sum\n    partial_sums(thread_id + 1) = (thread_id + 1) * 10\n    print '(A,I0,A,I0)', 'Thread ', thread_id, ' computed partial sum: ', partial_sums(thread_id + 1)\n\n    ! Wait for all threads to finish computing\n    !$omp barrier\n\n    ! Only thread 0 computes the total after all partial sums are ready\n    !$omp single\n      do i = 1, n\n        total_sum = total_sum + partial_sums(i)\n      end do\n      print '(A,I0)', 'Total sum after barrier: ', total_sum\n    !$omp end single\n  !$omp end parallel\n\nend program demo_omp_barrier\n```\n\nResults:\n```text\nThread 0 computed partial sum: 10\nThread 1 computed partial sum: 20\nThread 2 computed partial sum: 30\nThread 3 computed partial sum: 40\nTotal sum after barrier: 100\n```\n\n### **Standard**\n\nOpenMP 1.0 (1997 for Fortran)\n\n### **See Also**\n\n[**!$omp parallel**(3)](#omp_parallel),\n[**!$omp critical**(3)](#omp_critical),\n[**!$omp single**(3)](#omp_single),\n[**!$omp atomic**(3)](#omp_atomic),\n[**omp_get_thread_num**(3)](#omp_get_thread_num)\n\n### **Resources**\n\n- [OpenMP 5.0 Barrier Construct Specification](https://www.openmp.org/spec-html/5.0/openmpsu90.html)\n- [LLNL OpenMP Tutorial - Barrier Directive](https://hpc-tutorials.llnl.gov/openmp/barrier_directive/)\n- [OpenMP Official Site](https://www.openmp.org/)",
  "modproc": "## modproc\n\n### **Name**\n\n**module procedure** - \\[STRUCTURE:PROCEDURE\\] Declare a module procedure within an interface or submodule\n\n### **Synopsis**\n```fortran\n    module procedure proc_name\n```\n```fortran\n     module procedure proc_name [, proc_name2, ...]\n\n     ! Within an interface block:\n     interface generic_name\n       module procedure specific_proc1\n       module procedure specific_proc2\n     end interface\n\n     ! Within a submodule:\n     submodule (parent_module) child_submodule\n     contains\n       module procedure deferred_proc\n         ! Implementation\n       end procedure\n     end submodule\n```\n\n### **Characteristics**\n\n - **proc_name** is the name of a procedure defined in the current module or its parent module.\n - Used within INTERFACE blocks to add module procedures to a generic interface.\n - Used within SUBMODULE to provide implementation of a deferred (separate) module procedure.\n - Multiple procedure names can be listed, separated by commas.\n - The referenced procedure must be accessible in the current scope.\n\n### **Description**\n\n **module procedure** serves two primary purposes in Fortran:\n\n 1. **Generic Interfaces**: Within an INTERFACE block, it declares that a module\n    procedure is a specific implementation of a generic interface. This allows\n    procedure overloading based on argument types.\n\n 2. **Submodule Implementation**: Within a SUBMODULE, it provides the actual\n    implementation of a procedure whose interface was declared with the SEPARATE\n    attribute in the parent module.\n\n### **Options**\n\n- **proc_name**\n  : The name of the module procedure to be included in the generic interface\n  or implemented in a submodule. Must be a valid Fortran identifier referencing\n  an accessible module procedure. Multiple names can be provided as a\n  comma-separated list.\n\n### **Examples**\n\nSample program demonstrating generic interface:\n```fortran\nprogram demo_module_procedure\n  use math_operations\n  implicit none\n  integer :: int_result\n  real :: real_result\n\n  ! Generic 'add' resolves to appropriate specific procedure\n  int_result = add(2, 3)\n  real_result = add(2.5, 3.7)\n\n  print *, 'Integer addition: ', int_result\n  print *, 'Real addition: ', real_result\n\nend program demo_module_procedure\n\nmodule math_operations\n  implicit none\n\n  interface add\n    module procedure add_integers\n    module procedure add_reals\n  end interface add\n\ncontains\n\n  function add_integers(a, b) result(c)\n    integer, intent(in) :: a, b\n    integer :: c\n    c = a + b\n  end function add_integers\n\n  function add_reals(a, b) result(c)\n    real, intent(in) :: a, b\n    real :: c\n    c = a + b\n  end function add_reals\n\nend module math_operations\n```\nResults:\n```text\n Integer addition:            5\n Real addition:    6.20000029\n```\n\nSample program demonstrating submodule implementation:\n```fortran\nmodule base_module\n  implicit none\n\n  interface\n    module subroutine greet(name)\n      character(len=*), intent(in) :: name\n    end subroutine greet\n  end interface\n\nend module base_module\n\nsubmodule (base_module) greetings_impl\n  implicit none\ncontains\n\n  module procedure greet\n    print *, 'Hello, ', trim(name), '!'\n  end procedure greet\n\nend submodule greetings_impl\n\nprogram demo_submodule_procedure\n  use base_module\n  implicit none\n\n  call greet('World')\n\nend program demo_submodule_procedure\n```\nResults:\n```text\n Hello, World!\n```\n\n### **Standard**\n\nFortran 90 (generic interfaces), Fortran 2008 (submodules)\n\n**Compatibility Notes:**\n- gfortran 4.5+, Intel Fortran 11.0+, NAG 5.3+\n- Allows generic interface with module procedures\n- Procedures must be in same module or accessible\n\n### **See Also**\n\n[**interface**(3)](#interface),\n[**submodule**(3)](#submodule),\n[**procedure**(3)](#procedure),\n[**contains**(3)](#contains)",
  "moduleprocedure": "## moduleprocedure\n\n### **Name**\n\n**module procedure** - \\[STRUCTURE:PROCEDURE\\] Declare a module procedure within an interface or submodule\n\n### **Synopsis**\n```fortran\n    module procedure proc_name\n```\n```fortran\n     module procedure proc_name [, proc_name2, ...]\n\n     ! Within an interface block:\n     interface generic_name\n       module procedure specific_proc1\n       module procedure specific_proc2\n     end interface\n\n     ! Within a submodule:\n     submodule (parent_module) child_submodule\n     contains\n       module procedure deferred_proc\n         ! Implementation\n       end procedure\n     end submodule\n```\n\n### **Characteristics**\n\n - **proc_name** is the name of a procedure defined in the current module or its parent module.\n - Used within INTERFACE blocks to add module procedures to a generic interface.\n - Used within SUBMODULE to provide implementation of a deferred (separate) module procedure.\n - Multiple procedure names can be listed, separated by commas.\n - The referenced procedure must be accessible in the current scope.\n\n### **Description**\n\n **module procedure** serves two primary purposes in Fortran:\n\n 1. **Generic Interfaces**: Within an INTERFACE block, it declares that a module\n    procedure is a specific implementation of a generic interface. This allows\n    procedure overloading based on argument types.\n\n 2. **Submodule Implementation**: Within a SUBMODULE, it provides the actual\n    implementation of a procedure whose interface was declared with the SEPARATE\n    attribute in the parent module.\n\n### **Options**\n\n- **proc_name**\n  : The name of the module procedure to be included in the generic interface\n  or implemented in a submodule. Must be a valid Fortran identifier referencing\n  an accessible module procedure. Multiple names can be provided as a\n  comma-separated list.\n\n### **Examples**\n\nSample program demonstrating generic interface:\n```fortran\nprogram demo_module_procedure\n  use math_operations\n  implicit none\n  integer :: int_result\n  real :: real_result\n\n  ! Generic 'add' resolves to appropriate specific procedure\n  int_result = add(2, 3)\n  real_result = add(2.5, 3.7)\n\n  print *, 'Integer addition: ', int_result\n  print *, 'Real addition: ', real_result\n\nend program demo_module_procedure\n\nmodule math_operations\n  implicit none\n\n  interface add\n    module procedure add_integers\n    module procedure add_reals\n  end interface add\n\ncontains\n\n  function add_integers(a, b) result(c)\n    integer, intent(in) :: a, b\n    integer :: c\n    c = a + b\n  end function add_integers\n\n  function add_reals(a, b) result(c)\n    real, intent(in) :: a, b\n    real :: c\n    c = a + b\n  end function add_reals\n\nend module math_operations\n```\nResults:\n```text\n Integer addition:            5\n Real addition:    6.20000029\n```\n\nSample program demonstrating submodule implementation:\n```fortran\nmodule base_module\n  implicit none\n\n  interface\n    module subroutine greet(name)\n      character(len=*), intent(in) :: name\n    end subroutine greet\n  end interface\n\nend module base_module\n\nsubmodule (base_module) greetings_impl\n  implicit none\ncontains\n\n  module procedure greet\n    print *, 'Hello, ', trim(name), '!'\n  end procedure greet\n\nend submodule greetings_impl\n\nprogram demo_submodule_procedure\n  use base_module\n  implicit none\n\n  call greet('World')\n\nend program demo_submodule_procedure\n```\nResults:\n```text\n Hello, World!\n```\n\n### **Standard**\n\nFortran 90 (generic interfaces), Fortran 2008 (submodules)\n\n**Compatibility Notes:**\n- gfortran 4.5+, Intel Fortran 11.0+, NAG 5.3+\n- Allows generic interface with module procedures\n- Procedures must be in same module or accessible\n\n### **See Also**\n\n[**interface**(3)](#interface),\n[**submodule**(3)](#submodule),\n[**procedure**(3)](#procedure),\n[**contains**(3)](#contains)",
  "cbindsub": "## bind_c_subroutine\n\n### **Name**\n\n**bind_c_subroutine** - \\[INTEROP:C_BINDING\\] Declare a Fortran subroutine interoperable with C\n\n### **Synopsis**\n```fortran\n    call fortran_sub(arg1, arg2)\n```\n```fortran\n     subroutine fortran_sub(arg1, arg2) bind(c, name='c_func_name')\n\n      use iso_c_binding, only: c_int, c_double, c_ptr\n      integer(c_int), intent(in), value :: arg1\n      real(c_double), intent(inout)     :: arg2\n```\n\n### **Characteristics**\n\n - **bind(c)** makes the subroutine callable from C with C calling conventions.\n - **name='c_func_name'** specifies the external C name (optional, defaults to lowercase Fortran name).\n - All dummy arguments must be interoperable C types from ISO_C_BINDING.\n - Arguments passed by value use the **value** attribute.\n - Arguments passed by reference (C pointers) omit the value attribute.\n - Subroutines correspond to C void functions.\n\n### **Description**\n\n **bind_c_subroutine** creates a Fortran subroutine that can be called from C code\n or that implements a C void function interface. The BIND(C) attribute ensures the\n subroutine uses C calling conventions and name mangling. The NAME= specifier\n allows controlling the exact symbol name visible to the C linker.\n\n### **Options**\n\n- **bind(c)**\n  : Required attribute that specifies C interoperability. The subroutine will\n  use C calling conventions and be callable from C code.\n\n- **name='c_name'**\n  : Optional. Specifies the exact C symbol name for the subroutine. If omitted,\n  the Fortran name is used in lowercase. Use this to match existing C APIs.\n\n- **value**\n  : Attribute for dummy arguments that should be passed by value (like C\n  scalar arguments). Without this attribute, arguments are passed by reference.\n\n- **intent(in/out/inout)**\n  : Specifies argument intent. For value arguments, only intent(in) is valid.\n  For reference arguments, any intent may be used.\n\n### **Result**\n\n  The subroutine has no return value (corresponds to void in C). All output\n  is through intent(out) or intent(inout) arguments passed by reference.\n\n### **Examples**\n\nSample program (Fortran side):\n```fortran\nmodule c_interface_module\n  use iso_c_binding\n  implicit none\ncontains\n\n  ! Subroutine callable from C as: void scale_array(double* arr, int n, double factor)\n  subroutine scale_array(arr, n, factor) bind(c, name='scale_array')\n    integer(c_int), intent(in), value :: n\n    real(c_double), intent(inout)     :: arr(n)\n    real(c_double), intent(in), value :: factor\n\n    arr = arr * factor\n  end subroutine scale_array\n\n  ! Subroutine callable from C as: void swap_values(int* a, int* b)\n  subroutine swap_values(a, b) bind(c, name='swap_values')\n    integer(c_int), intent(inout) :: a, b\n    integer(c_int) :: temp\n\n    temp = a\n    a = b\n    b = temp\n  end subroutine swap_values\n\n  ! Subroutine callable from C as: void init_array(double* arr, int n, double val)\n  subroutine init_array(arr, n, val) bind(c, name='init_array')\n    integer(c_int), intent(in), value :: n\n    real(c_double), intent(out)       :: arr(n)\n    real(c_double), intent(in), value :: val\n\n    arr = val\n  end subroutine init_array\n\nend module c_interface_module\n\nprogram demo_bind_c_subroutine\n  use c_interface_module\n  use iso_c_binding\n  implicit none\n\n  real(c_double) :: data(5)\n  integer(c_int) :: x, y\n\n  ! Initialize array\n  call init_array(data, 5_c_int, 2.0_c_double)\n  print '(A,5F8.2)', 'After init: ', data\n\n  ! Scale array\n  call scale_array(data, 5_c_int, 3.0_c_double)\n  print '(A,5F8.2)', 'After scale:', data\n\n  ! Swap values\n  x = 10\n  y = 20\n  print '(A,I0,A,I0)', 'Before swap: x=', x, ', y=', y\n  call swap_values(x, y)\n  print '(A,I0,A,I0)', 'After swap:  x=', x, ', y=', y\n\nend program demo_bind_c_subroutine\n```\n\nCorresponding C header:\n```c\n/* c_interface.h */\nvoid scale_array(double* arr, int n, double factor);\nvoid swap_values(int* a, int* b);\nvoid init_array(double* arr, int n, double val);\n```\n\nResults:\n```text\nAfter init:     2.00    2.00    2.00    2.00    2.00\nAfter scale:    6.00    6.00    6.00    6.00    6.00\nBefore swap: x=10, y=20\nAfter swap:  x=20, y=10\n```\n\n### **Standard**\n\nFortran 2003 (ISO/IEC 1539-1:2004)\n\n**Compatibility Notes:**\n- gfortran 4.3+, Intel Fortran 10.0+, NAG 5.1+\n- Subroutine corresponds to void C function\n- Use VALUE attribute for pass-by-value arguments\n\n### **See Also**\n\n[**bind_c_function**(3)](#bind_c_function),\n[**bind_c_type**(3)](#bind_c_type),\n[**c_loc**(3)](#c_loc),\n[**c_f_pointer**(3)](#c_f_pointer),\n[**iso_c_binding**(3)](#iso_c_binding)",
  "dp": "## kind_parameter_dp\n\n### **Name**\n\n**dp** - \\[NUMERIC:KIND\\] Define a kind parameter for double precision reals\n\n### **Synopsis**\n```fortran\n    integer, parameter :: dp = selected_real_kind(15, 307)\n```\n```fortran\n     ! Kind parameter definition\n\n      integer, parameter :: dp = selected_real_kind(15, 307)\n      ! Alternative using kind intrinsic:\n      integer, parameter :: dp = kind(1.0d0)\n```\n\n### **Characteristics**\n\n - **dp** is an integer named constant representing a kind value.\n - **selected_real_kind(15, 307)** requests at least 15 decimal digits and exponent range of 307.\n - This approach is portable across different compilers and platforms.\n - Typically returns kind value 8 on most systems (64-bit IEEE 754 double).\n\n### **Description**\n\n **dp** defines a named kind parameter for double precision real numbers.\n Using `selected_real_kind` ensures portability by specifying precision and\n range requirements rather than relying on compiler-specific kind values.\n This is the modern Fortran approach, replacing the non-standard\n `double precision` type declaration.\n\n### **Options**\n\n- **selected_real_kind(p, r)**\n  : Returns a kind value providing at least **p** decimal digits of precision\n  and an exponent range of at least **r**. For double precision, p=15 and\n  r=307 are typical choices.\n\n- **kind(1.0d0)**\n  : Returns the kind value of the double precision constant 1.0d0. This is\n  compiler-specific but usually gives the same result as selected_real_kind.\n\n### **Result**\n\n  An integer constant representing the kind type parameter for double\n  precision real variables. This value can be used in declarations and\n  literal constant suffixes.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_dp_kind\nimplicit none\n  ! Portable double precision kind parameter\n  integer, parameter :: dp = selected_real_kind(15, 307)\n\n  real(dp) :: x, y, z\n  real(dp), parameter :: pi = 3.14159265358979323846_dp\n\n  ! Verify precision\n  print '(A,I0)', 'Kind value: ', dp\n  print '(A,I0)', 'Decimal digits: ', precision(x)\n  print '(A,I0)', 'Exponent range: ', range(x)\n  print '(A,I0)', 'Storage size (bits): ', storage_size(x)\n\n  ! Use in calculations\n  x = 1.0_dp\n  y = 3.0_dp\n  z = x / y\n  print '(A,F25.20)', 'x/y = ', z\n\n  ! Compare with pi\n  print '(A,F25.20)', 'pi  = ', pi\n\nend program demo_dp_kind\n```\nResults:\n```text\nKind value: 8\nDecimal digits: 15\nExponent range: 307\nStorage size (bits): 64\nx/y =  0.33333333333333331483\npi  =  3.14159265358979311600\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**selected_real_kind**(3)](#selected_real_kind),\n[**precision**(3)](#precision),\n[**range**(3)](#range),\n[**kind**(3)](#kind)",
  "_dp": "## kind_suffix_dp\n\n### **Name**\n\n**_dp** - \\[NUMERIC:KIND\\] Double precision kind suffix for numeric literals\n\n### **Synopsis**\n```fortran\n    value_dp = 1.0_dp\n```\n```fortran\n     ! Kind suffix usage\n\n      integer, parameter :: dp = selected_real_kind(15, 307)\n      real(dp) :: x = 3.14159265358979_dp\n```\n\n### **Characteristics**\n\n - **_dp** is appended to literal constants to specify their kind.\n - The kind parameter **dp** must be defined before use.\n - Ensures literal constants have the correct precision throughout computations.\n - Prevents precision loss from implicit conversions.\n\n### **Description**\n\n **_dp** is a kind type parameter suffix that specifies the precision of a\n numeric literal constant. By appending _dp to a literal, you ensure the\n constant is stored with double precision from the start, avoiding precision\n loss that would occur if a single precision literal were later converted\n to double precision.\n\n### **Options**\n\n- **dp**\n  : The kind parameter name. Must be previously defined, typically as\n  `integer, parameter :: dp = selected_real_kind(15, 307)` or\n  `integer, parameter :: dp = kind(1.0d0)`.\n\n### **Result**\n\n  The literal constant is created with the specified kind parameter,\n  ensuring full precision is maintained throughout calculations.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_kind_suffix\nimplicit none\n  integer, parameter :: dp = selected_real_kind(15, 307)\n  real(dp) :: pi_correct, pi_wrong\n  real(dp) :: small_correct, small_wrong\n\n  ! Correct: literal has full precision\n  pi_correct = 3.14159265358979323846_dp\n\n  ! Wrong: literal truncated to single precision, then converted\n  pi_wrong = 3.14159265358979323846\n\n  ! Show the difference\n  print '(A)', 'Pi comparison:'\n  print '(A,F25.20)', '  With _dp suffix:    ', pi_correct\n  print '(A,F25.20)', '  Without suffix:     ', pi_wrong\n  print '(A,ES15.8)', '  Difference:         ', abs(pi_correct - pi_wrong)\n\n  ! Small numbers also affected\n  small_correct = 1.23456789012345_dp\n  small_wrong = 1.23456789012345\n\n  print '(A)', 'Small number comparison:'\n  print '(A,F20.15)', '  With _dp suffix:    ', small_correct\n  print '(A,F20.15)', '  Without suffix:     ', small_wrong\n\nend program demo_kind_suffix\n```\nResults:\n```text\nPi comparison:\n  With _dp suffix:      3.14159265358979311600\n  Without suffix:       3.14159274101257324219\n  Difference:    8.74E-08\nSmall number comparison:\n  With _dp suffix:     1.234567890123450\n  Without suffix:      1.234567880630493\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**selected_real_kind**(3)](#selected_real_kind),\n[**kind**(3)](#kind),\n[**real**(3)](#real)",
  "iocheck": "## iostat_check\n\n### **Name**\n\n**iostat_check** - \\[IO:FILE\\] Check IOSTAT return value and handle I/O errors\n\n### **Synopsis**\n```fortran\n    if (ierr /= 0) then\n      ! Handle error\n    end if\n```\n```fortran\n     ! Pattern for IOSTAT checking\n\n      integer :: ierr                    ! IOSTAT return value\n      character(len=*) :: errmsg         ! IOMSG error description\n\n      ! Check iostat after I/O operation\n      if (ierr < 0) then\n        ! End-of-file or end-of-record\n      else if (ierr > 0) then\n        ! Error occurred\n      else\n        ! Success (ierr == 0)\n      end if\n```\n\n### **Characteristics**\n\n - **ierr** is an integer variable that received the IOSTAT value from an I/O operation.\n - Zero indicates successful completion.\n - Positive values indicate an error condition occurred.\n - Negative values indicate end-of-file (-1) or end-of-record (-2).\n - The pattern prevents program termination on I/O errors.\n\n### **Description**\n\n **iostat_check** demonstrates the standard pattern for handling I/O status codes. Using IOSTAT= in I/O statements prevents the default behavior of program termination on errors, allowing graceful error handling. This is essential for robust programs that must handle missing files, invalid data, or network issues.\n\n### **Options**\n\n- **ierr values**\n  : The IOSTAT return codes have these meanings:\n  - `0`: Operation completed successfully\n  - `> 0`: An error occurred (code is processor-dependent)\n  - `< 0`: End condition:\n    - `IOSTAT_END` (typically -1): End-of-file reached\n    - `IOSTAT_EOR` (typically -2): End-of-record (non-advancing I/O)\n\n- **errmsg**\n  : The IOMSG= specifier provides a human-readable error description when IOSTAT is nonzero.\n\n- **ISO_FORTRAN_ENV constants**\n  : Use `IOSTAT_END` and `IOSTAT_EOR` from ISO_FORTRAN_ENV for portable EOF/EOR checking.\n\n### **Result**\n\n  The program can detect and respond to error conditions instead of terminating. This enables retry logic, alternative actions, or clean shutdown procedures.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_iostat_check\nuse iso_fortran_env, only: iostat_end, iostat_eor\nimplicit none\n  integer :: unit_num, ierr, line_num\n  character(len=256) :: errmsg, line\n  real :: value\n\n  ! Create test file\n  open(newunit=unit_num, file='test_io.txt', status='replace')\n  write(unit_num, '(A)') '100.0'\n  write(unit_num, '(A)') '200.0'\n  write(unit_num, '(A)') 'invalid'\n  write(unit_num, '(A)') '300.0'\n  close(unit_num)\n\n  ! Read with comprehensive error handling\n  open(newunit=unit_num, file='test_io.txt', status='old', &\n       iostat=ierr, iomsg=errmsg)\n\n  if (ierr /= 0) then\n    print '(A,A)', 'Cannot open file: ', trim(errmsg)\n    error stop\n  end if\n\n  line_num = 0\n  do\n    line_num = line_num + 1\n    read(unit_num, '(A)', iostat=ierr, iomsg=errmsg) line\n\n    ! Check for end-of-file\n    if (ierr == iostat_end) then\n      print '(A)', 'Reached end of file'\n      exit\n    end if\n\n    ! Check for other errors\n    if (ierr > 0) then\n      print '(A,I0,A,A)', 'Read error on line ', line_num, ': ', trim(errmsg)\n      cycle\n    end if\n\n    ! Parse the line\n    read(line, *, iostat=ierr, iomsg=errmsg) value\n    if (ierr /= 0) then\n      print '(A,I0,A,A)', 'Parse error on line ', line_num, &\n            ': \"', trim(line), '\"'\n    else\n      print '(A,I0,A,F10.2)', 'Line ', line_num, ': value = ', value\n    end if\n  end do\n\n  close(unit_num, status='delete')\n\nend program demo_iostat_check\n```\nResults:\n```text\nLine 1: value =     100.00\nLine 2: value =     200.00\nParse error on line 3: \"invalid\"\nLine 4: value =     300.00\nReached end of file\n```\n\n### **Standard**\n\nFortran 90 (IOSTAT), Fortran 2003 (IOMSG, ISO_FORTRAN_ENV)\n\n**Compatibility Notes:**\n- gfortran 4.0+, Intel Fortran 9.0+, NAG 5.0+\n- Use IOSTAT= and IOMSG= for error handling\n- IS_IOSTAT_END() for end-of-file detection (F2003)\n\n### **See Also**\n\n[**open**(3)](#open),\n[**read**(3)](#read),\n[**write**(3)](#write),\n[**iostat_end**(3)](#iostat_end),\n[**iostat_eor**(3)](#iostat_eor)",
  "nullify": "## nullify\n\n### **Name**\n\n**nullify** - \\[TYPE:POINTER\\] Disassociate a pointer from its target\n\n### **Synopsis**\n```fortran\n    nullify(pointer1 [, pointer2, ...])\n```\n```fortran\n     ! Nullify statement\n\n      nullify(ptr)\n      nullify(ptr1, ptr2, ptr3)\n```\n\n### **Characteristics**\n\n - Sets pointer association status to \"disassociated\".\n - Can nullify multiple pointers in one statement.\n - Does NOT deallocate the target.\n - Pointer becomes safe to test with associated().\n\n### **Description**\n\n **nullify** disassociates one or more pointers from their targets. After\n nullification, the pointer's association status is \"disassociated\" rather\n than \"undefined\". This is important because associated() can only be safely\n called on pointers that are either associated or disassociated, not undefined.\n\n### **Options**\n\n- **pointer1, pointer2, ...**\n  : One or more pointer variables to disassociate. Each pointer's association\n  status becomes \"disassociated\".\n\n### **Result**\n\n  The specified pointers are disassociated. Their targets are not affected\n  (no deallocation occurs).\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_nullify\nimplicit none\n  integer, pointer :: p1, p2, p3\n  integer, target :: x = 10, y = 20, z = 30\n  integer, pointer :: arr(:)\n  integer, target :: data(5) = [1, 2, 3, 4, 5]\n\n  ! Associate pointers\n  p1 => x\n  p2 => y\n  p3 => z\n  arr => data\n\n  print '(A)', 'Before nullify:'\n  print '(A,L1)', '  p1 associated: ', associated(p1)\n  print '(A,L1)', '  p2 associated: ', associated(p2)\n  print '(A,L1)', '  p3 associated: ', associated(p3)\n  print '(A,L1)', '  arr associated: ', associated(arr)\n\n  ! Nullify single pointer\n  nullify(p1)\n  print '(A)', 'After nullify(p1):'\n  print '(A,L1)', '  p1 associated: ', associated(p1)\n\n  ! Nullify multiple pointers\n  nullify(p2, p3, arr)\n  print '(A)', 'After nullify(p2, p3, arr):'\n  print '(A,L1)', '  p2 associated: ', associated(p2)\n  print '(A,L1)', '  p3 associated: ', associated(p3)\n  print '(A,L1)', '  arr associated: ', associated(arr)\n\n  ! Original targets are unaffected\n  print '(A)', 'Original targets (unchanged):'\n  print '(A,I0)', '  x = ', x\n  print '(A,I0)', '  y = ', y\n  print '(A,I0)', '  z = ', z\n  print '(A,5I3)', '  data = ', data\n\n  ! Safe to reassign after nullify\n  p1 => x\n  print '(A,I0)', 'p1 reassigned to x: ', p1\n\nend program demo_nullify\n```\nResults:\n```text\nBefore nullify:\n  p1 associated: T\n  p2 associated: T\n  p3 associated: T\n  arr associated: T\nAfter nullify(p1):\n  p1 associated: F\nAfter nullify(p2, p3, arr):\n  p2 associated: F\n  p3 associated: F\n  arr associated: F\nOriginal targets (unchanged):\n  x = 10\n  y = 20\n  z = 30\n  data =   1  2  3  4  5\np1 reassigned to x: 10\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**null**(3)](#null),\n[**associated**(3)](#associated),\n[**deallocate**(3)](#deallocate)",
  "iostatcheck": "## iostat_check\n\n### **Name**\n\n**iostat_check** - \\[IO:FILE\\] Check IOSTAT return value and handle I/O errors\n\n### **Synopsis**\n```fortran\n    if (ierr /= 0) then\n      ! Handle error\n    end if\n```\n```fortran\n     ! Pattern for IOSTAT checking\n\n      integer :: ierr                    ! IOSTAT return value\n      character(len=*) :: errmsg         ! IOMSG error description\n\n      ! Check iostat after I/O operation\n      if (ierr < 0) then\n        ! End-of-file or end-of-record\n      else if (ierr > 0) then\n        ! Error occurred\n      else\n        ! Success (ierr == 0)\n      end if\n```\n\n### **Characteristics**\n\n - **ierr** is an integer variable that received the IOSTAT value from an I/O operation.\n - Zero indicates successful completion.\n - Positive values indicate an error condition occurred.\n - Negative values indicate end-of-file (-1) or end-of-record (-2).\n - The pattern prevents program termination on I/O errors.\n\n### **Description**\n\n **iostat_check** demonstrates the standard pattern for handling I/O status codes. Using IOSTAT= in I/O statements prevents the default behavior of program termination on errors, allowing graceful error handling. This is essential for robust programs that must handle missing files, invalid data, or network issues.\n\n### **Options**\n\n- **ierr values**\n  : The IOSTAT return codes have these meanings:\n  - `0`: Operation completed successfully\n  - `> 0`: An error occurred (code is processor-dependent)\n  - `< 0`: End condition:\n    - `IOSTAT_END` (typically -1): End-of-file reached\n    - `IOSTAT_EOR` (typically -2): End-of-record (non-advancing I/O)\n\n- **errmsg**\n  : The IOMSG= specifier provides a human-readable error description when IOSTAT is nonzero.\n\n- **ISO_FORTRAN_ENV constants**\n  : Use `IOSTAT_END` and `IOSTAT_EOR` from ISO_FORTRAN_ENV for portable EOF/EOR checking.\n\n### **Result**\n\n  The program can detect and respond to error conditions instead of terminating. This enables retry logic, alternative actions, or clean shutdown procedures.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_iostat_check\nuse iso_fortran_env, only: iostat_end, iostat_eor\nimplicit none\n  integer :: unit_num, ierr, line_num\n  character(len=256) :: errmsg, line\n  real :: value\n\n  ! Create test file\n  open(newunit=unit_num, file='test_io.txt', status='replace')\n  write(unit_num, '(A)') '100.0'\n  write(unit_num, '(A)') '200.0'\n  write(unit_num, '(A)') 'invalid'\n  write(unit_num, '(A)') '300.0'\n  close(unit_num)\n\n  ! Read with comprehensive error handling\n  open(newunit=unit_num, file='test_io.txt', status='old', &\n       iostat=ierr, iomsg=errmsg)\n\n  if (ierr /= 0) then\n    print '(A,A)', 'Cannot open file: ', trim(errmsg)\n    error stop\n  end if\n\n  line_num = 0\n  do\n    line_num = line_num + 1\n    read(unit_num, '(A)', iostat=ierr, iomsg=errmsg) line\n\n    ! Check for end-of-file\n    if (ierr == iostat_end) then\n      print '(A)', 'Reached end of file'\n      exit\n    end if\n\n    ! Check for other errors\n    if (ierr > 0) then\n      print '(A,I0,A,A)', 'Read error on line ', line_num, ': ', trim(errmsg)\n      cycle\n    end if\n\n    ! Parse the line\n    read(line, *, iostat=ierr, iomsg=errmsg) value\n    if (ierr /= 0) then\n      print '(A,I0,A,A)', 'Parse error on line ', line_num, &\n            ': \"', trim(line), '\"'\n    else\n      print '(A,I0,A,F10.2)', 'Line ', line_num, ': value = ', value\n    end if\n  end do\n\n  close(unit_num, status='delete')\n\nend program demo_iostat_check\n```\nResults:\n```text\nLine 1: value =     100.00\nLine 2: value =     200.00\nParse error on line 3: \"invalid\"\nLine 4: value =     300.00\nReached end of file\n```\n\n### **Standard**\n\nFortran 90 (IOSTAT), Fortran 2003 (IOMSG, ISO_FORTRAN_ENV)\n\n**Compatibility Notes:**\n- gfortran 4.0+, Intel Fortran 9.0+, NAG 5.0+\n- Use IOSTAT= and IOMSG= for error handling\n- IS_IOSTAT_END() for end-of-file detection (F2003)\n\n### **See Also**\n\n[**open**(3)](#open),\n[**read**(3)](#read),\n[**write**(3)](#write),\n[**iostat_end**(3)](#iostat_end),\n[**iostat_eor**(3)](#iostat_eor)",
  "dgemm": "## dgemm\n\n### **Name**\n\n**dgemm** - \\[NUMERIC:BLAS\\] Double precision general matrix-matrix multiply\n\n### **Synopsis**\n```fortran\n    call dgemm(transa, transb, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc)\n```\n```fortran\n     subroutine dgemm(transa, transb, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc)\n\n      character(len=1), intent(in) :: transa, transb\n      integer, intent(in)          :: m, n, k, lda, ldb, ldc\n      double precision, intent(in) :: alpha, beta\n      double precision, intent(in) :: A(lda,*), B(ldb,*)\n      double precision, intent(inout) :: C(ldc,*)\n```\n\n### **Characteristics**\n\n - Level 3 BLAS routine for matrix-matrix operations.\n - Performs C := alpha*op(A)*op(B) + beta*C.\n - **op(X)** is X, X**T (transpose), or X**H (conjugate transpose).\n - Requires linking with a BLAS library (OpenBLAS, MKL, etc.).\n\n### **Description**\n\n **dgemm** performs one of the matrix-matrix operations C := alpha*op(A)*op(B) + beta*C,\n where op(X) is X or X**T, alpha and beta are scalars, and A, B, and C are matrices.\n op(A) is an m-by-k matrix, op(B) is a k-by-n matrix, and C is an m-by-n matrix.\n This is the fundamental BLAS Level 3 routine for matrix multiplication.\n\n### **Options**\n\n- **transa**\n  : Specifies op(A): 'N' for A, 'T' for A**T, 'C' for A**H.\n\n- **transb**\n  : Specifies op(B): 'N' for B, 'T' for B**T, 'C' for B**H.\n\n- **m**\n  : Number of rows of op(A) and C.\n\n- **n**\n  : Number of columns of op(B) and C.\n\n- **k**\n  : Number of columns of op(A) and rows of op(B).\n\n- **alpha**\n  : Scalar multiplier for op(A)*op(B).\n\n- **A**\n  : Array containing matrix A.\n\n- **lda**\n  : Leading dimension of A. Must be >= max(1, m) if transa='N', else >= max(1, k).\n\n- **B**\n  : Array containing matrix B.\n\n- **ldb**\n  : Leading dimension of B. Must be >= max(1, k) if transb='N', else >= max(1, n).\n\n- **beta**\n  : Scalar multiplier for C. If beta=0, C need not be initialized.\n\n- **C**\n  : Array containing matrix C. On exit, overwritten by result.\n\n- **ldc**\n  : Leading dimension of C. Must be >= max(1, m).\n\n### **Result**\n\n  Matrix C is overwritten with alpha*op(A)*op(B) + beta*C.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_dgemm\nimplicit none\n  external :: dgemm\n\n  integer, parameter :: m = 3, n = 3, k = 2\n  double precision :: A(m, k), B(k, n), C(m, n)\n  double precision :: alpha, beta\n  integer :: i\n\n  ! Initialize matrices\n  ! A is 3x2\n  A = reshape([1.0d0, 2.0d0, 3.0d0, &\n               4.0d0, 5.0d0, 6.0d0], [m, k])\n\n  ! B is 2x3\n  B = reshape([1.0d0, 2.0d0, &\n               3.0d0, 4.0d0, &\n               5.0d0, 6.0d0], [k, n])\n\n  ! C is 3x3, initialize to zero\n  C = 0.0d0\n\n  alpha = 1.0d0\n  beta = 0.0d0\n\n  ! Compute C = alpha * A * B + beta * C\n  call dgemm('N', 'N', m, n, k, alpha, A, m, B, k, beta, C, m)\n\n  print '(A)', 'Matrix A (3x2):'\n  do i = 1, m\n    print '(2F8.2)', A(i, :)\n  end do\n\n  print '(A)', 'Matrix B (2x3):'\n  do i = 1, k\n    print '(3F8.2)', B(i, :)\n  end do\n\n  print '(A)', 'Result C = A * B (3x3):'\n  do i = 1, m\n    print '(3F8.2)', C(i, :)\n  end do\n\n  ! Compare with intrinsic matmul\n  print '(A)', 'Verification using matmul:'\n  C = matmul(A, B)\n  do i = 1, m\n    print '(3F8.2)', C(i, :)\n  end do\n\nend program demo_dgemm\n```\nResults:\n```text\nMatrix A (3x2):\n    1.00    4.00\n    2.00    5.00\n    3.00    6.00\nMatrix B (2x3):\n    1.00    3.00    5.00\n    2.00    4.00    6.00\nResult C = A * B (3x3):\n    9.00   19.00   29.00\n   12.00   26.00   40.00\n   15.00   33.00   51.00\nVerification using matmul:\n    9.00   19.00   29.00\n   12.00   26.00   40.00\n   15.00   33.00   51.00\n```\n\n### **Standard**\n\nBLAS Level 3 (not Fortran standard, but widely available)\n\n### **See Also**\n\n[**matmul**(3)](#matmul),\n[**dgemv**(3)](#dgemv),\n[**dgesv**(3)](#dgesv)",
  "genericinterface": "## generic_interface\n\n### **Name**\n\n**generic_interface** - \\[STRUCTURE:PROCEDURE\\] Define a generic interface that maps a single name to multiple specific procedures\n\n### **Synopsis**\n```fortran\n    interface generic_name\n       module procedure specific_proc1\n       module procedure specific_proc2\n    end interface generic_name\n```\n```fortran\n     interface generic_name\n\n      ! Declares a generic name that can resolve to\n      ! different procedures based on argument types\n      module procedure :: specific_proc1  ! handles type1 arguments\n      module procedure :: specific_proc2  ! handles type2 arguments\n\n     end interface generic_name\n```\n\n### **Characteristics**\n\n - **generic_name** is the common name used to invoke any of the specific procedures.\n - **specific procedures** must have distinguishable argument signatures (type, kind, or rank).\n - All procedures in the interface must be module procedures or external procedures with explicit interfaces.\n - The compiler selects the appropriate procedure based on the actual arguments at the call site.\n\n### **Description**\n\n **generic_interface** allows multiple procedures to be called using a single generic name. The compiler determines which specific procedure to invoke based on the types, kinds, and ranks of the actual arguments. This enables polymorphic behavior and cleaner APIs where the same operation can apply to different data types.\n\n### **Options**\n\n- **generic_name**\n  : The identifier used to call any of the grouped procedures. Must be a valid Fortran identifier.\n\n- **module procedure**\n  : Specifies a procedure defined in the same module that should be accessible through the generic name. Each listed procedure must have a unique signature distinguishable by argument characteristics.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_generic_interface\nimplicit none\n\n  interface swap\n     module procedure swap_int, swap_real\n  end interface swap\n\n  integer :: i1 = 10, i2 = 20\n  real    :: r1 = 1.5, r2 = 3.5\n\n  print *, 'Before swap:'\n  print *, 'Integers: i1 =', i1, ', i2 =', i2\n  print *, 'Reals:    r1 =', r1, ', r2 =', r2\n\n  call swap(i1, i2)  ! Calls swap_int\n  call swap(r1, r2)  ! Calls swap_real\n\n  print *, 'After swap:'\n  print *, 'Integers: i1 =', i1, ', i2 =', i2\n  print *, 'Reals:    r1 =', r1, ', r2 =', r2\n\ncontains\n\n  subroutine swap_int(a, b)\n    integer, intent(inout) :: a, b\n    integer :: temp\n    temp = a\n    a = b\n    b = temp\n  end subroutine swap_int\n\n  subroutine swap_real(a, b)\n    real, intent(inout) :: a, b\n    real :: temp\n    temp = a\n    a = b\n    b = temp\n  end subroutine swap_real\n\nend program demo_generic_interface\n```\nResults:\n```text\n Before swap:\n Integers: i1 =          10 , i2 =          20\n Reals:    r1 =   1.500000     , r2 =   3.500000\n After swap:\n Integers: i1 =          20 , i2 =          10\n Reals:    r1 =   3.500000     , r2 =   1.500000\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**abstract_interface**(3)](#abstract_interface),\n[**module**(3)](#module),\n[**procedure**(3)](#procedure)",
  "allocsource": "## allocate_source\n\n### **Name**\n\n**allocate_source** - \\[ARRAY:ALLOCATION\\] Allocate with source initialization\n\n### **Synopsis**\n```fortran\n    allocate(object, source=source_expr)\n```\n```fortran\n     allocate(alloc_var, source=source_expr, stat=stat_var, errmsg=errmsg_var)\n\n      type(TYPE(kind=**)), allocatable :: alloc_var(..)\n      type(TYPE(kind=**))              :: source_expr(..)\n      integer                          :: stat_var\n      character(len=*)                 :: errmsg_var\n```\n\n### **Characteristics**\n\n - **alloc_var** is an allocatable variable or pointer of any type and rank.\n - **source_expr** provides both shape and values for initialization.\n - **stat_var** is an optional integer variable for allocation status.\n - **errmsg_var** is an optional character variable for error messages.\n - The allocated variable has the same dynamic type, shape, and values as source.\n - For polymorphic variables, the dynamic type is cloned from source.\n\n### **Description**\n\n **allocate** with the **source=** specifier dynamically creates storage for\n an allocatable variable or pointer target and initializes it with the value\n and dynamic type of the source expression. This is particularly useful for\n polymorphic allocation where the exact type may not be known at compile time,\n and for creating copies of existing arrays. The allocated object gets\n both the shape and values from the source.\n\n### **Options**\n\n- **alloc_var**\n  : The allocatable variable or pointer to be allocated. Must not already\n  be allocated.\n\n- **source**\n  : Expression providing the type, shape, and values for the allocation.\n  The allocated object will be a copy of this expression.\n\n- **stat**\n  : Optional. Integer variable set to zero on success, positive on error.\n\n- **errmsg**\n  : Optional. Character variable for descriptive error message on failure.\n\n### **Result**\n\n  The allocated variable has the same dynamic type, shape, and values as\n  the source expression. This is a deep copy for intrinsic types. For\n  polymorphic types, the dynamic type is preserved.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_allocate_source\n  use, intrinsic :: iso_fortran_env, only: dp => real64\n  implicit none\n\n  real(dp) :: template(5) = [1.0_dp, 2.0_dp, 3.0_dp, 4.0_dp, 5.0_dp]\n  real(dp), allocatable :: copy(:)\n  real(dp), allocatable :: matrix(:,:)\n  real(dp), allocatable :: doubled(:)\n  integer :: ierr\n\n  ! Allocate and copy from existing array\n  allocate(copy, source=template, stat=ierr)\n  if (ierr /= 0) error stop 'Allocation failed'\n\n  print *, 'Template:', template\n  print *, 'Copy:', copy\n  print *, 'Same values?', all(copy == template)\n\n  ! Modify copy - original unchanged\n  copy = copy * 2\n  print *, 'Modified copy:', copy\n  print *, 'Original template:', template\n\n  ! Allocate with expression as source\n  allocate(doubled, source=template * 3.0_dp)\n  print *, 'Tripled:', doubled\n\n  ! 2D array from reshape\n  allocate(matrix, source=reshape([(real(i,dp), i=1,6)], [2,3]))\n  print *, 'Matrix shape:', shape(matrix)\n  print *, 'Matrix row 1:', matrix(1,:)\n  print *, 'Matrix row 2:', matrix(2,:)\n\n  deallocate(copy, doubled, matrix)\n\nend program demo_allocate_source\n```\nResults:\n```text\n Template:   1.0000000000000000   2.0000000000000000   3.0000000000000000   4.0000000000000000   5.0000000000000000\n Copy:   1.0000000000000000   2.0000000000000000   3.0000000000000000   4.0000000000000000   5.0000000000000000\n Same values? T\n Modified copy:   2.0000000000000000   4.0000000000000000   6.0000000000000000   8.0000000000000000   10.000000000000000\n Original template:   1.0000000000000000   2.0000000000000000   3.0000000000000000   4.0000000000000000   5.0000000000000000\n Tripled:   3.0000000000000000   6.0000000000000000   9.0000000000000000   12.000000000000000   15.000000000000000\n Matrix shape:           2           3\n Matrix row 1:   1.0000000000000000   3.0000000000000000   5.0000000000000000\n Matrix row 2:   2.0000000000000000   4.0000000000000000   6.0000000000000000\n```\n\n### **Standard**\n\nFortran 2003\n\n**Compatibility Notes:**\n- gfortran 4.6+, Intel Fortran 12.0+, NAG 5.3+\n- SOURCE= copies type, shape, and values\n- Useful for cloning polymorphic variables\n\n### **See Also**\n\n[**allocate**](#allocate),\n[**allocate_mold**](#allocate_mold),\n[**move_alloc**](#move_alloc),\n[**deallocate**](#deallocate)",
  "ompatomic": "## omp_atomic\n\n### **Name**\n\n**omp_atomic** - \\[PARALLEL:OPENMP\\] Atomic memory operation for thread-safe updates\n\n### **Synopsis**\n\n```fortran\n    !$omp atomic [atomic-clause] [memory-order-clause]\n       statement\n    [!$omp end atomic]\n```\n\n```fortran\n    !$omp atomic [read | write | update | capture] [seq_cst | acq_rel | release | acquire | relaxed]\n       x = x operator expr   ! update (default)\n       x = expr              ! write\n       v = x                 ! read\n       v = x; x = expr       ! capture (requires end atomic)\n    [!$omp end atomic]\n```\n\n### **Characteristics**\n\n - **x** is a scalar variable of intrinsic type (integer, real, complex, or logical).\n - **x** must not have the ALLOCATABLE attribute.\n - **v** is a scalar variable used to capture the original or final value of x.\n - **expr** is an expression that does not reference the storage location of x.\n - **operator** is one of: +, -, *, /, .AND., .OR., .EQV., .NEQV.\n - **intrinsic_procedure** is one of: MAX, MIN, IAND, IOR, IEOR.\n - The directive ensures atomic read-modify-write operations across threads.\n - Only the memory access to x is atomic; expression evaluation is not.\n\n### **Description**\n\n **!$omp atomic** ensures that a specific storage location is accessed atomically, preventing data races when multiple threads update shared variables. The atomic construct provides a lightweight synchronization mechanism compared to critical sections, often with hardware support on modern processors.\n\n The default behavior (without a clause) is atomic update, which performs a read-modify-write operation atomically. The read, write, and capture clauses provide additional atomic operations for different use cases.\n\n### **Options**\n\n- **read**\n  : Atomically reads the value of x into v. Syntax: `v = x`\n\n- **write**\n  : Atomically writes the value of expr to x. Syntax: `x = expr`\n\n- **update** (default)\n  : Atomically updates x using an operation. Syntax: `x = x op expr` or `x = intrinsic(x, expr)`. Supported operations:\n  - Arithmetic: x = x + expr, x = x - expr, x = x * expr, x = x / expr\n  - Intrinsic: x = max(x, expr), x = min(x, expr)\n  - Bitwise: x = iand(x, expr), x = ior(x, expr), x = ieor(x, expr)\n  - Unary: x = x + 1, x = x - 1 (increment/decrement)\n\n- **capture**\n  : Atomically updates x and captures either the original or final value. Requires `!$omp end atomic`. Syntax: `v = x; x = x op expr` or `v = x; x = expr; !$omp end atomic`\n\n- **seq_cst**\n  : Sequentially consistent memory ordering. Provides the strongest ordering guarantees.\n\n- **acq_rel**\n  : Acquire-release memory ordering for capture operations.\n\n- **release**\n  : Release memory ordering for write and update operations.\n\n- **acquire**\n  : Acquire memory ordering for read operations.\n\n- **relaxed**\n  : Relaxed memory ordering. No synchronization with other operations.\n\n- **hint(hint-expression)**\n  : OpenMP 5.0+ hint about contention (uncontended, contended, nonspeculative, speculative).\n\n### **Result**\n\n  The atomic construct ensures that the specified memory operation on x completes without interference from other threads. For update operations, the final value of x reflects the atomic combination of all thread updates. For capture operations, v contains the captured value as specified.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_omp_atomic\n  use omp_lib\n  implicit none\n  integer :: counter, max_val, min_val\n  integer :: captured_before, captured_after\n  real(8) :: sum_val\n  integer :: i\n  integer, parameter :: n = 1000\n\n  ! Example 1: Atomic update (increment counter)\n  counter = 0\n  !$omp parallel do\n  do i = 1, n\n    !$omp atomic update\n    counter = counter + 1\n  end do\n  !$omp end parallel do\n  print '(A,I0)', 'Counter (should be 1000): ', counter\n\n  ! Example 2: Atomic with max\n  max_val = 0\n  !$omp parallel do private(i)\n  do i = 1, n\n    !$omp atomic update\n    max_val = max(max_val, i)\n  end do\n  !$omp end parallel do\n  print '(A,I0)', 'Maximum value: ', max_val\n\n  ! Example 3: Atomic with min\n  min_val = huge(min_val)\n  !$omp parallel do private(i)\n  do i = 1, n\n    !$omp atomic update\n    min_val = min(min_val, i)\n  end do\n  !$omp end parallel do\n  print '(A,I0)', 'Minimum value: ', min_val\n\n  ! Example 4: Atomic update with real\n  sum_val = 0.0d0\n  !$omp parallel do private(i)\n  do i = 1, n\n    !$omp atomic update\n    sum_val = sum_val + real(i, 8)\n  end do\n  !$omp end parallel do\n  print '(A,F12.2)', 'Sum (should be 500500.0): ', sum_val\n\n  ! Example 5: Atomic read\n  counter = 42\n  !$omp parallel\n  !$omp single\n    !$omp atomic read\n    captured_before = counter\n    print '(A,I0)', 'Captured value: ', captured_before\n  !$omp end single\n  !$omp end parallel\n\n  ! Example 6: Atomic write\n  !$omp parallel\n  !$omp single\n    !$omp atomic write\n    counter = 100\n  !$omp end single\n  !$omp end parallel\n  print '(A,I0)', 'Counter after atomic write: ', counter\n\n  ! Example 7: Atomic capture\n  counter = 0\n  !$omp parallel do private(i, captured_before)\n  do i = 1, 10\n    !$omp atomic capture\n    captured_before = counter\n    counter = counter + 1\n    !$omp end atomic\n    !$omp critical\n    print '(A,I2,A,I2,A,I2)', 'Thread got ', captured_before, &\n          ', incremented to ', captured_before + 1, ' at iteration ', i\n    !$omp end critical\n  end do\n  !$omp end parallel do\n  print '(A,I0)', 'Final counter: ', counter\n\nend program demo_omp_atomic\n```\n\nCompile with:\n```text\ngfortran -fopenmp demo_omp_atomic.f90 -o demo_omp_atomic\n```\n\nResults:\n```text\nCounter (should be 1000): 1000\nMaximum value: 1000\nMinimum value: 1\nSum (should be 500500.0):    500500.00\nCaptured value: 42\nCounter after atomic write: 100\nThread got  0, incremented to  1 at iteration  1\nThread got  1, incremented to  2 at iteration  2\n...\nFinal counter: 10\n```\n\n### **Standard**\n\nOpenMP 1.0 (basic atomic), OpenMP 3.1 (read/write/capture), OpenMP 4.5 (seq_cst), OpenMP 5.0 (memory order clauses)\n\n### **See Also**\n\n[**!$omp critical**(3)](#omp_critical),\n[**!$omp parallel do**(3)](#omp_parallel_do),\n[**!$omp reduction**(3)](#omp_reduction),\n[**omp_set_lock**(3)](#omp_set_lock)\n\n### **Resources**\n\n- [OpenMP 5.0 Atomic Construct](https://www.openmp.org/spec-html/5.0/openmpsu95.html)\n- [OpenMP Memory Model](https://www.openmp.org/spec-html/5.0/openmpch2.html)\n- [LLNL OpenMP Tutorial](https://hpc-tutorials.llnl.gov/openmp/)",
  "allocate_source": "## allocate_source\n\n### **Name**\n\n**allocate_source** - \\[ARRAY:ALLOCATION\\] Allocate with source initialization\n\n### **Synopsis**\n```fortran\n    allocate(object, source=source_expr)\n```\n```fortran\n     allocate(alloc_var, source=source_expr, stat=stat_var, errmsg=errmsg_var)\n\n      type(TYPE(kind=**)), allocatable :: alloc_var(..)\n      type(TYPE(kind=**))              :: source_expr(..)\n      integer                          :: stat_var\n      character(len=*)                 :: errmsg_var\n```\n\n### **Characteristics**\n\n - **alloc_var** is an allocatable variable or pointer of any type and rank.\n - **source_expr** provides both shape and values for initialization.\n - **stat_var** is an optional integer variable for allocation status.\n - **errmsg_var** is an optional character variable for error messages.\n - The allocated variable has the same dynamic type, shape, and values as source.\n - For polymorphic variables, the dynamic type is cloned from source.\n\n### **Description**\n\n **allocate** with the **source=** specifier dynamically creates storage for\n an allocatable variable or pointer target and initializes it with the value\n and dynamic type of the source expression. This is particularly useful for\n polymorphic allocation where the exact type may not be known at compile time,\n and for creating copies of existing arrays. The allocated object gets\n both the shape and values from the source.\n\n### **Options**\n\n- **alloc_var**\n  : The allocatable variable or pointer to be allocated. Must not already\n  be allocated.\n\n- **source**\n  : Expression providing the type, shape, and values for the allocation.\n  The allocated object will be a copy of this expression.\n\n- **stat**\n  : Optional. Integer variable set to zero on success, positive on error.\n\n- **errmsg**\n  : Optional. Character variable for descriptive error message on failure.\n\n### **Result**\n\n  The allocated variable has the same dynamic type, shape, and values as\n  the source expression. This is a deep copy for intrinsic types. For\n  polymorphic types, the dynamic type is preserved.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_allocate_source\n  use, intrinsic :: iso_fortran_env, only: dp => real64\n  implicit none\n\n  real(dp) :: template(5) = [1.0_dp, 2.0_dp, 3.0_dp, 4.0_dp, 5.0_dp]\n  real(dp), allocatable :: copy(:)\n  real(dp), allocatable :: matrix(:,:)\n  real(dp), allocatable :: doubled(:)\n  integer :: ierr\n\n  ! Allocate and copy from existing array\n  allocate(copy, source=template, stat=ierr)\n  if (ierr /= 0) error stop 'Allocation failed'\n\n  print *, 'Template:', template\n  print *, 'Copy:', copy\n  print *, 'Same values?', all(copy == template)\n\n  ! Modify copy - original unchanged\n  copy = copy * 2\n  print *, 'Modified copy:', copy\n  print *, 'Original template:', template\n\n  ! Allocate with expression as source\n  allocate(doubled, source=template * 3.0_dp)\n  print *, 'Tripled:', doubled\n\n  ! 2D array from reshape\n  allocate(matrix, source=reshape([(real(i,dp), i=1,6)], [2,3]))\n  print *, 'Matrix shape:', shape(matrix)\n  print *, 'Matrix row 1:', matrix(1,:)\n  print *, 'Matrix row 2:', matrix(2,:)\n\n  deallocate(copy, doubled, matrix)\n\nend program demo_allocate_source\n```\nResults:\n```text\n Template:   1.0000000000000000   2.0000000000000000   3.0000000000000000   4.0000000000000000   5.0000000000000000\n Copy:   1.0000000000000000   2.0000000000000000   3.0000000000000000   4.0000000000000000   5.0000000000000000\n Same values? T\n Modified copy:   2.0000000000000000   4.0000000000000000   6.0000000000000000   8.0000000000000000   10.000000000000000\n Original template:   1.0000000000000000   2.0000000000000000   3.0000000000000000   4.0000000000000000   5.0000000000000000\n Tripled:   3.0000000000000000   6.0000000000000000   9.0000000000000000   12.000000000000000   15.000000000000000\n Matrix shape:           2           3\n Matrix row 1:   1.0000000000000000   3.0000000000000000   5.0000000000000000\n Matrix row 2:   2.0000000000000000   4.0000000000000000   6.0000000000000000\n```\n\n### **Standard**\n\nFortran 2003\n\n**Compatibility Notes:**\n- gfortran 4.6+, Intel Fortran 12.0+, NAG 5.3+\n- SOURCE= copies type, shape, and values\n- Useful for cloning polymorphic variables\n\n### **See Also**\n\n[**allocate**](#allocate),\n[**allocate_mold**](#allocate_mold),\n[**move_alloc**](#move_alloc),\n[**deallocate**](#deallocate)",
  "!$omp atomic": "## omp_atomic\n\n### **Name**\n\n**omp_atomic** - \\[PARALLEL:OPENMP\\] Atomic memory operation for thread-safe updates\n\n### **Synopsis**\n\n```fortran\n    !$omp atomic [atomic-clause] [memory-order-clause]\n       statement\n    [!$omp end atomic]\n```\n\n```fortran\n    !$omp atomic [read | write | update | capture] [seq_cst | acq_rel | release | acquire | relaxed]\n       x = x operator expr   ! update (default)\n       x = expr              ! write\n       v = x                 ! read\n       v = x; x = expr       ! capture (requires end atomic)\n    [!$omp end atomic]\n```\n\n### **Characteristics**\n\n - **x** is a scalar variable of intrinsic type (integer, real, complex, or logical).\n - **x** must not have the ALLOCATABLE attribute.\n - **v** is a scalar variable used to capture the original or final value of x.\n - **expr** is an expression that does not reference the storage location of x.\n - **operator** is one of: +, -, *, /, .AND., .OR., .EQV., .NEQV.\n - **intrinsic_procedure** is one of: MAX, MIN, IAND, IOR, IEOR.\n - The directive ensures atomic read-modify-write operations across threads.\n - Only the memory access to x is atomic; expression evaluation is not.\n\n### **Description**\n\n **!$omp atomic** ensures that a specific storage location is accessed atomically, preventing data races when multiple threads update shared variables. The atomic construct provides a lightweight synchronization mechanism compared to critical sections, often with hardware support on modern processors.\n\n The default behavior (without a clause) is atomic update, which performs a read-modify-write operation atomically. The read, write, and capture clauses provide additional atomic operations for different use cases.\n\n### **Options**\n\n- **read**\n  : Atomically reads the value of x into v. Syntax: `v = x`\n\n- **write**\n  : Atomically writes the value of expr to x. Syntax: `x = expr`\n\n- **update** (default)\n  : Atomically updates x using an operation. Syntax: `x = x op expr` or `x = intrinsic(x, expr)`. Supported operations:\n  - Arithmetic: x = x + expr, x = x - expr, x = x * expr, x = x / expr\n  - Intrinsic: x = max(x, expr), x = min(x, expr)\n  - Bitwise: x = iand(x, expr), x = ior(x, expr), x = ieor(x, expr)\n  - Unary: x = x + 1, x = x - 1 (increment/decrement)\n\n- **capture**\n  : Atomically updates x and captures either the original or final value. Requires `!$omp end atomic`. Syntax: `v = x; x = x op expr` or `v = x; x = expr; !$omp end atomic`\n\n- **seq_cst**\n  : Sequentially consistent memory ordering. Provides the strongest ordering guarantees.\n\n- **acq_rel**\n  : Acquire-release memory ordering for capture operations.\n\n- **release**\n  : Release memory ordering for write and update operations.\n\n- **acquire**\n  : Acquire memory ordering for read operations.\n\n- **relaxed**\n  : Relaxed memory ordering. No synchronization with other operations.\n\n- **hint(hint-expression)**\n  : OpenMP 5.0+ hint about contention (uncontended, contended, nonspeculative, speculative).\n\n### **Result**\n\n  The atomic construct ensures that the specified memory operation on x completes without interference from other threads. For update operations, the final value of x reflects the atomic combination of all thread updates. For capture operations, v contains the captured value as specified.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_omp_atomic\n  use omp_lib\n  implicit none\n  integer :: counter, max_val, min_val\n  integer :: captured_before, captured_after\n  real(8) :: sum_val\n  integer :: i\n  integer, parameter :: n = 1000\n\n  ! Example 1: Atomic update (increment counter)\n  counter = 0\n  !$omp parallel do\n  do i = 1, n\n    !$omp atomic update\n    counter = counter + 1\n  end do\n  !$omp end parallel do\n  print '(A,I0)', 'Counter (should be 1000): ', counter\n\n  ! Example 2: Atomic with max\n  max_val = 0\n  !$omp parallel do private(i)\n  do i = 1, n\n    !$omp atomic update\n    max_val = max(max_val, i)\n  end do\n  !$omp end parallel do\n  print '(A,I0)', 'Maximum value: ', max_val\n\n  ! Example 3: Atomic with min\n  min_val = huge(min_val)\n  !$omp parallel do private(i)\n  do i = 1, n\n    !$omp atomic update\n    min_val = min(min_val, i)\n  end do\n  !$omp end parallel do\n  print '(A,I0)', 'Minimum value: ', min_val\n\n  ! Example 4: Atomic update with real\n  sum_val = 0.0d0\n  !$omp parallel do private(i)\n  do i = 1, n\n    !$omp atomic update\n    sum_val = sum_val + real(i, 8)\n  end do\n  !$omp end parallel do\n  print '(A,F12.2)', 'Sum (should be 500500.0): ', sum_val\n\n  ! Example 5: Atomic read\n  counter = 42\n  !$omp parallel\n  !$omp single\n    !$omp atomic read\n    captured_before = counter\n    print '(A,I0)', 'Captured value: ', captured_before\n  !$omp end single\n  !$omp end parallel\n\n  ! Example 6: Atomic write\n  !$omp parallel\n  !$omp single\n    !$omp atomic write\n    counter = 100\n  !$omp end single\n  !$omp end parallel\n  print '(A,I0)', 'Counter after atomic write: ', counter\n\n  ! Example 7: Atomic capture\n  counter = 0\n  !$omp parallel do private(i, captured_before)\n  do i = 1, 10\n    !$omp atomic capture\n    captured_before = counter\n    counter = counter + 1\n    !$omp end atomic\n    !$omp critical\n    print '(A,I2,A,I2,A,I2)', 'Thread got ', captured_before, &\n          ', incremented to ', captured_before + 1, ' at iteration ', i\n    !$omp end critical\n  end do\n  !$omp end parallel do\n  print '(A,I0)', 'Final counter: ', counter\n\nend program demo_omp_atomic\n```\n\nCompile with:\n```text\ngfortran -fopenmp demo_omp_atomic.f90 -o demo_omp_atomic\n```\n\nResults:\n```text\nCounter (should be 1000): 1000\nMaximum value: 1000\nMinimum value: 1\nSum (should be 500500.0):    500500.00\nCaptured value: 42\nCounter after atomic write: 100\nThread got  0, incremented to  1 at iteration  1\nThread got  1, incremented to  2 at iteration  2\n...\nFinal counter: 10\n```\n\n### **Standard**\n\nOpenMP 1.0 (basic atomic), OpenMP 3.1 (read/write/capture), OpenMP 4.5 (seq_cst), OpenMP 5.0 (memory order clauses)\n\n### **See Also**\n\n[**!$omp critical**(3)](#omp_critical),\n[**!$omp parallel do**(3)](#omp_parallel_do),\n[**!$omp reduction**(3)](#omp_reduction),\n[**omp_set_lock**(3)](#omp_set_lock)\n\n### **Resources**\n\n- [OpenMP 5.0 Atomic Construct](https://www.openmp.org/spec-html/5.0/openmpsu95.html)\n- [OpenMP Memory Model](https://www.openmp.org/spec-html/5.0/openmpch2.html)\n- [LLNL OpenMP Tutorial](https://hpc-tutorials.llnl.gov/openmp/)",
  "array2d": "## array2d\n\n### **Name**\n\n**allocatable_2d** - \\[ARRAY:ALLOCATION\\] Declare a two-dimensional allocatable array\n\n### **Synopsis**\n```fortran\n    type, allocatable :: array_name(:,:)\n```\n```fortran\n     type(TYPE(kind=**)), allocatable :: array_name(:,:)\n\n      type  :: Any valid Fortran type\n      kind  :: Optional kind parameter\n```\n\n### **Characteristics**\n\n - **type** can be any intrinsic type (integer, real, complex, logical, character) or derived type.\n - **kind** specifies the kind type parameter (e.g., dp for double precision real).\n - **array_name** must be a valid Fortran identifier.\n - The array has deferred shape indicated by (:,:) with two dimensions.\n - The array is initially unallocated; it must be allocated before use.\n - The ALLOCATED intrinsic can query allocation status.\n - Allocatable arrays are automatically deallocated when they go out of scope.\n\n### **Description**\n\n **allocatable_2d** declares a two-dimensional array with the ALLOCATABLE\n attribute. The array has deferred shape, meaning its bounds are not\n specified at declaration time but are determined dynamically at runtime\n through the ALLOCATE statement. This is the standard way to declare\n matrices whose size is determined at runtime.\n\n### **Options**\n\n- **type**\n  : The data type of array elements. Can be integer, real, complex,\n  logical, character, or any derived type.\n\n- **kind**\n  : Optional kind parameter specifying precision or storage size.\n\n- **array_name**\n  : The identifier for the array variable.\n\n### **Result**\n\n  A variable that can hold a 2D array of any shape, determined at runtime.\n  Must be allocated before use and can be reallocated with different sizes.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_array2d\n  use, intrinsic :: iso_fortran_env, only: dp => real64\n  implicit none\n\n  real(dp), allocatable :: matrix(:,:)\n  integer, allocatable :: grid(:,:)\n  integer :: rows, cols, ierr, i\n\n  ! Check initial state\n  print *, 'Initially allocated:', allocated(matrix)\n\n  ! Allocate based on runtime values\n  rows = 3\n  cols = 4\n  allocate(matrix(rows, cols), stat=ierr)\n  if (ierr /= 0) error stop 'Allocation failed'\n\n  print *, 'After allocate:', allocated(matrix)\n  print *, 'Shape:', shape(matrix)\n\n  ! Initialize matrix\n  matrix = reshape([(real(i, dp), i=1, rows*cols)], [rows, cols])\n  print *, 'Matrix contents:'\n  do i = 1, rows\n    print '(4F8.1)', matrix(i, :)\n  end do\n\n  ! Allocate with custom bounds\n  allocate(grid(0:2, -1:1))\n  print *, 'Grid bounds:', lbound(grid), 'to', ubound(grid)\n\n  deallocate(matrix, grid)\n\nend program demo_array2d\n```\nResults:\n```text\n Initially allocated: F\n After allocate: T\n Shape:           3           4\n Matrix contents:\n     1.0     2.0     3.0     4.0\n     5.0     6.0     7.0     8.0\n     9.0    10.0    11.0    12.0\n Grid bounds:           0          -1 to           2           1\n```\n\n### **Standard**\n\nFortran 90 (ISO/IEC 1539:1991, sections 5.2.6, 6.3.1, 6.3.3)\n\n### **See Also**\n\n[**allocate**](#allocate),\n[**deallocate**](#deallocate),\n[**allocated**](#allocated),\n[**shape**](#shape),\n[**size**](#size)",
  "cycleloop": "## cycleloop\n\n### **Name**\n\n**cycle-named** - \\[CONTROL:LOOP\\] Skip to the next iteration of a named loop construct.\n\n### **Synopsis**\n```fortran\n    cycle loop_name\n```\n```fortran\n     loop_name: do i = 1, n\n       if (condition) cycle loop_name\n     end do loop_name\n```\n\n### **Characteristics**\n\n - **loop_name** must be the name of an enclosing DO construct.\n - The CYCLE statement transfers control to the end of the named loop.\n - Execution continues with the next iteration of the loop if the loop control permits.\n - Without a loop name, CYCLE applies to the innermost DO construct.\n\n### **Description**\n\n **cycle** causes the current iteration of the named DO loop to terminate early. Control transfers to the END DO statement of the named construct, and the loop continues with its next iteration (if any remain). This is particularly useful in nested loops where you need to skip to the next iteration of an outer loop rather than the innermost one.\n\n### **Options**\n\n- **loop_name**\n  : The construct name of the DO loop to cycle. Must match the name label of an enclosing DO construct. When omitted, CYCLE applies to the innermost DO loop.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_cycle_named\nimplicit none\n  integer :: i, j\n  integer :: matrix(3,3)\n\n  ! Initialize matrix with values\n  matrix = reshape([1,2,3, 4,0,6, 7,8,9], [3,3])\n\n  ! Process matrix, skipping entire rows that contain zero\n  row_loop: do i = 1, 3\n    col_loop: do j = 1, 3\n      ! If we find a zero, skip to the next row\n      if (matrix(i,j) == 0) then\n        print *, 'Skipping row', i, 'due to zero at column', j\n        cycle row_loop  ! Skip remaining columns, go to next row\n      end if\n      print *, 'Processing element (', i, ',', j, ') =', matrix(i,j)\n    end do col_loop\n  end do row_loop\n\n  print *, 'Done processing matrix'\nend program demo_cycle_named\n```\nResults:\n```text\n Processing element ( 1 , 1 ) = 1\n Processing element ( 1 , 2 ) = 4\n Processing element ( 1 , 3 ) = 7\n Processing element ( 2 , 1 ) = 2\n Skipping row 2 due to zero at column 2\n Processing element ( 3 , 1 ) = 3\n Processing element ( 3 , 2 ) = 6\n Processing element ( 3 , 3 ) = 9\n Done processing matrix\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**exit**(3)](#exit), [**do**(3)](#do), [**do_concurrent**(3)](#do_concurrent)",
  "kindparam": "## kind_parameter_dp\n\n### **Name**\n\n**kind_parameter** - \\[NUMERIC:KIND\\] Define a kind parameter for double precision reals\n\n### **Synopsis**\n```fortran\n    integer, parameter :: dp = selected_real_kind(15, 307)\n```\n```fortran\n     ! Kind parameter definition\n\n      integer, parameter :: dp = selected_real_kind(15, 307)\n      ! Alternative using kind intrinsic:\n      integer, parameter :: dp = kind(1.0d0)\n```\n\n### **Characteristics**\n\n - **dp** is an integer named constant representing a kind value.\n - **selected_real_kind(15, 307)** requests at least 15 decimal digits and exponent range of 307.\n - This approach is portable across different compilers and platforms.\n - Typically returns kind value 8 on most systems (64-bit IEEE 754 double).\n\n### **Description**\n\n **kind_parameter** defines a named kind parameter for double precision real numbers.\n Using `selected_real_kind` ensures portability by specifying precision and\n range requirements rather than relying on compiler-specific kind values.\n This is the modern Fortran approach, replacing the non-standard\n `double precision` type declaration.\n\n### **Options**\n\n- **selected_real_kind(p, r)**\n  : Returns a kind value providing at least **p** decimal digits of precision\n  and an exponent range of at least **r**. For double precision, p=15 and\n  r=307 are typical choices.\n\n- **kind(1.0d0)**\n  : Returns the kind value of the double precision constant 1.0d0. This is\n  compiler-specific but usually gives the same result as selected_real_kind.\n\n### **Result**\n\n  An integer constant representing the kind type parameter for double\n  precision real variables. This value can be used in declarations and\n  literal constant suffixes.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_kind_parameter\nimplicit none\n  ! Portable double precision kind parameter\n  integer, parameter :: dp = selected_real_kind(15, 307)\n\n  real(dp) :: x, y, z\n  real(dp), parameter :: pi = 3.14159265358979323846_dp\n\n  ! Verify precision\n  print '(A,I0)', 'Kind value: ', dp\n  print '(A,I0)', 'Decimal digits: ', precision(x)\n  print '(A,I0)', 'Exponent range: ', range(x)\n  print '(A,I0)', 'Storage size (bits): ', storage_size(x)\n\n  ! Use in calculations\n  x = 1.0_dp\n  y = 3.0_dp\n  z = x / y\n  print '(A,F25.20)', 'x/y = ', z\n\n  ! Compare with pi\n  print '(A,F25.20)', 'pi  = ', pi\n\nend program demo_kind_parameter\n```\nResults:\n```text\nKind value: 8\nDecimal digits: 15\nExponent range: 307\nStorage size (bits): 64\nx/y =  0.33333333333333331483\npi  =  3.14159265358979311600\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**selected_real_kind**(3)](#selected_real_kind),\n[**precision**(3)](#precision),\n[**range**(3)](#range),\n[**kind**(3)](#kind)",
  "implieddo": "## implied_do_array_constructor\n\n### **Name**\n\n**implied_do_array_constructor** - \\[CONTROL:LOOP\\] Construct a rank-one array using an implied-do loop\n\n### **Synopsis**\n```fortran\n    array = [(expr, var = start, end [, step])]\n```\n```fortran\n     ! Implied-do loop in array constructor\n\n      type :: array(size)\n      array = [(expression, index = start, end, step)]\n```\n\n### **Characteristics**\n\n - Creates a rank-one (1D) array from an expression evaluated over an index range.\n - **expr** is any expression, typically involving the loop variable **var**.\n - **var** is an integer loop control variable.\n - **start**, **end**, and optional **step** define the iteration range.\n - The array size is determined by the number of iterations.\n\n### **Description**\n\n **implied_do_array_constructor** creates an array by evaluating an expression\n for each value of the loop index. The expression can involve the index variable,\n constants, or previously defined values. Implied-do loops can be nested for\n more complex array construction patterns.\n\n### **Options**\n\n- **expr**\n  : The expression evaluated for each iteration. Can be a scalar value,\n  a function call, or any expression involving the loop variable.\n\n- **var**\n  : The loop control variable (integer). Its scope is limited to the\n  implied-do construct.\n\n- **start**\n  : The initial value of the loop variable.\n\n- **end**\n  : The terminal value of the loop variable.\n\n- **step**\n  : Optional increment (default is 1). Can be negative for counting down.\n\n### **Result**\n\n  A rank-one array containing the values of **expr** for each value of\n  **var** from **start** to **end** with increment **step**.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_implied_do\nimplicit none\n  integer :: i, j\n  integer :: squares(10)\n  real    :: angles(5)\n  real, parameter :: pi = 3.14159265\n\n  ! Simple sequence: 1, 2, 3, ..., 10\n  print '(A,10I4)', 'Sequence: ', [(i, i=1,10)]\n\n  ! Squares: 1, 4, 9, 16, ...\n  squares = [(i**2, i=1,10)]\n  print '(A,10I4)', 'Squares:  ', squares\n\n  ! Even numbers: 2, 4, 6, 8, 10\n  print '(A,5I4)', 'Evens:    ', [(i, i=2,10,2)]\n\n  ! Countdown: 5, 4, 3, 2, 1\n  print '(A,5I4)', 'Countdown:', [(i, i=5,1,-1)]\n\n  ! Angles in radians: 0, pi/4, pi/2, 3pi/4, pi\n  angles = [(i*pi/4.0, i=0,4)]\n  print '(A,5F8.4)', 'Angles:   ', angles\n\n  ! Nested implied-do: creates 3x3 = 9 elements\n  print '(A,9I4)', 'Nested:   ', [((i*10+j, j=1,3), i=1,3)]\n\n  ! Initialize with repeated value\n  print '(A,5I4)', 'Fives:    ', [(5, i=1,5)]\n\nend program demo_implied_do\n```\nResults:\n```text\nSequence:    1   2   3   4   5   6   7   8   9  10\nSquares:     1   4   9  16  25  36  49  64  81 100\nEvens:       2   4   6   8  10\nCountdown:   5   4   3   2   1\nAngles:     0.0000  0.7854  1.5708  2.3562  3.1416\nNested:     11  12  13  21  22  23  31  32  33\nFives:       5   5   5   5   5\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**reshape**(3)](#reshape),\n[**spread**(3)](#spread),\n[**pack**(3)](#pack)",
  "optdefault": "## optional_with_default\n\n### **Name**\n\n**optional_with_default** - \\[PROCEDURE:ARGUMENT\\] Handle optional argument with default value assignment\n\n### **Synopsis**\n```fortran\n    if (present(arg)) then\n      local_var = arg\n    else\n      local_var = default_value\n    end if\n```\n```fortran\n     ! Optional argument with default pattern\n\n      subroutine sub(optional_arg)\n        integer, intent(in), optional :: optional_arg\n        integer :: local_value\n\n        if (present(optional_arg)) then\n          local_value = optional_arg\n        else\n          local_value = default_value\n        end if\n```\n\n### **Characteristics**\n\n - Uses PRESENT intrinsic to check if argument was provided.\n - Assigns default value when argument is absent.\n - Local variable must be used for processing.\n - Cannot directly use absent optional argument.\n\n### **Description**\n\n **optional_with_default** implements the pattern for handling optional\n arguments with default values. Since absent optional arguments cannot be\n used directly in expressions, a local variable is assigned either the\n provided argument value or a default value based on presence.\n\n### **Options**\n\n- **optional_arg**\n  : The optional dummy argument declared with OPTIONAL attribute.\n\n- **local_var**\n  : A local variable of the same type to hold either the provided value\n  or the default.\n\n- **default_value**\n  : The value to use when the optional argument is not provided.\n\n### **Result**\n\n  A local variable is initialized with either the provided argument value\n  or a default, and can then be safely used in subsequent code.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_optional_default\nimplicit none\n\n  call greet('Alice')\n  call greet('Bob', greeting='Hello')\n  call greet('Charlie', greeting='Hi', times=3)\n\n  print '(A)', ''\n  print '(A,F8.2)', 'Default tolerance: ', compute(10.0)\n  print '(A,F8.2)', 'Custom tolerance:  ', compute(10.0, tol=0.001)\n\ncontains\n\n  subroutine greet(name, greeting, times)\n    character(len=*), intent(in) :: name\n    character(len=*), intent(in), optional :: greeting\n    integer, intent(in), optional :: times\n\n    character(len=20) :: actual_greeting\n    integer :: actual_times\n    integer :: i\n\n    ! Apply defaults for optional arguments\n    if (present(greeting)) then\n      actual_greeting = greeting\n    else\n      actual_greeting = 'Good day'\n    end if\n\n    if (present(times)) then\n      actual_times = times\n    else\n      actual_times = 1\n    end if\n\n    ! Use the values\n    do i = 1, actual_times\n      print '(A,A,A,A)', trim(actual_greeting), ', ', trim(name), '!'\n    end do\n\n  end subroutine greet\n\n  function compute(x, tol) result(y)\n    real, intent(in) :: x\n    real, intent(in), optional :: tol\n    real :: y\n\n    real :: actual_tol\n\n    ! Default tolerance\n    if (present(tol)) then\n      actual_tol = tol\n    else\n      actual_tol = 0.01\n    end if\n\n    y = x + actual_tol\n  end function compute\n\nend program demo_optional_default\n```\nResults:\n```text\nGood day, Alice!\nHello, Bob!\nHi, Charlie!\nHi, Charlie!\nHi, Charlie!\n\nDefault tolerance:    10.01\nCustom tolerance:     10.00\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**present**(3)](#present),\n[**optional**(3)](#optional)",
  "flush": "## flush\n\n### **Name**\n\n**flush** - \\[IO:FILE\\] Flush pending output to a file unit\n\n### **Synopsis**\n```fortran\n    flush(unit)\n```\n```fortran\n     subroutine flush(unit)\n\n      integer, intent(in), optional :: unit   ! File unit number\n```\n\n### **Characteristics**\n\n - **unit** is a scalar integer representing a connected file unit number.\n - The unit must be open for output.\n - This is a statement (Fortran 2003) or subroutine (older compilers).\n - If unit is omitted, all open units are flushed.\n\n### **Description**\n\n **flush** causes any data written to the specified file unit to be immediately transferred to the external file. This ensures that buffered output is written to disk before the program continues, which is useful for debugging, ensuring data integrity before a potential crash, or when coordinating with other processes reading the same file.\n\n### **Options**\n\n- **unit** (optional)\n  : A scalar integer expression specifying the unit number of an external file that is connected for output. The unit must be open. If unit is omitted, all open units are flushed.\n\n### **Result**\n\n  All buffered output data for the specified unit (or all units) is written to the external file. The file position remains unchanged. After flush returns, the data is guaranteed to be physically written to the storage medium.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_flush\nimplicit none\n  integer :: io_unit\n  integer :: i\n\n  ! Open a file for writing\n  open(newunit=io_unit, file='output.txt', status='replace')\n\n  ! Write some data\n  do i = 1, 5\n    write(io_unit, '(A,I0)') 'Line ', i\n  end do\n\n  ! Flush to ensure data is written to disk\n  flush(io_unit)\n\n  print *, 'Data flushed to output.txt'\n\n  ! Continue with more operations...\n  write(io_unit, '(A)') 'Final line after flush'\n\n  close(io_unit)\n\n  ! Display file contents\n  open(newunit=io_unit, file='output.txt', status='old', action='read')\n  do\n    read(io_unit, '(A)', end=100) \n  end do\n100 continue\n  close(io_unit, status='delete')\n\nend program demo_flush\n```\nResults:\n```text\n Data flushed to output.txt\n```\n\n### **Standard**\n\nFortran 2003\n\n**Compatibility Notes:**\n- gfortran 4.4+, Intel Fortran 10.0+, NAG 5.2+\n- Ensures buffered output is written to file\n- May be no-op on some systems\n\n### **See Also**\n\n[**open**(3)](#open),\n[**close**(3)](#close),\n[**write**(3)](#write),\n[**inquire**(3)](#inquire)",
  "optionaldefault": "## optional_with_default\n\n### **Name**\n\n**optional_with_default** - \\[PROCEDURE:ARGUMENT\\] Handle optional argument with default value assignment\n\n### **Synopsis**\n```fortran\n    if (present(arg)) then\n      local_var = arg\n    else\n      local_var = default_value\n    end if\n```\n```fortran\n     ! Optional argument with default pattern\n\n      subroutine sub(optional_arg)\n        integer, intent(in), optional :: optional_arg\n        integer :: local_value\n\n        if (present(optional_arg)) then\n          local_value = optional_arg\n        else\n          local_value = default_value\n        end if\n```\n\n### **Characteristics**\n\n - Uses PRESENT intrinsic to check if argument was provided.\n - Assigns default value when argument is absent.\n - Local variable must be used for processing.\n - Cannot directly use absent optional argument.\n\n### **Description**\n\n **optional_with_default** implements the pattern for handling optional\n arguments with default values. Since absent optional arguments cannot be\n used directly in expressions, a local variable is assigned either the\n provided argument value or a default value based on presence.\n\n### **Options**\n\n- **optional_arg**\n  : The optional dummy argument declared with OPTIONAL attribute.\n\n- **local_var**\n  : A local variable of the same type to hold either the provided value\n  or the default.\n\n- **default_value**\n  : The value to use when the optional argument is not provided.\n\n### **Result**\n\n  A local variable is initialized with either the provided argument value\n  or a default, and can then be safely used in subsequent code.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_optional_default\nimplicit none\n\n  call process_data(values=[1.0, 2.0, 3.0])\n  call process_data(values=[1.0, 2.0, 3.0], scale=10.0)\n  call process_data(values=[1.0, 2.0, 3.0], scale=10.0, offset=5.0)\n\ncontains\n\n  subroutine process_data(values, scale, offset)\n    real, intent(in) :: values(:)\n    real, intent(in), optional :: scale, offset\n\n    real :: actual_scale, actual_offset\n    real :: result(size(values))\n\n    ! Set defaults\n    if (present(scale)) then\n      actual_scale = scale\n    else\n      actual_scale = 1.0\n    end if\n\n    if (present(offset)) then\n      actual_offset = offset\n    else\n      actual_offset = 0.0\n    end if\n\n    ! Process\n    result = values * actual_scale + actual_offset\n\n    print '(A,3F8.2)', 'Input:  ', values\n    print '(A,F8.2)', 'Scale:  ', actual_scale\n    print '(A,F8.2)', 'Offset: ', actual_offset\n    print '(A,3F8.2)', 'Output: ', result\n    print '(A)', ''\n\n  end subroutine process_data\n\nend program demo_optional_default\n```\nResults:\n```text\nInput:      1.00    2.00    3.00\nScale:      1.00\nOffset:     0.00\nOutput:     1.00    2.00    3.00\n\nInput:      1.00    2.00    3.00\nScale:     10.00\nOffset:     0.00\nOutput:    10.00   20.00   30.00\n\nInput:      1.00    2.00    3.00\nScale:     10.00\nOffset:     5.00\nOutput:    15.00   25.00   35.00\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**present**(3)](#present),\n[**optional**(3)](#optional)",
  "reduction": "## omp_reduction\n\n### **Name**\n\n**omp_reduction** - \\[PARALLEL:OPENMP\\] Reduction clause for parallel accumulation operations\n\n### **Synopsis**\n\n```fortran\n    !$omp parallel do reduction(operator:variable_list)\n    do i = start, end\n      variable = variable operator expression\n    end do\n    !$omp end parallel do\n```\n\n```fortran\n    !$omp parallel do reduction(operator:var1, var2, ...)\n    !$omp parallel reduction(operator:var)\n    !$omp simd reduction(operator:var)\n    !$omp do reduction(operator:var)\n\n    ! Supported operators:\n    ! Arithmetic: +, -, *\n    ! Logical: .and., .or., .eqv., .neqv.\n    ! Intrinsic: max, min, iand, ior, ieor\n```\n\n### **Characteristics**\n\n - **operator** specifies the reduction operation to perform.\n - **variable_list** is one or more scalar variables to reduce.\n - Each thread receives a private copy initialized to the identity value.\n - At region end, private copies are combined using the operator.\n - The original variable receives the final combined result.\n - Reduction variables must be scalar (arrays require explicit loops or user-defined reductions).\n - The reduction operator must be associative for correct results.\n\n### **Description**\n\n **reduction(operator:list)** is a data-sharing clause that enables safe parallel accumulation of values into shared variables. Without reduction, multiple threads updating the same variable would cause a race condition. With reduction, each thread accumulates into its own private copy, and these copies are combined at the end of the parallel region.\n\n The private copies are initialized to the identity value for the operator: 0 for +, 1 for *, .true. for .and., .false. for .or., largest negative for max, largest positive for min, all bits set for iand, and zero for ior and ieor.\n\n### **Options**\n\n- **+ (addition)**\n  : Identity value: 0. Combines partial sums from all threads.\n\n- **- (subtraction)**\n  : Identity value: 0. Note: Subtraction is not truly associative; treated as addition of negated values.\n\n- ** * (multiplication)**\n  : Identity value: 1. Combines partial products from all threads.\n\n- **.and. (logical AND)**\n  : Identity value: .true.. Result is .true. only if all partial results are .true..\n\n- **.or. (logical OR)**\n  : Identity value: .false.. Result is .true. if any partial result is .true..\n\n- **.eqv. (logical equivalence)**\n  : Identity value: .true.. Tests if all partial results have the same logical value.\n\n- **.neqv. (logical non-equivalence)**\n  : Identity value: .false.. Logical XOR across all threads.\n\n- **max (maximum)**\n  : Identity value: smallest representable value for the type. Finds maximum across all threads.\n\n- **min (minimum)**\n  : Identity value: largest representable value for the type. Finds minimum across all threads.\n\n- **iand (bitwise AND)**\n  : Identity value: all bits set to 1. Performs bitwise AND across all threads.\n\n- **ior (bitwise OR)**\n  : Identity value: 0. Performs bitwise OR across all threads.\n\n- **ieor (bitwise XOR)**\n  : Identity value: 0. Performs bitwise XOR across all threads.\n\n### **Result**\n\n  After the parallel region completes, the reduction variable contains the combined result of the reduction operation applied across all threads. The order of combination is implementation-defined but mathematically equivalent to sequential execution for associative operators.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_omp_reduction\n  use omp_lib\n  implicit none\n  integer, parameter :: n = 10000\n  real(8) :: a(n)\n  real(8) :: sum_val, product_val, max_val, min_val\n  integer :: count_positive\n  logical :: all_positive, any_negative\n  integer :: i\n\n  ! Initialize array with mixed values\n  do i = 1, n\n    a(i) = real(i - n/2, 8)  ! Values from -5000 to 5000\n  end do\n\n  ! Reduction with + (sum)\n  sum_val = 0.0d0\n  !$omp parallel do reduction(+:sum_val)\n  do i = 1, n\n    sum_val = sum_val + a(i)\n  end do\n  !$omp end parallel do\n  print '(A,F15.2)', 'Sum:     ', sum_val\n\n  ! Reduction with max\n  max_val = -huge(max_val)\n  !$omp parallel do reduction(max:max_val)\n  do i = 1, n\n    max_val = max(max_val, a(i))\n  end do\n  !$omp end parallel do\n  print '(A,F15.2)', 'Maximum: ', max_val\n\n  ! Reduction with min\n  min_val = huge(min_val)\n  !$omp parallel do reduction(min:min_val)\n  do i = 1, n\n    min_val = min(min_val, a(i))\n  end do\n  !$omp end parallel do\n  print '(A,F15.2)', 'Minimum: ', min_val\n\n  ! Logical reduction: .and.\n  all_positive = .true.\n  !$omp parallel do reduction(.and.:all_positive)\n  do i = 1, n\n    all_positive = all_positive .and. (a(i) > 0.0d0)\n  end do\n  !$omp end parallel do\n  print '(A,L)', 'All positive: ', all_positive\n\n  ! Logical reduction: .or.\n  any_negative = .false.\n  !$omp parallel do reduction(.or.:any_negative)\n  do i = 1, n\n    any_negative = any_negative .or. (a(i) < 0.0d0)\n  end do\n  !$omp end parallel do\n  print '(A,L)', 'Any negative: ', any_negative\n\n  ! Integer reduction: count\n  count_positive = 0\n  !$omp parallel do reduction(+:count_positive)\n  do i = 1, n\n    if (a(i) > 0.0d0) count_positive = count_positive + 1\n  end do\n  !$omp end parallel do\n  print '(A,I0)', 'Count positive: ', count_positive\n\n  ! Multiple reductions in one directive\n  sum_val = 0.0d0\n  max_val = -huge(max_val)\n  min_val = huge(min_val)\n  !$omp parallel do reduction(+:sum_val) reduction(max:max_val) reduction(min:min_val)\n  do i = 1, n\n    sum_val = sum_val + a(i)\n    max_val = max(max_val, a(i))\n    min_val = min(min_val, a(i))\n  end do\n  !$omp end parallel do\n  print '(A)', 'Combined reductions:'\n  print '(A,F15.2)', '  Sum: ', sum_val\n  print '(A,F15.2)', '  Max: ', max_val\n  print '(A,F15.2)', '  Min: ', min_val\n\nend program demo_omp_reduction\n```\n\nCompile with:\n```text\ngfortran -fopenmp demo_omp_reduction.f90 -o demo_omp_reduction\n```\n\nResults:\n```text\nSum:            5000.00\nMaximum:        5000.00\nMinimum:       -4999.00\nAll positive: F\nAny negative: T\nCount positive: 5000\nCombined reductions:\n  Sum:          5000.00\n  Max:          5000.00\n  Min:         -4999.00\n```\n\n### **Standard**\n\nOpenMP 1.0 (1997 for Fortran), with extensions in later versions\n\n### **See Also**\n\n[**!$omp parallel do**(3)](#omp_parallel_do),\n[**!$omp parallel**(3)](#omp_parallel),\n[**!$omp atomic**(3)](#omp_atomic),\n[**!$omp critical**(3)](#omp_critical)\n\n### **Resources**\n\n- [OpenMP 5.0 Reduction Clause](https://www.openmp.org/spec-html/5.0/openmpsu107.html)\n- [OpenMP Reduction Tutorial](https://www.openmp.org/resources/tutorials-articles/)\n- [LLNL OpenMP Tutorial - Reduction](https://hpc-tutorials.llnl.gov/openmp/)",
  "ompdosimd": "## omp_parallel_do_simd\n\n### **Name**\n\n**omp_parallel_do_simd** - \\[PARALLEL:OPENMP\\] Combined parallel worksharing-loop SIMD construct\n\n### **Synopsis**\n\n```fortran\n    !$omp parallel do simd [clause [[,] clause] ...]\n    do i = start, end [, step]\n      ! loop body (vectorizable operations)\n    end do\n    !$omp end parallel do simd\n```\n\n```fortran\n    !$omp parallel do simd private(list) shared(list) reduction(operator:list)\n    !$omp& simdlen(length) safelen(length) aligned(list:alignment)\n    !$omp& schedule(type [, chunk]) collapse(n) linear(list:step)\n    do index = lower, upper [, stride]\n      ! loop body - distributed across threads and vectorized\n    end do\n    !$omp end parallel do simd\n```\n\n### **Characteristics**\n\n - **private(list)** creates thread-private copies of listed variables.\n - **shared(list)** specifies variables shared among all threads.\n - **reduction(operator:list)** performs a reduction with SIMD-aware implementation.\n - **simdlen(length)** specifies the preferred number of concurrent SIMD lanes.\n - **safelen(length)** specifies the maximum distance for loop-carried dependencies.\n - **aligned(list:alignment)** specifies that list variables have the given alignment.\n - **linear(list:step)** specifies variables that increase linearly with each iteration.\n - **schedule(type [, chunk])** controls how iterations are distributed among threads.\n - **collapse(n)** combines n nested loops before distributing and vectorizing.\n - The loop body must be suitable for SIMD vectorization.\n - An implicit barrier exists at the end of the construct.\n\n### **Description**\n\n **!$omp parallel do simd** creates a parallel region containing a combined worksharing-loop and SIMD construct. Loop iterations are first distributed across threads, then each thread's iterations are vectorized using SIMD instructions. This provides two levels of parallelism: thread-level parallelism from the parallel do and data-level parallelism from SIMD vectorization.\n\n The loop body must be suitable for vectorization: no function calls (unless declared as simd), no I/O operations, no dependencies between SIMD lanes beyond what safelen allows, and operations should be uniform or linear.\n\n### **Options**\n\n- **private(list)**\n  : Creates thread-private copies of listed variables. Within each thread, SIMD lanes may share or privatize these variables depending on the implementation.\n\n- **shared(list)**\n  : Specifies variables shared among all threads. Arrays accessed with the loop index are typically shared.\n\n- **reduction(operator:list)**\n  : Performs a reduction operation. The implementation combines both thread-level and SIMD-level reductions efficiently. Operators: +, -, *, .and., .or., .eqv., .neqv., max, min, iand, ior, ieor.\n\n- **simdlen(length)**\n  : Specifies the preferred number of SIMD lanes. Should match the hardware vector width for best performance (e.g., 4 for SSE with double, 8 for AVX with single).\n\n- **safelen(length)**\n  : Maximum number of iterations that can be executed concurrently without violating dependencies. If there are no loop-carried dependencies, this can be omitted.\n\n- **aligned(list:alignment)**\n  : Declares that array addresses are aligned to the specified byte boundary. Enables aligned vector load/store instructions. Common values: 16 (SSE), 32 (AVX), 64 (AVX-512).\n\n- **linear(list:step)**\n  : Specifies that listed variables have a linear relationship with the loop iteration, incrementing by step each iteration.\n\n- **collapse(n)**\n  : Combines n nested loops into a single iteration space before distributing and vectorizing.\n\n### **Result**\n\n  The parallel do simd construct achieves both thread-level parallelism and SIMD vectorization. Loop iterations are distributed across threads, and each thread processes its iterations using vector instructions. Upon completion, any reduction variables contain the fully combined result from all threads and all SIMD lanes.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_omp_parallel_do_simd\n  use omp_lib\n  implicit none\n  integer, parameter :: n = 10000\n  real(8), allocatable :: a(:), b(:), c(:)\n  real(8) :: sum_val, dot_product_val\n  integer :: i\n\n  allocate(a(n), b(n), c(n))\n\n  ! Initialize arrays\n  do i = 1, n\n    a(i) = real(i, 8) * 0.001d0\n    b(i) = real(n - i + 1, 8) * 0.001d0\n  end do\n\n  ! Parallel do simd: array addition with SIMD vectorization\n  !$omp parallel do simd private(i) shared(a, b, c) simdlen(8)\n  do i = 1, n\n    c(i) = a(i) + b(i)\n  end do\n  !$omp end parallel do simd\n\n  print '(A,F12.6)', 'c(1)   = ', c(1)\n  print '(A,F12.6)', 'c(n)   = ', c(n)\n  print '(A,F12.6)', 'c(n/2) = ', c(n/2)\n\n  ! Parallel do simd with reduction: sum\n  sum_val = 0.0d0\n  !$omp parallel do simd private(i) reduction(+:sum_val)\n  do i = 1, n\n    sum_val = sum_val + c(i)\n  end do\n  !$omp end parallel do simd\n\n  print '(A,F15.6)', 'Sum of c: ', sum_val\n\n  ! Parallel do simd: dot product\n  dot_product_val = 0.0d0\n  !$omp parallel do simd private(i) reduction(+:dot_product_val)\n  do i = 1, n\n    dot_product_val = dot_product_val + a(i) * b(i)\n  end do\n  !$omp end parallel do simd\n\n  print '(A,F15.6)', 'Dot product a.b: ', dot_product_val\n\n  deallocate(a, b, c)\n\nend program demo_omp_parallel_do_simd\n```\n\nCompile with:\n```text\ngfortran -fopenmp -march=native demo_omp_parallel_do_simd.f90 -o demo\nifort -qopenmp -xHost demo_omp_parallel_do_simd.f90 -o demo\n```\n\nResults:\n```text\nc(1)   =    10.001000\nc(n)   =    10.001000\nc(n/2) =    10.001000\nSum of c:   100010.000000\nDot product a.b:   166716.670000\n```\n\n### **Standard**\n\nOpenMP 4.0 (SIMD constructs introduced)\n\n### **See Also**\n\n[**!$omp parallel do**(3)](#omp_parallel_do),\n[**!$omp simd**(3)](#omp_simd),\n[**!$omp declare simd**(3)](#omp_declare_simd),\n[**!$omp parallel**(3)](#omp_parallel),\n[**!$omp do**(3)](#omp_do)\n\n### **Resources**\n\n- [OpenMP 5.0 SIMD Construct](https://www.openmp.org/spec-html/5.0/openmpsu42.html)\n- [Intel OpenMP SIMD Vectorization Guide](https://www.intel.com/content/www/us/en/docs/cpp-compiler/developer-guide-reference/)\n- [OpenMP Official Site](https://www.openmp.org/)",
  "dgesv": "## dgesv\n\n### **Name**\n\n**dgesv** - \\[NUMERIC:LAPACK\\] Solve a system of linear equations A*X = B\n\n### **Synopsis**\n```fortran\n    call dgesv(n, nrhs, A, lda, ipiv, B, ldb, info)\n```\n```fortran\n     subroutine dgesv(n, nrhs, A, lda, ipiv, B, ldb, info)\n\n      integer, intent(in)    :: n, nrhs, lda, ldb\n      integer, intent(out)   :: ipiv(n), info\n      double precision, intent(inout) :: A(lda,n), B(ldb,nrhs)\n```\n\n### **Characteristics**\n\n - LAPACK driver routine for solving linear systems.\n - Uses LU factorization with partial pivoting.\n - Requires linking with a LAPACK library.\n - Matrix A is overwritten with its LU factorization.\n\n### **Description**\n\n **dgesv** computes the solution to a real system of linear equations A*X = B,\n where A is an n-by-n matrix and X and B are n-by-nrhs matrices. The LU\n decomposition with partial pivoting and row interchanges is used to factor A\n as A = P*L*U, where P is a permutation matrix, L is unit lower triangular,\n and U is upper triangular. The factored form of A is then used to solve the\n system of equations A*X = B.\n\n### **Options**\n\n- **n**\n  : The number of linear equations (order of matrix A).\n\n- **nrhs**\n  : The number of right-hand sides (columns of B).\n\n- **A**\n  : On entry, the n-by-n coefficient matrix A. On exit, the factors L and U\n  from the factorization A = P*L*U.\n\n- **lda**\n  : Leading dimension of A. Must be >= max(1, n).\n\n- **ipiv**\n  : Integer array of size n. The pivot indices defining permutation matrix P.\n\n- **B**\n  : On entry, the n-by-nrhs right-hand side matrix B. On exit, the solution\n  matrix X if info=0.\n\n- **ldb**\n  : Leading dimension of B. Must be >= max(1, n).\n\n- **info**\n  : = 0: successful exit.\n  < 0: if info = -i, the i-th argument had an illegal value.\n  > 0: if info = i, U(i,i) is exactly zero (singular matrix).\n\n### **Result**\n\n  On successful exit (info=0), B contains the solution matrix X.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_dgesv\nimplicit none\n  external :: dgesv\n\n  integer, parameter :: n = 3, nrhs = 1\n  double precision :: A(n, n), B(n, nrhs), A_orig(n, n)\n  integer :: ipiv(n), info\n  integer :: i\n\n  ! System of equations:\n  ! 2x + y - z = 8\n  ! -3x - y + 2z = -11\n  ! -2x + y + 2z = -3\n\n  A = reshape([2.0d0, -3.0d0, -2.0d0, &   ! Column 1\n               1.0d0, -1.0d0,  1.0d0, &   ! Column 2\n              -1.0d0,  2.0d0,  2.0d0], &  ! Column 3\n              [n, n])\n  A_orig = A  ! Save original for verification\n\n  B = reshape([8.0d0, -11.0d0, -3.0d0], [n, nrhs])\n\n  print '(A)', 'Coefficient matrix A:'\n  do i = 1, n\n    print '(3F10.4)', A(i, :)\n  end do\n\n  print '(A)', 'Right-hand side B:'\n  print '(3F10.4)', B(:, 1)\n\n  ! Solve the system\n  call dgesv(n, nrhs, A, n, ipiv, B, n, info)\n\n  if (info == 0) then\n    print '(A)', 'Solution X:'\n    print '(3F10.4)', B(:, 1)\n\n    ! Verify: A_orig * X should equal original B\n    print '(A)', 'Verification A*X:'\n    print '(3F10.4)', matmul(A_orig, B(:,1))\n  else if (info < 0) then\n    print '(A,I0,A)', 'Error: argument ', -info, ' had illegal value'\n  else\n    print '(A,I0)', 'Error: matrix is singular, U(', info, ',', info, ')=0'\n  end if\n\nend program demo_dgesv\n```\nResults:\n```text\nCoefficient matrix A:\n    2.0000    1.0000   -1.0000\n   -3.0000   -1.0000    2.0000\n   -2.0000    1.0000    2.0000\nRight-hand side B:\n    8.0000  -11.0000   -3.0000\nSolution X:\n    2.0000    3.0000   -1.0000\nVerification A*X:\n    8.0000  -11.0000   -3.0000\n```\n\n### **Standard**\n\nLAPACK (not Fortran standard, but widely available)\n\n### **See Also**\n\n[**dgetrf**(3)](#dgetrf),\n[**dgetrs**(3)](#dgetrs),\n[**dgemm**(3)](#dgemm)",
  "nosavedecl": "## initialization_without_save\n\n### **Name**\n\n**initialization_without_save** - \\[STRUCTURE:DECLARATION\\] Declare and initialize a variable without implicit SAVE\n\n### **Synopsis**\n```fortran\n    type :: variable\n    variable = value\n```\n```fortran\n     ! Separate declaration and initialization\n\n      real :: x\n      x = 0.0\n```\n\n### **Characteristics**\n\n - Separates declaration from initialization.\n - Avoids implicit SAVE attribute that comes with initializers.\n - Local variables are re-initialized on each procedure call.\n - Required for automatic (stack) variables.\n\n### **Description**\n\n **initialization_without_save** declares a variable and initializes it on\n separate lines. In Fortran, when a variable is initialized in its declaration\n (e.g., `real :: x = 0.0`), it implicitly receives the SAVE attribute, meaning\n its value persists between procedure calls. To avoid this, declare the\n variable first, then initialize it in an executable statement.\n\n### **Options**\n\n- **type**\n  : The data type of the variable (integer, real, character, etc.).\n\n- **variable**\n  : The variable name being declared and initialized.\n\n- **value**\n  : The initial value to assign.\n\n### **Result**\n\n  The variable is initialized without the SAVE attribute, so it will be\n  re-initialized on each procedure invocation.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_init_without_save\nimplicit none\n  integer :: i\n\n  do i = 1, 3\n    call with_save()\n    call without_save()\n    print '(A)', '---'\n  end do\n\ncontains\n\n  subroutine with_save()\n    ! WARNING: This has implicit SAVE attribute!\n    integer :: counter = 0\n    counter = counter + 1\n    print '(A,I0)', 'With SAVE: counter = ', counter\n  end subroutine with_save\n\n  subroutine without_save()\n    ! Correct: no implicit SAVE\n    integer :: counter\n    counter = 0\n    counter = counter + 1\n    print '(A,I0)', 'Without SAVE: counter = ', counter\n  end subroutine without_save\n\nend program demo_init_without_save\n```\nResults:\n```text\nWith SAVE: counter = 1\nWithout SAVE: counter = 1\n---\nWith SAVE: counter = 2\nWithout SAVE: counter = 1\n---\nWith SAVE: counter = 3\nWithout SAVE: counter = 1\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**save**(3)](#save),\n[**parameter**(3)](#parameter),\n[**automatic**(3)](#automatic)",
  "initvar": "## initialization_without_save\n\n### **Name**\n\n**initialization_without_save** - \\[STRUCTURE:DECLARATION\\] Declare and initialize a variable without implicit SAVE\n\n### **Synopsis**\n```fortran\n    type :: variable\n    variable = value\n```\n```fortran\n     ! Separate declaration and initialization\n\n      real :: x\n      x = 0.0\n```\n\n### **Characteristics**\n\n - Separates declaration from initialization.\n - Avoids implicit SAVE attribute that comes with initializers.\n - Local variables are re-initialized on each procedure call.\n - Required for automatic (stack) variables.\n\n### **Description**\n\n **initialization_without_save** declares a variable and initializes it on\n separate lines. In Fortran, when a variable is initialized in its declaration\n (e.g., `real :: x = 0.0`), it implicitly receives the SAVE attribute, meaning\n its value persists between procedure calls. To avoid this, declare the\n variable first, then initialize it in an executable statement.\n\n### **Options**\n\n- **type**\n  : The data type of the variable (integer, real, character, etc.).\n\n- **variable**\n  : The variable name being declared and initialized.\n\n- **value**\n  : The initial value to assign.\n\n### **Result**\n\n  The variable is initialized without the SAVE attribute, so it will be\n  re-initialized on each procedure invocation.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_init_without_save\nimplicit none\n  integer :: i\n\n  do i = 1, 3\n    call with_save()\n    call without_save()\n    print '(A)', '---'\n  end do\n\ncontains\n\n  subroutine with_save()\n    ! WARNING: This has implicit SAVE attribute!\n    integer :: counter = 0\n    counter = counter + 1\n    print '(A,I0)', 'With SAVE: counter = ', counter\n  end subroutine with_save\n\n  subroutine without_save()\n    ! Correct: no implicit SAVE\n    integer :: counter\n    counter = 0\n    counter = counter + 1\n    print '(A,I0)', 'Without SAVE: counter = ', counter\n  end subroutine without_save\n\nend program demo_init_without_save\n```\nResults:\n```text\nWith SAVE: counter = 1\nWithout SAVE: counter = 1\n---\nWith SAVE: counter = 2\nWithout SAVE: counter = 1\n---\nWith SAVE: counter = 3\nWithout SAVE: counter = 1\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**save**(3)](#save),\n[**parameter**(3)](#parameter),\n[**automatic**(3)](#automatic)",
  "mpi_send": "## MPI_Send\n\n### **Name**\n\n**MPI_Send** - \\[PARALLEL:MPI\\] Standard-mode blocking send\n\n### **Synopsis**\n\n```fortran\n    call MPI_Send(buf, count, datatype, dest, tag, comm, ierror)\n```\n\n```fortran\n     subroutine MPI_Send(buf, count, datatype, dest, tag, comm, ierror)\n\n      type(*), dimension(..), intent(in) :: buf\n      integer, intent(in)                :: count\n      type(MPI_Datatype), intent(in)     :: datatype\n      integer, intent(in)                :: dest\n      integer, intent(in)                :: tag\n      type(MPI_Comm), intent(in)         :: comm\n      integer, intent(out), optional     :: ierror\n```\n\n### **Characteristics**\n\n - **buf** is the starting address of the send buffer; can be any data type.\n - **count** is a non-negative integer specifying the number of elements to send.\n - **datatype** is an MPI datatype handle (e.g., MPI_INTEGER, MPI_DOUBLE_PRECISION, MPI_REAL).\n - **dest** is an integer rank of the destination process within the communicator.\n - **tag** is a non-negative integer message tag for matching send/receive pairs.\n - **comm** is an MPI communicator handle (e.g., MPI_COMM_WORLD).\n - **ierror** is the output error status (Fortran only); returns MPI_SUCCESS on success.\n - This is a **blocking** operation: the call does not return until the send buffer can be safely reused.\n\n### **Description**\n\n **MPI_Send** performs a standard-mode blocking send operation. It transmits\n count elements of the specified datatype from the send buffer to the\n destination process. The call blocks until the send buffer can be safely\n reused by the caller, which may occur before, during, or after the\n matching receive completes, depending on the MPI implementation's\n buffering behavior.\n\n### **Options**\n\n- **buf**\n  : Starting address of the send buffer containing count elements of the\n  specified datatype. The buffer contents are transmitted to the destination.\n\n- **count**\n  : Number of elements to send. Must be non-negative. A count of 0 sends\n  an empty message.\n\n- **datatype**\n  : MPI datatype handle describing each buffer element. Common types:\n  MPI_INTEGER, MPI_REAL, MPI_DOUBLE_PRECISION, MPI_COMPLEX, MPI_LOGICAL.\n\n- **dest**\n  : Rank of destination process within comm (0 to comm_size-1).\n  MPI_PROC_NULL is allowed for a null send (no operation).\n\n- **tag**\n  : Message tag for matching with a corresponding receive. Must be\n  non-negative and less than MPI_TAG_UB.\n\n- **comm**\n  : MPI communicator defining the process group.\n\n- **ierror**\n  : Error code. Returns MPI_SUCCESS (0) on successful completion.\n\n### **Result**\n\n  The send buffer data is transmitted to the destination process. The call\n  returns when the buffer can be safely reused; this does not guarantee\n  the message has been received. Use MPI_Ssend for synchronous behavior\n  or MPI_Bsend for buffered sends.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_mpi_send\n  use mpi_f08\n  implicit none\n  integer :: rank, nprocs, ierr\n  real(8) :: message(10)\n  type(MPI_Status) :: status\n  integer :: i\n\n  call MPI_Init(ierr)\n  call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierr)\n  call MPI_Comm_size(MPI_COMM_WORLD, nprocs, ierr)\n\n  if (nprocs < 2) then\n    print *, 'This example requires at least 2 processes'\n    call MPI_Abort(MPI_COMM_WORLD, 1, ierr)\n  end if\n\n  if (rank == 0) then\n    ! Process 0 sends data to process 1\n    message = [(real(i, 8), i = 1, 10)]\n    print *, 'Process 0 sending:', message(1:5), '...'\n    call MPI_Send(message, 10, MPI_DOUBLE_PRECISION, 1, 42, &\n                  MPI_COMM_WORLD, ierr)\n    print *, 'Process 0 send completed'\n  else if (rank == 1) then\n    ! Process 1 receives data from process 0\n    call MPI_Recv(message, 10, MPI_DOUBLE_PRECISION, 0, 42, &\n                  MPI_COMM_WORLD, status, ierr)\n    print *, 'Process 1 received:', message(1:5), '...'\n  end if\n\n  call MPI_Finalize(ierr)\n\nend program demo_mpi_send\n```\n\nResults (with 2+ processes):\n\n```text\n Process 0 sending:   1.0000000000000000   2.0000000000000000   3.0000000000000000   4.0000000000000000   5.0000000000000000  ...\n Process 0 send completed\n Process 1 received:   1.0000000000000000   2.0000000000000000   3.0000000000000000   4.0000000000000000   5.0000000000000000  ...\n```\n\n### **Standard**\n\nMPI-1.0\n\n### **See Also**\n\n[**MPI_Recv**(3)](#mpi_recv),\n[**MPI_Isend**(3)](#mpi_isend),\n[**MPI_Ssend**(3)](#mpi_ssend),\n[**MPI_Bsend**(3)](#mpi_bsend),\n[**MPI_Sendrecv**(3)](#mpi_sendrecv),\n[**MPI_Probe**(3)](#mpi_probe)",
  "mpisend": "## MPI_Send\n\n### **Name**\n\n**MPI_Send** - \\[PARALLEL:MPI\\] Standard-mode blocking send\n\n### **Synopsis**\n\n```fortran\n    call MPI_Send(buf, count, datatype, dest, tag, comm, ierror)\n```\n\n```fortran\n     subroutine MPI_Send(buf, count, datatype, dest, tag, comm, ierror)\n\n      type(*), dimension(..), intent(in) :: buf\n      integer, intent(in)                :: count\n      type(MPI_Datatype), intent(in)     :: datatype\n      integer, intent(in)                :: dest\n      integer, intent(in)                :: tag\n      type(MPI_Comm), intent(in)         :: comm\n      integer, intent(out), optional     :: ierror\n```\n\n### **Characteristics**\n\n - **buf** is the starting address of the send buffer; can be any data type.\n - **count** is a non-negative integer specifying the number of elements to send.\n - **datatype** is an MPI datatype handle (e.g., MPI_INTEGER, MPI_DOUBLE_PRECISION, MPI_REAL).\n - **dest** is an integer rank of the destination process within the communicator.\n - **tag** is a non-negative integer message tag for matching send/receive pairs.\n - **comm** is an MPI communicator handle (e.g., MPI_COMM_WORLD).\n - **ierror** is the output error status (Fortran only); returns MPI_SUCCESS on success.\n - This is a **blocking** operation: the call does not return until the send buffer can be safely reused.\n\n### **Description**\n\n **MPI_Send** performs a standard-mode blocking send operation. It transmits\n count elements of the specified datatype from the send buffer to the\n destination process. The call blocks until the send buffer can be safely\n reused by the caller, which may occur before, during, or after the\n matching receive completes, depending on the MPI implementation's\n buffering behavior.\n\n### **Options**\n\n- **buf**\n  : Starting address of the send buffer containing count elements of the\n  specified datatype. The buffer contents are transmitted to the destination.\n\n- **count**\n  : Number of elements to send. Must be non-negative. A count of 0 sends\n  an empty message.\n\n- **datatype**\n  : MPI datatype handle describing each buffer element. Common types:\n  MPI_INTEGER, MPI_REAL, MPI_DOUBLE_PRECISION, MPI_COMPLEX, MPI_LOGICAL.\n\n- **dest**\n  : Rank of destination process within comm (0 to comm_size-1).\n  MPI_PROC_NULL is allowed for a null send (no operation).\n\n- **tag**\n  : Message tag for matching with a corresponding receive. Must be\n  non-negative and less than MPI_TAG_UB.\n\n- **comm**\n  : MPI communicator defining the process group.\n\n- **ierror**\n  : Error code. Returns MPI_SUCCESS (0) on successful completion.\n\n### **Result**\n\n  The send buffer data is transmitted to the destination process. The call\n  returns when the buffer can be safely reused; this does not guarantee\n  the message has been received. Use MPI_Ssend for synchronous behavior\n  or MPI_Bsend for buffered sends.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_mpi_send\n  use mpi_f08\n  implicit none\n  integer :: rank, nprocs, ierr\n  real(8) :: message(10)\n  type(MPI_Status) :: status\n  integer :: i\n\n  call MPI_Init(ierr)\n  call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierr)\n  call MPI_Comm_size(MPI_COMM_WORLD, nprocs, ierr)\n\n  if (nprocs < 2) then\n    print *, 'This example requires at least 2 processes'\n    call MPI_Abort(MPI_COMM_WORLD, 1, ierr)\n  end if\n\n  if (rank == 0) then\n    ! Process 0 sends data to process 1\n    message = [(real(i, 8), i = 1, 10)]\n    print *, 'Process 0 sending:', message(1:5), '...'\n    call MPI_Send(message, 10, MPI_DOUBLE_PRECISION, 1, 42, &\n                  MPI_COMM_WORLD, ierr)\n    print *, 'Process 0 send completed'\n  else if (rank == 1) then\n    ! Process 1 receives data from process 0\n    call MPI_Recv(message, 10, MPI_DOUBLE_PRECISION, 0, 42, &\n                  MPI_COMM_WORLD, status, ierr)\n    print *, 'Process 1 received:', message(1:5), '...'\n  end if\n\n  call MPI_Finalize(ierr)\n\nend program demo_mpi_send\n```\n\nResults (with 2+ processes):\n\n```text\n Process 0 sending:   1.0000000000000000   2.0000000000000000   3.0000000000000000   4.0000000000000000   5.0000000000000000  ...\n Process 0 send completed\n Process 1 received:   1.0000000000000000   2.0000000000000000   3.0000000000000000   4.0000000000000000   5.0000000000000000  ...\n```\n\n### **Standard**\n\nMPI-1.0\n\n### **See Also**\n\n[**MPI_Recv**(3)](#mpi_recv),\n[**MPI_Isend**(3)](#mpi_isend),\n[**MPI_Ssend**(3)](#mpi_ssend),\n[**MPI_Bsend**(3)](#mpi_bsend),\n[**MPI_Sendrecv**(3)](#mpi_sendrecv),\n[**MPI_Probe**(3)](#mpi_probe)",
  "assert": "## assert\n\n### **Name**\n\n**assert** - \\[ERROR:HANDLING\\] Runtime assertion pattern for condition verification\n\n### **Synopsis**\n```fortran\n    if (.not. condition) error stop 'Assertion failed: message'\n```\n```fortran\n     ! Assertion pattern with descriptive message\n\n      if (.not. (condition)) then\n        write(error_unit, '(A)') 'Assertion failed: description'\n        error stop 1\n      end if\n```\n\n### **Characteristics**\n\n - Verifies that a logical condition is true at runtime.\n - Halts program execution with an error message if condition is false.\n - Uses **error stop** for abnormal termination with nonzero exit code.\n - Provides descriptive error messages for debugging.\n - Can write to error_unit for proper stderr output.\n\n### **Description**\n\n **assert** implements a runtime assertion pattern that verifies a condition\n is true. If the condition is false, the program halts with an error message.\n This pattern is useful for catching programming errors, validating inputs,\n and ensuring invariants are maintained. Unlike some languages, Fortran does\n not have a built-in assert statement, so this pattern must be implemented\n manually.\n\n### **Options**\n\n- **condition**\n  : A logical expression that should evaluate to .true. under normal\n  circumstances. If .false., the assertion fails and the program terminates.\n\n- **message**\n  : A character string describing what condition was expected. Should be\n  descriptive enough to help identify the source of the failure.\n\n### **Result**\n\n  If the condition is true, execution continues normally. If false, the\n  program terminates with an error message and nonzero exit status.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_assert\nuse iso_fortran_env, only: error_unit\nimplicit none\n  real :: x, result\n  integer :: n\n  real, allocatable :: array(:)\n\n  ! Simple assertion - verify positive input\n  x = 4.0\n  if (.not. (x > 0.0)) error stop 'Assertion failed: x must be positive'\n  result = sqrt(x)\n  print '(A,F8.4)', 'sqrt(x) = ', result\n\n  ! Assertion with detailed message\n  n = 10\n  if (.not. (n >= 1 .and. n <= 100)) then\n    write(error_unit, '(A,I0,A)') 'Assertion failed: n=', n, ' not in [1,100]'\n    error stop 1\n  end if\n  print '(A,I0)', 'n is valid: ', n\n\n  ! Array bounds check\n  allocate(array(n))\n  array = [(real(i), i=1,n)]\n  call check_bounds(5, n)\n\n  print '(A)', 'All assertions passed.'\n\ncontains\n\n  subroutine check_bounds(index, size)\n    integer, intent(in) :: index, size\n    if (.not. (index >= 1 .and. index <= size)) then\n      write(error_unit, '(A,I0,A,I0)') &\n        'Assertion failed: index ', index, ' out of bounds [1:', size\n      error stop 1\n    end if\n  end subroutine\n\nend program demo_assert\n```\nResults:\n```text\nsqrt(x) =   2.0000\nn is valid: 10\nAll assertions passed.\n```\n\n### **Standard**\n\nFortran 2008 (error stop)\n\n**Compatibility Notes:**\n- gfortran 4.5+, Intel Fortran 11.0+, NAG 5.3+\n- ERROR STOP provides termination with message\n- Use for runtime invariant checking\n\n### **See Also**\n\n[**error_stop**(3)](#error_stop),\n[**stop**(3)](#stop),\n[**error_unit**(3)](#error_unit)",
  "contiguous": "## contiguous\n\n### **Name**\n\n**contiguous** - \\[ARRAY:DECLARATION\\] Declare a contiguous assumed-shape array argument\n\n### **Synopsis**\n```fortran\n    type, intent(in), contiguous :: array(:)\n```\n```fortran\n     subroutine proc(array)\n\n      type(TYPE(kind=**)), intent(in|out|inout), contiguous :: array(:,..)\n```\n\n### **Characteristics**\n\n - **array** is an assumed-shape dummy argument with the CONTIGUOUS attribute.\n - The actual argument must be contiguous in memory.\n - Enables compiler optimizations that require contiguous memory access.\n - The procedure must have an explicit interface.\n - Can be applied to any rank of assumed-shape array.\n - IS_CONTIGUOUS intrinsic can verify contiguity at runtime.\n\n### **Description**\n\n The **contiguous** attribute indicates that an assumed-shape array dummy\n argument will only receive contiguous actual arguments. This enables\n aggressive compiler optimizations such as vectorization, loop unrolling,\n and efficient cache utilization. When passing to C functions via\n iso_c_binding, contiguous arrays can be passed directly without copying.\n The compiler may generate copy-in/copy-out code if a non-contiguous\n actual argument is passed to a contiguous dummy.\n\n### **Options**\n\n- **type**\n  : Any intrinsic or derived type.\n\n- **kind**\n  : Optional kind parameter for the type.\n\n- **intent**\n  : Data flow direction: in (read-only), out (write-only), or inout (read-write).\n\n- **array**\n  : The dummy argument name with assumed-shape syntax `(:)` or `(:,:)`, etc.\n\n### **Result**\n\n  The dummy argument is guaranteed to be contiguous in memory, allowing\n  the compiler to generate optimized code. Array operations and pointer\n  arithmetic can assume sequential memory layout.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_contiguous\n  use, intrinsic :: iso_fortran_env, only: dp => real64\n  use, intrinsic :: iso_c_binding, only: c_double, c_int\n  implicit none\n\n  real(dp), target :: full_array(100)\n  real(dp), pointer :: ptr_contig(:), ptr_strided(:)\n  integer :: i\n\n  ! Initialize array\n  full_array = [(real(i, dp), i = 1, 100)]\n\n  ! Contiguous pointer (every element)\n  ptr_contig => full_array(1:50)\n\n  ! Strided pointer (every other element) - NOT contiguous\n  ptr_strided => full_array(1:100:2)\n\n  print *, 'Is full_array contiguous?', is_contiguous(full_array)\n  print *, 'Is ptr_contig contiguous?', is_contiguous(ptr_contig)\n  print *, 'Is ptr_strided contiguous?', is_contiguous(ptr_strided)\n\n  ! Call procedure requiring contiguous array\n  call process_contiguous(full_array)\n  call process_contiguous(ptr_contig)\n  ! call process_contiguous(ptr_strided)  ! Would require copy-in/copy-out\n\ncontains\n\n  subroutine process_contiguous(arr)\n    real(dp), intent(in), contiguous :: arr(:)\n\n    print *, 'Processing contiguous array of size:', size(arr)\n    print *, 'Sum:', sum(arr)\n  end subroutine process_contiguous\n\n  ! Example of C interoperability with contiguous array\n  subroutine pass_to_c(arr, n)\n    real(c_double), intent(inout), contiguous :: arr(:)\n    integer(c_int), intent(in) :: n\n\n    ! Contiguous arrays can be passed directly to C\n    ! call c_function(arr, n)\n    print *, 'Would pass contiguous array of size', n, 'to C'\n  end subroutine pass_to_c\n\nend program demo_contiguous\n```\nResults:\n```text\n Is full_array contiguous? T\n Is ptr_contig contiguous? T\n Is ptr_strided contiguous? F\n Processing contiguous array of size:         100\n Sum:   5050.0000000000000\n Processing contiguous array of size:          50\n Sum:   1275.0000000000000\n```\n\n### **Standard**\n\nFortran 2008\n\n**Compatibility Notes:**\n- gfortran 4.6+, Intel Fortran 12.0+, NAG 6.0+\n- Required for assumed-shape arrays passed to C or requiring contiguous memory\n- Compiler may make temporary copies if actual argument is not contiguous\n\n### **See Also**\n\n[**is_contiguous**](#is_contiguous),\n[**assumed_shape**](#assumed_shape),\n[**c_f_pointer**](#c_f_pointer)",
  "param": "## parameter\n\n### **Name**\n\n**parameter** - \\[STRUCTURE:DECLARATION\\] Declare a named constant with a fixed value\n\n### **Synopsis**\n```fortran\n    type, parameter :: name = value\n```\n```fortran\n     ! Named constant declaration\n\n      integer, parameter :: n = 100\n      real, parameter    :: pi = 3.14159265\n```\n\n### **Characteristics**\n\n - **parameter** declares a named constant (cannot be modified).\n - Value must be known at compile time.\n - Can be used in array dimension specifications.\n - Type can be any intrinsic or derived type.\n\n### **Description**\n\n **parameter** declares a named constant whose value is fixed at compile time\n and cannot be changed during program execution. Named constants improve code\n readability, enable compiler optimizations, and ensure values cannot be\n accidentally modified.\n\n### **Options**\n\n- **type**\n  : The data type of the constant (integer, real, character, logical, or\n  derived type with constant components).\n\n- **name**\n  : The identifier for the named constant. Conventionally uppercase or\n  with descriptive names.\n\n- **value**\n  : A constant expression that can be evaluated at compile time.\n\n### **Result**\n\n  A named constant is declared that can be used anywhere a literal constant\n  of that type would be valid.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_parameter\nimplicit none\n  ! Numeric constants\n  integer, parameter :: MAX_SIZE = 1000\n  integer, parameter :: dp = selected_real_kind(15, 307)\n  real(dp), parameter :: PI = 3.14159265358979323846_dp\n  real(dp), parameter :: E = 2.71828182845904523536_dp\n  real(dp), parameter :: GOLDEN_RATIO = (1.0_dp + sqrt(5.0_dp)) / 2.0_dp\n\n  ! Character constants\n  character(len=*), parameter :: VERSION = '1.0.0'\n  character(len=*), parameter :: AUTHOR = 'Fortran Programmer'\n\n  ! Array constant\n  integer, parameter :: PRIMES(5) = [2, 3, 5, 7, 11]\n\n  ! Derived from other parameters\n  real(dp), parameter :: TWO_PI = 2.0_dp * PI\n  integer, parameter :: MAX_INDEX = MAX_SIZE - 1\n\n  ! Use in array declarations\n  real(dp) :: data(MAX_SIZE)\n  real(dp) :: angles(360)\n\n  ! Use in calculations\n  print '(A,A)', 'Version: ', VERSION\n  print '(A,F20.16)', 'Pi: ', PI\n  print '(A,F20.16)', 'e: ', E\n  print '(A,F20.16)', 'Golden ratio: ', GOLDEN_RATIO\n  print '(A,I0)', 'Max size: ', MAX_SIZE\n  print '(A,5I3)', 'First primes: ', PRIMES\n\n  ! Calculate area of circle\n  data(1) = PI * 5.0_dp**2\n  print '(A,F10.4)', 'Area of circle (r=5): ', data(1)\n\nend program demo_parameter\n```\nResults:\n```text\nVersion: 1.0.0\nPi: 3.1415926535897931\ne: 2.7182818284590451\nGolden ratio: 1.6180339887498949\nMax size: 1000\nFirst primes:   2  3  5  7 11\nArea of circle (r=5):    78.5398\n```\n\n### **Standard**\n\nFortran 77\n\n### **See Also**\n\n[**save**(3)](#save),\n[**data**(3)](#data),\n[**kind**(3)](#kind)",
  "stderr": "## error_unit\n\n### **Name**\n\n**error_unit** - \\[IO:FILE\\] Write diagnostic messages to standard error stream\n\n### **Synopsis**\n```fortran\n    use iso_fortran_env, only: error_unit\n    write(error_unit, fmt) message\n```\n```fortran\n     use iso_fortran_env, only: error_unit, output_unit, input_unit\n\n     ! error_unit is a default integer constant\n     integer, parameter :: error_unit = <processor-defined>\n\n     write(unit=error_unit, fmt=format_spec) output_list\n```\n\n### **Characteristics**\n\n - **error_unit** is a named constant from ISO_FORTRAN_ENV module.\n - It identifies the unit number preconnected to standard error.\n - Typically unit 0 on Unix-like systems, but processor-dependent.\n - Messages written to error_unit appear on stderr, separate from stdout.\n - Useful for error messages that should not mix with program output.\n\n### **Description**\n\n **error_unit** from ISO_FORTRAN_ENV provides a portable way to write to the standard error stream. This is the Fortran equivalent of fprintf(stderr, ...) in C. Error messages written to error_unit:\n - Appear on the terminal even if stdout is redirected\n - Can be redirected separately from normal output\n - Follow Unix conventions for error reporting\n - Are unbuffered on many systems for immediate display\n\n### **Options**\n\n- **error_unit**\n  : The preconnected unit for standard error output. Use with WRITE statement.\n\n- **output_unit**\n  : Related constant for standard output (stdout), typically unit 6.\n\n- **input_unit**\n  : Related constant for standard input (stdin), typically unit 5.\n\n### **Result**\n\n  Formatted output is written to the standard error stream, which is typically displayed on the terminal but can be redirected separately from standard output.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_error_unit\nuse iso_fortran_env, only: error_unit, output_unit\nimplicit none\n  integer :: ierr\n  real :: value\n  character(len=100) :: filename\n\n  filename = 'nonexistent_file.dat'\n\n  ! Normal output goes to stdout\n  write(output_unit, '(A)') 'Program starting...'\n\n  ! Error messages go to stderr\n  open(unit=10, file=filename, status='old', iostat=ierr)\n  if (ierr /= 0) then\n    write(error_unit, '(A,A)') 'ERROR: Cannot open file: ', trim(filename)\n    write(error_unit, '(A,I0)') 'IOSTAT code: ', ierr\n  end if\n\n  ! Demonstrate mixing stdout and stderr\n  write(output_unit, '(A)') 'Continuing with calculations...'\n\n  value = -1.0\n  if (value < 0.0) then\n    write(error_unit, '(A,F8.3)') 'WARNING: Negative value encountered: ', value\n  end if\n\n  write(output_unit, '(A)') 'Program complete.'\n\n  ! Usage with format specifications\n  write(error_unit, '(A,I0,A)') 'Debug: processed ', 100, ' items'\n\nend program demo_error_unit\n```\nResults (stderr output shown with > prefix):\n```text\nProgram starting...\n> ERROR: Cannot open file: nonexistent_file.dat\n> IOSTAT code: 2\nContinuing with calculations...\n> WARNING: Negative value encountered:   -1.000\nProgram complete.\n> Debug: processed 100 items\n```\n\n### **Standard**\n\nFortran 2003 (ISO_FORTRAN_ENV module)\n\n**Compatibility Notes:**\n- gfortran 4.0+, Intel Fortran 9.0+, NAG 5.0+\n- Use ISO_FORTRAN_ENV for portable unit numbers\n- ERROR_UNIT typically maps to stderr (unit 0)\n\n### **See Also**\n\n[**output_unit**(3)](#output_unit),\n[**input_unit**(3)](#input_unit),\n[**write**(3)](#write),\n[**iso_fortran_env**(3)](#iso_fortran_env)",
  "stream_read": "## stream_read\n\n### **Name**\n\n**read** - \\[IO:STREAM\\] Read unformatted data from a stream access file\n\n### **Synopsis**\n```fortran\n    read(unit) var1, var2, ...\n```\n```fortran\n     read(unit=unit_num, iostat=ios, iomsg=msg, pos=position) var_list\n\n      integer, intent(in)            :: unit_num   ! Connected stream unit\n      integer, intent(out), optional :: ios        ! I/O status\n      character(len=*), intent(inout), optional :: msg  ! Error message\n      integer, intent(in), optional  :: position   ! Byte position (1-based)\n```\n\n### **Characteristics**\n\n - **unit** is an integer unit number connected for stream access.\n - **var_list** contains variables to receive the binary data.\n - Stream access provides byte-addressable I/O without record structure.\n - Data is read in processor-dependent binary representation.\n - The file must be opened with ACCESS='STREAM' and FORM='UNFORMATTED'.\n\n### **Description**\n\n **read** from a stream access file transfers binary data directly into program variables without format conversion or record delimiters. This provides efficient I/O for large datasets and compatibility with binary files created by C programs or other languages. The POS specifier allows random access to any byte position in the file.\n\n### **Options**\n\n- **unit**\n  : Unit number of a file opened with ACCESS='STREAM', FORM='UNFORMATTED'.\n\n- **pos=** (optional)\n  : Byte position to start reading (1-based). If omitted, reads from the current position.\n\n- **iostat=** (optional)\n  : Integer variable set to zero on success, positive on error, negative on end-of-file.\n\n- **iomsg=** (optional)\n  : Character variable that receives an error message if an error occurs.\n\n### **Result**\n\n  Variables receive binary data read directly from the file. The number of bytes read equals the storage size of the variables in the input list.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_stream_read\nimplicit none\n  integer :: unit_num, ios, i\n  real(8) :: data_write(10), data_read(10)\n  integer :: header_write, header_read\n  character(len=100) :: errmsg\n\n  ! Initialize test data\n  header_write = 12345\n  data_write = [(real(i, 8) * 1.5d0, i = 1, 10)]\n\n  ! Write binary data\n  open(newunit=unit_num, file='stream_test.bin', access='stream', &\n       form='unformatted', status='replace', iostat=ios)\n  if (ios /= 0) error stop 'Cannot create file'\n\n  write(unit_num) header_write\n  write(unit_num) data_write\n  close(unit_num)\n\n  ! Read binary data back\n  open(newunit=unit_num, file='stream_test.bin', access='stream', &\n       form='unformatted', status='old', iostat=ios, iomsg=errmsg)\n  if (ios /= 0) then\n    print *, 'Error: ', trim(errmsg)\n    error stop\n  end if\n\n  read(unit_num, iostat=ios) header_read\n  read(unit_num, iostat=ios) data_read\n  close(unit_num, status='delete')\n\n  ! Verify data\n  print '(A,I0)', 'Header: ', header_read\n  print '(A)', 'Data array:'\n  print '(5F10.2)', data_read\n\n  if (header_read == header_write .and. all(data_read == data_write)) then\n    print '(A)', 'SUCCESS: Data integrity verified'\n  else\n    print '(A)', 'ERROR: Data mismatch'\n  end if\n\nend program demo_stream_read\n```\nResults:\n```text\nHeader: 12345\nData array:\n      1.50      3.00      4.50      6.00      7.50\n      9.00     10.50     12.00     13.50     15.00\nSUCCESS: Data integrity verified\n```\n\n### **Standard**\n\nFortran 2003\n\n**Compatibility Notes:**\n- gfortran 4.0+, Intel Fortran 9.1+, NAG 5.0+\n- File must be opened with ACCESS='STREAM'\n- Use POS= for positioning\n\n### **See Also**\n\n[**write_stream**(3)](#write_stream),\n[**open**(3)](#open),\n[**inquire**(3)](#inquire),\n[**stream_open**(3)](#stream_open)",
  "allocmold": "## allocate_mold\n\n### **Name**\n\n**allocate_mold** - \\[ARRAY:ALLOCATION\\] Allocate with shape and type from a mold expression\n\n### **Synopsis**\n```fortran\n    allocate(alloc_var, mold=source_expr)\n```\n```fortran\n     allocate(alloc_var, mold=source_expr, stat=stat_var, errmsg=errmsg_var)\n\n      type(TYPE(kind=**)), allocatable :: alloc_var(..)\n      type(TYPE(kind=**))              :: source_expr(..)\n      integer                          :: stat_var\n      character(len=*)                 :: errmsg_var\n```\n\n### **Characteristics**\n\n - **alloc_var** is an allocatable variable of any type and rank.\n - **source_expr** provides the type and shape for allocation but not values.\n - **stat_var** is an optional integer variable that receives the allocation status.\n - **errmsg_var** is an optional character variable that receives an error message.\n - The allocated variable has the same dynamic type and shape as the mold.\n - Unlike SOURCE=, the values from mold are NOT copied to the allocated variable.\n - The allocated variable is left undefined (or processor-dependent for pointers).\n\n### **Description**\n\n **allocate** with the **mold=** specifier dynamically allocates storage for\n an allocatable variable or pointer, giving it the same dynamic type and shape\n as the mold expression without copying the mold's values. This is particularly\n useful for allocating polymorphic variables to match another object's type,\n or for creating arrays with the same shape as an existing array when you\n intend to fill the values independently.\n\n### **Options**\n\n- **alloc_var**\n  : The allocatable variable or pointer to be allocated. Must have the\n  ALLOCATABLE or POINTER attribute. Must not already be allocated.\n\n- **mold**\n  : An expression that determines the type and shape of the allocation.\n  For arrays, the allocated object gets the same shape. For polymorphic\n  types, the allocated object gets the same dynamic type.\n\n- **stat**\n  : Optional. Integer variable set to zero on success, positive on error.\n  If absent, allocation failure causes program termination.\n\n- **errmsg**\n  : Optional. Character variable that receives a descriptive error message\n  if allocation fails. Unchanged if allocation succeeds.\n\n### **Result**\n\n  The allocated variable has the same dynamic type and shape as the mold\n  expression. The values are undefined and must be assigned before use.\n  If stat is present and allocation succeeds, it is set to zero.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_allocate_mold\n  use, intrinsic :: iso_fortran_env, only: dp => real64\n  implicit none\n\n  real(dp) :: template(3, 4)\n  real(dp), allocatable :: matrix(:,:)\n  real(dp), allocatable :: vector(:)\n  integer :: ierr\n  character(len=100) :: errmsg\n\n  ! Allocate matrix with same shape as template\n  allocate(matrix, mold=template, stat=ierr, errmsg=errmsg)\n  if (ierr /= 0) error stop errmsg\n\n  print *, 'Matrix shape:', shape(matrix)  ! [3, 4]\n\n  ! Allocate vector with shape from array section\n  allocate(vector, mold=template(:,1))\n  print *, 'Vector size:', size(vector)    ! 3\n\n  ! Fill with values (mold does not copy values)\n  matrix = 1.0_dp\n  vector = 2.0_dp\n\n  print *, 'Matrix(1,1):', matrix(1,1)\n  print *, 'Vector(1):', vector(1)\n\n  deallocate(matrix, vector)\n\nend program demo_allocate_mold\n```\nResults:\n```text\n Matrix shape:           3           4\n Vector size:           3\n Matrix(1,1):   1.0000000000000000\n Vector(1):   2.0000000000000000\n```\n\n### **Standard**\n\nFortran 2003\n\n**Compatibility Notes:**\n- gfortran 4.6+, Intel Fortran 12.0+, NAG 5.3+\n- MOLD= creates same type/shape but uninitialized\n- Useful for allocating polymorphic variables\n\n### **See Also**\n\n[**allocate**](#allocate),\n[**allocate_source**](#allocate_source),\n[**move_alloc**](#move_alloc),\n[**deallocate**](#deallocate)",
  "mpi_allreduce": "## MPI_Allreduce\n\n### **Name**\n\n**MPI_Allreduce** - \\[PARALLEL:MPI\\] Combines values from all processes and distributes the result back to all processes\n\n### **Synopsis**\n\n```fortran\n    call MPI_Allreduce(sendbuf, recvbuf, count, datatype, op, comm, ierr)\n```\n\n```fortran\n    USE mpi_f08\n    MPI_Allreduce(sendbuf, recvbuf, count, datatype, op, comm, ierror)\n\n        TYPE(*), DIMENSION(..), INTENT(IN)  :: sendbuf\n        TYPE(*), DIMENSION(..)              :: recvbuf\n        INTEGER, INTENT(IN)                 :: count\n        TYPE(MPI_Datatype), INTENT(IN)      :: datatype\n        TYPE(MPI_Op), INTENT(IN)            :: op\n        TYPE(MPI_Comm), INTENT(IN)          :: comm\n        INTEGER, OPTIONAL, INTENT(OUT)      :: ierror\n```\n\n### **Characteristics**\n\n- **sendbuf** is a buffer of any type with `count` elements to be reduced\n- **recvbuf** is a buffer of the same type as `sendbuf` to receive the result\n- **count** is a non-negative integer specifying the number of elements\n- **datatype** must match the type of data in `sendbuf` and `recvbuf`\n- **op** must be a valid reduction operation compatible with `datatype`\n- **comm** is a valid MPI communicator (intracommunicator or intercommunicator)\n- **ierr** returns the error status (0 for success)\n- All processes in the communicator must call this routine\n- The result is distributed to all processes (unlike MPI_Reduce)\n\n### **Description**\n\n**MPI_Allreduce** performs a global reduction operation (sum, max, min, etc.) on data from all processes in a communicator and distributes the result to all processes. This is equivalent to an MPI_Reduce followed by an MPI_Bcast, but is typically more efficient. All processes contribute data and all processes receive the final result.\n\n### **Options**\n\n- **sendbuf**\n  : Starting address of the send buffer containing `count` elements of type `datatype`. Use MPI_IN_PLACE for in-place operations on intracommunicators.\n\n- **recvbuf**\n  : Starting address of the receive buffer where the reduction result will be stored. Must be distinct from `sendbuf` unless using MPI_IN_PLACE.\n\n- **count**\n  : Number of elements in `sendbuf` and `recvbuf`. Must be non-negative and identical on all processes.\n\n- **datatype**\n  : MPI datatype of elements. Common Fortran types:\n  - MPI_INTEGER, MPI_REAL, MPI_DOUBLE_PRECISION\n  - MPI_COMPLEX, MPI_DOUBLE_COMPLEX\n  - MPI_LOGICAL, MPI_CHARACTER\n\n- **op**\n  : Reduction operation to perform. Predefined operations:\n  - Arithmetic: MPI_SUM, MPI_PROD\n  - Comparison: MPI_MAX, MPI_MIN\n  - Logical: MPI_LAND, MPI_LOR, MPI_LXOR\n  - Bitwise: MPI_BAND, MPI_BOR, MPI_BXOR\n  - Location: MPI_MAXLOC, MPI_MINLOC\n\n- **comm**\n  : MPI communicator defining the group of processes participating. Typically MPI_COMM_WORLD for all processes.\n\n- **ierr**\n  : Integer error code. Returns MPI_SUCCESS (0) on successful completion.\n\n\n\n### **Result**\n\n  On all processes, **recvbuf** contains the combined result of applying\n  the reduction operation to the corresponding elements from all processes.\n  Unlike MPI_Reduce, every process receives the same result. The operation\n  is applied element-wise for arrays (when count > 1). This is equivalent\n  to an MPI_Reduce followed by an MPI_Bcast but may be implemented more\n  efficiently.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_mpi_allreduce\n  use mpi\n  implicit none\n  integer :: ierr, rank, nprocs\n  real(8) :: local_sum, global_sum\n  real(8) :: local_max, global_max\n  real(8) :: local_array(3), global_array(3)\n\n  ! Initialize MPI\n  call MPI_Init(ierr)\n  call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierr)\n  call MPI_Comm_size(MPI_COMM_WORLD, nprocs, ierr)\n\n  ! Example 1: Sum of scalar values across all processes\n  local_sum = real(rank + 1, 8)  ! Each process has value rank+1\n  call MPI_Allreduce(local_sum, global_sum, 1, MPI_DOUBLE_PRECISION, &\n                     MPI_SUM, MPI_COMM_WORLD, ierr)\n  if (rank == 0) then\n    print '(A,F8.2)', 'Global sum: ', global_sum\n  end if\n\n  ! Example 2: Maximum value across all processes\n  local_max = real(rank * 10, 8)\n  call MPI_Allreduce(local_max, global_max, 1, MPI_DOUBLE_PRECISION, &\n                     MPI_MAX, MPI_COMM_WORLD, ierr)\n  if (rank == 0) then\n    print '(A,F8.2)', 'Global max: ', global_max\n  end if\n\n  ! Example 3: Element-wise reduction of arrays\n  local_array = [real(rank, 8), real(rank*2, 8), real(rank*3, 8)]\n  call MPI_Allreduce(local_array, global_array, 3, MPI_DOUBLE_PRECISION, &\n                     MPI_SUM, MPI_COMM_WORLD, ierr)\n  if (rank == 0) then\n    print '(A,3F8.2)', 'Global array sum: ', global_array\n  end if\n\n  ! Example 4: In-place reduction (result overwrites sendbuf)\n  local_sum = real(rank + 1, 8)\n  call MPI_Allreduce(MPI_IN_PLACE, local_sum, 1, MPI_DOUBLE_PRECISION, &\n                     MPI_SUM, MPI_COMM_WORLD, ierr)\n  if (rank == 0) then\n    print '(A,F8.2)', 'In-place sum: ', local_sum\n  end if\n\n  call MPI_Finalize(ierr)\nend program demo_mpi_allreduce\n```\n\nResults (with 4 processes):\n\n```text\n    Global sum:    10.00\n    Global max:    30.00\n    Global array sum:     6.00   12.00   18.00\n    In-place sum:    10.00\n```\n\n### **Standard**\n\nMPI-1.0 (introduced in the original MPI standard, 1994)\n\n### **See Also**\n\n[**MPI_Reduce**(3)](#mpi_reduce),\n[**MPI_Bcast**(3)](#mpi_bcast),\n[**MPI_Scatter**(3)](#mpi_scatter),\n[**MPI_Gather**(3)](#mpi_gather),\n[**MPI_Allgather**(3)](#mpi_allgather),\n[**MPI_Reduce_scatter**(3)](#mpi_reduce_scatter),\n[**MPI_Iallreduce**(3)](#mpi_iallreduce)\n\n### **Resources**\n\n- [Open MPI 5.0.x MPI_Allreduce Documentation](https://docs.open-mpi.org/en/v5.0.x/man-openmpi/man3/MPI_Allreduce.3.html)\n- [MPI Tutorial: MPI Reduce and Allreduce](https://mpitutorial.com/tutorials/mpi-reduce-and-allreduce/)\n- [MPI Forum Predefined Reduce Operations](https://www.mpi-forum.org/docs/mpi-1.1/mpi-11-html/node78.html)",
  "module_private": "## module_private\n\n### **Name**\n\n**module_private** - \\[STRUCTURE:MODULE\\] Module with private default and explicit public exports\n\n### **Synopsis**\n```fortran\n    module module_name\n      implicit none\n      private\n      public :: public_entity\n      ! declarations\n    contains\n      ! procedures\n    end module module_name\n```\n```fortran\n     module module_name\n\n      implicit none\n      private                    ! Default visibility is private\n      public :: exported_var     ! Explicitly export public entities\n      public :: exported_type\n      public :: exported_proc\n\n      integer :: internal_var    ! Private by default\n      integer :: exported_var    ! Public via explicit declaration\n\n     contains\n\n      subroutine exported_proc() ! Public via explicit declaration\n      end subroutine\n\n      subroutine internal_proc() ! Private by default\n      end subroutine\n\n     end module module_name\n```\n\n### **Characteristics**\n\n - **module_name** is a valid Fortran identifier for the module.\n - **private** statement sets default visibility to private for all entities.\n - **public** statement explicitly exports selected entities.\n - All module entities are private unless explicitly declared public.\n - Provides encapsulation by hiding implementation details.\n\n### **Description**\n\n **module_private** creates a module with private default visibility where\n all module entities (variables, types, procedures) are private unless\n explicitly exported via the `public` statement. This pattern follows the\n principle of information hiding and encapsulation, exposing only the\n intended public interface while keeping implementation details hidden\n from module users.\n\n### **Options**\n\n- **module_name**\n  : The identifier for the module. Must be a valid Fortran name starting\n  with a letter and containing only letters, digits, and underscores.\n\n- **public_entity**\n  : One or more entities to export from the module. Can be variables,\n  parameters, derived types, or procedure names. Multiple entities can\n  be listed comma-separated or in multiple public statements.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_module_private\n  use vector_math, only: vector_t, vector_add, vector_magnitude\n  implicit none\n\n  type(vector_t) :: v1, v2, v3\n\n  ! Initialize vectors using public constructor\n  v1 = vector_t(1.0, 2.0, 3.0)\n  v2 = vector_t(4.0, 5.0, 6.0)\n\n  ! Use public procedures\n  v3 = vector_add(v1, v2)\n  print '(A,3F8.3)', 'Sum vector: ', v3%x, v3%y, v3%z\n  print '(A,F8.3)', 'Magnitude:  ', vector_magnitude(v3)\n\nend program demo_module_private\n\nmodule vector_math\n  implicit none\n  private\n  public :: vector_t, vector_add, vector_magnitude\n\n  type :: vector_t\n    real :: x = 0.0\n    real :: y = 0.0\n    real :: z = 0.0\n  end type vector_t\n\n  ! Internal constant - not exported\n  real, parameter :: tolerance = 1.0e-10\n\ncontains\n\n  pure function vector_add(a, b) result(c)\n    type(vector_t), intent(in) :: a, b\n    type(vector_t) :: c\n    c%x = a%x + b%x\n    c%y = a%y + b%y\n    c%z = a%z + b%z\n  end function vector_add\n\n  pure function vector_magnitude(v) result(mag)\n    type(vector_t), intent(in) :: v\n    real :: mag\n    mag = sqrt(v%x**2 + v%y**2 + v%z**2)\n  end function vector_magnitude\n\n  ! Internal helper - not exported\n  pure function is_zero_vector(v) result(is_zero)\n    type(vector_t), intent(in) :: v\n    logical :: is_zero\n    is_zero = vector_magnitude(v) < tolerance\n  end function is_zero_vector\n\nend module vector_math\n```\nResults:\n```text\n    Sum vector:    5.000   7.000   9.000\n    Magnitude:    12.449\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**module**(3)](#module),\n[**use**(3)](#use),\n[**private**(3)](#private),\n[**public**(3)](#public),\n[**protected**(3)](#protected)",
  "streamwrite": "## stream_write\n\n### **Name**\n\n**write** - \\[IO:STREAM\\] Write unformatted data to a stream access file\n\n### **Synopsis**\n```fortran\n    write(unit) var1, var2, ...\n```\n```fortran\n     write(unit=unit_num, iostat=ios, iomsg=msg, pos=position) var_list\n\n      integer, intent(in)            :: unit_num   ! Connected stream unit\n      integer, intent(out), optional :: ios        ! I/O status\n      character(len=*), intent(inout), optional :: msg  ! Error message\n      integer, intent(in), optional  :: position   ! Byte position (1-based)\n```\n\n### **Characteristics**\n\n - **unit** is an integer unit number connected for stream access.\n - **var_list** contains variables or expressions to write as binary data.\n - Stream access provides byte-addressable I/O without record structure.\n - Data is written in processor-dependent binary representation.\n - The file must be opened with ACCESS='STREAM' and FORM='UNFORMATTED'.\n\n### **Description**\n\n **write** to a stream access file transfers binary data directly from program variables without format conversion or record delimiters. This provides efficient I/O and produces files compatible with C programs or other languages that use raw binary I/O. The POS specifier allows random access to any byte position.\n\n### **Options**\n\n- **unit**\n  : Unit number of a file opened with ACCESS='STREAM', FORM='UNFORMATTED'.\n\n- **pos=** (optional)\n  : Byte position to start writing (1-based). If omitted, writes at the current position.\n\n- **iostat=** (optional)\n  : Integer variable set to zero on success, positive on error.\n\n- **iomsg=** (optional)\n  : Character variable that receives an error message if an error occurs.\n\n### **Result**\n\n  Binary data is written to the file at the specified or current position. The number of bytes written equals the storage size of the items in the output list.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_stream_write\nimplicit none\n  integer :: unit_num, ios, i\n  real(4) :: matrix(3,3)\n  integer(4) :: dimensions(2)\n  character(len=100) :: errmsg\n\n  ! Initialize data\n  dimensions = [3, 3]\n  matrix = reshape([(real(i), i = 1, 9)], [3, 3])\n\n  ! Write structured binary file\n  open(newunit=unit_num, file='matrix.bin', access='stream', &\n       form='unformatted', status='replace', iostat=ios, iomsg=errmsg)\n  if (ios /= 0) then\n    print *, 'Error creating file: ', trim(errmsg)\n    error stop\n  end if\n\n  ! Write header with dimensions\n  write(unit_num, iostat=ios) dimensions\n\n  ! Write matrix data\n  write(unit_num, iostat=ios) matrix\n\n  close(unit_num)\n  print '(A)', 'Binary file written successfully'\n\n  ! Verify by reading back\n  block\n    real(4) :: read_matrix(3,3)\n    integer(4) :: read_dims(2)\n\n    open(newunit=unit_num, file='matrix.bin', access='stream', &\n         form='unformatted', status='old')\n    read(unit_num) read_dims\n    read(unit_num) read_matrix\n    close(unit_num, status='delete')\n\n    print '(A,2I3)', 'Dimensions: ', read_dims\n    print '(A)', 'Matrix:'\n    do i = 1, 3\n      print '(3F8.2)', read_matrix(i,:)\n    end do\n  end block\n\nend program demo_stream_write\n```\nResults:\n```text\nBinary file written successfully\nDimensions:   3  3\nMatrix:\n    1.00    4.00    7.00\n    2.00    5.00    8.00\n    3.00    6.00    9.00\n```\n\n### **Standard**\n\nFortran 2003\n\n**Compatibility Notes:**\n- gfortran 4.0+, Intel Fortran 9.1+, NAG 5.0+\n- File must be opened with ACCESS='STREAM'\n- Use POS= for positioning\n\n### **See Also**\n\n[**read_stream**(3)](#read_stream),\n[**open**(3)](#open),\n[**inquire**(3)](#inquire),\n[**stream_open**(3)](#stream_open)",
  "ptrassign": "## pointer_assignment\n\n### **Name**\n\n**pointer_assignment** - \\[TYPE:POINTER\\] Associate a pointer with a target\n\n### **Synopsis**\n```fortran\n    pointer => target\n```\n```fortran\n     ! Pointer assignment syntax\n\n      type, pointer  :: ptr\n      type, target   :: tgt\n      ptr => tgt\n```\n\n### **Characteristics**\n\n - **pointer** must have the POINTER attribute.\n - **target** must have the TARGET attribute or be another pointer.\n - Both must have the same type, kind, and rank.\n - After assignment, pointer references the same data as target.\n - For arrays, pointer inherits the bounds of the target.\n\n### **Description**\n\n **=>** is the pointer assignment operator. It associates a pointer with a\n target so that the pointer references the same data as the target. Unlike\n ordinary assignment (=) which copies values, pointer assignment creates an\n alias relationship. Changes made through the pointer affect the target and\n vice versa.\n\n### **Options**\n\n- **pointer**\n  : A variable with the POINTER attribute. It will be associated with the\n  target after the assignment. Must be of compatible type, kind, and rank.\n\n- **target**\n  : A variable with the TARGET attribute, an expression returning a pointer,\n  or another pointer. If it is a pointer, the result pointer becomes associated\n  with whatever the target pointer is associated with.\n\n### **Result**\n\n  The pointer becomes associated with the target. The pointer's association\n  status becomes \"associated\". For arrays, the pointer inherits the bounds\n  of the target. For scalars, the pointer references the same memory location.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_pointer_assignment\nimplicit none\n  real, target  :: x = 3.14\n  real, pointer :: p\n  real, target  :: arr(5) = [1.0, 2.0, 3.0, 4.0, 5.0]\n  real, pointer :: parr(:)\n\n  ! Associate pointer with scalar target\n  p => x\n  print '(A,F6.2)', 'p points to x: ', p\n\n  ! Modify through pointer\n  p = 2.71\n  print '(A,F6.2)', 'x after modification: ', x\n\n  ! Associate pointer with array target\n  parr => arr\n  print '(A,5F6.2)', 'parr points to arr: ', parr\n\n  ! Point to array section\n  parr => arr(2:4)\n  print '(A,3F6.2)', 'parr points to arr(2:4): ', parr\n\n  ! Check association status\n  print '(A,L1)', 'p is associated: ', associated(p)\n  print '(A,L1)', 'p is associated with x: ', associated(p, x)\n\nend program demo_pointer_assignment\n```\nResults:\n```text\np points to x:   3.14\nx after modification:   2.71\nparr points to arr:   1.00  2.00  3.00  4.00  5.00\nparr points to arr(2:4):   2.00  3.00  4.00\np is associated: T\np is associated with x: T\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**associated**(3)](#associated),\n[**null**(3)](#null),\n[**nullify**(3)](#nullify),\n[**pointer**(3)](#pointer),\n[**target**(3)](#target)",
  "directive": "## compiler_directive\n\n### **Name**\n\n**compiler_directive** - \\[COMPILER:DIRECTIVE\\] Insert a compiler-specific optimization directive\n\n### **Synopsis**\n```fortran\n    !DIR$ DIRECTIVE\n```\n```fortran\n     ! Compiler-specific directive syntax\n\n      !DIR$ IVDEP\n      !DIR$ VECTOR\n      !DIR$ SIMD\n      !DIR$ NOINLINE\n```\n\n### **Characteristics**\n\n - Directives begin with **!DIR$** (Intel/Cray) or similar vendor-specific prefix.\n - They appear as comments to non-supporting compilers.\n - Directives affect optimization, vectorization, and code generation.\n - Placement is significant: directives typically apply to the immediately following statement or loop.\n\n### **Description**\n\n **compiler_directive** inserts a compiler-specific directive that controls\n optimization and code generation behavior. Common uses include enabling\n vectorization, specifying loop independence, and controlling inlining.\n Directives are treated as comments by compilers that do not recognize them,\n making code portable.\n\n### **Options**\n\n- **IVDEP**\n  : Ignore Vector DEPendencies. Tells the compiler that apparent loop-carried\n  dependencies can be safely ignored for vectorization purposes.\n\n- **VECTOR**\n  : Requests vectorization of the following loop.\n\n- **NOVECTOR**\n  : Disables vectorization of the following loop.\n\n- **SIMD**\n  : Requests SIMD (Single Instruction Multiple Data) optimization.\n\n- **NOINLINE**\n  : Prevents inlining of the following function or subroutine call.\n\n- **INLINE**\n  : Requests inlining of the following function or subroutine call.\n\n### **Result**\n\n  The compiler modifies its optimization behavior for the following code\n  according to the specified directive. If the directive is not supported\n  or not applicable, it is silently ignored.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_directive\nimplicit none\n  integer, parameter :: n = 1000\n  real :: a(n), b(n), c(n)\n  integer :: i\n\n  ! Initialize arrays\n  a = 1.0\n  b = 2.0\n\n  ! Tell compiler to vectorize and ignore potential dependencies\n  !DIR$ IVDEP\n  !DIR$ VECTOR\n  do i = 1, n\n    c(i) = a(i) + b(i)\n  end do\n\n  print '(A,F10.2)', 'Sum of c: ', sum(c)\n\nend program demo_directive\n```\nResults:\n```text\nSum of c:    3000.00\n```\n\n### **Standard**\n\nCompiler extension (Intel, Cray, GCC, etc.)\n\n### **See Also**\n\n[**!$omp**(3)](#omp),\n[**!GCC$**(3)](#gcc_attributes)",
  "=>": "## pointer_assignment\n\n### **Name**\n\n**pointer_assignment** - \\[TYPE:POINTER\\] Associate a pointer with a target\n\n### **Synopsis**\n```fortran\n    pointer => target\n```\n```fortran\n     ! Pointer assignment syntax\n\n      type, pointer  :: ptr\n      type, target   :: tgt\n      ptr => tgt\n```\n\n### **Characteristics**\n\n - **pointer** must have the POINTER attribute.\n - **target** must have the TARGET attribute or be another pointer.\n - Both must have the same type, kind, and rank.\n - After assignment, pointer references the same data as target.\n - For arrays, pointer inherits the bounds of the target.\n\n### **Description**\n\n **=>** is the pointer assignment operator. It associates a pointer with a\n target so that the pointer references the same data as the target. Unlike\n ordinary assignment (=) which copies values, pointer assignment creates an\n alias relationship. Changes made through the pointer affect the target and\n vice versa.\n\n### **Options**\n\n- **pointer**\n  : A variable with the POINTER attribute. It will be associated with the\n  target after the assignment. Must be of compatible type, kind, and rank.\n\n- **target**\n  : A variable with the TARGET attribute, an expression returning a pointer,\n  or another pointer. If it is a pointer, the result pointer becomes associated\n  with whatever the target pointer is associated with.\n\n### **Result**\n\n  The pointer becomes associated with the target. The pointer's association\n  status becomes \"associated\". For arrays, the pointer inherits the bounds\n  of the target. For scalars, the pointer references the same memory location.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_pointer_assignment\nimplicit none\n  real, target  :: x = 3.14\n  real, pointer :: p\n  real, target  :: arr(5) = [1.0, 2.0, 3.0, 4.0, 5.0]\n  real, pointer :: parr(:)\n\n  ! Associate pointer with scalar target\n  p => x\n  print '(A,F6.2)', 'p points to x: ', p\n\n  ! Modify through pointer\n  p = 2.71\n  print '(A,F6.2)', 'x after modification: ', x\n\n  ! Associate pointer with array target\n  parr => arr\n  print '(A,5F6.2)', 'parr points to arr: ', parr\n\n  ! Point to array section\n  parr => arr(2:4)\n  print '(A,3F6.2)', 'parr points to arr(2:4): ', parr\n\n  ! Check association status\n  print '(A,L1)', 'p is associated: ', associated(p)\n  print '(A,L1)', 'p is associated with x: ', associated(p, x)\n\nend program demo_pointer_assignment\n```\nResults:\n```text\np points to x:   3.14\nx after modification:   2.71\nparr points to arr:   1.00  2.00  3.00  4.00  5.00\nparr points to arr(2:4):   2.00  3.00  4.00\np is associated: T\np is associated with x: T\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**associated**(3)](#associated),\n[**null**(3)](#null),\n[**nullify**(3)](#nullify),\n[**pointer**(3)](#pointer),\n[**target**(3)](#target)",
  "c_f_pointer": "## c_f_pointer\n\n### **Name**\n\n**c_f_pointer** - \\[INTEROP:C_BINDING\\] Convert a C pointer to a Fortran pointer\n\n### **Synopsis**\n```fortran\n    call c_f_pointer(cptr, fptr)\n    call c_f_pointer(cptr, fptr, shape)\n```\n```fortran\n     subroutine c_f_pointer(cptr, fptr, shape)\n\n      type(c_ptr), intent(in)           :: cptr\n      type(*), pointer, intent(out)     :: fptr\n      integer, intent(in), optional     :: shape(:)\n```\n\n### **Characteristics**\n\n - **cptr** is a scalar of type C_PTR from ISO_C_BINDING.\n - **fptr** is a pointer of any interoperable type (scalar or array).\n - **shape** is required when fptr is an array pointer; specifies array dimensions.\n - The subroutine associates fptr with the target of cptr.\n - If cptr is C_NULL_PTR, fptr becomes disassociated.\n - The target must be allocated and valid memory.\n\n### **Description**\n\n **c_f_pointer** associates a Fortran pointer with the target of a C pointer.\n This is essential for accessing C-allocated memory or C arrays from Fortran.\n The target of cptr must have the same type as fptr. For array pointers, the\n shape argument specifies the array dimensions, allowing Fortran to treat\n C memory as a properly-bounded array.\n\n### **Options**\n\n- **cptr**\n  : A C pointer (type(c_ptr)) pointing to interoperable data. Obtained from\n  C functions, c_loc(), or c_f_procpointer. If C_NULL_PTR, fptr is nullified.\n\n- **fptr**\n  : A Fortran pointer that will be associated with cptr's target. Must have\n  the POINTER attribute and an interoperable type. Can be scalar or array.\n\n- **shape**\n  : Required for array pointers. An integer array specifying the dimensions.\n  For a rank-n array, shape has n elements: [dim1, dim2, ..., dimn].\n  Not present for scalar pointers.\n\n### **Result**\n\n  After the call, fptr points to the memory addressed by cptr. For arrays,\n  fptr has the bounds [1:shape(1), 1:shape(2), ...]. The association remains\n  valid as long as the underlying memory is valid.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_c_f_pointer\n  use iso_c_binding\n  implicit none\n\n  interface\n    ! C function: double* allocate_array(int n)\n    function allocate_array(n) result(ptr) bind(c, name='allocate_array')\n      import :: c_ptr, c_int\n      integer(c_int), intent(in), value :: n\n      type(c_ptr) :: ptr\n    end function allocate_array\n\n    ! C function: void free_array(double* ptr)\n    subroutine free_array(ptr) bind(c, name='free_array')\n      import :: c_ptr\n      type(c_ptr), intent(in), value :: ptr\n    end subroutine free_array\n  end interface\n\n  type(c_ptr) :: c_array_ptr\n  real(c_double), pointer :: f_array(:)\n  real(c_double), pointer :: f_scalar\n  real(c_double), target  :: local_val\n  integer(c_int) :: n\n  integer :: i\n\n  n = 5\n\n  ! Example 1: Get C pointer and convert to Fortran array pointer\n  c_array_ptr = allocate_array(n)\n  call c_f_pointer(c_array_ptr, f_array, [n])\n\n  ! Now use f_array as a normal Fortran array\n  f_array = [(real(i, c_double), i = 1, n)]\n  print '(A,5F8.2)', 'Array values: ', f_array\n\n  ! Example 2: Convert Fortran target to C pointer and back\n  local_val = 42.0_c_double\n  c_array_ptr = c_loc(local_val)\n  call c_f_pointer(c_array_ptr, f_scalar)\n  print '(A,F8.2)', 'Scalar value: ', f_scalar\n\n  ! Example 3: Handle null pointer\n  c_array_ptr = c_null_ptr\n  call c_f_pointer(c_array_ptr, f_scalar)\n  if (.not. associated(f_scalar)) then\n    print '(A)', 'Null pointer correctly handled'\n  end if\n\n  ! Clean up C-allocated memory\n  c_array_ptr = c_loc(f_array(1))\n  call free_array(c_array_ptr)\n\nend program demo_c_f_pointer\n```\n\nResults:\n```text\nArray values:     1.00    2.00    3.00    4.00    5.00\nScalar value:    42.00\nNull pointer correctly handled\n```\n\n### **Standard**\n\nFortran 2003 (ISO/IEC 1539-1:2004)\n\n**Compatibility Notes:**\n- gfortran 4.3+, Intel Fortran 10.0+, NAG 5.1+\n- Requires USE ISO_C_BINDING\n- For array targets, SHAPE argument is required\n\n### **See Also**\n\n[**c_loc**(3)](#c_loc),\n[**c_funloc**(3)](#c_funloc),\n[**c_f_procpointer**(3)](#c_f_procpointer),\n[**c_ptr**(3)](#c_ptr),\n[**iso_c_binding**(3)](#iso_c_binding)",
  "assumed3d": "## assumed3d\n\n### **Name**\n\n**assumed3d** - \\[ARRAY:DECLARATION\\] Declare a three-dimensional assumed-shape array argument\n\n### **Synopsis**\n```fortran\n    type, intent(in) :: array(:,:,:)\n```\n```fortran\n     subroutine proc(array)\n\n      type(TYPE(kind=**)), intent(in|out|inout) :: array(:,:,:)\n```\n\n### **Characteristics**\n\n - **array** is a rank-3 dummy argument with assumed shape, indicated by `(:,:,:)`.\n - The extents are determined from the actual argument at runtime.\n - The procedure must have an explicit interface.\n - Lower bounds default to 1 unless explicitly specified.\n - Array inquiry intrinsics (SIZE, SHAPE, LBOUND, UBOUND) work on assumed-shape arrays.\n - No array copying occurs; the descriptor is passed by reference.\n\n### **Description**\n\n **Assumed-shape** three-dimensional arrays allow procedures to accept\n rank-3 arrays of any extents without requiring explicit size parameters.\n The bounds information is passed automatically through the array descriptor.\n This is the modern and recommended approach for passing 3D arrays in Fortran,\n providing type safety and enabling bounds checking by the compiler.\n\n### **Options**\n\n- **type**\n  : Any intrinsic or derived type (integer, real, complex, logical, character,\n  or user-defined type).\n\n- **kind**\n  : Optional kind parameter for the type (e.g., real64 for double precision).\n\n- **intent**\n  : Data flow direction: in (read-only), out (write-only), or inout (read-write).\n\n- **array**\n  : The dummy argument name. The `(:,:,:)` syntax indicates assumed shape with rank 3.\n\n### **Result**\n\n  The dummy argument references the actual argument with full shape information\n  available. The procedure can use SIZE, SHAPE, LBOUND, and UBOUND to query\n  dimensions and iterate over elements.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_assumed3d\n  use, intrinsic :: iso_fortran_env, only: dp => real64\n  implicit none\n\n  real(dp), allocatable :: field(:,:,:)\n  real(dp) :: fixed_array(2, 3, 4)\n  real(dp) :: total\n\n  ! Allocate a 3D field\n  allocate(field(10, 20, 30))\n  field = 1.0_dp\n\n  fixed_array = 2.0_dp\n\n  ! Process with assumed-shape array\n  call sum_3d_array(field, total)\n  print *, 'Field sum:', total\n\n  call sum_3d_array(fixed_array, total)\n  print *, 'Fixed array sum:', total\n\n  call print_array_info(field)\n  call print_array_info(fixed_array)\n\n  deallocate(field)\n\ncontains\n\n  subroutine sum_3d_array(arr, total)\n    real(dp), intent(in) :: arr(:,:,:)  ! Assumed-shape 3D\n    real(dp), intent(out) :: total\n\n    total = sum(arr)\n  end subroutine sum_3d_array\n\n  subroutine print_array_info(arr)\n    real(dp), intent(in) :: arr(:,:,:)  ! Assumed-shape 3D\n\n    print *, 'Shape:', shape(arr)\n    print *, 'Size:', size(arr)\n    print *, 'Bounds dim 1:', lbound(arr, 1), ':', ubound(arr, 1)\n    print *, 'Bounds dim 2:', lbound(arr, 2), ':', ubound(arr, 2)\n    print *, 'Bounds dim 3:', lbound(arr, 3), ':', ubound(arr, 3)\n  end subroutine print_array_info\n\nend program demo_assumed3d\n```\nResults:\n```text\n Field sum:   6000.0000000000000\n Fixed array sum:   48.000000000000000\n Shape:          10          20          30\n Size:        6000\n Bounds dim 1:           1 :          10\n Bounds dim 2:           1 :          20\n Bounds dim 3:           1 :          30\n Shape:           2           3           4\n Size:          24\n Bounds dim 1:           1 :           2\n Bounds dim 2:           1 :           3\n Bounds dim 3:           1 :           4\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**assumed2d**](#assumed2d),\n[**assumed_rank**](#assumed_rank),\n[**size**](#size),\n[**shape**](#shape),\n[**contiguous**](#contiguous)",
  "sync all": "## sync_all\n\n### **Name**\n\n**sync_all** - \\[PARALLEL:COARRAY\\] Synchronize all images in the current team\n\n### **Synopsis**\n```fortran\n    sync all [stat=stat_variable] [errmsg=errmsg_variable]\n```\n```fortran\n     sync all [sync-stat-list]\n\n      integer, intent(out), optional :: stat_variable\n      character(*), intent(inout), optional :: errmsg_variable\n```\n\n### **Characteristics**\n\n - **stat_variable** is a scalar integer variable that receives the synchronization status.\n - **errmsg_variable** is a scalar default character variable that receives an error message if an error occurs.\n - This is an image control statement that affects execution ordering.\n - All images in the current team participate in the synchronization.\n\n### **Description**\n\n **sync all** provides a global synchronization barrier for all images in the\n current team. When an image executes SYNC ALL, it waits until all other\n images in the team have also reached a SYNC ALL statement. This ensures\n that all images have completed their preceding operations before any\n image proceeds past the barrier.\n\n The synchronization establishes a segment boundary. All operations that\n precede SYNC ALL on any image are ordered before all operations that\n follow SYNC ALL on any image in the team.\n\n### **Options**\n\n- **stat=stat_variable**\n  : Optional. If present, receives a status value upon completion.\n  A value of zero indicates successful synchronization. A nonzero value\n  indicates an error occurred, such as a stopped or failed image.\n  The constant STAT_STOPPED_IMAGE or STAT_FAILED_IMAGE from ISO_FORTRAN_ENV\n  may be returned.\n\n- **errmsg=errmsg_variable**\n  : Optional. If present and an error occurs, receives an explanatory\n  message describing the error condition. The variable is assigned only\n  if stat_variable is also present and receives a nonzero value.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_sync_all\n  use iso_fortran_env, only: int64\n  implicit none\n  integer :: me, num_images\n  real, allocatable :: local_data(:)[:]  ! Coarray\n  real :: global_sum\n  integer :: i, stat\n  character(len=100) :: errmsg\n\n  me = this_image()\n  num_images = num_images()\n\n  ! Allocate coarray on all images\n  allocate(local_data(100)[*])\n\n  ! Each image initializes its own data\n  local_data = real(me)\n\n  ! Synchronize to ensure all images have initialized their data\n  sync all\n\n  ! Now safe to access data from other images\n  if (me == 1) then\n    global_sum = 0.0\n    do i = 1, num_images\n      global_sum = global_sum + local_data(1)[i]\n    end do\n    print '(A,F10.2)', 'Sum of first elements from all images: ', global_sum\n  end if\n\n  ! Synchronize before cleanup\n  sync all\n\n  ! Example with error handling\n  sync all (stat=stat, errmsg=errmsg)\n  if (stat /= 0) then\n    print '(A,I0,A,A)', 'Image ', me, ' sync error: ', trim(errmsg)\n  end if\n\n  deallocate(local_data)\n\nend program demo_sync_all\n```\nResults (with 4 images):\n```text\n    Sum of first elements from all images:      10.00\n```\n\n### **Standard**\n\nFortran 2008\n\n**Compatibility Notes:**\n- gfortran 5.0+, Intel Fortran 12.0+, NAG 6.0+\n- Global barrier across all images\n- Use STAT= to detect stopped/failed images\n\n### **See Also**\n\n[**sync_images**(3)](#sync_images),\n[**sync_memory**(3)](#sync_memory),\n[**sync_team**(3)](#sync_team),\n[**this_image**(3)](#this_image),\n[**num_images**(3)](#num_images),\n[**co_sum**(3)](#co_sum),\n[**co_broadcast**(3)](#co_broadcast)",
  "arr3d": "## assumed3d\n\n### **Name**\n\n**assumed3d** - \\[ARRAY:DECLARATION\\] Declare a three-dimensional assumed-shape array argument\n\n### **Synopsis**\n```fortran\n    type, intent(in) :: array(:,:,:)\n```\n```fortran\n     subroutine proc(array)\n\n      type(TYPE(kind=**)), intent(in|out|inout) :: array(:,:,:)\n```\n\n### **Characteristics**\n\n - **array** is a rank-3 dummy argument with assumed shape, indicated by `(:,:,:)`.\n - The extents are determined from the actual argument at runtime.\n - The procedure must have an explicit interface.\n - Lower bounds default to 1 unless explicitly specified.\n - Array inquiry intrinsics (SIZE, SHAPE, LBOUND, UBOUND) work on assumed-shape arrays.\n - No array copying occurs; the descriptor is passed by reference.\n\n### **Description**\n\n **Assumed-shape** three-dimensional arrays allow procedures to accept\n rank-3 arrays of any extents without requiring explicit size parameters.\n The bounds information is passed automatically through the array descriptor.\n This is the modern and recommended approach for passing 3D arrays in Fortran,\n providing type safety and enabling bounds checking by the compiler.\n\n### **Options**\n\n- **type**\n  : Any intrinsic or derived type (integer, real, complex, logical, character,\n  or user-defined type).\n\n- **kind**\n  : Optional kind parameter for the type (e.g., real64 for double precision).\n\n- **intent**\n  : Data flow direction: in (read-only), out (write-only), or inout (read-write).\n\n- **array**\n  : The dummy argument name. The `(:,:,:)` syntax indicates assumed shape with rank 3.\n\n### **Result**\n\n  The dummy argument references the actual argument with full shape information\n  available. The procedure can use SIZE, SHAPE, LBOUND, and UBOUND to query\n  dimensions and iterate over elements.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_assumed3d\n  use, intrinsic :: iso_fortran_env, only: dp => real64\n  implicit none\n\n  real(dp), allocatable :: field(:,:,:)\n  real(dp) :: fixed_array(2, 3, 4)\n  real(dp) :: total\n\n  ! Allocate a 3D field\n  allocate(field(10, 20, 30))\n  field = 1.0_dp\n\n  fixed_array = 2.0_dp\n\n  ! Process with assumed-shape array\n  call sum_3d_array(field, total)\n  print *, 'Field sum:', total\n\n  call sum_3d_array(fixed_array, total)\n  print *, 'Fixed array sum:', total\n\n  call print_array_info(field)\n  call print_array_info(fixed_array)\n\n  deallocate(field)\n\ncontains\n\n  subroutine sum_3d_array(arr, total)\n    real(dp), intent(in) :: arr(:,:,:)  ! Assumed-shape 3D\n    real(dp), intent(out) :: total\n\n    total = sum(arr)\n  end subroutine sum_3d_array\n\n  subroutine print_array_info(arr)\n    real(dp), intent(in) :: arr(:,:,:)  ! Assumed-shape 3D\n\n    print *, 'Shape:', shape(arr)\n    print *, 'Size:', size(arr)\n    print *, 'Bounds dim 1:', lbound(arr, 1), ':', ubound(arr, 1)\n    print *, 'Bounds dim 2:', lbound(arr, 2), ':', ubound(arr, 2)\n    print *, 'Bounds dim 3:', lbound(arr, 3), ':', ubound(arr, 3)\n  end subroutine print_array_info\n\nend program demo_assumed3d\n```\nResults:\n```text\n Field sum:   6000.0000000000000\n Fixed array sum:   48.000000000000000\n Shape:          10          20          30\n Size:        6000\n Bounds dim 1:           1 :          10\n Bounds dim 2:           1 :          20\n Bounds dim 3:           1 :          30\n Shape:           2           3           4\n Size:          24\n Bounds dim 1:           1 :           2\n Bounds dim 2:           1 :           3\n Bounds dim 3:           1 :           4\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**assumed2d**](#assumed2d),\n[**assumed_rank**](#assumed_rank),\n[**size**](#size),\n[**shape**](#shape),\n[**contiguous**](#contiguous)",
  "syncall": "## sync_all\n\n### **Name**\n\n**sync_all** - \\[PARALLEL:COARRAY\\] Synchronize all images in the current team\n\n### **Synopsis**\n```fortran\n    sync all [stat=stat_variable] [errmsg=errmsg_variable]\n```\n```fortran\n     sync all [sync-stat-list]\n\n      integer, intent(out), optional :: stat_variable\n      character(*), intent(inout), optional :: errmsg_variable\n```\n\n### **Characteristics**\n\n - **stat_variable** is a scalar integer variable that receives the synchronization status.\n - **errmsg_variable** is a scalar default character variable that receives an error message if an error occurs.\n - This is an image control statement that affects execution ordering.\n - All images in the current team participate in the synchronization.\n\n### **Description**\n\n **sync all** provides a global synchronization barrier for all images in the\n current team. When an image executes SYNC ALL, it waits until all other\n images in the team have also reached a SYNC ALL statement. This ensures\n that all images have completed their preceding operations before any\n image proceeds past the barrier.\n\n The synchronization establishes a segment boundary. All operations that\n precede SYNC ALL on any image are ordered before all operations that\n follow SYNC ALL on any image in the team.\n\n### **Options**\n\n- **stat=stat_variable**\n  : Optional. If present, receives a status value upon completion.\n  A value of zero indicates successful synchronization. A nonzero value\n  indicates an error occurred, such as a stopped or failed image.\n  The constant STAT_STOPPED_IMAGE or STAT_FAILED_IMAGE from ISO_FORTRAN_ENV\n  may be returned.\n\n- **errmsg=errmsg_variable**\n  : Optional. If present and an error occurs, receives an explanatory\n  message describing the error condition. The variable is assigned only\n  if stat_variable is also present and receives a nonzero value.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_sync_all\n  use iso_fortran_env, only: int64\n  implicit none\n  integer :: me, num_images\n  real, allocatable :: local_data(:)[:]  ! Coarray\n  real :: global_sum\n  integer :: i, stat\n  character(len=100) :: errmsg\n\n  me = this_image()\n  num_images = num_images()\n\n  ! Allocate coarray on all images\n  allocate(local_data(100)[*])\n\n  ! Each image initializes its own data\n  local_data = real(me)\n\n  ! Synchronize to ensure all images have initialized their data\n  sync all\n\n  ! Now safe to access data from other images\n  if (me == 1) then\n    global_sum = 0.0\n    do i = 1, num_images\n      global_sum = global_sum + local_data(1)[i]\n    end do\n    print '(A,F10.2)', 'Sum of first elements from all images: ', global_sum\n  end if\n\n  ! Synchronize before cleanup\n  sync all\n\n  ! Example with error handling\n  sync all (stat=stat, errmsg=errmsg)\n  if (stat /= 0) then\n    print '(A,I0,A,A)', 'Image ', me, ' sync error: ', trim(errmsg)\n  end if\n\n  deallocate(local_data)\n\nend program demo_sync_all\n```\nResults (with 4 images):\n```text\n    Sum of first elements from all images:      10.00\n```\n\n### **Standard**\n\nFortran 2008\n\n**Compatibility Notes:**\n- gfortran 5.0+, Intel Fortran 12.0+, NAG 6.0+\n- Global barrier across all images\n- Use STAT= to detect stopped/failed images\n\n### **See Also**\n\n[**sync_images**(3)](#sync_images),\n[**sync_memory**(3)](#sync_memory),\n[**sync_team**(3)](#sync_team),\n[**this_image**(3)](#this_image),\n[**num_images**(3)](#num_images),\n[**co_sum**(3)](#co_sum),\n[**co_broadcast**(3)](#co_broadcast)",
  "cfptr": "## c_f_pointer\n\n### **Name**\n\n**c_f_pointer** - \\[INTEROP:C_BINDING\\] Convert a C pointer to a Fortran pointer\n\n### **Synopsis**\n```fortran\n    call c_f_pointer(cptr, fptr)\n    call c_f_pointer(cptr, fptr, shape)\n```\n```fortran\n     subroutine c_f_pointer(cptr, fptr, shape)\n\n      type(c_ptr), intent(in)           :: cptr\n      type(*), pointer, intent(out)     :: fptr\n      integer, intent(in), optional     :: shape(:)\n```\n\n### **Characteristics**\n\n - **cptr** is a scalar of type C_PTR from ISO_C_BINDING.\n - **fptr** is a pointer of any interoperable type (scalar or array).\n - **shape** is required when fptr is an array pointer; specifies array dimensions.\n - The subroutine associates fptr with the target of cptr.\n - If cptr is C_NULL_PTR, fptr becomes disassociated.\n - The target must be allocated and valid memory.\n\n### **Description**\n\n **c_f_pointer** associates a Fortran pointer with the target of a C pointer.\n This is essential for accessing C-allocated memory or C arrays from Fortran.\n The target of cptr must have the same type as fptr. For array pointers, the\n shape argument specifies the array dimensions, allowing Fortran to treat\n C memory as a properly-bounded array.\n\n### **Options**\n\n- **cptr**\n  : A C pointer (type(c_ptr)) pointing to interoperable data. Obtained from\n  C functions, c_loc(), or c_f_procpointer. If C_NULL_PTR, fptr is nullified.\n\n- **fptr**\n  : A Fortran pointer that will be associated with cptr's target. Must have\n  the POINTER attribute and an interoperable type. Can be scalar or array.\n\n- **shape**\n  : Required for array pointers. An integer array specifying the dimensions.\n  For a rank-n array, shape has n elements: [dim1, dim2, ..., dimn].\n  Not present for scalar pointers.\n\n### **Result**\n\n  After the call, fptr points to the memory addressed by cptr. For arrays,\n  fptr has the bounds [1:shape(1), 1:shape(2), ...]. The association remains\n  valid as long as the underlying memory is valid.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_c_f_pointer\n  use iso_c_binding\n  implicit none\n\n  interface\n    ! C function: double* allocate_array(int n)\n    function allocate_array(n) result(ptr) bind(c, name='allocate_array')\n      import :: c_ptr, c_int\n      integer(c_int), intent(in), value :: n\n      type(c_ptr) :: ptr\n    end function allocate_array\n\n    ! C function: void free_array(double* ptr)\n    subroutine free_array(ptr) bind(c, name='free_array')\n      import :: c_ptr\n      type(c_ptr), intent(in), value :: ptr\n    end subroutine free_array\n  end interface\n\n  type(c_ptr) :: c_array_ptr\n  real(c_double), pointer :: f_array(:)\n  real(c_double), pointer :: f_scalar\n  real(c_double), target  :: local_val\n  integer(c_int) :: n\n  integer :: i\n\n  n = 5\n\n  ! Example 1: Get C pointer and convert to Fortran array pointer\n  c_array_ptr = allocate_array(n)\n  call c_f_pointer(c_array_ptr, f_array, [n])\n\n  ! Now use f_array as a normal Fortran array\n  f_array = [(real(i, c_double), i = 1, n)]\n  print '(A,5F8.2)', 'Array values: ', f_array\n\n  ! Example 2: Convert Fortran target to C pointer and back\n  local_val = 42.0_c_double\n  c_array_ptr = c_loc(local_val)\n  call c_f_pointer(c_array_ptr, f_scalar)\n  print '(A,F8.2)', 'Scalar value: ', f_scalar\n\n  ! Example 3: Handle null pointer\n  c_array_ptr = c_null_ptr\n  call c_f_pointer(c_array_ptr, f_scalar)\n  if (.not. associated(f_scalar)) then\n    print '(A)', 'Null pointer correctly handled'\n  end if\n\n  ! Clean up C-allocated memory\n  c_array_ptr = c_loc(f_array(1))\n  call free_array(c_array_ptr)\n\nend program demo_c_f_pointer\n```\n\nResults:\n```text\nArray values:     1.00    2.00    3.00    4.00    5.00\nScalar value:    42.00\nNull pointer correctly handled\n```\n\n### **Standard**\n\nFortran 2003 (ISO/IEC 1539-1:2004)\n\n**Compatibility Notes:**\n- gfortran 4.3+, Intel Fortran 10.0+, NAG 5.1+\n- Use C_F_POINTER to convert C_PTR to Fortran pointer\n- SHAPE argument required for array targets\n\n### **See Also**\n\n[**c_loc**(3)](#c_loc),\n[**c_funloc**(3)](#c_funloc),\n[**c_f_procpointer**(3)](#c_f_procpointer),\n[**c_ptr**(3)](#c_ptr),\n[**iso_c_binding**(3)](#iso_c_binding)",
  "codimension": "## coarray_declaration\n\n### **Name**\n\n**coarray_declaration** - \\[PARALLEL:COARRAY\\] Declare a coarray variable with codimension\n\n### **Synopsis**\n```fortran\n    type, codimension[cosubscript] :: variable_name\n```\n```fortran\n     type(TYPE(kind=**)), codimension[lower:upper, ...] :: var\n\n     ! Equivalent explicit declaration:\n     type(TYPE(kind=**)) :: var[lower:upper, ...]\n```\n\n### **Characteristics**\n\n - **type** can be any intrinsic or derived type (integer, real, complex, logical, character, or user-defined type).\n - **codimension** specifies the coarray bounds in square brackets.\n - The final upper cobound must be an asterisk (*) indicating deferred upper cobound.\n - Coarrays can be scalars or arrays with any valid array bounds.\n - All images in the program have their own instance of the coarray.\n\n### **Description**\n\n **coarray_declaration** declares a variable as a coarray, enabling parallel data access across multiple images in a SPMD (Single Program, Multiple Data) parallel execution model. Each image has its own local copy of the coarray, and images can access data on other images using coarray syntax with square bracket notation.\n\n### **Options**\n\n- **type**\n  : The data type of the coarray variable. Can be any intrinsic type (integer, real, complex, logical, character) or a derived type. Kind parameters may be specified.\n\n- **codimension[cosubscripts]**\n  : Specifies the coarray cobounds. The cosubscripts define the mapping of images to coarray indices. The final upper cobound must be * (asterisk). For a single codimension, use [*]. For multiple codimensions, use [lower:upper, ..., *].\n\n- **variable_name**\n  : The name of the coarray variable being declared.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_coarray_declaration\n  use iso_fortran_env, only: dp => real64\n  implicit none\n\n  ! Simple coarray scalar\n  real(dp), codimension[*] :: scalar_value\n\n  ! Coarray with explicit lower cobound\n  integer, codimension[0:*] :: indexed_from_zero\n\n  ! Coarray array (local array, distributed across images)\n  real(dp), dimension(100), codimension[*] :: local_array\n\n  ! 2D coarray grid layout\n  real(dp), codimension[2, *] :: grid_value\n\n  ! Alternative syntax (equivalent to codimension)\n  real(dp) :: alternate_syntax[*]\n\n  ! Initialize local value\n  scalar_value = real(this_image(), dp)\n\n  ! Synchronize all images\n  sync all\n\n  ! Access value from image 1 on all images\n  if (this_image() /= 1) then\n    print '(A,I0,A,F6.2)', 'Image ', this_image(), &\n          ' reads from image 1: ', scalar_value[1]\n  else\n    print '(A,F6.2)', 'Image 1 has value: ', scalar_value\n  end if\n\nend program demo_coarray_declaration\n```\nResults (with 4 images):\n```text\n    Image 1 has value:   1.00\n    Image 2 reads from image 1:   1.00\n    Image 3 reads from image 1:   1.00\n    Image 4 reads from image 1:   1.00\n```\n\n### **Standard**\n\nFortran 2008\n\n**Compatibility Notes:**\n- gfortran 4.6+, Intel Fortran 12.0+, NAG 6.0+\n- Coarray bounds specified in square brackets [*]\n- Use SYNC ALL for synchronization\n\n### **See Also**\n\n[**sync_all**(3)](#sync_all),\n[**sync_images**(3)](#sync_images),\n[**this_image**(3)](#this_image),\n[**num_images**(3)](#num_images),\n[**co_sum**(3)](#co_sum),\n[**co_broadcast**(3)](#co_broadcast)",
  "moduledp": "## module_precision\n\n### **Name**\n\n**module_precision** - \\[STRUCTURE:MODULE\\] Module providing portable floating-point precision parameters\n\n### **Synopsis**\n```fortran\n    use precision_module, only: dp\n    real(dp) :: value\n```\n```fortran\n     module precision_module\n\n      implicit none\n      integer, parameter :: dp = selected_real_kind(p, r)\n\n     end module precision_module\n```\n\n### **Characteristics**\n\n - **dp** is an integer parameter representing a kind value for real numbers.\n - **p** specifies the minimum decimal precision (significant digits).\n - **r** specifies the minimum decimal exponent range.\n - Uses selected_real_kind to ensure portability across compilers and platforms.\n - Typical values: p=15, r=307 for double precision (64-bit IEEE).\n\n### **Description**\n\n **module_precision** provides a centralized definition of floating-point\n precision parameters using selected_real_kind. This ensures portable\n precision specifications across different compilers and architectures,\n avoiding non-portable kind specifications like kind=8 or kind(1.0d0).\n The module exports named parameters that can be used to declare real\n variables with guaranteed minimum precision throughout an application.\n\n### **Options**\n\n- **p**\n  : Minimum number of significant decimal digits. Common values:\n  6-7 for single precision, 15-16 for double precision.\n\n- **r**\n  : Minimum decimal exponent range. The parameter ensures the kind\n  can represent values from 10^(-r) to 10^(r). Common values:\n  37 for single precision, 307 for double precision.\n\n- **dp**\n  : The resulting kind parameter. Returns -1 if no kind satisfies the\n  requirements, -2 if precision requirement cannot be met, -3 if\n  range requirement cannot be met.\n\n### **Result**\n\n  An integer kind parameter that can be used in real type declarations\n  to ensure the specified minimum precision and range on any conforming\n  Fortran implementation.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_module_precision\n  use constants, only: dp, sp, wp\n  implicit none\n\n  real(sp) :: single_val\n  real(dp) :: double_val\n  real(wp) :: working_val\n\n  single_val = 1.0_sp / 3.0_sp\n  double_val = 1.0_dp / 3.0_dp\n  working_val = 1.0_wp / 3.0_wp\n\n  print '(a,i0)', 'Single precision kind: ', sp\n  print '(a,i0)', 'Double precision kind: ', dp\n  print '(a,i0)', 'Working precision kind: ', wp\n  print *\n  print '(a,e15.8)', 'Single 1/3: ', single_val\n  print '(a,e23.16)', 'Double 1/3: ', double_val\n  print '(a,e23.16)', 'Working 1/3: ', working_val\n\nend program demo_module_precision\n\nmodule constants\n  implicit none\n  private\n  public :: sp, dp, wp\n\n  ! Single precision: ~6-7 significant digits\n  integer, parameter :: sp = selected_real_kind(6, 37)\n\n  ! Double precision: ~15-16 significant digits\n  integer, parameter :: dp = selected_real_kind(15, 307)\n\n  ! Working precision (can be changed project-wide)\n  integer, parameter :: wp = dp\n\nend module constants\n```\nResults:\n```text\nSingle precision kind: 4\nDouble precision kind: 8\nWorking precision kind: 8\n\nSingle 1/3:  0.33333334E+00\nDouble 1/3:  0.3333333333333333E+00\nWorking 1/3:  0.3333333333333333E+00\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**selected_real_kind**(3)](#selected_real_kind),\n[**selected_int_kind**(3)](#selected_int_kind),\n[**kind**(3)](#kind),\n[**precision**(3)](#precision),\n[**range**(3)](#range),\n[**iso_fortran_env**(3)](#iso_fortran_env)",
  "sysclock": "## system_clock\n\n### **Name**\n\n**system_clock** - \\[SYSTEM:TIME\\] Return processor clock information for wall clock timing\n\n### **Synopsis**\n```fortran\n    call system_clock([count] [,count_rate] [,count_max])\n```\n```fortran\n     subroutine system_clock(count, count_rate, count_max)\n\n      integer, intent(out), optional :: count\n      integer, intent(out), optional :: count_rate\n      integer, intent(out), optional :: count_max\n```\n\n### **Characteristics**\n\n - All arguments are optional with intent(out).\n - **count** is the current clock tick value.\n - **count_rate** is ticks per second.\n - **count_max** is the maximum count before wraparound.\n - Measures wall clock time (elapsed real time).\n\n### **Description**\n\n **system_clock** returns information about the processor's real-time clock.\n Unlike cpu_time which measures processor time, system_clock measures wall\n clock (elapsed) time, making it suitable for timing I/O operations, parallel\n code, and waiting periods.\n\n### **Options**\n\n- **count**\n  : Optional. The current value of the system clock counter. Increases\n  monotonically until it reaches count_max, then wraps to zero.\n\n- **count_rate**\n  : Optional. The number of clock ticks per second. Used to convert\n  count differences to time in seconds.\n\n- **count_max**\n  : Optional. The maximum value count can reach before wrapping to zero.\n  Useful for detecting counter wraparound.\n\n### **Result**\n\n  The requested clock information is returned in the corresponding arguments.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_system_clock\nimplicit none\n  integer :: count_start, count_end, count_rate, count_max\n  real :: elapsed_time\n  integer :: i, j\n  real :: a(1000, 1000)\n\n  ! Get clock information\n  call system_clock(count_rate=count_rate, count_max=count_max)\n  print '(A,I0)', 'Clock ticks per second: ', count_rate\n  print '(A,I0)', 'Maximum count: ', count_max\n  print '(A,F10.2,A)', 'Clock wraps after: ', real(count_max)/count_rate, ' seconds'\n\n  ! Time a computation\n  call system_clock(count_start)\n\n  ! Perform some work\n  do i = 1, 1000\n    do j = 1, 1000\n      a(i, j) = real(i * j)\n    end do\n  end do\n\n  call system_clock(count_end)\n\n  ! Calculate elapsed time\n  elapsed_time = real(count_end - count_start) / real(count_rate)\n  print '(A,F10.6,A)', 'Elapsed wall time: ', elapsed_time, ' seconds'\n\n  ! Handle potential wraparound\n  if (count_end < count_start) then\n    elapsed_time = real((count_max - count_start) + count_end + 1) / real(count_rate)\n    print '(A)', 'Note: Clock wrapped around'\n  end if\n\n  ! High-precision timing (use integer(int64) for longer measurements)\n  block\n    use iso_fortran_env, only: int64\n    integer(int64) :: t1, t2, rate\n    real :: time_seconds\n\n    call system_clock(t1, rate)\n    ! ... work ...\n    call system_clock(t2)\n\n    time_seconds = real(t2 - t1) / real(rate)\n    print '(A,I0)', 'High-precision rate: ', rate\n  end block\n\nend program demo_system_clock\n```\nResults:\n```text\nClock ticks per second: 1000000000\nMaximum count: 9223372036854775807\nClock wraps after: 9223372036.85 seconds\nElapsed wall time:   0.012345 seconds\nHigh-precision rate: 1000000000\n```\n\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**cpu_time**(3)](#cpu_time),\n[**date_and_time**(3)](#date_and_time)",
  "modprecision": "## module_precision\n\n### **Name**\n\n**module_precision** - \\[STRUCTURE:MODULE\\] Module providing portable floating-point precision parameters\n\n### **Synopsis**\n```fortran\n    use precision_module, only: dp\n    real(dp) :: value\n```\n```fortran\n     module precision_module\n\n      implicit none\n      integer, parameter :: dp = selected_real_kind(p, r)\n\n     end module precision_module\n```\n\n### **Characteristics**\n\n - **dp** is an integer parameter representing a kind value for real numbers.\n - **p** specifies the minimum decimal precision (significant digits).\n - **r** specifies the minimum decimal exponent range.\n - Uses selected_real_kind to ensure portability across compilers and platforms.\n - Typical values: p=15, r=307 for double precision (64-bit IEEE).\n\n### **Description**\n\n **module_precision** provides a centralized definition of floating-point\n precision parameters using selected_real_kind. This ensures portable\n precision specifications across different compilers and architectures,\n avoiding non-portable kind specifications like kind=8 or kind(1.0d0).\n The module exports named parameters that can be used to declare real\n variables with guaranteed minimum precision throughout an application.\n\n### **Options**\n\n- **p**\n  : Minimum number of significant decimal digits. Common values:\n  6-7 for single precision, 15-16 for double precision.\n\n- **r**\n  : Minimum decimal exponent range. The parameter ensures the kind\n  can represent values from 10^(-r) to 10^(r). Common values:\n  37 for single precision, 307 for double precision.\n\n- **dp**\n  : The resulting kind parameter. Returns -1 if no kind satisfies the\n  requirements, -2 if precision requirement cannot be met, -3 if\n  range requirement cannot be met.\n\n### **Result**\n\n  An integer kind parameter that can be used in real type declarations\n  to ensure the specified minimum precision and range on any conforming\n  Fortran implementation.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_module_precision\n  use constants, only: dp, sp, wp\n  implicit none\n\n  real(sp) :: single_val\n  real(dp) :: double_val\n  real(wp) :: working_val\n\n  single_val = 1.0_sp / 3.0_sp\n  double_val = 1.0_dp / 3.0_dp\n  working_val = 1.0_wp / 3.0_wp\n\n  print '(a,i0)', 'Single precision kind: ', sp\n  print '(a,i0)', 'Double precision kind: ', dp\n  print '(a,i0)', 'Working precision kind: ', wp\n  print *\n  print '(a,e15.8)', 'Single 1/3: ', single_val\n  print '(a,e23.16)', 'Double 1/3: ', double_val\n  print '(a,e23.16)', 'Working 1/3: ', working_val\n\nend program demo_module_precision\n\nmodule constants\n  implicit none\n  private\n  public :: sp, dp, wp\n\n  ! Single precision: ~6-7 significant digits\n  integer, parameter :: sp = selected_real_kind(6, 37)\n\n  ! Double precision: ~15-16 significant digits\n  integer, parameter :: dp = selected_real_kind(15, 307)\n\n  ! Working precision (can be changed project-wide)\n  integer, parameter :: wp = dp\n\nend module constants\n```\nResults:\n```text\nSingle precision kind: 4\nDouble precision kind: 8\nWorking precision kind: 8\n\nSingle 1/3:  0.33333334E+00\nDouble 1/3:  0.3333333333333333E+00\nWorking 1/3:  0.3333333333333333E+00\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**selected_real_kind**(3)](#selected_real_kind),\n[**selected_int_kind**(3)](#selected_int_kind),\n[**kind**(3)](#kind),\n[**precision**(3)](#precision),\n[**range**(3)](#range),\n[**iso_fortran_env**(3)](#iso_fortran_env)",
  "systemclock": "## system_clock\n\n### **Name**\n\n**system_clock** - \\[SYSTEM:TIME\\] Return processor clock information for wall clock timing\n\n### **Synopsis**\n```fortran\n    call system_clock([count] [,count_rate] [,count_max])\n```\n```fortran\n     subroutine system_clock(count, count_rate, count_max)\n\n      integer, intent(out), optional :: count\n      integer, intent(out), optional :: count_rate\n      integer, intent(out), optional :: count_max\n```\n\n### **Characteristics**\n\n - All arguments are optional with intent(out).\n - **count** is the current clock tick value.\n - **count_rate** is ticks per second.\n - **count_max** is the maximum count before wraparound.\n - Measures wall clock time (elapsed real time).\n\n### **Description**\n\n **system_clock** returns information about the processor's real-time clock.\n Unlike cpu_time which measures processor time, system_clock measures wall\n clock (elapsed) time, making it suitable for timing I/O operations, parallel\n code, and waiting periods.\n\n### **Options**\n\n- **count**\n  : Optional. The current value of the system clock counter. Increases\n  monotonically until it reaches count_max, then wraps to zero.\n\n- **count_rate**\n  : Optional. The number of clock ticks per second. Used to convert\n  count differences to time in seconds.\n\n- **count_max**\n  : Optional. The maximum value count can reach before wrapping to zero.\n  Useful for detecting counter wraparound.\n\n### **Result**\n\n  The requested clock information is returned in the corresponding arguments.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_system_clock\nimplicit none\n  integer :: count_start, count_end, count_rate, count_max\n  real :: elapsed_time\n  integer :: i, j\n  real :: a(1000, 1000)\n\n  ! Get clock information\n  call system_clock(count_rate=count_rate, count_max=count_max)\n  print '(A,I0)', 'Clock ticks per second: ', count_rate\n  print '(A,I0)', 'Maximum count: ', count_max\n\n  ! Time a computation\n  call system_clock(count_start)\n\n  ! Perform some work\n  do i = 1, 1000\n    do j = 1, 1000\n      a(i, j) = real(i * j)\n    end do\n  end do\n\n  call system_clock(count_end)\n\n  ! Calculate elapsed time\n  elapsed_time = real(count_end - count_start) / real(count_rate)\n  print '(A,F10.6,A)', 'Elapsed wall time: ', elapsed_time, ' seconds'\n\nend program demo_system_clock\n```\nResults:\n```text\nClock ticks per second: 1000000000\nMaximum count: 9223372036854775807\nElapsed wall time:   0.012345 seconds\n```\n\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**cpu_time**(3)](#cpu_time),\n[**date_and_time**(3)](#date_and_time)",
  "coarray": "## coarray_declaration\n\n### **Name**\n\n**coarray_declaration** - \\[PARALLEL:COARRAY\\] Declare a coarray variable with codimension\n\n### **Synopsis**\n```fortran\n    type, codimension[cosubscript] :: variable_name\n```\n```fortran\n     type(TYPE(kind=**)), codimension[lower:upper, ...] :: var\n\n     ! Equivalent explicit declaration:\n     type(TYPE(kind=**)) :: var[lower:upper, ...]\n```\n\n### **Characteristics**\n\n - **type** can be any intrinsic or derived type (integer, real, complex, logical, character, or user-defined type).\n - **codimension** specifies the coarray bounds in square brackets.\n - The final upper cobound must be an asterisk (*) indicating deferred upper cobound.\n - Coarrays can be scalars or arrays with any valid array bounds.\n - All images in the program have their own instance of the coarray.\n\n### **Description**\n\n **coarray_declaration** declares a variable as a coarray, enabling parallel data access across multiple images in a SPMD (Single Program, Multiple Data) parallel execution model. Each image has its own local copy of the coarray, and images can access data on other images using coarray syntax with square bracket notation.\n\n### **Options**\n\n- **type**\n  : The data type of the coarray variable. Can be any intrinsic type (integer, real, complex, logical, character) or a derived type. Kind parameters may be specified.\n\n- **codimension[cosubscripts]**\n  : Specifies the coarray cobounds. The cosubscripts define the mapping of images to coarray indices. The final upper cobound must be * (asterisk). For a single codimension, use [*]. For multiple codimensions, use [lower:upper, ..., *].\n\n- **variable_name**\n  : The name of the coarray variable being declared.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_coarray_declaration\n  use iso_fortran_env, only: dp => real64\n  implicit none\n\n  ! Simple coarray scalar\n  real(dp), codimension[*] :: scalar_value\n\n  ! Coarray with explicit lower cobound\n  integer, codimension[0:*] :: indexed_from_zero\n\n  ! Coarray array (local array, distributed across images)\n  real(dp), dimension(100), codimension[*] :: local_array\n\n  ! 2D coarray grid layout\n  real(dp), codimension[2, *] :: grid_value\n\n  ! Alternative syntax (equivalent to codimension)\n  real(dp) :: alternate_syntax[*]\n\n  ! Initialize local value\n  scalar_value = real(this_image(), dp)\n\n  ! Synchronize all images\n  sync all\n\n  ! Access value from image 1 on all images\n  if (this_image() /= 1) then\n    print '(A,I0,A,F6.2)', 'Image ', this_image(), &\n          ' reads from image 1: ', scalar_value[1]\n  else\n    print '(A,F6.2)', 'Image 1 has value: ', scalar_value\n  end if\n\nend program demo_coarray_declaration\n```\nResults (with 4 images):\n```text\n    Image 1 has value:   1.00\n    Image 2 reads from image 1:   1.00\n    Image 3 reads from image 1:   1.00\n    Image 4 reads from image 1:   1.00\n```\n\n### **Standard**\n\nFortran 2008\n\n**Compatibility Notes:**\n- gfortran 4.6+ (partial), 5.0+ (complete), Intel Fortran 12.0+, NAG 6.0+\n- Requires -fcoarray=single/lib flag for gfortran\n- Some features require coarray runtime library (OpenCoarrays)\n\n### **See Also**\n\n[**sync_all**(3)](#sync_all),\n[**sync_images**(3)](#sync_images),\n[**this_image**(3)](#this_image),\n[**num_images**(3)](#num_images),\n[**co_sum**(3)](#co_sum),\n[**co_broadcast**(3)](#co_broadcast)",
  "system_clock": "## system_clock\n\n### **Name**\n\n**system_clock** - \\[SUBROUTINE:TIME\\] Returns processor clock information for timing measurements\n\n### **Synopsis**\n```fortran\n    call system_clock([count] [, count_rate] [, count_max])\n```\n```fortran\n     subroutine system_clock(count, count_rate, count_max)\n\n      integer, intent(out), optional :: count\n      integer, intent(out), optional :: count_rate  ! or REAL\n      integer, intent(out), optional :: count_max\n```\n\n### **Characteristics**\n\n - All arguments are **OPTIONAL** and **INTENT(OUT)**.\n - **count** is a scalar **INTEGER**.\n - **count_rate** is a scalar **INTEGER** or **REAL**.\n - **count_max** is a scalar **INTEGER**.\n - Using larger integer kinds (e.g., INTEGER(8)) provides higher resolution.\n - If no clock is available, **count** is set to -HUGE(count).\n\n### **Description**\n\n **system_clock** returns data from the processor's real-time clock.\n It is commonly used for measuring elapsed wall-clock time by calling\n it twice and computing the difference. The clock value increments\n from 0 to **count_max**, then wraps around to 0. The resolution\n depends on the integer kind used: default integer typically gives\n millisecond resolution, while 8-byte integers can provide microsecond\n or nanosecond resolution.\n\n### **Options**\n\n- **count**\n  : Intent(out), optional. Returns the current clock count value.\n  This is a processor-dependent value that increases with time.\n  The count is modulo **count_max**, meaning it wraps to 0 after\n  reaching **count_max**. If the clock query fails, it is set to\n  -HUGE(count).\n\n- **count_rate**\n  : Intent(out), optional. Returns the number of clock counts per\n  second. To convert a count difference to seconds, divide by\n  **count_rate**. Can be INTEGER or REAL. If the clock query fails,\n  it is set to 0. The value depends on the kind of the argument.\n\n- **count_max**\n  : Intent(out), optional. Returns the maximum value of **count**\n  before it wraps to 0. Typically equals HUGE(count_max) for the\n  given integer kind. If the clock query fails, it is set to 0.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_system_clock\nimplicit none\n  integer         :: count_start, count_end, count_rate, count_max\n  integer(kind=8) :: count8_start, count8_end, rate8, max8\n  real            :: elapsed_time\n  integer         :: i\n  real            :: sum\n\n  ! Query clock properties with default integer\n  call system_clock(count_rate=count_rate, count_max=count_max)\n  print '(A,I0)',     'Count rate (ticks/sec): ', count_rate\n  print '(A,I0)',     'Count max:              ', count_max\n  print '(A,F10.6)', 'Max measurable time (s): ', &\n                      real(count_max) / real(count_rate)\n\n  ! Time a computation with default integer\n  call system_clock(count_start)\n\n  sum = 0.0\n  do i = 1, 10000000\n    sum = sum + sqrt(real(i))\n  end do\n\n  call system_clock(count_end)\n\n  elapsed_time = real(count_end - count_start) / real(count_rate)\n  print '(/,A,F10.6,A)', 'Computation took: ', elapsed_time, ' seconds'\n  print '(A,ES12.5)',    'Result: ', sum\n\n  ! Higher precision timing with 8-byte integers\n  call system_clock(count8_start, rate8, max8)\n  print '(/,A,I0)', 'High-precision rate: ', rate8\n\n  sum = 0.0\n  do i = 1, 10000000\n    sum = sum + sqrt(real(i))\n  end do\n\n  call system_clock(count8_end)\n\n  elapsed_time = real(count8_end - count8_start) / real(rate8)\n  print '(A,F12.9,A)', 'High-precision time: ', elapsed_time, ' seconds'\n\nend program demo_system_clock\n```\nResults:\n```text\nCount rate (ticks/sec): 1000\nCount max:              2147483647\nMax measurable time (s):  2147483.500000\n\nComputation took:   0.125000 seconds\nResult: 2.10819E+10\n\nHigh-precision rate: 1000000000\nHigh-precision time: 0.124567890 seconds\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**date_and_time**(3)](#date_and_time),\n[**cpu_time**(3)](#cpu_time)",
  "callback": "## callback\n\n### **Name**\n\n**callback** - \\[INTEROP:C_BINDING\\] Pass a Fortran procedure as a callback to C code\n\n### **Synopsis**\n```fortran\n    call c_function_with_callback(c_funloc(fortran_proc))\n```\n```fortran\n     abstract interface\n       subroutine callback_interface(arg) bind(c)\n         import :: c_int\n         integer(c_int), intent(in), value :: arg\n       end subroutine callback_interface\n     end interface\n\n     subroutine fortran_proc(arg) bind(c)\n       integer(c_int), intent(in), value :: arg\n     end subroutine fortran_proc\n```\n\n### **Characteristics**\n\n - Fortran callback procedures must have the BIND(C) attribute.\n - Use **c_funloc()** to get a C function pointer from a Fortran procedure.\n - Use **c_funptr** type to store C function pointers.\n - Use **c_f_procpointer()** to convert C function pointer back to Fortran.\n - Callback signature must match exactly between Fortran and C.\n\n### **Description**\n\n **callback** enables passing Fortran procedures to C code that expects function\n pointers. This is essential for C libraries that use callbacks for event handling,\n numerical algorithms (like integration), or customizable behavior. The Fortran\n procedure must have BIND(C) and use interoperable types for all arguments.\n\n### **Options**\n\n- **c_funloc(proc)**\n  : Intrinsic function that returns a C function pointer (type(c_funptr)) from\n  a Fortran procedure with BIND(C). The procedure can be a module procedure,\n  internal procedure, or external procedure.\n\n- **c_funptr**\n  : Derived type representing a C function pointer. Can store callbacks from\n  C or Fortran procedures. Use c_f_procpointer to convert to procedure pointer.\n\n- **c_f_procpointer(cfunptr, fptr)**\n  : Associates a Fortran procedure pointer with a C function pointer. Allows\n  calling C callbacks from Fortran code.\n\n- **abstract interface**\n  : Defines the signature of callback procedures. Both the abstract interface\n  and implementing procedures must have BIND(C).\n\n### **Result**\n\n  The C code receives a valid function pointer that invokes the Fortran procedure\n  when called. Arguments are passed according to C calling conventions.\n\n### **Examples**\n\nSample program:\n```fortran\nmodule callback_module\n  use iso_c_binding\n  implicit none\n\n  ! Abstract interface for callback signature\n  abstract interface\n    subroutine callback_sub(x, y, result) bind(c)\n      import :: c_double\n      real(c_double), intent(in), value :: x, y\n      real(c_double), intent(out) :: result\n    end subroutine callback_sub\n\n    function callback_func(x) result(y) bind(c)\n      import :: c_double\n      real(c_double), intent(in), value :: x\n      real(c_double) :: y\n    end function callback_func\n  end interface\n\ncontains\n\n  ! Fortran procedure to be used as callback\n  subroutine add_values(x, y, result) bind(c)\n    real(c_double), intent(in), value :: x, y\n    real(c_double), intent(out) :: result\n    result = x + y\n  end subroutine add_values\n\n  subroutine multiply_values(x, y, result) bind(c)\n    real(c_double), intent(in), value :: x, y\n    real(c_double), intent(out) :: result\n    result = x * y\n  end subroutine multiply_values\n\n  function square(x) result(y) bind(c)\n    real(c_double), intent(in), value :: x\n    real(c_double) :: y\n    y = x * x\n  end function square\n\n  ! Higher-order function that accepts a callback\n  subroutine apply_operation(a, b, callback_ptr, result)\n    real(c_double), intent(in) :: a, b\n    type(c_funptr), intent(in) :: callback_ptr\n    real(c_double), intent(out) :: result\n    procedure(callback_sub), pointer :: callback\n\n    call c_f_procpointer(callback_ptr, callback)\n    call callback(a, b, result)\n  end subroutine apply_operation\n\n  ! Numerical integration using callback\n  function integrate(f_ptr, a, b, n) result(integral)\n    type(c_funptr), intent(in) :: f_ptr\n    real(c_double), intent(in) :: a, b\n    integer, intent(in) :: n\n    real(c_double) :: integral\n    procedure(callback_func), pointer :: f\n    real(c_double) :: h, x\n    integer :: i\n\n    call c_f_procpointer(f_ptr, f)\n    h = (b - a) / real(n, c_double)\n    integral = 0.5_c_double * (f(a) + f(b))\n    do i = 1, n - 1\n      x = a + real(i, c_double) * h\n      integral = integral + f(x)\n    end do\n    integral = integral * h\n  end function integrate\n\nend module callback_module\n\nprogram demo_callback\n  use callback_module\n  use iso_c_binding\n  implicit none\n\n  type(c_funptr) :: fptr\n  real(c_double) :: result, integral\n\n  ! Example 1: Pass add callback\n  fptr = c_funloc(add_values)\n  call apply_operation(3.0_c_double, 4.0_c_double, fptr, result)\n  print '(A,F10.4)', 'Add result: ', result\n\n  ! Example 2: Pass multiply callback\n  fptr = c_funloc(multiply_values)\n  call apply_operation(3.0_c_double, 4.0_c_double, fptr, result)\n  print '(A,F10.4)', 'Multiply result: ', result\n\n  ! Example 3: Numerical integration with callback\n  fptr = c_funloc(square)\n  integral = integrate(fptr, 0.0_c_double, 1.0_c_double, 1000)\n  print '(A,F10.6)', 'Integral of x^2 from 0 to 1: ', integral\n  print '(A,F10.6)', 'Expected value (1/3): ', 1.0_c_double / 3.0_c_double\n\nend program demo_callback\n```\n\nCorresponding C header (if calling C code with callbacks):\n```c\n/* callback.h */\ntypedef void (*binary_callback)(double x, double y, double* result);\ntypedef double (*unary_callback)(double x);\n\nvoid c_apply_operation(double a, double b, binary_callback cb, double* result);\ndouble c_integrate(unary_callback f, double a, double b, int n);\n```\n\nResults:\n```text\nAdd result:     7.0000\nMultiply result:    12.0000\nIntegral of x^2 from 0 to 1:   0.333333\nExpected value (1/3):   0.333333\n```\n\n### **Standard**\n\nFortran 2003 (ISO/IEC 1539-1:2004)\n\n**Compatibility Notes:**\n- gfortran 4.3+, Intel Fortran 10.0+, NAG 5.1+\n- Use ABSTRACT INTERFACE for callback type definition\n- C_FUNPTR for passing function pointers\n\n### **See Also**\n\n[**c_funloc**(3)](#c_funloc),\n[**c_funptr**(3)](#c_funptr),\n[**c_f_procpointer**(3)](#c_f_procpointer),\n[**bind_c_function**(3)](#bind_c_function),\n[**iso_c_binding**(3)](#iso_c_binding)",
  "walltime": "## wall_time\n\n### **Name**\n\n**wall_time** - \\[SYSTEM:TIME\\] Measure elapsed wall clock time using system_clock\n\n### **Synopsis**\n```fortran\n    call system_clock(count_start)\n    ! ... code to time ...\n    call system_clock(count_end)\n    elapsed = real(count_end - count_start) / real(count_rate)\n```\n```fortran\n     ! Wall time measurement pattern\n\n      integer :: t1, t2, rate\n      real :: elapsed\n\n      call system_clock(count_rate=rate)\n      call system_clock(t1)\n      ! code to time\n      call system_clock(t2)\n      elapsed = real(t2 - t1) / real(rate)\n```\n\n### **Characteristics**\n\n - Uses system_clock for wall clock (real elapsed) time.\n - Different from cpu_time which measures processor time.\n - Includes time spent waiting, in I/O, and by other processes.\n - Suitable for benchmarking parallel and I/O-bound code.\n\n### **Description**\n\n **wall_time** refers to the pattern of using system_clock to measure real\n elapsed time (wall clock time). This is the time that would pass on a\n wall clock during execution, including all waiting, I/O, and system overhead.\n This contrasts with cpu_time which only measures processor time.\n\n### **Options**\n\n- **count_rate**\n  : Ticks per second. Query once at the start of the program.\n\n- **count_start, count_end**\n  : Clock values captured before and after the code section to time.\n\n### **Result**\n\n  The elapsed wall clock time in seconds between the two system_clock calls.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_wall_time\nuse iso_fortran_env, only: int64\nimplicit none\n  integer(int64) :: t1, t2, rate\n  real :: cpu_start, cpu_end\n  real :: wall_seconds, cpu_seconds\n  integer :: i\n  real :: x\n\n  ! Get the clock rate\n  call system_clock(count_rate=rate)\n  print '(A,I0,A)', 'System clock rate: ', rate, ' ticks/second'\n\n  ! Measure both wall time and CPU time\n  call cpu_time(cpu_start)\n  call system_clock(t1)\n\n  ! Some computation\n  x = 0.0\n  do i = 1, 100000000\n    x = x + sin(real(i) * 0.001)\n  end do\n\n  call system_clock(t2)\n  call cpu_time(cpu_end)\n\n  wall_seconds = real(t2 - t1) / real(rate)\n  cpu_seconds = cpu_end - cpu_start\n\n  print '(A)', ''\n  print '(A)', 'Computation results:'\n  print '(A,F12.6,A)', 'Wall time: ', wall_seconds, ' seconds'\n  print '(A,F12.6,A)', 'CPU time:  ', cpu_seconds, ' seconds'\n  print '(A,F12.6)', 'Result x = ', x\n\n  ! Timing with I/O (wall time >> CPU time)\n  print '(A)', ''\n  print '(A)', 'I/O timing example:'\n\n  call cpu_time(cpu_start)\n  call system_clock(t1)\n\n  ! Simulate I/O delay (sleep would be ideal, but use busy wait)\n  open(unit=99, file='/dev/null', status='old', action='write')\n  do i = 1, 10000\n    write(99, '(I10)') i\n  end do\n  close(99)\n\n  call system_clock(t2)\n  call cpu_time(cpu_end)\n\n  wall_seconds = real(t2 - t1) / real(rate)\n  cpu_seconds = cpu_end - cpu_start\n\n  print '(A,F12.6,A)', 'Wall time: ', wall_seconds, ' seconds'\n  print '(A,F12.6,A)', 'CPU time:  ', cpu_seconds, ' seconds'\n  print '(A)', 'Note: Wall time includes I/O wait time'\n\nend program demo_wall_time\n```\nResults:\n```text\nSystem clock rate: 1000000000 ticks/second\n\nComputation results:\nWall time:     2.345678 seconds\nCPU time:      2.345000 seconds\nResult x =   999.876543\n\nI/O timing example:\nWall time:     0.050123 seconds\nCPU time:      0.010234 seconds\nNote: Wall time includes I/O wait time\n```\n\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**system_clock**(3)](#system_clock),\n[**cpu_time**(3)](#cpu_time),\n[**date_and_time**(3)](#date_and_time)",
  "cputime": "## cpu_time\n\n### **Name**\n\n**cpu_time** - \\[SYSTEM:TIME\\] Return the processor time\n\n### **Synopsis**\n```fortran\n    call cpu_time(time)\n```\n```fortran\n     subroutine cpu_time(time)\n\n      real, intent(out) :: time\n```\n\n### **Characteristics**\n\n - **time** is a scalar real of default kind with intent(out).\n - The returned value is processor-dependent.\n - If processor time is not available, a processor-dependent negative value is returned.\n\n### **Description**\n\n **cpu_time** returns a processor-dependent approximation of the processor\n time in seconds. If the processor cannot return a meaningful time, a\n processor-dependent negative value is returned.\n\n The absolute value of the time returned is processor-dependent and has\n no particular meaning. Only the difference between two calls to cpu_time\n is meaningful, representing the processor time used between the calls.\n\n### **Options**\n\n- **time**\n  : A real scalar variable with intent(out) that receives the processor\n  time in seconds. If processor time is not available, a negative value\n  is returned.\n\n### **Result**\n\n  The processor time in seconds is stored in the time argument.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_cpu_time\nimplicit none\n  real :: start_time, end_time\n  real :: elapsed\n  integer :: i, j\n  real :: a(1000, 1000)\n\n  ! Get starting time\n  call cpu_time(start_time)\n\n  ! Perform some computation\n  do i = 1, 1000\n    do j = 1, 1000\n      a(i, j) = real(i * j)\n    end do\n  end do\n\n  ! Get ending time\n  call cpu_time(end_time)\n\n  ! Calculate elapsed time\n  elapsed = end_time - start_time\n\n  print '(A)', 'Matrix initialization complete.'\n  print '(A,F10.6,A)', 'CPU time: ', elapsed, ' seconds'\n\n  ! Verify negative value indicates unavailable time\n  if (start_time < 0.0) then\n    print '(A)', 'Warning: CPU time not available on this processor.'\n  end if\n\nend program demo_cpu_time\n```\nResults:\n```text\nMatrix initialization complete.\nCPU time:   0.012345 seconds\n```\n\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**system_clock**(3)](#system_clock),\n[**date_and_time**(3)](#date_and_time)",
  "format": "## format\n\n### **Name**\n\n**format** - \\[IO:FORMATTED\\] Declare a named format string parameter for I/O operations\n\n### **Synopsis**\n```fortran\n    character(len=*), parameter :: fmt = '(format_descriptors)'\n    write(unit, fmt) variables\n```\n```fortran\n     ! Named format constant declaration\n     character(len=*), parameter :: fmt_name = '(descriptors)'\n\n     ! Alternative: FORMAT statement (legacy)\n     100 format(descriptors)\n     write(unit, 100) variables\n```\n\n### **Characteristics**\n\n - **fmt** is a character constant with assumed length (len=*).\n - The **parameter** attribute makes it a named constant.\n - Format strings must be enclosed in parentheses within the string.\n - Can be used with READ, WRITE, and PRINT statements.\n - Named formats improve readability over inline format strings.\n\n### **Description**\n\n **format** declares a named character parameter containing format edit descriptors for use in formatted input/output operations. Using named format parameters improves code readability and maintainability by allowing format strings to be defined once and reused throughout a program. Common format descriptors include:\n\n - **Iw[.m]** - Integer with width w (minimum m digits)\n - **Fw.d** - Fixed-point real with width w, d decimal places\n - **Ew.d** - Exponential notation with width w, d decimal places\n - **ESw.d** - Scientific notation (1.0-9.9 mantissa)\n - **Gw.d** - General format (auto F or E based on magnitude)\n - **Aw** - Character with width w (or variable length if w omitted)\n - **Lw** - Logical with width w\n - **nX** - Skip n positions (horizontal spacing)\n - **Tn** - Tab to column n\n - **/** - Start new record (newline)\n - **'text'** - Literal string in output\n - **n(...)** - Repeat group n times\n\n### **Options**\n\n- **format descriptors**\n  : Edit descriptors controlling data conversion and layout. Multiple descriptors are comma-separated within parentheses.\n\n- **repeat count**\n  : A number before a descriptor or group repeats it (e.g., 3I5 or 2(I5,F10.2)).\n\n- **width specifications**\n  : w = total field width, d = decimal places, m = minimum digits.\n\n### **Result**\n\n  The format string controls how data values are converted between internal representation and character form during I/O operations. For output, it determines field widths, decimal places, and spacing. For input, it specifies how characters are interpreted.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_format\nimplicit none\n  ! Declare format parameters for different output types\n  character(len=*), parameter :: fmt_header = '(A20, A10, A12)'\n  character(len=*), parameter :: fmt_data   = '(A20, I10, F12.2)'\n  character(len=*), parameter :: fmt_sci    = '(A, ES12.4)'\n  character(len=*), parameter :: fmt_multi  = '(3(I5, 2X))'\n  character(len=*), parameter :: fmt_table  = '(A, T25, A, T40, A)'\n\n  integer :: count\n  real    :: price, avogadro\n  character(len=20) :: product\n\n  ! Initialize variables\n  product = 'Widget'\n  count = 150\n  price = 29.99\n  avogadro = 6.022e23\n\n  ! Use named format parameters\n  print fmt_header, 'Product', 'Quantity', 'Price'\n  print fmt_header, '-------', '--------', '-----'\n  print fmt_data, product, count, price\n\n  ! Scientific notation format\n  print fmt_sci, 'Avogadro number: ', avogadro\n\n  ! Repeated format group\n  print '(A)', 'Three integers with repeat:'\n  print fmt_multi, 10, 20, 30\n\n  ! Tab-based alignment\n  print fmt_table, 'Column 1', 'Column 2', 'Column 3'\n\n  ! Inline format examples\n  write(*, '(A,I0,A,F0.2)') 'Item count: ', count, ', Total: $', count * price\n\nend program demo_format\n```\nResults:\n```text\nWidget                    150       29.99\n-------                   --------       -----\nWidget                    150       29.99\nAvogadro number: 6.0220E+23\nThree integers with repeat:\n   10     20     30\nColumn 1                Column 2       Column 3\nItem count: 150, Total: $4498.50\n```\n\n### **Standard**\n\nFortran 77 (FORMAT statement), Fortran 90 (character constant formats)\n\n### **See Also**\n\n[**read**(3)](#read),\n[**write**(3)](#write),\n[**print**(3)](#print),\n[**open**(3)](#open)",
  "cpu_time": "## cpu_time\n\n### **Name**\n\n**cpu_time** - \\[SYSTEM:TIME\\] Return the processor time\n\n### **Synopsis**\n```fortran\n    call cpu_time(time)\n```\n```fortran\n     subroutine cpu_time(time)\n\n      real, intent(out) :: time\n```\n\n### **Characteristics**\n\n - **time** is a scalar real of default kind with intent(out).\n - The returned value is processor-dependent.\n - If processor time is not available, a processor-dependent negative value is returned.\n\n### **Description**\n\n **cpu_time** returns a processor-dependent approximation of the processor\n time in seconds. If the processor cannot return a meaningful time, a\n processor-dependent negative value is returned.\n\n The absolute value of the time returned is processor-dependent and has\n no particular meaning. Only the difference between two calls to cpu_time\n is meaningful, representing the processor time used between the calls.\n\n### **Options**\n\n- **time**\n  : A real scalar variable with intent(out) that receives the processor\n  time in seconds. If processor time is not available, a negative value\n  is returned.\n\n### **Result**\n\n  The processor time in seconds is stored in the time argument.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_cpu_time\nimplicit none\n  real :: start_time, end_time\n  real :: elapsed\n  integer :: i, j\n  real :: a(1000, 1000)\n\n  ! Get starting time\n  call cpu_time(start_time)\n\n  ! Perform some computation\n  do i = 1, 1000\n    do j = 1, 1000\n      a(i, j) = real(i * j)\n    end do\n  end do\n\n  ! Get ending time\n  call cpu_time(end_time)\n\n  ! Calculate elapsed time\n  elapsed = end_time - start_time\n\n  print '(A)', 'Matrix initialization complete.'\n  print '(A,F10.6,A)', 'CPU time: ', elapsed, ' seconds'\n\n  ! Verify negative value indicates unavailable time\n  if (start_time < 0.0) then\n    print '(A)', 'Warning: CPU time not available on this processor.'\n  end if\n\nend program demo_cpu_time\n```\nResults:\n```text\nMatrix initialization complete.\nCPU time:   0.012345 seconds\n```\n\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**system_clock**(3)](#system_clock),\n[**date_and_time**(3)](#date_and_time)",
  "constructor": "## type_constructor\n\n### **Name**\n\n**type_constructor** - \\[STRUCTURE:TYPE\\] Define a constructor function for derived type initialization\n\n### **Synopsis**\n```fortran\n    interface type_name\n      module procedure constructor_function\n    end interface\n    obj = type_name(args)\n```\n```fortran\n     interface type_name\n\n      module procedure :: constructor_function\n     end interface type_name\n\n     function constructor_function(args) result(obj)\n\n      type(input_types), intent(in) :: args\n      type(type_name)               :: obj\n```\n\n### **Characteristics**\n\n - Constructor overloads the type name to act as a function.\n - Uses a generic interface with the same name as the derived type.\n - Allows custom initialization logic beyond structure constructors.\n - Multiple constructors can be defined with different argument signatures.\n - Returns an initialized instance of the derived type.\n\n### **Description**\n\n **type_constructor** creates a constructor function for a derived type by\n defining a generic interface with the same name as the type. This allows\n the type name to be used as a function call that returns an initialized\n instance. Unlike the default structure constructor, a custom constructor\n can perform validation, compute derived values, allocate components, and\n enforce invariants during object creation.\n\n### **Options**\n\n- **type_name**\n  : The name of the derived type. The interface uses this name to overload\n  the type name as a function.\n\n- **constructor_function**\n  : One or more module procedures that create and return instances of the\n  type. Each must return type(type_name) and have a unique argument\n  signature for generic resolution.\n\n- **args**\n  : Input arguments for the constructor. Types and number can differ\n  between overloaded constructors.\n\n### **Result**\n\n  An initialized instance of the derived type with all components properly\n  set according to the constructor logic.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_type_constructor\n  use vector_mod\n  implicit none\n\n  type(vector) :: v1, v2, v3, v4\n\n  ! Different constructor forms\n  v1 = vector(1.0, 2.0, 3.0)        ! From components\n  v2 = vector([4.0, 5.0, 6.0])      ! From array\n  v3 = vector(5.0)                  ! Uniform value\n  v4 = vector()                     ! Default (zero vector)\n\n  print '(a,3f8.3)', 'v1 (components): ', v1%x, v1%y, v1%z\n  print '(a,3f8.3)', 'v2 (array):      ', v2%x, v2%y, v2%z\n  print '(a,3f8.3)', 'v3 (uniform):    ', v3%x, v3%y, v3%z\n  print '(a,3f8.3)', 'v4 (default):    ', v4%x, v4%y, v4%z\n  print '(a,f8.3)',  'v1 magnitude:    ', v1%magnitude()\n\nend program demo_type_constructor\n\nmodule vector_mod\n  implicit none\n  private\n  public :: vector\n\n  type :: vector\n    real :: x = 0.0\n    real :: y = 0.0\n    real :: z = 0.0\n  contains\n    procedure :: magnitude\n  end type vector\n\n  ! Constructor interface - overloads type name\n  interface vector\n    module procedure :: vector_default\n    module procedure :: vector_components\n    module procedure :: vector_array\n    module procedure :: vector_uniform\n  end interface vector\n\ncontains\n\n  pure function vector_default() result(v)\n    type(vector) :: v\n    v = vector(0.0, 0.0, 0.0)\n  end function vector_default\n\n  pure function vector_components(x, y, z) result(v)\n    real, intent(in) :: x, y, z\n    type(vector) :: v\n    v%x = x\n    v%y = y\n    v%z = z\n  end function vector_components\n\n  pure function vector_array(arr) result(v)\n    real, intent(in) :: arr(3)\n    type(vector) :: v\n    v%x = arr(1)\n    v%y = arr(2)\n    v%z = arr(3)\n  end function vector_array\n\n  pure function vector_uniform(val) result(v)\n    real, intent(in) :: val\n    type(vector) :: v\n    v%x = val\n    v%y = val\n    v%z = val\n  end function vector_uniform\n\n  pure function magnitude(self) result(mag)\n    class(vector), intent(in) :: self\n    real :: mag\n    mag = sqrt(self%x**2 + self%y**2 + self%z**2)\n  end function magnitude\n\nend module vector_mod\n```\nResults:\n```text\nv1 (components):    1.000   2.000   3.000\nv2 (array):         4.000   5.000   6.000\nv3 (uniform):       5.000   5.000   5.000\nv4 (default):       0.000   0.000   0.000\nv1 magnitude:       3.742\n```\n\n### **Standard**\n\nFortran 90 (interfaces), Fortran 2003 (type-bound procedures)\n\n**Compatibility Notes:**\n- gfortran 4.5+, Intel Fortran 10.0+, NAG 5.2+\n- Structure constructors use type name as function\n- Component order matches type definition\n\n### **See Also**\n\n[**interface**(3)](#interface),\n[**type**(3)](#type),\n[**type_destructor**(3)](#type_destructor),\n[**module_procedure**(3)](#module_procedure)",
  "writestring": "## write_internal\n\n### **Name**\n\n**write** - \\[IO:INTERNAL\\] Write formatted data to an internal character variable\n\n### **Synopsis**\n```fortran\n    write(string, fmt) var1, var2, ...\n```\n```fortran\n     write(unit=string, fmt=format_spec, iostat=ios, iomsg=msg) var_list\n\n      character(len=*), intent(out)   :: string       ! Destination string\n      character(len=*), intent(in)    :: format_spec  ! Format or *\n      integer, intent(out), optional  :: ios          ! I/O status\n      character(len=*), intent(inout), optional :: msg  ! Error message\n```\n\n### **Characteristics**\n\n - **string** is a character variable that receives the formatted output.\n - **fmt** is a format specification (character expression, label, or * for list-directed).\n - **var_list** contains expressions or variables to convert to character representation.\n - The string must be long enough to hold the formatted result.\n - No file unit number is used; the character variable serves as the \"file\".\n\n### **Description**\n\n **write** with an internal file (character variable) converts numeric or other data types to their character representation. This is the Fortran equivalent of sprintf() in C or string formatting in other languages. Internal writes are commonly used for:\n - Converting numbers to strings for concatenation\n - Building formatted output strings dynamically\n - Creating file names with embedded numeric values\n - Preparing data for character-based processing\n\n### **Options**\n\n- **string**\n  : A character variable, substring, or array that receives the formatted output. For arrays, each element receives one record (line) of output.\n\n- **fmt**\n  : Format specification controlling how values are converted. Can be:\n  - `*` for list-directed (free-format) conversion\n  - A character expression containing format descriptors\n  - A statement label referencing a FORMAT statement\n\n- **var_list**\n  : One or more expressions to convert to character representation.\n\n- **iostat=** (optional)\n  : Integer variable set to zero on success, positive on error.\n\n- **iomsg=** (optional)\n  : Character variable that receives an error message if an error occurs.\n\n### **Result**\n\n  The string variable contains the character representation of the output list items formatted according to the format specification.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_write_internal\nimplicit none\n  character(len=50) :: result_str\n  character(len=100) :: filename\n  character(len=20) :: num_str\n  integer :: i, ios\n  real :: value\n  character(len=256) :: errmsg\n\n  ! Example 1: Simple number to string conversion\n  i = 42\n  write(num_str, '(I0)') i\n  print *, 'Integer as string: \"', trim(num_str), '\"'\n\n  ! Example 2: Formatted real conversion\n  value = 3.14159\n  write(result_str, '(F10.4)') value\n  print *, 'Real as string: \"', trim(adjustl(result_str)), '\"'\n\n  ! Example 3: Building a filename with number\n  i = 5\n  write(filename, '(A,I3.3,A)') 'output_', i, '.dat'\n  print *, 'Filename: ', trim(filename)\n\n  ! Example 4: Complex formatting\n  write(result_str, '(A,I0,A,F6.2,A)') 'Item ', i, ' costs $', 19.99, ' each'\n  print *, trim(result_str)\n\n  ! Example 5: Scientific notation\n  value = 6.022e23\n  write(result_str, '(A,ES12.4)') 'Avogadro: ', value\n  print *, trim(result_str)\n\n  ! Example 6: With error handling\n  write(num_str, '(I5)', iostat=ios, iomsg=errmsg) 123456789\n  if (ios /= 0) then\n    print *, 'Conversion error: ', trim(errmsg)\n  else\n    print *, 'Converted: ', trim(num_str)\n  end if\n\nend program demo_write_internal\n```\nResults:\n```text\n Integer as string: \"42\"\n Real as string: \"3.1416\"\n Filename: output_005.dat\n Item 5 costs $ 19.99 each\n Avogadro: 6.0220E+23\n Conversion error: Output statement overflows record\n```\n\n### **Standard**\n\nFortran 77 (internal files), Fortran 2003 (IOMSG)\n\n**Compatibility Notes:**\n- gfortran 4.0+, Intel Fortran 9.0+, NAG 5.0+\n- Use WRITE with internal file (character variable)\n- Ensure target string is long enough\n\n### **See Also**\n\n[**read_internal**(3)](#read_internal),\n[**write**(3)](#write),\n[**format**(3)](#format),\n[**trim**(3)](#trim),\n[**adjustl**(3)](#adjustl)",
  "procarg": "## procedure_argument\n\n### **Name**\n\n**procedure_argument** - \\[PROCEDURE:POINTER\\] Define a subroutine accepting a procedure as an argument\n\n### **Synopsis**\n```fortran\n    call driver(callback_procedure)\n```\n```fortran\n     subroutine driver(callback)\n       interface\n         subroutine callback(x, y)\n           real, intent(in) :: x\n           real, intent(out) :: y\n         end subroutine callback\n       end interface\n```\n\n### **Characteristics**\n\n - Uses INTERFACE block to define the expected procedure signature.\n - Allows passing procedures as arguments to other procedures.\n - Enables callback patterns and function-like parameters.\n - Procedure must match the interface exactly.\n\n### **Description**\n\n **procedure_argument** defines a subroutine that accepts another procedure\n (function or subroutine) as an argument. The interface block specifies the\n exact signature that the passed procedure must match. This enables callback\n patterns, custom integration routines, and generic algorithms.\n\n### **Options**\n\n- **interface block**\n  : Defines the signature (arguments, types, intents) of the procedure\n  that can be passed. Required for dummy procedure arguments.\n\n- **callback**\n  : The dummy argument representing the passed procedure. Called like\n  a regular procedure within the host subroutine.\n\n### **Result**\n\n  The caller can pass any procedure matching the interface, allowing\n  customizable behavior within the host procedure.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_procedure_argument\nimplicit none\n\n  real :: result\n\n  ! Call with different callback procedures\n  call integrate(square, 0.0, 1.0, result)\n  print '(A,F10.6)', 'Integral of x^2 from 0 to 1: ', result\n\n  call integrate(cube, 0.0, 1.0, result)\n  print '(A,F10.6)', 'Integral of x^3 from 0 to 1: ', result\n\n  call integrate(sine, 0.0, 3.14159265, result)\n  print '(A,F10.6)', 'Integral of sin(x) from 0 to pi: ', result\n\ncontains\n\n  ! Integration routine accepting a function argument\n  subroutine integrate(f, a, b, result)\n    interface\n      function f(x) result(y)\n        real, intent(in) :: x\n        real :: y\n      end function f\n    end interface\n    real, intent(in) :: a, b\n    real, intent(out) :: result\n\n    integer, parameter :: n = 1000\n    real :: h, sum\n    integer :: i\n\n    h = (b - a) / real(n)\n    sum = 0.5 * (f(a) + f(b))\n    do i = 1, n - 1\n      sum = sum + f(a + real(i) * h)\n    end do\n    result = sum * h\n\n  end subroutine integrate\n\n  ! Functions to integrate\n  function square(x) result(y)\n    real, intent(in) :: x\n    real :: y\n    y = x * x\n  end function square\n\n  function cube(x) result(y)\n    real, intent(in) :: x\n    real :: y\n    y = x * x * x\n  end function cube\n\n  function sine(x) result(y)\n    real, intent(in) :: x\n    real :: y\n    y = sin(x)\n  end function sine\n\nend program demo_procedure_argument\n```\nResults:\n```text\nIntegral of x^2 from 0 to 1:   0.333334\nIntegral of x^3 from 0 to 1:   0.250001\nIntegral of sin(x) from 0 to pi:   2.000000\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**procedure**(3)](#procedure),\n[**interface**(3)](#interface),\n[**external**(3)](#external)",
  "typeconstructor": "## type_constructor\n\n### **Name**\n\n**type_constructor** - \\[STRUCTURE:TYPE\\] Define a constructor function for derived type initialization\n\n### **Synopsis**\n```fortran\n    interface type_name\n      module procedure constructor_function\n    end interface\n    obj = type_name(args)\n```\n```fortran\n     interface type_name\n\n      module procedure :: constructor_function\n     end interface type_name\n\n     function constructor_function(args) result(obj)\n\n      type(input_types), intent(in) :: args\n      type(type_name)               :: obj\n```\n\n### **Characteristics**\n\n - Constructor overloads the type name to act as a function.\n - Uses a generic interface with the same name as the derived type.\n - Allows custom initialization logic beyond structure constructors.\n - Multiple constructors can be defined with different argument signatures.\n - Returns an initialized instance of the derived type.\n\n### **Description**\n\n **type_constructor** creates a constructor function for a derived type by\n defining a generic interface with the same name as the type. This allows\n the type name to be used as a function call that returns an initialized\n instance. Unlike the default structure constructor, a custom constructor\n can perform validation, compute derived values, allocate components, and\n enforce invariants during object creation.\n\n### **Options**\n\n- **type_name**\n  : The name of the derived type. The interface uses this name to overload\n  the type name as a function.\n\n- **constructor_function**\n  : One or more module procedures that create and return instances of the\n  type. Each must return type(type_name) and have a unique argument\n  signature for generic resolution.\n\n- **args**\n  : Input arguments for the constructor. Types and number can differ\n  between overloaded constructors.\n\n### **Result**\n\n  An initialized instance of the derived type with all components properly\n  set according to the constructor logic.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_type_constructor\n  use vector_mod\n  implicit none\n\n  type(vector) :: v1, v2, v3, v4\n\n  ! Different constructor forms\n  v1 = vector(1.0, 2.0, 3.0)        ! From components\n  v2 = vector([4.0, 5.0, 6.0])      ! From array\n  v3 = vector(5.0)                  ! Uniform value\n  v4 = vector()                     ! Default (zero vector)\n\n  print '(a,3f8.3)', 'v1 (components): ', v1%x, v1%y, v1%z\n  print '(a,3f8.3)', 'v2 (array):      ', v2%x, v2%y, v2%z\n  print '(a,3f8.3)', 'v3 (uniform):    ', v3%x, v3%y, v3%z\n  print '(a,3f8.3)', 'v4 (default):    ', v4%x, v4%y, v4%z\n  print '(a,f8.3)',  'v1 magnitude:    ', v1%magnitude()\n\nend program demo_type_constructor\n\nmodule vector_mod\n  implicit none\n  private\n  public :: vector\n\n  type :: vector\n    real :: x = 0.0\n    real :: y = 0.0\n    real :: z = 0.0\n  contains\n    procedure :: magnitude\n  end type vector\n\n  ! Constructor interface - overloads type name\n  interface vector\n    module procedure :: vector_default\n    module procedure :: vector_components\n    module procedure :: vector_array\n    module procedure :: vector_uniform\n  end interface vector\n\ncontains\n\n  pure function vector_default() result(v)\n    type(vector) :: v\n    v = vector(0.0, 0.0, 0.0)\n  end function vector_default\n\n  pure function vector_components(x, y, z) result(v)\n    real, intent(in) :: x, y, z\n    type(vector) :: v\n    v%x = x\n    v%y = y\n    v%z = z\n  end function vector_components\n\n  pure function vector_array(arr) result(v)\n    real, intent(in) :: arr(3)\n    type(vector) :: v\n    v%x = arr(1)\n    v%y = arr(2)\n    v%z = arr(3)\n  end function vector_array\n\n  pure function vector_uniform(val) result(v)\n    real, intent(in) :: val\n    type(vector) :: v\n    v%x = val\n    v%y = val\n    v%z = val\n  end function vector_uniform\n\n  pure function magnitude(self) result(mag)\n    class(vector), intent(in) :: self\n    real :: mag\n    mag = sqrt(self%x**2 + self%y**2 + self%z**2)\n  end function magnitude\n\nend module vector_mod\n```\nResults:\n```text\nv1 (components):    1.000   2.000   3.000\nv2 (array):         4.000   5.000   6.000\nv3 (uniform):       5.000   5.000   5.000\nv4 (default):       0.000   0.000   0.000\nv1 magnitude:       3.742\n```\n\n### **Standard**\n\nFortran 90 (interfaces), Fortran 2003 (type-bound procedures)\n\n**Compatibility Notes:**\n- gfortran 4.5+, Intel Fortran 10.0+, NAG 5.2+\n- Structure constructors use type name as function\n- Component order matches type definition\n\n### **See Also**\n\n[**interface**(3)](#interface),\n[**type**(3)](#type),\n[**type_destructor**(3)](#type_destructor),\n[**module_procedure**(3)](#module_procedure)",
  "!dir$": "## compiler_directive\n\n### **Name**\n\n**compiler_directive** - \\[COMPILER:DIRECTIVE\\] Insert a compiler-specific optimization directive\n\n### **Synopsis**\n```fortran\n    !DIR$ DIRECTIVE\n```\n```fortran\n     ! Compiler-specific directive syntax\n\n      !DIR$ IVDEP\n      !DIR$ VECTOR\n      !DIR$ SIMD\n      !DIR$ NOINLINE\n```\n\n### **Characteristics**\n\n - Directives begin with **!DIR$** (Intel/Cray) or similar vendor-specific prefix.\n - They appear as comments to non-supporting compilers.\n - Directives affect optimization, vectorization, and code generation.\n - Placement is significant: directives typically apply to the immediately following statement or loop.\n\n### **Description**\n\n **compiler_directive** inserts a compiler-specific directive that controls\n optimization and code generation behavior. Common uses include enabling\n vectorization, specifying loop independence, and controlling inlining.\n Directives are treated as comments by compilers that do not recognize them,\n making code portable.\n\n### **Options**\n\n- **IVDEP**\n  : Ignore Vector DEPendencies. Tells the compiler that apparent loop-carried\n  dependencies can be safely ignored for vectorization purposes.\n\n- **VECTOR**\n  : Requests vectorization of the following loop.\n\n- **NOVECTOR**\n  : Disables vectorization of the following loop.\n\n- **SIMD**\n  : Requests SIMD (Single Instruction Multiple Data) optimization.\n\n- **NOINLINE**\n  : Prevents inlining of the following function or subroutine call.\n\n- **INLINE**\n  : Requests inlining of the following function or subroutine call.\n\n### **Result**\n\n  The compiler modifies its optimization behavior for the following code\n  according to the specified directive. If the directive is not supported\n  or not applicable, it is silently ignored.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_directive\nimplicit none\n  integer, parameter :: n = 1000\n  real :: a(n), b(n), c(n)\n  integer :: i\n\n  ! Initialize arrays\n  a = 1.0\n  b = 2.0\n\n  ! Tell compiler to vectorize and ignore potential dependencies\n  !DIR$ IVDEP\n  !DIR$ VECTOR\n  do i = 1, n\n    c(i) = a(i) + b(i)\n  end do\n\n  print '(A,F10.2)', 'Sum of c: ', sum(c)\n\nend program demo_directive\n```\nResults:\n```text\nSum of c:    3000.00\n```\n\n### **Standard**\n\nCompiler extension (Intel, Cray, GCC, etc.)\n\n### **See Also**\n\n[**!$omp**(3)](#omp),\n[**!GCC$**(3)](#gcc_attributes)",
  "movealloc": "## move_alloc\n\n### **Name**\n\n**move_alloc** - \\[ARRAY:ALLOCATION\\] Move an allocation from one object to another\n\n### **Synopsis**\n```fortran\n    call move_alloc(from, to)\n```\n```fortran\n     subroutine move_alloc(from, to)\n\n      type(TYPE(kind=**)), allocatable, intent(inout) :: from(..)\n      type(TYPE(kind=**)), allocatable, intent(out)   :: to(..)\n```\n\n### **Characteristics**\n\n - **from** is an allocatable variable of any type and rank.\n - **to** is an allocatable variable with the same type and rank as from.\n - After the call, from becomes deallocated.\n - After the call, to has the allocation that was in from.\n - This is an intrinsic subroutine, not a function.\n - No data copying occurs; only the allocation is transferred.\n - If to was already allocated, it is deallocated before the move.\n\n### **Description**\n\n **move_alloc** transfers an allocation from one allocatable object to\n another without copying the data. After the call, the from variable\n becomes deallocated and the to variable holds what was previously in\n from. This is useful for efficiently resizing arrays or transferring\n ownership of allocated memory. The operation is much faster than\n allocating, copying, and deallocating separately.\n\n### **Options**\n\n- **from**\n  : The source allocatable variable. After the call, it will be deallocated.\n  Must be allocatable but can be currently unallocated.\n\n- **to**\n  : The destination allocatable variable. After the call, it will hold the\n  allocation from from. If it was already allocated, that allocation is\n  first deallocated.\n\n### **Result**\n\n  After execution:\n  - from is deallocated (allocated(from) returns .false.)\n  - to has the allocation and data that was in from\n  - No data copying occurs; the operation is O(1)\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_move_alloc\n  use, intrinsic :: iso_fortran_env, only: dp => real64\n  implicit none\n\n  real(dp), allocatable :: small(:), large(:), temp(:)\n  integer :: i\n\n  ! Allocate and initialize small array\n  allocate(small(5))\n  small = [(real(i, dp), i=1, 5)]\n  print *, 'Initial small:', small\n\n  ! Resize by moving to temp, reallocating, and moving back\n  call move_alloc(from=small, to=temp)\n  print *, 'After move: small allocated?', allocated(small)\n  print *, 'After move: temp allocated?', allocated(temp)\n  print *, 'Temp values:', temp\n\n  ! Allocate larger array and copy data\n  allocate(small(10))\n  small(1:5) = temp\n  small(6:10) = 0.0_dp\n  deallocate(temp)\n  print *, 'Resized small:', small\n\n  ! Demonstrate transfer of ownership\n  allocate(large(1000))\n  large = 42.0_dp\n  print *, 'large sum before move:', sum(large)\n\n  ! Transfer ownership - no copying!\n  allocate(temp(0))  ! Allocate empty first\n  deallocate(temp)\n  call move_alloc(large, temp)\n  print *, 'large allocated after move?', allocated(large)\n  print *, 'temp sum after move:', sum(temp)\n\n  deallocate(small, temp)\n\nend program demo_move_alloc\n```\nResults:\n```text\n Initial small:   1.0000000000000000   2.0000000000000000   3.0000000000000000   4.0000000000000000   5.0000000000000000\n After move: small allocated? F\n After move: temp allocated? T\n Temp values:   1.0000000000000000   2.0000000000000000   3.0000000000000000   4.0000000000000000   5.0000000000000000\n Resized small:   1.0000000000000000   2.0000000000000000   3.0000000000000000   4.0000000000000000   5.0000000000000000   0.0000000000000000   0.0000000000000000   0.0000000000000000   0.0000000000000000   0.0000000000000000\n large sum before move:   42000.000000000000\n large allocated after move? F\n temp sum after move:   42000.000000000000\n```\n\n### **Standard**\n\nFortran 2003\n\n**Compatibility Notes:**\n- gfortran 4.5+, Intel Fortran 11.0+, NAG 5.3+\n- For Fortran 95 compatibility, use manual allocation/deallocation\n- Thread-safe; both FROM and TO must have the same declared type\n\n### **See Also**\n\n[**allocate**](#allocate),\n[**deallocate**](#deallocate),\n[**allocated**](#allocated),\n[**allocate_source**](#allocate_source)",
  "streamread": "## stream_read\n\n### **Name**\n\n**read** - \\[IO:STREAM\\] Read unformatted data from a stream access file\n\n### **Synopsis**\n```fortran\n    read(unit) var1, var2, ...\n```\n```fortran\n     read(unit=unit_num, iostat=ios, iomsg=msg, pos=position) var_list\n\n      integer, intent(in)            :: unit_num   ! Connected stream unit\n      integer, intent(out), optional :: ios        ! I/O status\n      character(len=*), intent(inout), optional :: msg  ! Error message\n      integer, intent(in), optional  :: position   ! Byte position (1-based)\n```\n\n### **Characteristics**\n\n - **unit** is an integer unit number connected for stream access.\n - **var_list** contains variables to receive the binary data.\n - Stream access provides byte-addressable I/O without record structure.\n - Data is read in processor-dependent binary representation.\n - The file must be opened with ACCESS='STREAM' and FORM='UNFORMATTED'.\n\n### **Description**\n\n **read** from a stream access file transfers binary data directly into program variables without format conversion or record delimiters. This provides efficient I/O for large datasets and compatibility with binary files created by C programs or other languages. The POS specifier allows random access to any byte position in the file.\n\n### **Options**\n\n- **unit**\n  : Unit number of a file opened with ACCESS='STREAM', FORM='UNFORMATTED'.\n\n- **pos=** (optional)\n  : Byte position to start reading (1-based). If omitted, reads from the current position.\n\n- **iostat=** (optional)\n  : Integer variable set to zero on success, positive on error, negative on end-of-file.\n\n- **iomsg=** (optional)\n  : Character variable that receives an error message if an error occurs.\n\n### **Result**\n\n  Variables receive binary data read directly from the file. The number of bytes read equals the storage size of the variables in the input list.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_stream_read\nimplicit none\n  integer :: unit_num, ios, i\n  real(8) :: data_write(10), data_read(10)\n  integer :: header_write, header_read\n  character(len=100) :: errmsg\n\n  ! Initialize test data\n  header_write = 12345\n  data_write = [(real(i, 8) * 1.5d0, i = 1, 10)]\n\n  ! Write binary data\n  open(newunit=unit_num, file='stream_test.bin', access='stream', &\n       form='unformatted', status='replace', iostat=ios)\n  if (ios /= 0) error stop 'Cannot create file'\n\n  write(unit_num) header_write\n  write(unit_num) data_write\n  close(unit_num)\n\n  ! Read binary data back\n  open(newunit=unit_num, file='stream_test.bin', access='stream', &\n       form='unformatted', status='old', iostat=ios, iomsg=errmsg)\n  if (ios /= 0) then\n    print *, 'Error: ', trim(errmsg)\n    error stop\n  end if\n\n  read(unit_num, iostat=ios) header_read\n  read(unit_num, iostat=ios) data_read\n  close(unit_num, status='delete')\n\n  ! Verify data\n  print '(A,I0)', 'Header: ', header_read\n  print '(A)', 'Data array:'\n  print '(5F10.2)', data_read\n\n  if (header_read == header_write .and. all(data_read == data_write)) then\n    print '(A)', 'SUCCESS: Data integrity verified'\n  else\n    print '(A)', 'ERROR: Data mismatch'\n  end if\n\nend program demo_stream_read\n```\nResults:\n```text\nHeader: 12345\nData array:\n      1.50      3.00      4.50      6.00      7.50\n      9.00     10.50     12.00     13.50     15.00\nSUCCESS: Data integrity verified\n```\n\n### **Standard**\n\nFortran 2003\n\n**Compatibility Notes:**\n- gfortran 4.0+, Intel Fortran 9.1+, NAG 5.0+\n- File must be opened with ACCESS='STREAM'\n- Use POS= for positioning\n\n### **See Also**\n\n[**write_stream**(3)](#write_stream),\n[**open**(3)](#open),\n[**inquire**(3)](#inquire),\n[**stream_open**(3)](#stream_open)",
  "parameter": "## parameter\n\n### **Name**\n\n**parameter** - \\[STRUCTURE:DECLARATION\\] Declare a named constant with a fixed value\n\n### **Synopsis**\n```fortran\n    type, parameter :: name = value\n```\n```fortran\n     ! Named constant declaration\n\n      integer, parameter :: n = 100\n      real, parameter    :: pi = 3.14159265\n```\n\n### **Characteristics**\n\n - **parameter** declares a named constant (cannot be modified).\n - Value must be known at compile time.\n - Can be used in array dimension specifications.\n - Type can be any intrinsic or derived type.\n\n### **Description**\n\n **parameter** declares a named constant whose value is fixed at compile time\n and cannot be changed during program execution. Named constants improve code\n readability, enable compiler optimizations, and ensure values cannot be\n accidentally modified.\n\n### **Options**\n\n- **type**\n  : The data type of the constant (integer, real, character, logical, or\n  derived type with constant components).\n\n- **name**\n  : The identifier for the named constant. Conventionally uppercase or\n  with descriptive names.\n\n- **value**\n  : A constant expression that can be evaluated at compile time.\n\n### **Result**\n\n  A named constant is declared that can be used anywhere a literal constant\n  of that type would be valid.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_parameter\nimplicit none\n  ! Numeric constants\n  integer, parameter :: MAX_SIZE = 1000\n  integer, parameter :: dp = selected_real_kind(15, 307)\n  real(dp), parameter :: PI = 3.14159265358979323846_dp\n  real(dp), parameter :: E = 2.71828182845904523536_dp\n  real(dp), parameter :: GOLDEN_RATIO = (1.0_dp + sqrt(5.0_dp)) / 2.0_dp\n\n  ! Character constants\n  character(len=*), parameter :: VERSION = '1.0.0'\n  character(len=*), parameter :: AUTHOR = 'Fortran Programmer'\n\n  ! Array constant\n  integer, parameter :: PRIMES(5) = [2, 3, 5, 7, 11]\n\n  ! Derived from other parameters\n  real(dp), parameter :: TWO_PI = 2.0_dp * PI\n  integer, parameter :: MAX_INDEX = MAX_SIZE - 1\n\n  ! Use in array declarations\n  real(dp) :: data(MAX_SIZE)\n  real(dp) :: angles(360)\n\n  ! Use in calculations\n  print '(A,A)', 'Version: ', VERSION\n  print '(A,F20.16)', 'Pi: ', PI\n  print '(A,F20.16)', 'e: ', E\n  print '(A,F20.16)', 'Golden ratio: ', GOLDEN_RATIO\n  print '(A,I0)', 'Max size: ', MAX_SIZE\n  print '(A,5I3)', 'First primes: ', PRIMES\n\n  ! Calculate area of circle\n  data(1) = PI * 5.0_dp**2\n  print '(A,F10.4)', 'Area of circle (r=5): ', data(1)\n\nend program demo_parameter\n```\nResults:\n```text\nVersion: 1.0.0\nPi: 3.1415926535897931\ne: 2.7182818284590451\nGolden ratio: 1.6180339887498949\nMax size: 1000\nFirst primes:   2  3  5  7 11\nArea of circle (r=5):    78.5398\n```\n\n### **Standard**\n\nFortran 77\n\n### **See Also**\n\n[**save**(3)](#save),\n[**data**(3)](#data),\n[**kind**(3)](#kind)",
  "custombounds": "## arraybounds\n\n### **Name**\n\n**arraybounds** - \\[ARRAY:DECLARATION\\] Declare an array with custom index bounds\n\n### **Synopsis**\n```fortran\n    type :: array_name(lower:upper)\n```\n```fortran\n     type(TYPE(kind=**)) :: array_name(lower1:upper1 [, lower2:upper2, ...])\n\n      type  :: Any valid Fortran type\n      kind  :: Optional kind parameter\n      lower :: Lower bound (integer constant or expression)\n      upper :: Upper bound (integer constant or expression)\n```\n\n### **Characteristics**\n\n - **type** can be any intrinsic type or derived type.\n - **lower** and **upper** are integer expressions defining the index range.\n - Custom bounds allow zero-based, negative, or arbitrary indexing.\n - LBOUND and UBOUND intrinsics return the actual bounds.\n - SIZE returns the extent regardless of bounds.\n - Arrays with custom bounds are storage-compatible with 1-based arrays of same size.\n\n### **Description**\n\n **Custom index bounds** allow arrays to use indexing schemes other than\n the default 1-based indexing. This is useful for algorithms that naturally\n use zero-based indexing (like C interoperability), negative indices\n (like stencil operations), or domain-specific ranges. The lower bound\n can be any integer value, and the upper bound must be >= lower - 1\n (for a zero-sized array).\n\n### **Options**\n\n- **type**\n  : The data type of array elements.\n\n- **kind**\n  : Optional kind parameter specifying precision.\n\n- **lower**\n  : The lower bound for the dimension. Can be negative, zero, or positive.\n\n- **upper**\n  : The upper bound for the dimension. Must satisfy upper >= lower - 1.\n\n### **Result**\n\n  An array with indices ranging from lower to upper inclusive.\n  The array has extent (upper - lower + 1) elements.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_arraybounds\n  use, intrinsic :: iso_fortran_env, only: dp => real64\n  implicit none\n\n  ! Zero-based array (C-style)\n  real(dp) :: c_style(0:9)\n\n  ! Negative indices (centered stencil)\n  real(dp) :: stencil(-2:2)\n\n  ! Custom range (year-based)\n  integer :: yearly_data(2020:2025)\n\n  ! Multi-dimensional with mixed bounds\n  real(dp) :: grid(-10:10, 0:100)\n\n  integer :: i\n\n  ! Zero-based array\n  c_style = [(real(i, dp), i = 0, 9)]\n  print *, 'C-style bounds:', lbound(c_style, 1), 'to', ubound(c_style, 1)\n  print *, 'C-style size:', size(c_style)\n  print *, 'c_style(0):', c_style(0)\n  print *, 'c_style(9):', c_style(9)\n\n  ! Stencil with negative indices\n  stencil = [-2.0_dp, -1.0_dp, 0.0_dp, 1.0_dp, 2.0_dp]\n  print *, 'Stencil bounds:', lbound(stencil, 1), 'to', ubound(stencil, 1)\n  print *, 'stencil(-2):', stencil(-2)\n  print *, 'stencil(0):', stencil(0)\n  print *, 'stencil(2):', stencil(2)\n\n  ! Year-indexed data\n  yearly_data = [100, 150, 120, 180, 200, 210]\n  print *, 'Yearly bounds:', lbound(yearly_data, 1), 'to', ubound(yearly_data, 1)\n  print *, 'Data for 2022:', yearly_data(2022)\n\n  ! Multi-dimensional\n  grid = 0.0_dp\n  print *, 'Grid shape:', shape(grid)\n  print *, 'Grid bounds dim 1:', lbound(grid, 1), 'to', ubound(grid, 1)\n  print *, 'Grid bounds dim 2:', lbound(grid, 2), 'to', ubound(grid, 2)\n\nend program demo_arraybounds\n```\nResults:\n```text\n C-style bounds:           0 to           9\n C-style size:          10\n c_style(0):   0.0000000000000000\n c_style(9):   9.0000000000000000\n Stencil bounds:          -2 to           2\n stencil(-2):  -2.0000000000000000\n stencil(0):   0.0000000000000000\n stencil(2):   2.0000000000000000\n Yearly bounds:        2020 to        2025\n Data for 2022:         120\n Grid shape:          21         101\n Grid bounds dim 1:         -10 to          10\n Grid bounds dim 2:           0 to         100\n```\n\n### **Standard**\n\nFortran 77\n\n### **See Also**\n\n[**lbound**](#lbound),\n[**ubound**](#ubound),\n[**size**](#size),\n[**shape**](#shape)",
  "this_image": "## this_image / num_images\n\n### **Name**\n\n**this_image / num_images** - \\[PARALLEL:COARRAY\\] Query coarray image index and total image count\n\n### **Synopsis**\n```fortran\n    me = this_image()\n    nimages = num_images()\n```\n```fortran\n     function this_image() result(image_index)\n       integer :: image_index\n\n     function this_image(coarray) result(cosubscripts)\n       type(*), dimension[..] :: coarray\n       integer                :: cosubscripts(:)\n\n     function this_image(coarray, dim) result(cosubscript)\n       type(*), dimension[..] :: coarray\n       integer, intent(in)    :: dim\n       integer                :: cosubscript\n\n     function num_images() result(nimages)\n       integer :: nimages\n\n     function num_images(team) result(nimages)\n       type(team_type), intent(in) :: team\n       integer                     :: nimages\n\n     function num_images(team_number) result(nimages)\n       integer, intent(in) :: team_number\n       integer             :: nimages\n```\n\n### **Characteristics**\n\n - **this_image()** with no arguments returns the image index of the invoking image as a default integer.\n - **this_image(coarray)** returns an integer array of cosubscripts for the invoking image.\n - **this_image(coarray, dim)** returns the cosubscript for dimension **dim** as a scalar integer.\n - **num_images()** with no arguments returns the total number of images in the current team.\n - **num_images(team)** returns the number of images in the specified team.\n - **num_images(team_number)** returns the number of images in the team with the specified team number.\n - Image indices range from 1 to num_images().\n\n### **Description**\n\n **this_image** returns the image index of the invoking image within the current team, or the cosubscripts corresponding to the invoking image for a given coarray. **num_images** returns the total number of images in execution, either in the current team or a specified team. These functions are fundamental for coarray parallel programming, enabling each image to identify itself and coordinate with other images.\n\n### **Options**\n\n- **coarray**\n  : A coarray of any type. Used with this_image to determine the cosubscripts that would be used to access the invoking image's portion of the coarray.\n\n- **dim**\n  : An integer scalar indicating which dimension's cosubscript to return. Must be between 1 and the corank of the coarray.\n\n- **team**\n  : A scalar of type TEAM_TYPE from ISO_FORTRAN_ENV, specifying the team to query.\n\n- **team_number**\n  : An integer scalar specifying the team number to query.\n\n### **Result**\n\n  For **this_image()** with no arguments, the result is a default integer representing the image index (1 to num_images()).\n\n  For **this_image(coarray)**, the result is an integer array with size equal to the corank of the coarray, containing the cosubscripts for the invoking image.\n\n  For **this_image(coarray, dim)**, the result is a scalar integer representing the cosubscript for the specified dimension.\n\n  For **num_images()**, the result is a default integer representing the total number of images currently executing.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_coarray_image_query\n  use iso_fortran_env, only: team_type\n  implicit none\n  integer :: me, nimages\n  integer :: data[*]  ! Simple coarray\n  integer :: matrix[2, *]  ! 2D cobounds coarray\n  integer :: cosubs(1)\n\n  ! Get image index and total images\n  me = this_image()\n  nimages = num_images()\n\n  print '(A,I0,A,I0)', 'Image ', me, ' of ', nimages\n\n  ! Initialize local data\n  data = me * 10\n\n  ! Synchronize all images before accessing remote data\n  sync all\n\n  ! Image 1 collects data from all images\n  if (me == 1) then\n    print *, 'Image 1 collecting data:'\n    block\n      integer :: i\n      do i = 1, nimages\n        print '(A,I0,A,I0)', '  data[', i, '] = ', data[i]\n      end do\n    end block\n  end if\n\n  ! Get cosubscripts for a coarray\n  cosubs = this_image(data)\n  print '(A,I0,A,I0)', 'Image ', me, ' has cosubscript: ', cosubs(1)\n\n  sync all\n\nend program demo_coarray_image_query\n```\nResults (with 4 images):\n```text\nImage 1 of 4\nImage 2 of 4\nImage 3 of 4\nImage 4 of 4\n Image 1 collecting data:\n  data[1] = 10\n  data[2] = 20\n  data[3] = 30\n  data[4] = 40\nImage 1 has cosubscript: 1\nImage 2 has cosubscript: 2\nImage 3 has cosubscript: 3\nImage 4 has cosubscript: 4\n```\n\n### **Standard**\n\nFortran 2008 (basic forms), Fortran 2018 (team arguments)\n\n**Compatibility Notes:**\n- gfortran 5.0+, Intel Fortran 12.0+, NAG 6.0+\n- Returns current image index (1 to NUM_IMAGES())\n- With coarray argument, returns cobounds\n\n### **See Also**\n\n[**sync_all**(3)](#sync_all),\n[**sync_images**(3)](#sync_images),\n[**co_sum**(3)](#co_sum),\n[**co_broadcast**(3)](#co_broadcast),\n[**team_type**(3)](#team_type)",
  "arraybounds": "## arraybounds\n\n### **Name**\n\n**arraybounds** - \\[ARRAY:DECLARATION\\] Declare an array with custom index bounds\n\n### **Synopsis**\n```fortran\n    type :: array_name(lower:upper)\n```\n```fortran\n     type(TYPE(kind=**)) :: array_name(lower1:upper1 [, lower2:upper2, ...])\n\n      type  :: Any valid Fortran type\n      kind  :: Optional kind parameter\n      lower :: Lower bound (integer constant or expression)\n      upper :: Upper bound (integer constant or expression)\n```\n\n### **Characteristics**\n\n - **type** can be any intrinsic type or derived type.\n - **lower** and **upper** are integer expressions defining the index range.\n - Custom bounds allow zero-based, negative, or arbitrary indexing.\n - LBOUND and UBOUND intrinsics return the actual bounds.\n - SIZE returns the extent regardless of bounds.\n - Arrays with custom bounds are storage-compatible with 1-based arrays of same size.\n\n### **Description**\n\n **Custom index bounds** allow arrays to use indexing schemes other than\n the default 1-based indexing. This is useful for algorithms that naturally\n use zero-based indexing (like C interoperability), negative indices\n (like stencil operations), or domain-specific ranges. The lower bound\n can be any integer value, and the upper bound must be >= lower - 1\n (for a zero-sized array).\n\n### **Options**\n\n- **type**\n  : The data type of array elements.\n\n- **kind**\n  : Optional kind parameter specifying precision.\n\n- **lower**\n  : The lower bound for the dimension. Can be negative, zero, or positive.\n\n- **upper**\n  : The upper bound for the dimension. Must satisfy upper >= lower - 1.\n\n### **Result**\n\n  An array with indices ranging from lower to upper inclusive.\n  The array has extent (upper - lower + 1) elements.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_arraybounds\n  use, intrinsic :: iso_fortran_env, only: dp => real64\n  implicit none\n\n  ! Zero-based array (C-style)\n  real(dp) :: c_style(0:9)\n\n  ! Negative indices (centered stencil)\n  real(dp) :: stencil(-2:2)\n\n  ! Custom range (year-based)\n  integer :: yearly_data(2020:2025)\n\n  ! Multi-dimensional with mixed bounds\n  real(dp) :: grid(-10:10, 0:100)\n\n  integer :: i\n\n  ! Zero-based array\n  c_style = [(real(i, dp), i = 0, 9)]\n  print *, 'C-style bounds:', lbound(c_style, 1), 'to', ubound(c_style, 1)\n  print *, 'C-style size:', size(c_style)\n  print *, 'c_style(0):', c_style(0)\n  print *, 'c_style(9):', c_style(9)\n\n  ! Stencil with negative indices\n  stencil = [-2.0_dp, -1.0_dp, 0.0_dp, 1.0_dp, 2.0_dp]\n  print *, 'Stencil bounds:', lbound(stencil, 1), 'to', ubound(stencil, 1)\n  print *, 'stencil(-2):', stencil(-2)\n  print *, 'stencil(0):', stencil(0)\n  print *, 'stencil(2):', stencil(2)\n\n  ! Year-indexed data\n  yearly_data = [100, 150, 120, 180, 200, 210]\n  print *, 'Yearly bounds:', lbound(yearly_data, 1), 'to', ubound(yearly_data, 1)\n  print *, 'Data for 2022:', yearly_data(2022)\n\n  ! Multi-dimensional\n  grid = 0.0_dp\n  print *, 'Grid shape:', shape(grid)\n  print *, 'Grid bounds dim 1:', lbound(grid, 1), 'to', ubound(grid, 1)\n  print *, 'Grid bounds dim 2:', lbound(grid, 2), 'to', ubound(grid, 2)\n\nend program demo_arraybounds\n```\nResults:\n```text\n C-style bounds:           0 to           9\n C-style size:          10\n c_style(0):   0.0000000000000000\n c_style(9):   9.0000000000000000\n Stencil bounds:          -2 to           2\n stencil(-2):  -2.0000000000000000\n stencil(0):   0.0000000000000000\n stencil(2):   2.0000000000000000\n Yearly bounds:        2020 to        2025\n Data for 2022:         120\n Grid shape:          21         101\n Grid bounds dim 1:         -10 to          10\n Grid bounds dim 2:           0 to         100\n```\n\n### **Standard**\n\nFortran 77\n\n### **See Also**\n\n[**lbound**](#lbound),\n[**ubound**](#ubound),\n[**size**](#size),\n[**shape**](#shape)",
  "getcommandargument": "## get_command_argument\n\n### **Name**\n\n**get_command_argument** - \\[SYSTEM:ENVIRONMENT\\] Retrieve a command line argument by position\n\n### **Synopsis**\n```fortran\n    call get_command_argument(number [,value] [,length] [,status])\n```\n```fortran\n     subroutine get_command_argument(number, value, length, status)\n\n      integer, intent(in)            :: number\n      character(len=*), intent(out)  :: value\n      integer, intent(out), optional :: length\n      integer, intent(out), optional :: status\n```\n\n### **Characteristics**\n\n - **number** is an integer specifying which argument to retrieve.\n - **value** is a character variable receiving the argument.\n - **length** optionally returns the actual argument length.\n - **status** optionally returns an error code.\n\n### **Description**\n\n **get_command_argument** retrieves a specific command line argument by its\n position number. Argument 0 is the program name (if available), and\n arguments 1 through command_argument_count() are the user-provided\n arguments in order.\n\n### **Options**\n\n- **number**\n  : Position of the argument to retrieve. 0 for program name, 1 to argc\n  for user arguments.\n\n- **value**\n  : Character variable to receive the argument value. If shorter than the\n  actual argument, the value is truncated and status is set to -1.\n\n- **length**\n  : Optional. Returns the actual length of the argument in characters.\n\n- **status**\n  : Optional. Returns 0 on success, -1 if value was truncated, positive\n  integer if the argument doesn't exist.\n\n### **Result**\n\n  The specified command line argument is returned in the value parameter.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_get_command_argument\nimplicit none\n  integer :: i, argc, length, status\n  character(len=256) :: arg\n\n  argc = command_argument_count()\n\n  ! Get and display program name\n  call get_command_argument(0, arg, length, status)\n  if (status == 0) then\n    print '(A,A,A,I0,A)', 'Program: \"', trim(arg), '\" (length=', length, ')'\n  end if\n\n  ! Process all arguments\n  do i = 1, argc\n    call get_command_argument(i, arg, length, status)\n    select case (status)\n    case (0)\n      print '(A,I0,A,A,A)', 'Arg(', i, ') = \"', trim(arg), '\"'\n    case (-1)\n      print '(A,I0,A)', 'Arg(', i, ') was truncated'\n    case default\n      print '(A,I0,A)', 'Arg(', i, ') error'\n    end select\n  end do\n\nend program demo_get_command_argument\n```\nResults (when run as `./program input.txt output.txt`):\n```text\nProgram: \"./program\" (length=9)\nArg(1) = \"input.txt\"\nArg(2) = \"output.txt\"\n```\n\n### **Standard**\n\nFortran 2003\n\n**Compatibility Notes:**\n- gfortran 4.0+, Intel Fortran 9.0+, NAG 5.0+\n- Argument 0 is program name\n- Use STATUS= to detect missing arguments\n\n### **See Also**\n\n[**command_argument_count**(3)](#command_argument_count),\n[**get_command**(3)](#get_command)",
  "ompdo": "## omp_parallel_do\n\n### **Name**\n\n**omp_parallel_do** - \\[PARALLEL:OPENMP\\] Combined parallel worksharing-loop construct\n\n### **Synopsis**\n\n```fortran\n    !$omp parallel do [clause [[,] clause] ...]\n    do i = start, end [, step]\n      ! loop body\n    end do\n    !$omp end parallel do\n```\n\n```fortran\n    !$omp parallel do private(list) shared(list) default(none|shared|private)\n    !$omp& firstprivate(list) lastprivate(list) reduction(operator:list)\n    !$omp& schedule(type [, chunk_size]) collapse(n) ordered\n    !$omp& if(scalar-logical-expr) num_threads(scalar-integer-expr)\n    do index = lower, upper [, stride]\n      ! loop body - iterations distributed across threads\n    end do\n    !$omp end parallel do\n```\n\n### **Characteristics**\n\n - **private(list)** creates thread-private copies of listed variables with undefined initial values.\n - **shared(list)** specifies variables shared among all threads in the team.\n - **default(none|shared|private)** sets the default data-sharing attribute for variables.\n - **firstprivate(list)** creates private copies initialized from the original value.\n - **lastprivate(list)** copies the value from the last sequential iteration to the original.\n - **reduction(operator:list)** performs a reduction operation across all threads.\n - **schedule(type [, chunk])** controls how loop iterations are distributed among threads.\n - **collapse(n)** combines n nested loops into a single iteration space.\n - **ordered** enforces sequential ordering for ordered regions within the loop.\n - **if(expr)** conditionally executes in parallel; runs serially if false.\n - **num_threads(expr)** specifies the number of threads to use.\n - An implicit barrier exists at the end of the parallel do region.\n\n### **Description**\n\n **!$omp parallel do** creates a parallel region containing a single worksharing-loop construct, distributing loop iterations across a team of threads. This combined construct is a shorthand for a parallel region containing only a single do directive, and is the most common OpenMP construct for parallelizing Fortran loops.\n\n When execution reaches the parallel do directive, a team of threads is created. The loop iterations are then distributed among the threads according to the schedule clause. Each thread executes its assigned portion of the loop iterations. At the end of the construct, threads synchronize at an implicit barrier before only the master thread continues.\n\n### **Options**\n\n- **private(list)**\n  : Creates a new private instance of each listed variable for each thread. The initial value is undefined. At the end of the parallel region, the original variable is unchanged.\n\n- **shared(list)**\n  : Specifies that listed variables are shared among all threads. All threads access the same storage location. Care must be taken to avoid race conditions.\n\n- **default(none|shared|private)**\n  : Sets the default data-sharing attribute for variables. Using `none` is recommended as it requires explicit specification of all variables, preventing accidental sharing bugs.\n\n- **firstprivate(list)**\n  : Like private, but each thread's copy is initialized from the original variable's value before the parallel region begins.\n\n- **lastprivate(list)**\n  : Like private, but the value from the sequentially last iteration is copied back to the original variable after the loop completes.\n\n- **reduction(operator:list)**\n  : Performs a reduction using the specified operator. Each thread has a private copy initialized appropriately (0 for +, 1 for *, etc.). At region end, partial results are combined. Operators: +, -, *, .and., .or., .eqv., .neqv., max, min, iand, ior, ieor.\n\n- **schedule(type [, chunk_size])**\n  : Controls iteration distribution:\n  - `static` - Iterations divided into chunks assigned round-robin (default)\n  - `dynamic` - Threads take chunks from a queue as they finish\n  - `guided` - Chunk sizes decrease exponentially\n  - `runtime` - Determined by OMP_SCHEDULE environment variable\n  - `auto` - Compiler/runtime decides\n\n- **collapse(n)**\n  : Combines n nested loops into one larger iteration space for better load balancing.\n\n- **num_threads(expr)**\n  : Specifies the number of threads for the parallel region.\n\n- **if(expr)**\n  : If false, the region executes serially with a single thread.\n\n### **Result**\n\n  The parallel do construct distributes loop iterations across multiple threads, achieving parallel execution of the loop body. Upon completion, all threads have executed their assigned iterations, any reduction variables contain the combined result, and lastprivate variables hold the value from the final sequential iteration.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_omp_parallel_do\n  use omp_lib\n  implicit none\n  integer, parameter :: n = 1000\n  real(8) :: a(n), b(n), c(n)\n  real(8) :: sum_result\n  integer :: i, thread_id\n\n  ! Initialize arrays\n  do i = 1, n\n    a(i) = real(i, 8)\n    b(i) = real(i, 8) * 2.0d0\n  end do\n\n  ! Basic parallel do - array addition\n  !$omp parallel do private(i) shared(a, b, c)\n  do i = 1, n\n    c(i) = a(i) + b(i)\n  end do\n  !$omp end parallel do\n\n  print '(A,F10.2)', 'c(1) = ', c(1)\n  print '(A,F10.2)', 'c(n) = ', c(n)\n\n  ! Parallel do with reduction\n  sum_result = 0.0d0\n  !$omp parallel do private(i) shared(a) reduction(+:sum_result)\n  do i = 1, n\n    sum_result = sum_result + a(i)\n  end do\n  !$omp end parallel do\n\n  print '(A,F15.2)', 'Sum of a: ', sum_result\n\n  ! Parallel do with schedule and thread info\n  !$omp parallel do private(i, thread_id) schedule(dynamic, 100)\n  do i = 1, n\n    thread_id = omp_get_thread_num()\n    if (mod(i, 250) == 0) then\n      !$omp critical\n      print '(A,I4,A,I2)', 'Iteration ', i, ' executed by thread ', thread_id\n      !$omp end critical\n    end if\n  end do\n  !$omp end parallel do\n\nend program demo_omp_parallel_do\n```\n\nCompile with:\n```text\ngfortran -fopenmp demo_omp_parallel_do.f90 -o demo_omp_parallel_do\nifort -qopenmp demo_omp_parallel_do.f90 -o demo_omp_parallel_do\n```\n\nResults:\n```text\nc(1) =       3.00\nc(n) =    3000.00\nSum of a:       500500.00\nIteration  250 executed by thread  1\nIteration  500 executed by thread  0\nIteration  750 executed by thread  2\nIteration 1000 executed by thread  3\n```\n\n### **Standard**\n\nOpenMP 1.0 (1997 for Fortran)\n\n### **See Also**\n\n[**!$omp parallel**(3)](#omp_parallel),\n[**!$omp do**(3)](#omp_do),\n[**!$omp parallel do simd**(3)](#omp_parallel_do_simd),\n[**!$omp critical**(3)](#omp_critical),\n[**!$omp reduction**(3)](#omp_reduction),\n[**omp_get_thread_num**(3)](#omp_get_thread_num),\n[**omp_get_num_threads**(3)](#omp_get_num_threads)\n\n### **Resources**\n\n- [OpenMP 5.0 Worksharing-Loop Construct](https://www.openmp.org/spec-html/5.0/openmpsu41.html)\n- [LLNL OpenMP Tutorial](https://hpc-tutorials.llnl.gov/openmp/)\n- [OpenMP Official Site](https://www.openmp.org/)",
  "procptr": "## procedure_pointer\n\n### **Name**\n\n**procedure_pointer** - \\[PROCEDURE:POINTER\\] Declare a pointer to a procedure\n\n### **Synopsis**\n```fortran\n    procedure(interface), pointer :: ptr => null()\n```\n```fortran\n     ! Procedure pointer declaration\n\n      procedure(real_func), pointer :: fptr => null()\n\n      abstract interface\n        function real_func(x) result(y)\n          real, intent(in) :: x\n          real :: y\n        end function real_func\n      end interface\n```\n\n### **Characteristics**\n\n - Declared with PROCEDURE statement and POINTER attribute.\n - Must specify an interface (abstract or explicit).\n - Can be associated with any procedure matching the interface.\n - Can be nullified and reassigned at runtime.\n\n### **Description**\n\n **procedure_pointer** declares a pointer that can reference any procedure\n (function or subroutine) matching a specified interface. This enables\n runtime selection of procedures, callback mechanisms, and dynamic dispatch\n patterns similar to function pointers in C.\n\n### **Options**\n\n- **interface**\n  : The name of an abstract interface or an existing procedure that defines\n  the signature the pointer can reference.\n\n- **pointer**\n  : Required attribute indicating this is a pointer to a procedure.\n\n- **null()**\n  : Initial value for disassociated pointer (recommended).\n\n### **Result**\n\n  A procedure pointer that can be associated with compatible procedures\n  and called like a regular procedure.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_procedure_pointer\nimplicit none\n\n  ! Abstract interface for real functions\n  abstract interface\n    function unary_func(x) result(y)\n      real, intent(in) :: x\n      real :: y\n    end function unary_func\n  end interface\n\n  ! Procedure pointer\n  procedure(unary_func), pointer :: operation => null()\n\n  real :: x, result\n\n  x = 2.0\n\n  ! Point to different functions\n  operation => square\n  result = operation(x)\n  print '(A,F8.4)', 'square(2.0) = ', result\n\n  operation => cube\n  result = operation(x)\n  print '(A,F8.4)', 'cube(2.0) = ', result\n\n  operation => reciprocal\n  result = operation(x)\n  print '(A,F8.4)', '1/2.0 = ', result\n\n  ! Nullify\n  operation => null()\n  print '(A,L1)', 'operation is associated: ', associated(operation)\n\ncontains\n\n  function square(x) result(y)\n    real, intent(in) :: x\n    real :: y\n    y = x * x\n  end function square\n\n  function cube(x) result(y)\n    real, intent(in) :: x\n    real :: y\n    y = x * x * x\n  end function cube\n\n  function reciprocal(x) result(y)\n    real, intent(in) :: x\n    real :: y\n    y = 1.0 / x\n  end function reciprocal\n\nend program demo_procedure_pointer\n```\nResults:\n```text\nsquare(2.0) =   4.0000\ncube(2.0) =   8.0000\n1/2.0 =   0.5000\noperation is associated: F\n```\n\n### **Standard**\n\nFortran 2003\n\n**Compatibility Notes:**\n- gfortran 4.5+, Intel Fortran 11.0+, NAG 5.3+\n- Requires explicit interface for target procedure\n- Use PROCEDURE(interface) for type declaration\n\n### **See Also**\n\n[**procedure**(3)](#procedure),\n[**associated**(3)](#associated),\n[**null**(3)](#null),\n[**abstract interface**(3)](#abstract_interface)",
  "omp_reduction": "## omp_reduction\n\n### **Name**\n\n**omp_reduction** - \\[PARALLEL:OPENMP\\] Reduction clause for parallel accumulation operations\n\n### **Synopsis**\n\n```fortran\n    !$omp parallel do reduction(operator:variable_list)\n    do i = start, end\n      variable = variable operator expression\n    end do\n    !$omp end parallel do\n```\n\n```fortran\n    !$omp parallel do reduction(operator:var1, var2, ...)\n    !$omp parallel reduction(operator:var)\n    !$omp simd reduction(operator:var)\n    !$omp do reduction(operator:var)\n\n    ! Supported operators:\n    ! Arithmetic: +, -, *\n    ! Logical: .and., .or., .eqv., .neqv.\n    ! Intrinsic: max, min, iand, ior, ieor\n```\n\n### **Characteristics**\n\n - **operator** specifies the reduction operation to perform.\n - **variable_list** is one or more scalar variables to reduce.\n - Each thread receives a private copy initialized to the identity value.\n - At region end, private copies are combined using the operator.\n - The original variable receives the final combined result.\n - Reduction variables must be scalar (arrays require explicit loops or user-defined reductions).\n - The reduction operator must be associative for correct results.\n\n### **Description**\n\n **reduction(operator:list)** is a data-sharing clause that enables safe parallel accumulation of values into shared variables. Without reduction, multiple threads updating the same variable would cause a race condition. With reduction, each thread accumulates into its own private copy, and these copies are combined at the end of the parallel region.\n\n The private copies are initialized to the identity value for the operator: 0 for +, 1 for *, .true. for .and., .false. for .or., largest negative for max, largest positive for min, all bits set for iand, and zero for ior and ieor.\n\n### **Options**\n\n- **+ (addition)**\n  : Identity value: 0. Combines partial sums from all threads.\n\n- **- (subtraction)**\n  : Identity value: 0. Note: Subtraction is not truly associative; treated as addition of negated values.\n\n- ** * (multiplication)**\n  : Identity value: 1. Combines partial products from all threads.\n\n- **.and. (logical AND)**\n  : Identity value: .true.. Result is .true. only if all partial results are .true..\n\n- **.or. (logical OR)**\n  : Identity value: .false.. Result is .true. if any partial result is .true..\n\n- **.eqv. (logical equivalence)**\n  : Identity value: .true.. Tests if all partial results have the same logical value.\n\n- **.neqv. (logical non-equivalence)**\n  : Identity value: .false.. Logical XOR across all threads.\n\n- **max (maximum)**\n  : Identity value: smallest representable value for the type. Finds maximum across all threads.\n\n- **min (minimum)**\n  : Identity value: largest representable value for the type. Finds minimum across all threads.\n\n- **iand (bitwise AND)**\n  : Identity value: all bits set to 1. Performs bitwise AND across all threads.\n\n- **ior (bitwise OR)**\n  : Identity value: 0. Performs bitwise OR across all threads.\n\n- **ieor (bitwise XOR)**\n  : Identity value: 0. Performs bitwise XOR across all threads.\n\n### **Result**\n\n  After the parallel region completes, the reduction variable contains the combined result of the reduction operation applied across all threads. The order of combination is implementation-defined but mathematically equivalent to sequential execution for associative operators.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_omp_reduction\n  use omp_lib\n  implicit none\n  integer, parameter :: n = 10000\n  real(8) :: a(n)\n  real(8) :: sum_val, product_val, max_val, min_val\n  integer :: count_positive\n  logical :: all_positive, any_negative\n  integer :: i\n\n  ! Initialize array with mixed values\n  do i = 1, n\n    a(i) = real(i - n/2, 8)  ! Values from -5000 to 5000\n  end do\n\n  ! Reduction with + (sum)\n  sum_val = 0.0d0\n  !$omp parallel do reduction(+:sum_val)\n  do i = 1, n\n    sum_val = sum_val + a(i)\n  end do\n  !$omp end parallel do\n  print '(A,F15.2)', 'Sum:     ', sum_val\n\n  ! Reduction with max\n  max_val = -huge(max_val)\n  !$omp parallel do reduction(max:max_val)\n  do i = 1, n\n    max_val = max(max_val, a(i))\n  end do\n  !$omp end parallel do\n  print '(A,F15.2)', 'Maximum: ', max_val\n\n  ! Reduction with min\n  min_val = huge(min_val)\n  !$omp parallel do reduction(min:min_val)\n  do i = 1, n\n    min_val = min(min_val, a(i))\n  end do\n  !$omp end parallel do\n  print '(A,F15.2)', 'Minimum: ', min_val\n\n  ! Logical reduction: .and.\n  all_positive = .true.\n  !$omp parallel do reduction(.and.:all_positive)\n  do i = 1, n\n    all_positive = all_positive .and. (a(i) > 0.0d0)\n  end do\n  !$omp end parallel do\n  print '(A,L)', 'All positive: ', all_positive\n\n  ! Logical reduction: .or.\n  any_negative = .false.\n  !$omp parallel do reduction(.or.:any_negative)\n  do i = 1, n\n    any_negative = any_negative .or. (a(i) < 0.0d0)\n  end do\n  !$omp end parallel do\n  print '(A,L)', 'Any negative: ', any_negative\n\n  ! Integer reduction: count\n  count_positive = 0\n  !$omp parallel do reduction(+:count_positive)\n  do i = 1, n\n    if (a(i) > 0.0d0) count_positive = count_positive + 1\n  end do\n  !$omp end parallel do\n  print '(A,I0)', 'Count positive: ', count_positive\n\n  ! Multiple reductions in one directive\n  sum_val = 0.0d0\n  max_val = -huge(max_val)\n  min_val = huge(min_val)\n  !$omp parallel do reduction(+:sum_val) reduction(max:max_val) reduction(min:min_val)\n  do i = 1, n\n    sum_val = sum_val + a(i)\n    max_val = max(max_val, a(i))\n    min_val = min(min_val, a(i))\n  end do\n  !$omp end parallel do\n  print '(A)', 'Combined reductions:'\n  print '(A,F15.2)', '  Sum: ', sum_val\n  print '(A,F15.2)', '  Max: ', max_val\n  print '(A,F15.2)', '  Min: ', min_val\n\nend program demo_omp_reduction\n```\n\nCompile with:\n```text\ngfortran -fopenmp demo_omp_reduction.f90 -o demo_omp_reduction\n```\n\nResults:\n```text\nSum:            5000.00\nMaximum:        5000.00\nMinimum:       -4999.00\nAll positive: F\nAny negative: T\nCount positive: 5000\nCombined reductions:\n  Sum:          5000.00\n  Max:          5000.00\n  Min:         -4999.00\n```\n\n### **Standard**\n\nOpenMP 1.0 (1997 for Fortran), with extensions in later versions\n\n### **See Also**\n\n[**!$omp parallel do**(3)](#omp_parallel_do),\n[**!$omp parallel**(3)](#omp_parallel),\n[**!$omp atomic**(3)](#omp_atomic),\n[**!$omp critical**(3)](#omp_critical)\n\n### **Resources**\n\n- [OpenMP 5.0 Reduction Clause](https://www.openmp.org/spec-html/5.0/openmpsu107.html)\n- [OpenMP Reduction Tutorial](https://www.openmp.org/resources/tutorials-articles/)\n- [LLNL OpenMP Tutorial - Reduction](https://hpc-tutorials.llnl.gov/openmp/)",
  "procedurepointer": "## procedure_pointer\n\n### **Name**\n\n**procedure_pointer** - \\[PROCEDURE:POINTER\\] Declare a pointer to a procedure\n\n### **Synopsis**\n```fortran\n    procedure(interface), pointer :: ptr => null()\n```\n```fortran\n     ! Procedure pointer declaration\n\n      procedure(real_func), pointer :: fptr => null()\n\n      abstract interface\n        function real_func(x) result(y)\n          real, intent(in) :: x\n          real :: y\n        end function real_func\n      end interface\n```\n\n### **Characteristics**\n\n - Declared with PROCEDURE statement and POINTER attribute.\n - Must specify an interface (abstract or explicit).\n - Can be associated with any procedure matching the interface.\n - Can be nullified and reassigned at runtime.\n\n### **Description**\n\n **procedure_pointer** declares a pointer that can reference any procedure\n (function or subroutine) matching a specified interface. This enables\n runtime selection of procedures, callback mechanisms, and dynamic dispatch\n patterns similar to function pointers in C.\n\n### **Options**\n\n- **interface**\n  : The name of an abstract interface or an existing procedure that defines\n  the signature the pointer can reference.\n\n- **pointer**\n  : Required attribute indicating this is a pointer to a procedure.\n\n- **null()**\n  : Initial value for disassociated pointer (recommended).\n\n### **Result**\n\n  A procedure pointer that can be associated with compatible procedures\n  and called like a regular procedure.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_procedure_pointer\nimplicit none\n\n  ! Abstract interface for real functions\n  abstract interface\n    function unary_func(x) result(y)\n      real, intent(in) :: x\n      real :: y\n    end function unary_func\n  end interface\n\n  ! Procedure pointer\n  procedure(unary_func), pointer :: operation => null()\n\n  real :: x, result\n\n  x = 2.0\n\n  ! Point to different functions\n  operation => square\n  result = operation(x)\n  print '(A,F8.4)', 'square(2.0) = ', result\n\n  operation => cube\n  result = operation(x)\n  print '(A,F8.4)', 'cube(2.0) = ', result\n\n  operation => reciprocal\n  result = operation(x)\n  print '(A,F8.4)', '1/2.0 = ', result\n\n  ! Nullify\n  operation => null()\n  print '(A,L1)', 'operation is associated: ', associated(operation)\n\n  ! Select operation at runtime\n  call compute_with_operation(cube, 3.0)\n  call compute_with_operation(square, 4.0)\n\ncontains\n\n  function square(x) result(y)\n    real, intent(in) :: x\n    real :: y\n    y = x * x\n  end function square\n\n  function cube(x) result(y)\n    real, intent(in) :: x\n    real :: y\n    y = x * x * x\n  end function cube\n\n  function reciprocal(x) result(y)\n    real, intent(in) :: x\n    real :: y\n    y = 1.0 / x\n  end function reciprocal\n\n  subroutine compute_with_operation(op, val)\n    procedure(unary_func), pointer, intent(in) :: op\n    real, intent(in) :: val\n    print '(A,F8.4,A,F8.4)', 'op(', val, ') = ', op(val)\n  end subroutine compute_with_operation\n\nend program demo_procedure_pointer\n```\nResults:\n```text\nsquare(2.0) =   4.0000\ncube(2.0) =   8.0000\n1/2.0 =   0.5000\noperation is associated: F\nop(  3.0000) =  27.0000\nop(  4.0000) =  16.0000\n```\n\n### **Standard**\n\nFortran 2003\n\n**Compatibility Notes:**\n- gfortran 4.5+, Intel Fortran 11.0+, NAG 5.3+\n- Requires explicit interface for target procedure\n- Use PROCEDURE(interface) for type declaration\n\n### **See Also**\n\n[**procedure**(3)](#procedure),\n[**associated**(3)](#associated),\n[**null**(3)](#null),\n[**abstract interface**(3)](#abstract_interface)",
  "select rank": "## select_rank\n\n### **Name**\n\n**select_rank** - \\[CONTROL:CONDITIONAL\\] Select code block based on the rank of an assumed-rank array\n\n### **Synopsis**\n```fortran\n    select rank (array-name)\n      rank (0)\n        ! scalar case\n      rank (n)\n        ! rank-n array handling\n      rank default\n        ! handle other ranks\n    end select\n```\n```fortran\n     select rank (selector)\n\n      type(*), dimension(..) :: selector  ! assumed-rank array\n      ! Inside rank(n) block, selector has rank n\n      ! Inside rank(*), selector is assumed-size\n      ! Inside rank default, selector is assumed-rank\n```\n\n### **Characteristics**\n\n - **selector** is an assumed-rank variable (declared with `dimension(..)`).\n - Each **rank (n)** block receives the variable with the specified rank.\n - **rank (*)** handles assumed-size arrays passed from older code.\n - **rank default** catches all unspecified ranks; selector remains assumed-rank.\n - Only one rank block executes based on the actual rank at runtime.\n\n### **Description**\n\n **select_rank** provides a mechanism to handle assumed-rank dummy arguments\n by selecting code blocks based on the actual rank of the array at runtime.\n This construct is essential for writing generic procedures that accept\n arrays of any rank while providing type-safe, rank-specific implementations.\n Within each rank block, the assumed-rank variable becomes a regular array\n with the specified rank, enabling standard array operations.\n\n### **Options**\n\n- **selector**\n  : The assumed-rank dummy argument to inspect. Must be declared with\n  `dimension(..)`. Can optionally include an associate-name using\n  `select rank (name => selector)` syntax.\n\n- **rank (n)**\n  : Executes when selector has rank n (0 for scalar, 1-15 for arrays).\n  Inside this block, the selector has the specified fixed rank.\n\n- **rank (*)**\n  : Executes when an assumed-size array is passed. The selector becomes\n  assumed-size `dimension(*)` inside this block.\n\n- **rank default**\n  : Executes when no other rank case matches. The selector remains\n  assumed-rank inside this block (limited operations available).\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_select_rank\nimplicit none\n  real :: scalar_val = 3.14\n  real :: array_1d(5) = [1.0, 2.0, 3.0, 4.0, 5.0]\n  real :: array_2d(2,3) = reshape([1.0,2.0,3.0,4.0,5.0,6.0], [2,3])\n  real :: array_3d(2,2,2) = 1.0\n\n  print '(a)', 'Testing scalar:'\n  call print_rank(scalar_val)\n\n  print '(a)', 'Testing rank-1 array:'\n  call print_rank(array_1d)\n\n  print '(a)', 'Testing rank-2 array:'\n  call print_rank(array_2d)\n\n  print '(a)', 'Testing rank-3 array:'\n  call print_rank(array_3d)\n\ncontains\n\n  subroutine print_rank(arr)\n    real, dimension(..), intent(in) :: arr\n\n    select rank (arr)\n      rank (0)\n        print '(a,f6.2)', '  Scalar value: ', arr\n      rank (1)\n        print '(a,i0)', '  Rank-1 array, size: ', size(arr)\n        print '(a,*(f6.2,1x))', '  Elements: ', arr\n      rank (2)\n        print '(a,i0,a,i0)', '  Rank-2 array, shape: ', &\n              size(arr,1), ' x ', size(arr,2)\n        print '(a,f6.2)', '  First element: ', arr(1,1)\n      rank default\n        print '(a,i0)', '  Higher rank array, rank: ', rank(arr)\n    end select\n  end subroutine print_rank\n\nend program demo_select_rank\n```\nResults:\n```text\nTesting scalar:\n  Scalar value:   3.14\nTesting rank-1 array:\n  Rank-1 array, size: 5\n  Elements:   1.00   2.00   3.00   4.00   5.00\nTesting rank-2 array:\n  Rank-2 array, shape: 2 x 3\n  First element:   1.00\nTesting rank-3 array:\n  Higher rank array, rank: 3\n```\n\n### **Standard**\n\nFortran 2018\n\n**Compatibility Notes:**\n- gfortran 8.0+, Intel Fortran 16.0+, NAG 6.2+\n- Works with assumed-rank dummy arguments\n- Allows rank-specific processing in generic procedures\n\n### **See Also**\n\n[**select_type**(3)](#select_type),\n[**select_case**(3)](#select_case),\n[**rank**(3)](#rank),\n[**assumed_rank**(3)](#assumed_rank)",
  "c2fstring": "## c_to_f_string\n\n### **Name**\n\n**c_to_f_string** - \\[INTEROP:C_BINDING\\] Convert a C null-terminated string to a Fortran string\n\n### **Synopsis**\n```fortran\n    f_string = c_to_f_string(c_string)\n```\n```fortran\n     function c_to_f_string(c_string) result(f_string)\n\n      character(kind=c_char), intent(in) :: c_string(*)\n      character(len=:), allocatable      :: f_string\n```\n\n### **Characteristics**\n\n - **c_string** is a C-style null-terminated character array.\n - **f_string** is an allocatable Fortran character string.\n - The function scans for C_NULL_CHAR to determine string length.\n - The null terminator is NOT included in the Fortran string.\n - Handles empty strings (immediate null terminator) correctly.\n\n### **Description**\n\n **c_to_f_string** converts a C-style null-terminated string to a Fortran\n allocatable character string. This is essential when receiving strings\n from C functions, as C strings use null termination while Fortran uses\n fixed or deferred lengths. The function allocates exactly the right\n amount of memory and copies characters up to (but not including) the\n null terminator.\n\n### **Options**\n\n- **c_string**\n  : A C-style character array ending with C_NULL_CHAR (character(0)).\n  Typically received from a C function via type(c_ptr) and c_f_pointer,\n  or passed directly as character(kind=c_char) array.\n\n### **Result**\n\n  An allocatable character string containing the C string contents without\n  the null terminator. The length equals the position of C_NULL_CHAR minus 1.\n  If the C string is empty (starts with null), returns a zero-length string.\n\n### **Examples**\n\nSample program:\n```fortran\nmodule c_string_utils\n  use iso_c_binding\n  implicit none\ncontains\n\n  ! Convert C null-terminated string to Fortran allocatable string\n  function c_to_f_string(c_string) result(f_string)\n    character(kind=c_char), intent(in) :: c_string(*)\n    character(len=:), allocatable :: f_string\n    integer :: i, length\n\n    ! Find the null terminator\n    length = 0\n    do i = 1, huge(1)\n      if (c_string(i) == c_null_char) exit\n      length = length + 1\n    end do\n\n    ! Allocate and copy\n    allocate(character(len=length) :: f_string)\n    do i = 1, length\n      f_string(i:i) = c_string(i)\n    end do\n  end function c_to_f_string\n\n  ! Convert C pointer to Fortran string\n  function c_ptr_to_f_string(c_ptr_str) result(f_string)\n    type(c_ptr), intent(in) :: c_ptr_str\n    character(len=:), allocatable :: f_string\n    character(kind=c_char), pointer :: c_string(:)\n    integer :: length, i\n\n    if (.not. c_associated(c_ptr_str)) then\n      f_string = ''\n      return\n    end if\n\n    ! Get length first\n    call c_f_pointer(c_ptr_str, c_string, [1024])  ! Max length\n    length = 0\n    do i = 1, 1024\n      if (c_string(i) == c_null_char) exit\n      length = length + 1\n    end do\n\n    ! Allocate and copy\n    allocate(character(len=length) :: f_string)\n    do i = 1, length\n      f_string(i:i) = c_string(i)\n    end do\n  end function c_ptr_to_f_string\n\nend module c_string_utils\n\nprogram demo_c_to_f_string\n  use c_string_utils\n  use iso_c_binding\n  implicit none\n\n  interface\n    ! C function: const char* get_message(void)\n    function get_message() result(ptr) bind(c, name='get_message')\n      import :: c_ptr\n      type(c_ptr) :: ptr\n    end function get_message\n  end interface\n\n  character(kind=c_char) :: c_str(20)\n  character(len=:), allocatable :: f_str\n\n  ! Example 1: Convert inline C string\n  c_str = ['H', 'e', 'l', 'l', 'o', c_null_char, ' ', ' ', ' ', ' ', &\n           ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ']\n  f_str = c_to_f_string(c_str)\n  print '(A,A,A,I0)', 'Converted: \"', f_str, '\" (length: ', len(f_str), ')'\n\n  ! Example 2: Handle empty string\n  c_str(1) = c_null_char\n  f_str = c_to_f_string(c_str)\n  print '(A,I0)', 'Empty string length: ', len(f_str)\n\n  ! Example 3: String with special characters\n  c_str = ['T', 'a', 'b', ':', char(9), 'X', c_null_char, &\n           ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ']\n  f_str = c_to_f_string(c_str)\n  print '(A,A,A)', 'With tab: \"', f_str, '\"'\n\nend program demo_c_to_f_string\n```\n\nResults:\n```text\nConverted: \"Hello\" (length: 5)\nEmpty string length: 0\nWith tab: \"Tab:\tX\"\n```\n\n### **Standard**\n\nFortran 2003 (user-defined utility using ISO_C_BINDING)\n\n**Compatibility Notes:**\n- gfortran 4.3+, Intel Fortran 10.0+, NAG 5.1+\n- Scan for C_NULL_CHAR to find string length\n- Allocate appropriate length Fortran string\n\n### **See Also**\n\n[**f_to_c_string**(3)](#f_to_c_string),\n[**c_f_pointer**(3)](#c_f_pointer),\n[**c_null_char**(3)](#c_null_char),\n[**iso_c_binding**(3)](#iso_c_binding)",
  "command_argument_count": "## command_line_arguments\n\n### **Name**\n\n**command_argument_count** - \\[SYSTEM:ENVIRONMENT\\] Return the number of command line arguments\n\n### **Synopsis**\n```fortran\n    result = command_argument_count()\n```\n```fortran\n     function command_argument_count() result(argc)\n\n      integer :: argc\n```\n\n### **Characteristics**\n\n - Returns an integer count of command line arguments.\n - Does not count the program name (argument 0).\n - Returns 0 if no arguments were provided.\n - Pure function with no side effects.\n\n### **Description**\n\n **command_argument_count** returns the number of command line arguments\n passed to the program, not including the program name itself. This is\n typically used to determine how many arguments to process before calling\n get_command_argument for each one.\n\n### **Options**\\n\\nNone. This function takes no arguments.\n\n### **Result**\n\n  An integer representing the number of command line arguments. Returns 0\n  if no arguments were provided or if command line arguments are not\n  supported.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_command_argument_count\nimplicit none\n  integer :: argc, i\n  character(len=256) :: arg\n\n  argc = command_argument_count()\n\n  print '(A,I0,A)', 'Program received ', argc, ' argument(s)'\n\n  if (argc == 0) then\n    print '(A)', 'Usage: program arg1 [arg2 ...]'\n    stop 1\n  end if\n\n  do i = 1, argc\n    call get_command_argument(i, arg)\n    print '(A,I0,A,A)', '  Arg ', i, ': ', trim(arg)\n  end do\n\nend program demo_command_argument_count\n```\nResults (when run as `./program hello world`):\n```text\nProgram received 2 argument(s)\n  Arg 1: hello\n  Arg 2: world\n```\n\n### **Standard**\n\nFortran 2003\n\n**Compatibility Notes:**\n- gfortran 4.0+, Intel Fortran 9.0+, NAG 5.0+\n- Returns 0 if no arguments provided\n- Count does not include the program name itself\n\n### **See Also**\n\n[**get_command_argument**(3)](#get_command_argument),\n[**get_command**(3)](#get_command)",
  "fcptr": "## c_loc\n\n### **Name**\n\n**c_loc** - \\[INTEROP:C_BINDING\\] Get the C address of a Fortran data object\n\n### **Synopsis**\n```fortran\n    cptr = c_loc(x)\n```\n```fortran\n     function c_loc(x) result(cptr)\n\n      type(*), intent(in), target :: x\n      type(c_ptr)                 :: cptr\n```\n\n### **Characteristics**\n\n - **x** must have the TARGET attribute or be a pointer.\n - **x** must be interoperable (scalar or contiguous array of interoperable type).\n - Returns a C_PTR containing the C address of x.\n - If x is an array, returns address of first element.\n - The target must remain valid while the pointer is used.\n\n### **Description**\n\n **c_loc** returns the C address of a Fortran data object as a C_PTR value.\n This enables passing Fortran data to C functions that expect pointers.\n The result can be passed to C functions or used with C_F_POINTER to\n associate other Fortran pointers with the same memory.\n\n### **Options**\n\n- **x**\n  : A Fortran variable with the TARGET attribute, or a Fortran pointer that\n  is associated with a target. Must be an interoperable type: intrinsic types\n  with interoperable kinds, or BIND(C) derived types. For arrays, must be\n  contiguous (no strides).\n\n### **Result**\n\n  A scalar of type C_PTR containing the C address of x. This is equivalent\n  to &x in C. For arrays, returns the address of element x(1) or x(1,1,...).\n  If x is a disassociated pointer or has undefined status, behavior is undefined.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_c_loc\n  use iso_c_binding\n  implicit none\n\n  interface\n    ! C function: void print_address(void* ptr)\n    subroutine print_address(ptr) bind(c, name='print_address')\n      import :: c_ptr\n      type(c_ptr), intent(in), value :: ptr\n    end subroutine print_address\n\n    ! C function: void modify_value(double* ptr, double val)\n    subroutine modify_value(ptr, val) bind(c, name='modify_value')\n      import :: c_ptr, c_double\n      type(c_ptr), intent(in), value :: ptr\n      real(c_double), intent(in), value :: val\n    end subroutine modify_value\n  end interface\n\n  real(c_double), target :: scalar_val\n  real(c_double), target :: array_val(5)\n  type(c_ptr) :: ptr\n  integer :: i\n\n  ! Example 1: Get address of scalar\n  scalar_val = 3.14159_c_double\n  ptr = c_loc(scalar_val)\n  print '(A)', 'Address of scalar obtained'\n\n  ! Example 2: Get address of array (returns address of first element)\n  array_val = [(real(i, c_double), i = 1, 5)]\n  ptr = c_loc(array_val)\n  print '(A)', 'Address of array[1] obtained'\n\n  ! Alternatively, get address of specific element\n  ptr = c_loc(array_val(3))\n  print '(A)', 'Address of array[3] obtained'\n\n  ! Example 3: Pass address to C function\n  ptr = c_loc(scalar_val)\n  call modify_value(ptr, 2.71828_c_double)\n  print '(A,F10.5)', 'Modified scalar: ', scalar_val\n\n  ! Example 4: Use with c_f_pointer for memory aliasing\n  block\n    real(c_double), pointer :: alias_ptr\n    ptr = c_loc(scalar_val)\n    call c_f_pointer(ptr, alias_ptr)\n    alias_ptr = 100.0_c_double\n    print '(A,F10.2)', 'Value via alias: ', scalar_val\n  end block\n\nend program demo_c_loc\n```\n\nResults:\n```text\nAddress of scalar obtained\nAddress of array[1] obtained\nAddress of array[3] obtained\nModified scalar:   2.71828\nValue via alias:     100.00\n```\n\n### **Standard**\n\nFortran 2003 (ISO/IEC 1539-1:2004)\n\n**Compatibility Notes:**\n- gfortran 4.3+, Intel Fortran 10.0+, NAG 5.1+\n- Use C_LOC to get C_PTR from Fortran variable\n- Target must have TARGET attribute\n\n### **See Also**\n\n[**c_f_pointer**(3)](#c_f_pointer),\n[**c_funloc**(3)](#c_funloc),\n[**c_ptr**(3)](#c_ptr),\n[**c_null_ptr**(3)](#c_null_ptr),\n[**iso_c_binding**(3)](#iso_c_binding)",
  "deferredstr": "## deferred_length_string\n\n### **Name**\n\n**deferred_length_string** - \\[STRUCTURE:TYPE\\] Declare a character variable with deferred (dynamic) length\n\n### **Synopsis**\n```fortran\n    character(len=:), allocatable :: variable\n    variable = 'dynamic string'\n```\n```fortran\n     character(len=:), allocatable :: scalar_str\n     character(len=:), allocatable :: str_array(:)\n     character(len=:), pointer     :: str_ptr\n```\n\n### **Characteristics**\n\n - **len=:** specifies deferred length (determined at allocation or assignment).\n - Must have **allocatable** or **pointer** attribute.\n - Length is determined when allocated or assigned.\n - Automatic reallocation on assignment (allocatable variables).\n - Different array elements can have different lengths with allocatable arrays.\n\n### **Description**\n\n **deferred_length_string** declares a character variable whose length is not\n fixed at compile time but determined dynamically at runtime. When combined\n with the allocatable attribute, the string automatically reallocates to\n accommodate assigned values of different lengths. This eliminates the need\n to declare fixed-size character buffers and prevents truncation or wasted\n memory from oversized declarations.\n\n### **Options**\n\n- **len=:**\n  : The colon indicates deferred length. The actual length is determined\n  when the variable is allocated or assigned a value.\n\n- **allocatable**\n  : Required for automatic reallocation on assignment. The variable is\n  automatically allocated or reallocated to match the assigned value's\n  length.\n\n- **pointer**\n  : Alternative to allocatable. Requires explicit allocation and management.\n  Does not support automatic reallocation on assignment.\n\n### **Result**\n\n  A character variable with dynamic length that can hold strings of any\n  length, automatically managing memory as needed.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_deferred_length_string\nimplicit none\n  character(len=:), allocatable :: str\n  character(len=:), allocatable :: filename\n  character(len=:), allocatable :: words(:)\n  integer :: i\n\n  ! Automatic allocation on assignment\n  str = 'Hello'\n  print '(a,i0,a,a)', 'str (len=', len(str), '): ', str\n\n  ! Automatic reallocation to longer string\n  str = 'Hello, World!'\n  print '(a,i0,a,a)', 'str (len=', len(str), '): ', str\n\n  ! Automatic reallocation to shorter string\n  str = 'Hi'\n  print '(a,i0,a,a)', 'str (len=', len(str), '): ', str\n\n  ! Build string dynamically\n  str = ''\n  do i = 1, 5\n    str = str // ' word'\n  end do\n  print '(a,i0,a,a)', 'built (len=', len(str), '): ', trim(str)\n\n  ! Use with functions returning variable-length strings\n  filename = build_filename('data', 'output', 'csv')\n  print '(a,a)', 'filename: ', filename\n\n  ! Allocatable array of deferred-length strings\n  allocate(character(len=10) :: words(3))\n  words = ['apple     ', 'banana    ', 'cherry    ']\n  do i = 1, 3\n    print '(a,i0,a,a,a)', 'words(', i, '): ', trim(words(i)), ''\n  end do\n\n  ! Cleanup is automatic when variables go out of scope\n\ncontains\n\n  function build_filename(prefix, name, extension) result(fname)\n    character(len=*), intent(in) :: prefix, name, extension\n    character(len=:), allocatable :: fname\n    fname = trim(prefix) // '_' // trim(name) // '.' // trim(extension)\n  end function build_filename\n\nend program demo_deferred_length_string\n```\nResults:\n```text\nstr (len=5): Hello\nstr (len=13): Hello, World!\nstr (len=2): Hi\nbuilt (len=25):  word word word word word\nfilename: data_output.csv\nwords(1): apple\nwords(2): banana\nwords(3): cherry\n```\n\n### **Standard**\n\nFortran 2003\n\n**Compatibility Notes:**\n- gfortran 4.5+, Intel Fortran 11.0+, NAG 5.2+\n- Deferred-length character strings require F2003\n- Length determined at allocation time\n\n### **See Also**\n\n[**character**(3)](#character),\n[**allocatable**(3)](#allocatable),\n[**len**(3)](#len),\n[**trim**(3)](#trim),\n[**adjustl**(3)](#adjustl)",
  "real64": "## real64\n\n### **Name**\n\n**real64** - \\[NUMERIC:KIND\\] Declare a 64-bit real variable using ISO_FORTRAN_ENV\n\n### **Synopsis**\n```fortran\n    use, intrinsic :: iso_fortran_env, only: real64\n    real(real64) :: variable_name\n```\n```fortran\n     ! Declaration using ISO_FORTRAN_ENV kind constant\n\n      use, intrinsic :: iso_fortran_env, only: real64\n      real(real64)   :: variable_name\n```\n\n### **Characteristics**\n\n - **real64** is an integer constant from ISO_FORTRAN_ENV module.\n - Represents the kind value for a 64-bit IEEE 754 double precision real.\n - Provides exactly 64 bits of storage (no more, no less).\n - Guarantees binary interoperability with C double type.\n\n### **Description**\n\n **real64** declares a real variable using the ISO_FORTRAN_ENV kind constant\n that guarantees exactly 64 bits of storage. Unlike selected_real_kind which\n specifies minimum precision requirements, real64 specifies an exact bit width.\n This is useful when binary compatibility with external libraries or file\n formats is required.\n\n### **Options**\n\n- **real64**\n  : The kind constant from ISO_FORTRAN_ENV specifying 64-bit real. Must be\n  accessed via `use, intrinsic :: iso_fortran_env, only: real64`.\n\n- **variable_name**\n  : The name of the variable being declared. Must be a valid Fortran identifier.\n\n### **Result**\n\n  A real variable with exactly 64 bits of storage (IEEE 754 binary64 format)\n  providing approximately 15-17 significant decimal digits and an exponent\n  range of approximately +/-307.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_real64\nuse, intrinsic :: iso_fortran_env, only: real64, real32, real128\nimplicit none\n\n  real(real64) :: x, y, z\n  real(real64), parameter :: pi = 3.14159265358979323846_real64\n\n  ! Verify size and precision\n  print '(A,I0)', 'Kind value: ', real64\n  print '(A,I0)', 'Storage size (bits): ', storage_size(x)\n  print '(A,I0)', 'Decimal precision: ', precision(x)\n  print '(A,I0)', 'Exponent range: ', range(x)\n\n  ! Calculate and display\n  x = 1.0_real64\n  y = 3.0_real64\n  z = x / y\n  print '(A,F25.20)', '1/3 = ', z\n  print '(A,F25.20)', 'pi  = ', pi\n\n  ! Compare kind values\n  print '(A)', 'Available real kinds:'\n  print '(A,I0)', '  real32:  ', real32\n  print '(A,I0)', '  real64:  ', real64\n  print '(A,I0)', '  real128: ', real128\n\nend program demo_real64\n```\nResults:\n```text\nKind value: 8\nStorage size (bits): 64\nDecimal precision: 15\nExponent range: 307\n1/3 =  0.33333333333333331483\npi  =  3.14159265358979311600\nAvailable real kinds:\n  real32:  4\n  real64:  8\n  real128: 16\n```\n\n### **Standard**\n\nFortran 2008\n\n**Compatibility Notes:**\n- gfortran 4.4+, Intel Fortran 10.0+, NAG 5.2+\n- From ISO_FORTRAN_ENV module\n- Guaranteed 64-bit real (double precision)\n\n### **See Also**\n\n[**iso_fortran_env**(3)](#iso_fortran_env),\n[**real32**(3)](#real32),\n[**real128**(3)](#real128),\n[**selected_real_kind**(3)](#selected_real_kind)",
  "random_number": "## random_number\n\n### **Name**\n\n**random_number** - \\[SUBROUTINE:RANDOM\\] Returns pseudorandom numbers from a uniform distribution\n\n### **Synopsis**\n```fortran\n    call random_number(harvest)\n```\n```fortran\n     subroutine random_number(harvest)\n\n      real(kind=**), intent(out) :: harvest(..)\n```\n\n### **Characteristics**\n\n - **harvest** is **INTENT(OUT)**, type **REAL** of any kind.\n - **harvest** can be a scalar or an array of any rank.\n - This is an intrinsic subroutine (not elemental).\n - The generated values satisfy 0 <= x < 1.\n\n### **Description**\n\n **random_number** returns one or more pseudorandom numbers from a\n uniform distribution over the interval [0, 1). The numbers are\n generated using a pseudorandom number generator (PRNG). The specific\n algorithm is processor-dependent, but modern implementations typically\n use high-quality generators like xoshiro256**. The sequence is\n deterministic given the same seed state.\n\n### **Options**\n\n- **harvest**\n  : Intent(out). A scalar or array of type REAL that receives the\n  pseudorandom values. Each element is set to a value in the range\n  0 <= harvest < 1. When **harvest** is an array, all elements are\n  filled with independent random values.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_random_number\nimplicit none\n  real              :: x, y\n  real              :: array(5)\n  real, allocatable :: matrix(:,:)\n  integer           :: i\n\n  ! Generate a single random number\n  call random_number(x)\n  print '(A,F10.8)', 'Single random number: ', x\n\n  ! Generate multiple random numbers into an array\n  call random_number(array)\n  print '(A)', 'Array of random numbers:'\n  do i = 1, 5\n    print '(2X,I1,A,F10.8)', i, ': ', array(i)\n  end do\n\n  ! Generate random numbers into a 2D array\n  allocate(matrix(3, 3))\n  call random_number(matrix)\n  print '(/,A)', 'Random 3x3 matrix:'\n  do i = 1, 3\n    print '(3F10.6)', matrix(i, :)\n  end do\n\n  ! Generate random numbers in a different range [a, b)\n  ! Formula: a + (b - a) * random\n  call random_number(x)\n  y = 10.0 + (20.0 - 10.0) * x  ! Random in [10, 20)\n  print '(/,A,F10.4)', 'Random in [10, 20): ', y\n\n  ! Generate random integers in range [1, 6] (dice roll)\n  call random_number(x)\n  i = 1 + int(6.0 * x)  ! 1 to 6\n  print '(A,I1)', 'Dice roll: ', i\n\n  deallocate(matrix)\n\nend program demo_random_number\n```\nResults:\n```text\nSingle random number: 0.37454012\nArray of random numbers:\n  1: 0.95071429\n  2: 0.73199391\n  3: 0.59865850\n  4: 0.15601864\n  5: 0.15599452\n\nRandom 3x3 matrix:\n  0.058084  0.866176  0.601115\n  0.708073  0.020584  0.969910\n  0.832443  0.212339  0.181825\n\nRandom in [10, 20):    13.4556\nDice roll: 4\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**random_seed**(3)](#random_seed)",
  "readstring": "## read_internal\n\n### **Name**\n\n**read** - \\[IO:INTERNAL\\] Read formatted data from an internal character variable\n\n### **Synopsis**\n```fortran\n    read(string, fmt) var1, var2, ...\n```\n```fortran\n     read(unit=string, fmt=format_spec, iostat=ios, iomsg=msg) var_list\n\n      character(len=*), intent(in)  :: string       ! Source string\n      character(len=*), intent(in)  :: format_spec  ! Format or *\n      integer, intent(out), optional :: ios         ! I/O status\n      character(len=*), intent(inout), optional :: msg  ! Error message\n```\n\n### **Characteristics**\n\n - **string** is a character variable or array containing the data to be read.\n - **fmt** is a format specification (character expression, label, or * for list-directed).\n - **var** is the variable(s) to receive the parsed data.\n - The internal file must contain valid formatted data matching the format specification.\n - No file unit number is used; the character variable serves as the \"file\".\n\n### **Description**\n\n **read** with an internal file (character variable) parses formatted data from a string into program variables. This is commonly used for:\n - Converting strings to numeric values\n - Parsing user input that was read as a character string\n - Processing data from non-file sources\n - Extracting values from formatted text buffers\n\n The character variable acts as an internal file, with each element of a character array treated as a separate record.\n\n### **Options**\n\n- **string**\n  : A character variable, substring, or array containing formatted data to be parsed. For arrays, each element is treated as a separate record (line).\n\n- **fmt**\n  : Format specification controlling how data is interpreted. Can be:\n  - `*` for list-directed (free-format) reading\n  - A character expression containing format descriptors\n  - A statement label referencing a FORMAT statement\n  - `'(format-descriptors)'` as a literal string\n\n- **var**\n  : One or more variables to receive the parsed values. Types must match the format specification.\n\n- **iostat=** (optional)\n  : Integer variable set to zero on success, positive on error, negative on end-of-record/file.\n\n- **iomsg=** (optional)\n  : Character variable that receives an error message if an error occurs.\n\n### **Result**\n\n  The variables in the input list receive values converted from the character string according to the format specification. This provides the Fortran equivalent of sscanf() in C for parsing strings into typed values.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_internal_read\nimplicit none\n  character(len=50) :: input_string\n  character(len=20) :: name\n  integer :: age, ios\n  real :: temperature, value\n  character(len=100) :: errmsg\n\n  ! Example 1: Simple numeric conversion from string\n  input_string = '42'\n  read(input_string, *) age\n  print *, 'Age:', age\n\n  ! Example 2: Reading multiple values\n  input_string = '98.6  37.0'\n  read(input_string, *) temperature, value\n  print *, 'Temperature F:', temperature, ' C:', value\n\n  ! Example 3: Using explicit format\n  input_string = 'John                  25'\n  read(input_string, '(A20, I5)') name, age\n  print *, 'Name:', trim(name), ' Age:', age\n\n  ! Example 4: Error handling with iostat\n  input_string = 'not_a_number'\n  read(input_string, *, iostat=ios, iomsg=errmsg) value\n  if (ios /= 0) then\n    print *, 'Read error:', trim(errmsg)\n  else\n    print *, 'Value:', value\n  end if\n\n  ! Example 5: Reading from string with complex format\n  input_string = '2024-01-15'\n  block\n    integer :: year, month, day\n    read(input_string, '(I4, 1X, I2, 1X, I2)') year, month, day\n    print *, 'Date: Year=', year, ' Month=', month, ' Day=', day\n  end block\n\nend program demo_internal_read\n```\nResults:\n```text\n Age:          42\n Temperature F:   98.5999985      C:   37.0000000\n Name:John                  Age:          25\n Read error: Invalid argument\n Date: Year=        2024  Month=           1  Day=          15\n```\n\n### **Standard**\n\nFortran 77 (internal files), Fortran 2003 (IOMSG)\n\n**Compatibility Notes:**\n- gfortran 4.0+, Intel Fortran 9.0+, NAG 5.0+\n- Use READ with internal file (character variable)\n- IOSTAT= for error handling\n\n### **See Also**\n\n[**write_internal**(3)](#write_internal),\n[**read**(3)](#read),\n[**open**(3)](#open),\n[**format**(3)](#format)",
  "cmdargs": "## command_line_arguments\n\n### **Name**\n\n**command_line_arguments** - \\[SYSTEM:ENVIRONMENT\\] Retrieve command line arguments passed to the program\n\n### **Synopsis**\n```fortran\n    argc = command_argument_count()\n    call get_command_argument(number, value, length, status)\n```\n```fortran\n     ! Command line argument retrieval\n\n      integer :: argc, length, status\n      character(len=256) :: argv\n\n      argc = command_argument_count()\n      call get_command_argument(number, value, length, status)\n```\n\n### **Characteristics**\n\n - **command_argument_count()** returns the number of command line arguments.\n - **get_command_argument()** retrieves a specific argument by position.\n - Argument 0 is the program name (if available).\n - Arguments 1 to argc are the user-supplied arguments.\n - All string values are returned as character variables.\n\n### **Description**\n\n **command_line_arguments** retrieves command line arguments using two\n intrinsic procedures. The command_argument_count function returns the\n total number of arguments (excluding the program name). The\n get_command_argument subroutine retrieves individual arguments by their\n position number.\n\n### **Options**\n\n- **number**\n  : Integer position of the argument to retrieve. 0 returns the program name,\n  1 to argc return user-supplied arguments.\n\n- **value**\n  : Character variable to receive the argument value. Should be long enough\n  to hold the expected argument.\n\n- **length**\n  : Optional. Returns the actual length of the argument string.\n\n- **status**\n  : Optional. Returns 0 on success, -1 if value is too short, positive\n  value if argument doesn't exist.\n\n### **Result**\n\n  The command line arguments are retrieved and stored in character variables\n  for processing by the program.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_command_args\nimplicit none\n  integer :: argc, i, length, status\n  character(len=256) :: progname, arg\n\n  ! Get program name\n  call get_command_argument(0, progname, length, status)\n  print '(A,A)', 'Program: ', trim(progname)\n\n  ! Get number of arguments\n  argc = command_argument_count()\n  print '(A,I0)', 'Number of arguments: ', argc\n\n  ! Process each argument\n  do i = 1, argc\n    call get_command_argument(i, arg, length, status)\n    if (status == 0) then\n      print '(A,I0,A,A)', 'Argument ', i, ': ', trim(arg)\n    else if (status == -1) then\n      print '(A,I0,A)', 'Argument ', i, ' was truncated'\n    else\n      print '(A,I0,A)', 'Argument ', i, ' retrieval failed'\n    end if\n  end do\n\n  ! Example: parse a numeric argument\n  if (argc >= 1) then\n    call get_command_argument(1, arg)\n    print '(A,A)', 'First argument: ', trim(arg)\n  end if\n\nend program demo_command_args\n```\nResults (when run as `./demo_command_args foo bar 123`):\n```text\nProgram: ./demo_command_args\nNumber of arguments: 3\nArgument 1: foo\nArgument 2: bar\nArgument 3: 123\nFirst argument: foo\n```\n\n### **Standard**\n\nFortran 2003\n\n**Compatibility Notes:**\n- gfortran 4.0+, Intel Fortran 9.0+, NAG 5.0+\n- Use COMMAND_ARGUMENT_COUNT() and GET_COMMAND_ARGUMENT()\n- Arguments are numbered 0 (program name) to N\n\n### **See Also**\n\n[**get_command**(3)](#get_command),\n[**get_environment_variable**(3)](#get_environment_variable)",
  "deferred": "## deferred_procedure\n\n### **Name**\n\n**deferred** - \\[STRUCTURE:TYPE\\] Declare an abstract method in an abstract type requiring implementation by extending types\n\n### **Synopsis**\n```fortran\n    type, abstract :: abstract_type\n    contains\n      procedure(interface_name), deferred :: method_name\n    end type\n```\n```fortran\n     type, abstract :: abstract_type\n\n      type(component) :: comp\n     contains\n      procedure(interface_name), deferred :: method_name\n     end type abstract_type\n\n     abstract interface\n      function interface_name(self) result(res)\n        import :: abstract_type\n        class(abstract_type), intent(in) :: self\n        type(result_type) :: res\n      end function interface_name\n     end interface\n```\n\n### **Characteristics**\n\n - **deferred** attribute declares an abstract (unimplemented) method.\n - Can only appear in abstract type definitions.\n - Requires an interface specification via procedure(interface_name).\n - Extending non-abstract types must provide implementations.\n - The interface defines the method signature that implementations must match.\n\n### **Description**\n\n **deferred** declares a type-bound procedure that has no implementation in\n the abstract type. It establishes a contract that non-abstract extending\n types must fulfill by providing a concrete implementation. This enables\n polymorphic behavior where different extending types can have different\n implementations of the same method, selected dynamically at runtime based\n on the actual type of the object.\n\n### **Options**\n\n- **interface_name**\n  : The name of an abstract interface that defines the procedure signature.\n  The interface specifies argument types, intents, and return type that\n  all implementations must match.\n\n- **method_name**\n  : The name by which the procedure will be called on objects of the type.\n  Extending types override this using: procedure :: method_name => impl_name\n\n- **abstract interface**\n  : A separate interface block defining the procedure signature. Must use\n  IMPORT to access the abstract type for the CLASS argument.\n\n### **Result**\n\n  An abstract type with a declared method interface that must be implemented\n  by any non-abstract type extending it, enabling polymorphic method dispatch.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_deferred\nimplicit none\n\n  type, abstract :: integrator\n  contains\n    procedure(integrate_interface), deferred :: integrate\n  end type integrator\n\n  abstract interface\n    function integrate_interface(self, f, a, b, n) result(integral)\n      import :: integrator\n      class(integrator), intent(in) :: self\n      interface\n        pure function f(x) result(y)\n          real, intent(in) :: x\n          real :: y\n        end function f\n      end interface\n      real, intent(in) :: a, b\n      integer, intent(in) :: n\n      real :: integral\n    end function integrate_interface\n  end interface\n\n  type, extends(integrator) :: trapezoidal\n  contains\n    procedure :: integrate => trapezoidal_integrate\n  end type trapezoidal\n\n  type, extends(integrator) :: simpson\n  contains\n    procedure :: integrate => simpson_integrate\n  end type simpson\n\n  type(trapezoidal) :: trap\n  type(simpson) :: simp\n  real :: result_trap, result_simp\n\n  ! Integrate x^2 from 0 to 1 (exact = 1/3)\n  result_trap = trap%integrate(square, 0.0, 1.0, 100)\n  result_simp = simp%integrate(square, 0.0, 1.0, 100)\n\n  print '(a,f10.6)', 'Trapezoidal result: ', result_trap\n  print '(a,f10.6)', 'Simpson result:     ', result_simp\n  print '(a,f10.6)', 'Exact value:        ', 1.0/3.0\n\ncontains\n\n  pure function square(x) result(y)\n    real, intent(in) :: x\n    real :: y\n    y = x * x\n  end function square\n\n  function trapezoidal_integrate(self, f, a, b, n) result(integral)\n    class(trapezoidal), intent(in) :: self\n    interface\n      pure function f(x) result(y)\n        real, intent(in) :: x\n        real :: y\n      end function f\n    end interface\n    real, intent(in) :: a, b\n    integer, intent(in) :: n\n    real :: integral\n    real :: h, x\n    integer :: i\n\n    h = (b - a) / real(n)\n    integral = 0.5 * (f(a) + f(b))\n    do i = 1, n-1\n      x = a + real(i) * h\n      integral = integral + f(x)\n    end do\n    integral = integral * h\n  end function trapezoidal_integrate\n\n  function simpson_integrate(self, f, a, b, n) result(integral)\n    class(simpson), intent(in) :: self\n    interface\n      pure function f(x) result(y)\n        real, intent(in) :: x\n        real :: y\n      end function f\n    end interface\n    real, intent(in) :: a, b\n    integer, intent(in) :: n\n    real :: integral\n    real :: h, x\n    integer :: i, nn\n\n    nn = n\n    if (mod(nn, 2) /= 0) nn = nn + 1  ! Ensure even\n    h = (b - a) / real(nn)\n    integral = f(a) + f(b)\n    do i = 1, nn-1\n      x = a + real(i) * h\n      if (mod(i, 2) == 1) then\n        integral = integral + 4.0 * f(x)\n      else\n        integral = integral + 2.0 * f(x)\n      end if\n    end do\n    integral = integral * h / 3.0\n  end function simpson_integrate\n\nend program demo_deferred\n```\nResults:\n```text\nTrapezoidal result:   0.333350\nSimpson result:       0.333333\nExact value:          0.333333\n```\n\n### **Standard**\n\nFortran 2003\n\n**Compatibility Notes:**\n- gfortran 4.5+, Intel Fortran 12.0+, NAG 5.3+\n- Deferred procedures require ABSTRACT interface\n- Must be overridden in non-abstract extensions\n\n### **See Also**\n\n[**abstract**(3)](#abstract),\n[**extends**(3)](#extends),\n[**procedure**(3)](#procedure),\n[**class**(3)](#class)",
  "writefmtmulti": "## write_formatted_multi\n\n### **Name**\n\n**write** - \\[IO:FORMATTED\\] Write multiple variables with explicit format descriptors\n\n### **Synopsis**\n```fortran\n    write(unit, '(format_descriptors)') var1, var2, var3, ...\n```\n```fortran\n     write(unit=unit_num, fmt='(descriptors)', iostat=ios) var_list\n\n      integer, intent(in)            :: unit_num\n      integer, intent(out), optional :: ios\n      ! var_list: multiple variables matching format descriptors\n```\n\n### **Characteristics**\n\n - **unit** is an integer unit number or * for standard output.\n - **format** is a character string with multiple format descriptors.\n - **var_list** contains multiple variables or expressions to output.\n - Format descriptors must match variable types in order and number.\n - Repeat counts can be used for groups of similar data types.\n\n### **Description**\n\n **write** with multiple format descriptors outputs structured data with precise control over field widths, decimal places, and spacing. The format string specifies the exact layout of output data. Common descriptors include:\n\n - **Aw** - Character data (w = width)\n - **Iw** or **Iw.m** - Integer (w = width, m = minimum digits)\n - **Fw.d** - Fixed-point real (w = width, d = decimal places)\n - **Ew.d** - Exponential notation\n - **ESw.d** - Scientific notation\n - **Gw.d** - General format (auto F or E)\n - **Lw** - Logical\n - **nX** - Skip n spaces\n - **/** - New line\n - **'text'** - Literal text\n\n### **Options**\n\n- **unit**\n  : Integer unit number of an open file, or * for standard output.\n\n- **format descriptors**\n  : Comma-separated descriptors within parentheses controlling output layout.\n\n- **var_list**\n  : Variables or expressions to output. Types must match corresponding format descriptors.\n\n- **iostat=** (optional)\n  : Integer variable set to zero on success, positive on error.\n\n### **Result**\n\n  Each expression in the output list is converted to character representation according to its corresponding format descriptor and written to the output record.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_write_multi_format\nimplicit none\n  character(len=20) :: name\n  integer :: id, quantity\n  real :: price, total\n  logical :: available\n\n  ! Initialize data\n  name = 'Widget Pro'\n  id = 1001\n  quantity = 25\n  price = 49.99\n  total = quantity * price\n  available = .true.\n\n  ! Write with multiple format types\n  write(*, '(A20, I6, I8, F10.2, F12.2, L3)') &\n        name, id, quantity, price, total, available\n\n  ! Write with descriptive text embedded\n  write(*, '(A, A, /, A, I0, /, A, F0.2)') &\n        'Product: ', trim(name), &\n        'ID: ', id, &\n        'Price: $', price\n\n  ! Write multiple values with repeat count\n  write(*, '(A, 3I8)') 'Values: ', 100, 200, 300\n\n  ! Write with tab positioning\n  write(*, '(A, T15, A, T30, A)') 'Column1', 'Column2', 'Column3'\n\n  ! Write reals with different formats\n  write(*, '(A, F8.2, A, ES12.4)') &\n        'Fixed: ', price, '  Scientific: ', price\n\nend program demo_write_multi_format\n```\nResults:\n```text\nWidget Pro            1001      25     49.99     1249.75  T\nProduct: Widget Pro\nID: 1001\nPrice: $49.99\nValues:      100     200     300\nColumn1       Column2        Column3\nFixed:    49.99  Scientific: 4.9990E+01\n```\n\n### **Standard**\n\nFortran 77\n\n### **See Also**\n\n[**read**(3)](#read),\n[**write**(3)](#write),\n[**format**(3)](#format),\n[**print**(3)](#print)",
  "pi": "## pi_constant\n\n### **Name**\n\n**pi** - \\[NUMERIC:CONSTANT\\] Define the mathematical constant pi\n\n### **Synopsis**\n```fortran\n    real(dp), parameter :: pi = 4.0_dp * atan(1.0_dp)\n```\n```fortran\n     ! Pi definition using arctangent identity\n\n      integer, parameter :: dp = selected_real_kind(15, 307)\n      real(dp), parameter :: PI = 4.0_dp * atan(1.0_dp)\n```\n\n### **Characteristics**\n\n - Uses the identity pi = 4 * arctan(1) for exact computation.\n - Defined as a PARAMETER for compile-time evaluation.\n - Kind parameter ensures full double precision.\n - Works on all systems regardless of pi literal precision.\n\n### **Description**\n\n **pi** defines the mathematical constant pi (the ratio of a circle's\n circumference to its diameter) using the arctangent identity. This approach\n is portable and provides full precision for the target kind, avoiding issues\n with literal constants that might be truncated.\n\n### **Options**\n\n- **atan(1.0_dp)**\n  : The arctangent of 1.0 equals pi/4 radians (45 degrees). Multiplying by 4\n  gives pi with full precision.\n\n- **dp**\n  : The kind parameter ensuring double precision throughout the calculation.\n\n### **Result**\n\n  A named constant containing the value of pi with full precision for the\n  specified kind.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_pi\nimplicit none\n  integer, parameter :: dp = selected_real_kind(15, 307)\n\n  ! Define pi using arctangent identity (most portable)\n  real(dp), parameter :: PI = 4.0_dp * atan(1.0_dp)\n\n  ! Alternative: use acos(-1) identity\n  real(dp), parameter :: PI_ACOS = acos(-1.0_dp)\n\n  ! Related constants\n  real(dp), parameter :: TWO_PI = 2.0_dp * PI\n  real(dp), parameter :: HALF_PI = PI / 2.0_dp\n  real(dp), parameter :: PI_SQUARED = PI * PI\n  real(dp), parameter :: DEG_TO_RAD = PI / 180.0_dp\n  real(dp), parameter :: RAD_TO_DEG = 180.0_dp / PI\n\n  real(dp) :: angle_deg, angle_rad\n  real(dp) :: radius, circumference, area\n\n  ! Display pi\n  print '(A,F25.20)', 'pi (atan method):  ', PI\n  print '(A,F25.20)', 'pi (acos method):  ', PI_ACOS\n  print '(A,F25.20)', '2*pi:              ', TWO_PI\n  print '(A,F25.20)', 'pi/2:              ', HALF_PI\n  print '(A,F25.20)', 'pi^2:              ', PI_SQUARED\n\n  ! Angle conversion example\n  angle_deg = 45.0_dp\n  angle_rad = angle_deg * DEG_TO_RAD\n  print '(A,F10.4,A,F10.6,A)', 'Angle: ', angle_deg, ' deg = ', angle_rad, ' rad'\n\n  ! Circle calculations\n  radius = 5.0_dp\n  circumference = 2.0_dp * PI * radius\n  area = PI * radius**2\n  print '(A,F10.4)', 'Circle radius: ', radius\n  print '(A,F10.4)', 'Circumference: ', circumference\n  print '(A,F10.4)', 'Area: ', area\n\n  ! Verify Euler's identity: e^(i*pi) + 1 = 0\n  ! |e^(i*pi) + 1| should be very small\n  print '(A,ES15.8)', 'cos(pi) + 1: ', cos(PI) + 1.0_dp\n\nend program demo_pi\n```\nResults:\n```text\npi (atan method):   3.14159265358979311600\npi (acos method):   3.14159265358979311600\n2*pi:               6.28318530717958623200\npi/2:               1.57079632679489655800\npi^2:               9.86960440108935861883\nAngle:    45.0000 deg =   0.785398 rad\nCircle radius:     5.0000\nCircumference:    31.4159\nArea:    78.5398\ncos(pi) + 1:   0.00000000E+00\n```\n\n### **Standard**\n\nFortran 77 (atan), Fortran 90 (kind parameters)\n\n### **See Also**\n\n[**atan**(3)](#atan),\n[**acos**(3)](#acos),\n[**sin**(3)](#sin),\n[**cos**(3)](#cos)",
  "paralleldosimd": "## omp_parallel_do_simd\n\n### **Name**\n\n**omp_parallel_do_simd** - \\[PARALLEL:OPENMP\\] Combined parallel worksharing-loop SIMD construct\n\n### **Synopsis**\n\n```fortran\n    !$omp parallel do simd [clause [[,] clause] ...]\n    do i = start, end [, step]\n      ! loop body (vectorizable operations)\n    end do\n    !$omp end parallel do simd\n```\n\n```fortran\n    !$omp parallel do simd private(list) shared(list) reduction(operator:list)\n    !$omp& simdlen(length) safelen(length) aligned(list:alignment)\n    !$omp& schedule(type [, chunk]) collapse(n) linear(list:step)\n    do index = lower, upper [, stride]\n      ! loop body - distributed across threads and vectorized\n    end do\n    !$omp end parallel do simd\n```\n\n### **Characteristics**\n\n - **private(list)** creates thread-private copies of listed variables.\n - **shared(list)** specifies variables shared among all threads.\n - **reduction(operator:list)** performs a reduction with SIMD-aware implementation.\n - **simdlen(length)** specifies the preferred number of concurrent SIMD lanes.\n - **safelen(length)** specifies the maximum distance for loop-carried dependencies.\n - **aligned(list:alignment)** specifies that list variables have the given alignment.\n - **linear(list:step)** specifies variables that increase linearly with each iteration.\n - **schedule(type [, chunk])** controls how iterations are distributed among threads.\n - **collapse(n)** combines n nested loops before distributing and vectorizing.\n - The loop body must be suitable for SIMD vectorization.\n - An implicit barrier exists at the end of the construct.\n\n### **Description**\n\n **!$omp parallel do simd** creates a parallel region containing a combined worksharing-loop and SIMD construct. Loop iterations are first distributed across threads, then each thread's iterations are vectorized using SIMD instructions. This provides two levels of parallelism: thread-level parallelism from the parallel do and data-level parallelism from SIMD vectorization.\n\n The loop body must be suitable for vectorization: no function calls (unless declared as simd), no I/O operations, no dependencies between SIMD lanes beyond what safelen allows, and operations should be uniform or linear.\n\n### **Options**\n\n- **private(list)**\n  : Creates thread-private copies of listed variables. Within each thread, SIMD lanes may share or privatize these variables depending on the implementation.\n\n- **shared(list)**\n  : Specifies variables shared among all threads. Arrays accessed with the loop index are typically shared.\n\n- **reduction(operator:list)**\n  : Performs a reduction operation. The implementation combines both thread-level and SIMD-level reductions efficiently. Operators: +, -, *, .and., .or., .eqv., .neqv., max, min, iand, ior, ieor.\n\n- **simdlen(length)**\n  : Specifies the preferred number of SIMD lanes. Should match the hardware vector width for best performance (e.g., 4 for SSE with double, 8 for AVX with single).\n\n- **safelen(length)**\n  : Maximum number of iterations that can be executed concurrently without violating dependencies. If there are no loop-carried dependencies, this can be omitted.\n\n- **aligned(list:alignment)**\n  : Declares that array addresses are aligned to the specified byte boundary. Enables aligned vector load/store instructions. Common values: 16 (SSE), 32 (AVX), 64 (AVX-512).\n\n- **linear(list:step)**\n  : Specifies that listed variables have a linear relationship with the loop iteration, incrementing by step each iteration.\n\n- **collapse(n)**\n  : Combines n nested loops into a single iteration space before distributing and vectorizing.\n\n### **Result**\n\n  The parallel do simd construct achieves both thread-level parallelism and SIMD vectorization. Loop iterations are distributed across threads, and each thread processes its iterations using vector instructions. Upon completion, any reduction variables contain the fully combined result from all threads and all SIMD lanes.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_omp_parallel_do_simd\n  use omp_lib\n  implicit none\n  integer, parameter :: n = 10000\n  real(8), allocatable :: a(:), b(:), c(:)\n  real(8) :: sum_val, dot_product_val\n  integer :: i\n\n  allocate(a(n), b(n), c(n))\n\n  ! Initialize arrays\n  do i = 1, n\n    a(i) = real(i, 8) * 0.001d0\n    b(i) = real(n - i + 1, 8) * 0.001d0\n  end do\n\n  ! Parallel do simd: array addition with SIMD vectorization\n  !$omp parallel do simd private(i) shared(a, b, c) simdlen(8)\n  do i = 1, n\n    c(i) = a(i) + b(i)\n  end do\n  !$omp end parallel do simd\n\n  print '(A,F12.6)', 'c(1)   = ', c(1)\n  print '(A,F12.6)', 'c(n)   = ', c(n)\n  print '(A,F12.6)', 'c(n/2) = ', c(n/2)\n\n  ! Parallel do simd with reduction: sum\n  sum_val = 0.0d0\n  !$omp parallel do simd private(i) reduction(+:sum_val)\n  do i = 1, n\n    sum_val = sum_val + c(i)\n  end do\n  !$omp end parallel do simd\n\n  print '(A,F15.6)', 'Sum of c: ', sum_val\n\n  ! Parallel do simd: dot product\n  dot_product_val = 0.0d0\n  !$omp parallel do simd private(i) reduction(+:dot_product_val)\n  do i = 1, n\n    dot_product_val = dot_product_val + a(i) * b(i)\n  end do\n  !$omp end parallel do simd\n\n  print '(A,F15.6)', 'Dot product a.b: ', dot_product_val\n\n  deallocate(a, b, c)\n\nend program demo_omp_parallel_do_simd\n```\n\nCompile with:\n```text\ngfortran -fopenmp -march=native demo_omp_parallel_do_simd.f90 -o demo\nifort -qopenmp -xHost demo_omp_parallel_do_simd.f90 -o demo\n```\n\nResults:\n```text\nc(1)   =    10.001000\nc(n)   =    10.001000\nc(n/2) =    10.001000\nSum of c:   100010.000000\nDot product a.b:   166716.670000\n```\n\n### **Standard**\n\nOpenMP 4.0 (SIMD constructs introduced)\n\n### **See Also**\n\n[**!$omp parallel do**(3)](#omp_parallel_do),\n[**!$omp simd**(3)](#omp_simd),\n[**!$omp declare simd**(3)](#omp_declare_simd),\n[**!$omp parallel**(3)](#omp_parallel),\n[**!$omp do**(3)](#omp_do)\n\n### **Resources**\n\n- [OpenMP 5.0 SIMD Construct](https://www.openmp.org/spec-html/5.0/openmpsu42.html)\n- [Intel OpenMP SIMD Vectorization Guide](https://www.intel.com/content/www/us/en/docs/cpp-compiler/developer-guide-reference/)\n- [OpenMP Official Site](https://www.openmp.org/)",
  "finalize": "## type_destructor\n\n### **Name**\n\n**type_destructor** - \\[STRUCTURE:TYPE\\] Subroutine for derived type cleanup and resource deallocation\n\n### **Synopsis**\n```fortran\n    call type_name_destructor(self)\n```\n```fortran\n     subroutine type_name_destructor(self)\n\n      type(type_name), intent(inout) :: self\n```\n\n### **Characteristics**\n\n - **self** is a derived type instance to be cleaned up.\n - The subroutine deallocates allocatable components to prevent memory leaks.\n - Can be bound to the type as a FINAL procedure for automatic cleanup.\n - Intent(inout) allows modification of the object during cleanup.\n\n### **Description**\n\n **type_destructor** performs cleanup operations on a derived type instance,\n deallocating any allocatable components and releasing resources. When bound\n as a FINAL procedure, it is automatically called when the object goes out\n of scope or is explicitly deallocated.\n\n### **Options**\n\n- **self**\n  : The derived type instance to be destroyed. All allocatable components\n  will be deallocated. The object should not be used after destruction\n  unless reinitialized.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_type_destructor\nimplicit none\n\n  type :: container\n    integer, allocatable :: data(:)\n    character(len=:), allocatable :: name\n  contains\n    final :: container_destructor\n  end type container\n\n  type(container) :: obj\n\n  ! Allocate components\n  allocate(obj%data(100))\n  obj%data = 42\n  obj%name = 'test_container'\n\n  print *, 'Data allocated:', allocated(obj%data)\n  print *, 'Name allocated:', allocated(obj%name)\n\n  ! Manual cleanup (or automatic when obj goes out of scope)\n  call container_destructor(obj)\n\n  print *, 'After destructor:'\n  print *, 'Data allocated:', allocated(obj%data)\n  print *, 'Name allocated:', allocated(obj%name)\n\ncontains\n\n  subroutine container_destructor(self)\n    type(container), intent(inout) :: self\n\n    if (allocated(self%data)) then\n      deallocate(self%data)\n    end if\n\n    if (allocated(self%name)) then\n      deallocate(self%name)\n    end if\n\n  end subroutine container_destructor\n\nend program demo_type_destructor\n```\nResults:\n```text\n Data allocated: T\n Name allocated: T\n After destructor:\n Data allocated: F\n Name allocated: F\n```\n\n### **Standard**\n\nFortran 90 (FINAL procedures: Fortran 2003)\n\n**Compatibility Notes:**\n- gfortran 4.9+, Intel Fortran 15.0+, NAG 6.0+\n- Finalizers called in reverse order of construction\n- Not called for INTENT(OUT) dummy arguments in some compilers\n\n### **See Also**\n\n[**type_constructor**(3)](#type_constructor),\n[**allocate**(3)](#allocate),\n[**deallocate**(3)](#deallocate),\n[**derived_type**(3)](#derived_type)",
  "doconcurrentlocal": "## do_concurrent_local\n\n### **Name**\n\n**do_concurrent_local** - \\[CONTROL:LOOP\\] Execute loop iterations in parallel with explicit locality\n\n### **Synopsis**\n```fortran\n    do concurrent (var = start:end) local(vars) shared(vars)\n```\n```fortran\n     ! DO CONCURRENT with locality specifications\n\n      do concurrent (i = 1:n) local(temp) shared(array)\n        ! loop body\n      end do\n```\n\n### **Characteristics**\n\n - Iterations may execute in any order or simultaneously.\n - **LOCAL** variables are private to each iteration.\n - **SHARED** variables are shared across all iterations.\n - **LOCAL_INIT** creates local copies initialized from the outer scope.\n - No dependencies allowed between iterations.\n\n### **Description**\n\n **do_concurrent_local** executes loop iterations potentially in parallel\n with explicit locality specifications. The LOCAL clause declares variables\n that are private to each iteration. The SHARED clause declares variables\n that are shared (read-only or with atomic operations). This construct\n enables parallelization by making data dependencies explicit.\n\n### **Options**\n\n- **var**\n  : The loop index variable. Implicitly local to each iteration.\n\n- **start:end**\n  : The iteration range (inclusive).\n\n- **LOCAL(vars)**\n  : Variables that are private to each iteration. Each iteration has its own\n  independent copy.\n\n- **LOCAL_INIT(vars)**\n  : Variables that are private to each iteration but initialized with the\n  value from the outer scope.\n\n- **SHARED(vars)**\n  : Variables that are shared across iterations. These should only be read,\n  or written with proper synchronization.\n\n- **DEFAULT(NONE)**\n  : Requires explicit locality specification for all variables (Fortran 2023).\n\n### **Result**\n\n  The loop body executes for each value in the range, potentially in parallel.\n  Results in shared arrays are computed correctly when there are no data races.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_do_concurrent_local\nimplicit none\n  integer, parameter :: n = 1000\n  real :: array(n), result(n)\n  real :: factor\n  integer :: i\n\n  ! Initialize\n  array = [(real(i), i=1,n)]\n  factor = 2.0\n\n  ! DO CONCURRENT with local temporary variable\n  do concurrent (i = 1:n) local(temp) shared(array, result, factor)\n    real :: temp\n    temp = array(i) * factor\n    result(i) = temp + 1.0\n  end do\n\n  print '(A,F10.2)', 'First result: ', result(1)\n  print '(A,F10.2)', 'Last result:  ', result(n)\n\n  ! Multiple index variables\n  block\n    integer :: j\n    real :: matrix(10, 10), squared(10, 10)\n\n    matrix = reshape([(real(i), i=1,100)], [10, 10])\n\n    do concurrent (i = 1:10, j = 1:10)\n      squared(i, j) = matrix(i, j) ** 2\n    end do\n\n    print '(A,F10.2)', 'Matrix(5,5) squared: ', squared(5, 5)\n  end block\n\n  ! With reduction pattern (manual)\n  block\n    real :: partial_sums(n)\n    real :: total\n\n    do concurrent (i = 1:n) shared(array, partial_sums)\n      partial_sums(i) = array(i)\n    end do\n    total = sum(partial_sums)\n    print '(A,F12.2)', 'Sum of array: ', total\n  end block\n\nend program demo_do_concurrent_local\n```\nResults:\n```text\nFirst result:       3.00\nLast result:     2001.00\nMatrix(5,5) squared:    1936.00\nSum of array:    500500.00\n```\n\n### **Standard**\n\nFortran 2008 (basic), Fortran 2018 (locality specifiers)\n\n**Compatibility Notes:**\n- gfortran 9.0+, Intel Fortran 18.0+, NAG 6.2+\n- LOCAL clause specifies loop-private variables\n- Some compilers may not parallelize automatically\n\n### **See Also**\n\n[**do**(3)](#do),\n[**forall**(3)](#forall),\n[**pure**(3)](#pure)",
  "allocarr2d": "## alloc2d\n\n### **Name**\n\n**allocate_2d** - \\[ARRAY:ALLOCATION\\] Dynamically allocate a rank-2 (matrix) array with error handling\n\n### **Synopsis**\n```fortran\n    allocate(array_name(rows, cols), stat=status_variable)\n    if (status_variable /= 0) error stop 'Allocation failed'\n```\n```fortran\n     allocate(matrix(lower1:upper1, lower2:upper2), stat=ierr, errmsg=msg)\n\n      type(TYPE(kind=**)), allocatable :: matrix(:,:)\n      integer                          :: ierr\n      character(len=*)                 :: msg\n```\n\n### **Characteristics**\n\n - **array_name** must be declared with the ALLOCATABLE attribute and assumed-shape bounds (:,:).\n - **rows** and **cols** (or lower:upper bounds) must be scalar integer expressions.\n - **status_variable** must be a scalar default integer variable.\n - The array must not already be allocated when ALLOCATE is executed.\n - Custom lower bounds can be specified using lower:upper syntax.\n - Allocatable arrays are automatically deallocated when they go out of scope.\n\n### **Description**\n\n **allocate** for 2D arrays creates a rank-2 array with specified row and\n column dimensions. This is the standard pattern for dynamically sized\n matrices in Fortran. Always use STAT= for production code to handle\n potential allocation failures gracefully. The error stop with a message\n provides immediate feedback if allocation fails.\n\n### **Options**\n\n- **array_name**\n  : The 2D allocatable array to be allocated. Must be declared as\n  `type, allocatable :: name(:,:)`.\n\n- **rows, cols**\n  : Integer expressions specifying the extent of each dimension.\n  Use lower:upper syntax for custom bounds.\n\n- **stat**\n  : Optional but recommended. Integer variable set to zero on success.\n\n- **errmsg**\n  : Optional. Character variable for descriptive error message.\n\n### **Result**\n\n  A rank-2 array is allocated with the specified shape. The array elements\n  are undefined until assigned. If stat is present and allocation succeeds,\n  it is set to zero.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_alloc2d\n  use, intrinsic :: iso_fortran_env, only: dp => real64\n  implicit none\n\n  real(dp), allocatable :: matrix(:,:)\n  real(dp), allocatable :: grid(:,:)\n  integer :: rows, cols, ierr, i, j\n  character(len=100) :: errmsg\n\n  rows = 3\n  cols = 4\n\n  ! Basic allocation\n  allocate(matrix(rows, cols), stat=ierr)\n  if (ierr /= 0) error stop 'Matrix allocation failed'\n\n  ! Initialize with values\n  matrix = reshape([((i*10 + j, i=1,rows), j=1,cols)], [rows, cols])\n\n  print *, 'Matrix shape:', shape(matrix)\n  print *, 'Matrix contents:'\n  do i = 1, rows\n    print '(4F8.1)', matrix(i, :)\n  end do\n\n  ! Allocation with custom bounds\n  allocate(grid(-1:1, 0:5), stat=ierr, errmsg=errmsg)\n  if (ierr /= 0) error stop errmsg\n\n  print *, 'Grid bounds:', lbound(grid), 'to', ubound(grid)\n\n  deallocate(matrix, grid)\n\nend program demo_alloc2d\n```\nResults:\n```text\n Matrix shape:           3           4\n Matrix contents:\n    11.0    12.0    13.0    14.0\n    21.0    22.0    23.0    24.0\n    31.0    32.0    33.0    34.0\n Grid bounds:          -1           0 to           1           5\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**allocate**](#allocate),\n[**deallocate**](#deallocate),\n[**shape**](#shape),\n[**size**](#size),\n[**allocated**](#allocated)",
  "doconclocal": "## do_concurrent_local\n\n### **Name**\n\n**do_concurrent_local** - \\[CONTROL:LOOP\\] Execute loop iterations in parallel with explicit locality\n\n### **Synopsis**\n```fortran\n    do concurrent (var = start:end) local(vars) shared(vars)\n```\n```fortran\n     ! DO CONCURRENT with locality specifications\n\n      do concurrent (i = 1:n) local(temp) shared(array)\n        ! loop body\n      end do\n```\n\n### **Characteristics**\n\n - Iterations may execute in any order or simultaneously.\n - **LOCAL** variables are private to each iteration.\n - **SHARED** variables are shared across all iterations.\n - **LOCAL_INIT** creates local copies initialized from the outer scope.\n - No dependencies allowed between iterations.\n\n### **Description**\n\n **do_concurrent_local** executes loop iterations potentially in parallel\n with explicit locality specifications. The LOCAL clause declares variables\n that are private to each iteration. The SHARED clause declares variables\n that are shared (read-only or with atomic operations). This construct\n enables parallelization by making data dependencies explicit.\n\n### **Options**\n\n- **var**\n  : The loop index variable. Implicitly local to each iteration.\n\n- **start:end**\n  : The iteration range (inclusive).\n\n- **LOCAL(vars)**\n  : Variables that are private to each iteration. Each iteration has its own\n  independent copy.\n\n- **LOCAL_INIT(vars)**\n  : Variables that are private to each iteration but initialized with the\n  value from the outer scope.\n\n- **SHARED(vars)**\n  : Variables that are shared across iterations. These should only be read,\n  or written with proper synchronization.\n\n- **DEFAULT(NONE)**\n  : Requires explicit locality specification for all variables (Fortran 2023).\n\n### **Result**\n\n  The loop body executes for each value in the range, potentially in parallel.\n  Results in shared arrays are computed correctly when there are no data races.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_do_concurrent_local\nimplicit none\n  integer, parameter :: n = 1000\n  real :: array(n), result(n)\n  real :: factor\n  integer :: i\n\n  ! Initialize\n  array = [(real(i), i=1,n)]\n  factor = 2.0\n\n  ! DO CONCURRENT with local temporary variable\n  do concurrent (i = 1:n) local(temp) shared(array, result, factor)\n    real :: temp\n    temp = array(i) * factor\n    result(i) = temp + 1.0\n  end do\n\n  print '(A,F10.2)', 'First result: ', result(1)\n  print '(A,F10.2)', 'Last result:  ', result(n)\n\n  ! Multiple index variables\n  block\n    integer :: j\n    real :: matrix(10, 10), squared(10, 10)\n\n    matrix = reshape([(real(i), i=1,100)], [10, 10])\n\n    do concurrent (i = 1:10, j = 1:10)\n      squared(i, j) = matrix(i, j) ** 2\n    end do\n\n    print '(A,F10.2)', 'Matrix(5,5) squared: ', squared(5, 5)\n  end block\n\n  ! With reduction pattern (manual)\n  block\n    real :: partial_sums(n)\n    real :: total\n\n    do concurrent (i = 1:n) shared(array, partial_sums)\n      partial_sums(i) = array(i)\n    end do\n    total = sum(partial_sums)\n    print '(A,F12.2)', 'Sum of array: ', total\n  end block\n\nend program demo_do_concurrent_local\n```\nResults:\n```text\nFirst result:       3.00\nLast result:     2001.00\nMatrix(5,5) squared:    1936.00\nSum of array:    500500.00\n```\n\n### **Standard**\n\nFortran 2008 (basic), Fortran 2018 (locality specifiers)\n\n**Compatibility Notes:**\n- gfortran 9.0+, Intel Fortran 18.0+, NAG 6.2+\n- LOCAL clause specifies loop-private variables\n- Some compilers may not parallelize automatically\n\n### **See Also**\n\n[**do**(3)](#do),\n[**forall**(3)](#forall),\n[**pure**(3)](#pure)",
  "int64": "## int64\n\n### **Name**\n\n**int64** - \\[NUMERIC:KIND\\] Declare a 64-bit integer variable\n\n### **Synopsis**\n```fortran\n    use, intrinsic :: iso_fortran_env, only: int64\n    integer(int64) :: variable_name\n```\n```fortran\n     ! 64-bit integer declaration\n\n      use, intrinsic :: iso_fortran_env, only: int64\n      integer(int64) :: variable_name\n```\n\n### **Characteristics**\n\n - **int64** is an integer constant from ISO_FORTRAN_ENV.\n - Provides exactly 64 bits of storage.\n - Range: approximately -9.2 x 10^18 to 9.2 x 10^18.\n - Equivalent to C int64_t type.\n\n### **Description**\n\n **int64** declares a 64-bit integer variable using the ISO_FORTRAN_ENV\n kind constant. This is essential for calculations requiring large integer\n values that exceed the 32-bit range, such as file sizes, large array indices,\n or high-precision counters.\n\n### **Options**\n\n- **int64**\n  : The kind constant for 64-bit integers from ISO_FORTRAN_ENV. Must be\n  accessed via the USE statement.\n\n- **variable_name**\n  : The name of the integer variable being declared.\n\n### **Result**\n\n  An integer variable with exactly 64 bits of storage is declared.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_int64\nuse, intrinsic :: iso_fortran_env, only: int64, int32\nimplicit none\n\n  integer(int64) :: i64, big_number\n  integer(int32) :: i32\n  integer(int64) :: factorial\n\n  ! Verify storage size\n  print '(A,I0)', 'int64 kind value: ', int64\n  print '(A,I0,A)', 'Storage size: ', storage_size(i64), ' bits'\n\n  ! Range\n  print '(A,I0)', 'Maximum value: ', huge(i64)\n\n  ! Large number that overflows int32\n  i32 = 50000\n  i64 = 50000_int64\n\n  print '(A,I0)', '50000 * 50000 (int32): ', i32 * i32  ! Overflow!\n  print '(A,I0)', '50000 * 50000 (int64): ', i64 * i64  ! Correct\n\n  ! Factorial of 20 requires int64\n  factorial = factorial_func(20_int64)\n  print '(A,I0)', '20! = ', factorial\n\n  ! File size example\n  big_number = 5_int64 * 1024_int64 * 1024_int64 * 1024_int64  ! 5 GB\n  print '(A,I0,A)', 'File size: ', big_number, ' bytes (5 GB)'\n\ncontains\n\n  function factorial_func(n) result(fact)\n    integer(int64), intent(in) :: n\n    integer(int64) :: fact\n    integer(int64) :: i\n    fact = 1_int64\n    do i = 2_int64, n\n      fact = fact * i\n    end do\n  end function factorial_func\n\nend program demo_int64\n```\nResults:\n```text\nint64 kind value: 8\nStorage size: 64 bits\nMaximum value: 9223372036854775807\n50000 * 50000 (int32): -1794967296\n50000 * 50000 (int64): 2500000000\n20! = 2432902008176640000\nFile size: 5368709120 bytes (5 GB)\n```\n\n### **Standard**\n\nFortran 2008\n\n**Compatibility Notes:**\n- gfortran 4.4+, Intel Fortran 10.0+, NAG 5.2+\n- From ISO_FORTRAN_ENV module\n- Guaranteed 64-bit integer\n\n### **See Also**\n\n[**iso_fortran_env**(3)](#iso_fortran_env),\n[**int32**(3)](#int32),\n[**selected_int_kind**(3)](#selected_int_kind),\n[**huge**(3)](#huge)",
  "realdp": "## real_dp\n\n### **Name**\n\n**real_dp** - \\[NUMERIC:KIND\\] Declare a double precision real variable\n\n### **Synopsis**\n```fortran\n    real(dp) :: variable_name\n```\n```fortran\n     ! Declaration with kind parameter\n\n      integer, parameter :: dp = selected_real_kind(15, 307)\n      real(dp)           :: variable_name\n```\n\n### **Characteristics**\n\n - **dp** is a kind parameter specifying double precision (typically 64-bit).\n - **variable_name** is the identifier for the declared variable.\n - The kind parameter should be defined using `selected_real_kind` for portability.\n - Default double precision provides approximately 15-17 significant decimal digits.\n\n### **Description**\n\n **real_dp** declares a real variable with double precision. Using kind parameters\n instead of the non-standard `double precision` type ensures portability across\n different compilers and platforms. The dp parameter should be defined as\n `selected_real_kind(15, 307)` to guarantee at least 15 decimal digits of\n precision and an exponent range of at least 10^307.\n\n### **Options**\n\n- **dp**\n  : The kind parameter specifying double precision. Should be defined as\n  `integer, parameter :: dp = selected_real_kind(15, 307)` for portable code.\n  Common alternatives include `kind(1.0d0)` or compiler-specific constants.\n\n- **variable_name**\n  : The name of the variable being declared. Must be a valid Fortran identifier\n  (starts with letter, contains only letters, digits, and underscores).\n\n### **Result**\n\n  A real variable with double precision is declared and available for use.\n  The variable has approximately 15-17 significant decimal digits and an\n  exponent range of approximately +/-307.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_real_dp\nimplicit none\n  ! Define double precision kind parameter\n  integer, parameter :: dp = selected_real_kind(15, 307)\n\n  ! Declare double precision variables\n  real(dp) :: x\n  real(dp) :: pi\n  real(dp) :: result\n\n  ! Initialize with double precision literal\n  pi = 3.141592653589793_dp\n  x = 1.0_dp\n\n  ! Perform calculation\n  result = sin(pi * x)\n\n  print '(A,ES23.16)', 'pi     = ', pi\n  print '(A,ES23.16)', 'sin(pi)= ', result\n  print '(A,I0)',      'kind   = ', kind(x)\n  print '(A,I0)',      'digits = ', precision(x)\n\nend program demo_real_dp\n```\nResults:\n```text\npi     =  3.1415926535897931E+00\nsin(pi)=  1.2246467991473532E-16\nkind   = 8\ndigits = 15\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**selected_real_kind**(3)](#selected_real_kind),\n[**precision**(3)](#precision),\n[**kind**(3)](#kind),\n[**real**(3)](#real)",
  "reshape": "## reshape\n\n### **Name**\n\n**reshape** - \\[ARRAY:MANIPULATION\\] Construct an array with a specified shape from source elements\n\n### **Synopsis**\n```fortran\n    result = reshape(source, shape [, pad] [, order])\n```\n```fortran\n     function reshape(source, shape, pad, order) result(res)\n\n      type(any_type), intent(in) :: source(..)\n      integer, intent(in)        :: shape(:)\n      type(same_as_source), intent(in), optional :: pad(..)\n      integer, intent(in), optional :: order(:)\n      type(same_as_source)       :: res(shape(1), shape(2), ...)\n```\n\n### **Characteristics**\n\n - **source** can be any array of any intrinsic or derived type.\n - **shape** must be a rank-one integer array with size <= 15 and all positive values.\n - **pad** must have the same type and type parameters as **source**.\n - **order** must be a rank-one integer array with the same size as **shape**, containing a permutation of (1, 2, ..., n).\n - The result has the type and type parameters of **source** and shape specified by **shape**.\n\n### **Description**\n\n **reshape** constructs an array with a different shape from an existing array.\n Elements from **source** are placed into the result in array element order\n (column-major, unless modified by **order**). If **source** does not have\n enough elements, **pad** provides additional elements.\n\n This is one of the most versatile array manipulation functions, enabling\n conversion between different array dimensions and layouts.\n\n### **Options**\n\n- **source**\n  : The array supplying elements for the result. Its size must be >=\n  product(shape) if **pad** is absent or has size zero.\n\n- **shape**\n  : A rank-one integer array defining the shape of the result. The product\n  of shape values determines the total number of elements. Maximum rank is 15.\n\n- **pad**\n  : (Optional) An array of the same type as **source** used to fill the\n  result if **source** has insufficient elements. Elements are used\n  repeatedly if necessary.\n\n- **order**\n  : (Optional) A permutation of (1, 2, ..., n) specifying the order in\n  which dimensions are filled. Default is (1, 2, ..., n), meaning\n  column-major order. With order=[2,1], elements fill row-major.\n\n### **Result**\n\n The result is an array of shape **shape** with the same type as **source**.\n Elements are taken from **source** in array element order, followed by\n elements from **pad** (repeated as necessary) if more elements are needed.\n The **order** argument can change the dimension fill order.\n\n### **Examples**\n\n Sample program:\n\n```fortran\nprogram demo_reshape\n  implicit none\n  integer :: i\n  integer :: v(6), a(2, 3), b(3, 2), c(2, 4)\n  integer :: d(3, 3)\n\n  ! Basic reshape: vector to 2x3 matrix\n  v = [1, 2, 3, 4, 5, 6]\n  a = reshape(v, [2, 3])\n  print '(a)', 'Vector to 2x3 (column-major):'\n  do i = 1, 2\n    print '(3i4)', a(i, :)\n  end do\n\n  ! Reshape to different dimensions\n  b = reshape(v, [3, 2])\n  print *\n  print '(a)', 'Vector to 3x2 (column-major):'\n  do i = 1, 3\n    print '(2i4)', b(i, :)\n  end do\n\n  ! Using order for row-major layout\n  a = reshape(v, [2, 3], order=[2, 1])\n  print *\n  print '(a)', 'Vector to 2x3 (row-major via order=[2,1]):'\n  do i = 1, 2\n    print '(3i4)', a(i, :)\n  end do\n\n  ! Using pad when source is too small\n  c = reshape(v, [2, 4], pad=[0, 0])\n  print *\n  print '(a)', '6 elements to 2x4 with pad=0:'\n  do i = 1, 2\n    print '(4i4)', c(i, :)\n  end do\n\n  ! Create identity-like matrix using reshape and pad\n  d = reshape([1, 0, 0, 0, 1, 0, 0, 0, 1], [3, 3])\n  print *\n  print '(a)', '3x3 identity matrix:'\n  do i = 1, 3\n    print '(3i4)', d(i, :)\n  end do\n\n  ! Flatten a 2D array to 1D\n  print *\n  print '(a,6i3)', 'Flattened 2x3 array: ', reshape(a, [6])\n\n  ! Transpose-like operation using reshape + order\n  a = reshape([1, 2, 3, 4, 5, 6], [2, 3])\n  b = reshape(a, [3, 2], order=[2, 1])\n  print *\n  print '(a)', 'Original 2x3:'\n  do i = 1, 2\n    print '(3i4)', a(i, :)\n  end do\n  print '(a)', 'Reshaped to 3x2 with order=[2,1]:'\n  do i = 1, 3\n    print '(2i4)', b(i, :)\n  end do\n\nend program demo_reshape\n```\n\n Results:\n\n```text\nVector to 2x3 (column-major):\n   1   3   5\n   2   4   6\n\nVector to 3x2 (column-major):\n   1   4\n   2   5\n   3   6\n\nVector to 2x3 (row-major via order=[2,1]):\n   1   2   3\n   4   5   6\n\n6 elements to 2x4 with pad=0:\n   1   3   5   0\n   2   4   6   0\n\n3x3 identity matrix:\n   1   0   0\n   0   1   0\n   0   0   1\n\nFlattened 2x3 array:   1  4  2  5  3  6\n\nOriginal 2x3:\n   1   3   5\n   2   4   6\nReshaped to 3x2 with order=[2,1]:\n   1   2\n   3   4\n   5   6\n```\n\n### **Standard**\n\n Fortran 90\n\n### **See Also**\n\n - [**shape**](#shape) - Get the shape of an array\n - [**size**](#size) - Get the total size or extent of an array\n - [**transpose**](#transpose) - Transpose a rank-two array\n - [**spread**](#spread) - Replicate an array by adding a dimension",
  "transpose": "## transpose\n\n### **Name**\n\n**transpose** - \\[ARRAY:MANIPULATION\\] Transpose a rank-two array\n\n### **Synopsis**\n```fortran\n    result = transpose(matrix)\n```\n```fortran\n     function transpose(matrix) result(res)\n\n      type(any_type), intent(in) :: matrix(:,:)\n      type(same_as_matrix)       :: res(size(matrix,2), size(matrix,1))\n```\n\n### **Characteristics**\n\n - **matrix** must be an array of rank two (a matrix) of any type.\n - The result has the same type and type parameters as **matrix**.\n - If **matrix** has shape (n, m), the result has shape (m, n).\n\n### **Description**\n\n **transpose** returns the transpose of **matrix**. Element (i, j) of the result\n equals element (j, i) of **matrix** for all valid (i, j). This interchanges\n rows and columns: the first row of the result is the first column of **matrix**,\n and so on.\n\n Transposition is a fundamental matrix operation used in linear algebra,\n data manipulation, and converting between row-major and column-major layouts.\n\n### **Options**\n\n- **matrix**\n  : A rank-two array of any intrinsic or derived type to be transposed.\n\n### **Result**\n\n The result is an array of rank two with the same type as **matrix**.\n If **matrix** has shape (n, m), the result has shape (m, n).\n Element (i, j) of the result has the value matrix(j, i).\n\n### **Examples**\n\n Sample program:\n\n```fortran\nprogram demo_transpose\n  implicit none\n  integer :: i\n  integer :: a(2, 3), at(3, 2)\n  real :: b(3, 4), bt(4, 3)\n  character(len=1) :: c(2, 3), ct(3, 2)\n\n  ! Integer matrix transpose\n  a = reshape([1, 2, 3, 4, 5, 6], [2, 3])\n  at = transpose(a)\n\n  print '(a)', 'Original 2x3 integer matrix:'\n  do i = 1, 2\n    print '(3i4)', a(i, :)\n  end do\n\n  print *\n  print '(a)', 'Transposed 3x2 matrix:'\n  do i = 1, 3\n    print '(2i4)', at(i, :)\n  end do\n\n  ! Real matrix transpose\n  b = reshape([(real(i)/10.0, i=1,12)], [3, 4])\n  bt = transpose(b)\n\n  print *\n  print '(a)', 'Original 3x4 real matrix:'\n  do i = 1, 3\n    print '(4f6.1)', b(i, :)\n  end do\n\n  print *\n  print '(a)', 'Transposed 4x3 matrix:'\n  do i = 1, 4\n    print '(3f6.1)', bt(i, :)\n  end do\n\n  ! Character matrix transpose\n  c = reshape(['a', 'b', 'c', 'd', 'e', 'f'], [2, 3])\n  ct = transpose(c)\n\n  print *\n  print '(a)', 'Original 2x3 character matrix:'\n  do i = 1, 2\n    print '(3(a2))', c(i, :)\n  end do\n\n  print *\n  print '(a)', 'Transposed 3x2 matrix:'\n  do i = 1, 3\n    print '(2(a2))', ct(i, :)\n  end do\n\n  ! Verify transpose property: transpose(transpose(A)) = A\n  print *\n  print '(a,l)', 'transpose(transpose(a)) equals a: ', &\n    all(transpose(transpose(a)) == a)\n\n  ! Square matrix transpose\n  print *\n  print '(a)', 'Square 3x3 matrix and its transpose:'\n  block\n    integer :: s(3, 3), st(3, 3)\n    s = reshape([(i, i=1,9)], [3, 3])\n    st = transpose(s)\n    print '(a)', 'Original:'\n    do i = 1, 3\n      print '(3i4)', s(i, :)\n    end do\n    print '(a)', 'Transposed:'\n    do i = 1, 3\n      print '(3i4)', st(i, :)\n    end do\n  end block\n\nend program demo_transpose\n```\n\n Results:\n\n```text\nOriginal 2x3 integer matrix:\n   1   3   5\n   2   4   6\n\nTransposed 3x2 matrix:\n   1   2\n   3   4\n   5   6\n\nOriginal 3x4 real matrix:\n   0.1   0.4   0.7   1.0\n   0.2   0.5   0.8   1.1\n   0.3   0.6   0.9   1.2\n\nTransposed 4x3 matrix:\n   0.1   0.2   0.3\n   0.4   0.5   0.6\n   0.7   0.8   0.9\n   1.0   1.1   1.2\n\nOriginal 2x3 character matrix:\n a c e\n b d f\n\nTransposed 3x2 matrix:\n a b\n c d\n e f\n\ntranspose(transpose(a)) equals a:  T\n\nSquare 3x3 matrix and its transpose:\nOriginal:\n   1   4   7\n   2   5   8\n   3   6   9\nTransposed:\n   1   2   3\n   4   5   6\n   7   8   9\n```\n\n### **Standard**\n\n Fortran 90\n\n### **See Also**\n\n - [**reshape**](#reshape) - Construct an array with a specified shape\n - [**matmul**](#matmul) - Matrix multiplication\n - [**cshift**](#cshift) - Circular shift of array elements\n - [**eoshift**](#eoshift) - End-off shift of array elements",
  "pack": "## pack\n\n### **Name**\n\n**pack** - \\[ARRAY:MANIPULATION\\] Pack array elements into a rank-one array under mask control\n\n### **Synopsis**\n```fortran\n    result = pack(array, mask [, vector])\n```\n```fortran\n     function pack(array, mask, vector) result(res)\n\n      type(any_type), intent(in) :: array(..)\n      logical, intent(in)        :: mask(..)\n      type(same_as_array), intent(in), optional :: vector(:)\n      type(same_as_array)        :: res(:)\n```\n\n### **Characteristics**\n\n - **array** can be any array of any intrinsic or derived type.\n - **mask** must be of type logical and conformable with **array** (same shape or scalar).\n - **vector** must be a rank-one array of the same type and type parameters as **array**. If present, its size must be at least the number of .true. elements in **mask**.\n - The result is a rank-one array of the same type and type parameters as **array**.\n\n### **Description**\n\n **pack** gathers elements of **array** into a rank-one (vector) result based on\n a logical **mask**. Elements corresponding to .true. values in **mask** are\n collected in array element order (column-major for multi-dimensional arrays).\n\n If **vector** is present, it determines the size of the result, with elements\n beyond those selected by **mask** filled from **vector**.\n\n### **Options**\n\n- **array**\n  : The source array from which elements are selected. Can be of any type\n  and any rank.\n\n- **mask**\n  : A logical array conformable with **array**, or a scalar logical.\n  Elements of **array** are selected where **mask** is .true.\n  If **mask** is scalar .true., all elements are selected.\n\n- **vector**\n  : (Optional) A rank-one array of the same type as **array** that determines\n  the size of the result. Elements beyond those selected by **mask** are\n  taken from **vector**. Its size must be >= count(mask).\n\n### **Result**\n\n If **vector** is absent, the result is a rank-one array containing the\n elements of **array** corresponding to .true. elements of **mask**, in\n array element order. The size equals count(mask).\n\n If **vector** is present, the result has the same size as **vector**.\n The first count(mask) elements come from **array** (where mask is .true.),\n and the remaining elements come from the corresponding positions in **vector**.\n\n### **Examples**\n\n Sample program:\n\n```fortran\nprogram demo_pack\n  implicit none\n  integer :: i\n  integer :: a(6), b(2, 3)\n  integer, allocatable :: packed(:)\n  logical :: mask(6)\n  real :: values(5), positives(5)\n\n  ! Pack elements matching a condition\n  a = [1, 0, 3, 0, 5, 0]\n  packed = pack(a, a /= 0)\n  print '(a,6i3)',   'Original array:  ', a\n  print '(a,*(i3))', 'Packed nonzeros: ', packed\n\n  ! Pack with explicit mask\n  mask = [.true., .false., .true., .false., .true., .false.]\n  packed = pack(a, mask)\n  print *\n  print '(a,6l3)', 'Mask:            ', mask\n  print '(a,*(i3))', 'Packed by mask:  ', packed\n\n  ! Pack from 2D array (column-major order)\n  b = reshape([1, 2, 3, 4, 5, 6], [2, 3])\n  print *\n  print '(a)', '2D array (2x3):'\n  do i = 1, 2\n    print '(3i4)', b(i, :)\n  end do\n  packed = pack(b, b > 2)\n  print '(a,*(i3))', 'Elements > 2:    ', packed\n\n  ! Using vector argument for fixed-size result\n  a = [10, 0, 30, 0, 50, 0]\n  packed = pack(a, a /= 0, vector=[0, 0, 0, 0, 0])\n  print *\n  print '(a,6i4)', 'Array:               ', a\n  print '(a,5i4)', 'With vector fill:    ', packed\n\n  ! Pack all elements (scalar mask .true.)\n  packed = pack(a, .true.)\n  print '(a,*(i4))', 'Pack all:            ', packed\n\n  ! Practical: gather positive values\n  values = [-1.0, 2.5, -3.0, 4.5, 0.0]\n  print *\n  print '(a,5f6.1)', 'Values:     ', values\n  print '(a,*(f6.1))', 'Positives:  ', pack(values, values > 0.0)\n\nend program demo_pack\n```\n\n Results:\n\n```text\nOriginal array:     1  0  3  0  5  0\nPacked nonzeros:    1  3  5\n\nMask:              T  F  T  F  T  F\nPacked by mask:     1  3  5\n\n2D array (2x3):\n   1   3   5\n   2   4   6\nElements > 2:       3  4  5  6\n\nArray:                10   0  30   0  50   0\nWith vector fill:     10  30  50   0   0\nPack all:              10   0  30   0  50   0\n\nValues:        -1.0   2.5  -3.0   4.5   0.0\nPositives:        2.5   4.5\n```\n\n### **Standard**\n\n Fortran 90\n\n### **See Also**\n\n - [**unpack**](#unpack) - Unpack a vector into an array under mask control\n - [**merge**](#merge) - Merge two arrays under mask control\n - [**spread**](#spread) - Replicate an array by adding a dimension",
  "matmul": "**matmul** - [ARRAY:MATRIX] Performs matrix multiplication of numeric or logical arrays\n\n## Synopsis\n```fortran\nresult = MATMUL(MATRIX_A, MATRIX_B)\n```\n\n### Interface\n```fortran\ninterface matmul\n    function matmul(matrix_a, matrix_b) result(res)\n        ! Matrix-matrix: (n,m) x (m,k) -> (n,k)\n        integer|real|complex, intent(in) :: matrix_a(:,:)\n        integer|real|complex, intent(in) :: matrix_b(:,:)\n        integer|real|complex :: res(size(matrix_a,1), size(matrix_b,2))\n\n        ! Vector-matrix: (m) x (m,k) -> (k)\n        integer|real|complex, intent(in) :: matrix_a(:)\n        integer|real|complex, intent(in) :: matrix_b(:,:)\n        integer|real|complex :: res(size(matrix_b,2))\n\n        ! Matrix-vector: (n,m) x (m) -> (n)\n        integer|real|complex, intent(in) :: matrix_a(:,:)\n        integer|real|complex, intent(in) :: matrix_b(:)\n        integer|real|complex :: res(size(matrix_a,1))\n\n        ! Logical versions follow the same shape rules\n        logical, intent(in) :: matrix_a(:,:), matrix_b(:,:)\n        logical :: res(:,:)\n    end function\nend interface\n```\n\n## Characteristics\n- **Classification**: Transformational function\n- **Type constraints**: Both arguments must be numeric (INTEGER, REAL, COMPLEX) or both must be LOGICAL\n- **Rank constraints**: Arguments must be rank-1 or rank-2; at least one argument must be rank-2 (both cannot be vectors)\n- **Conformability**: The last dimension of MATRIX_A must equal the first dimension of MATRIX_B\n- **Result type**: Array of same type as arguments (following type promotion rules)\n\n## Description\n`MATMUL` performs standard matrix multiplication following linear algebra conventions.\n\n**For numeric types**, the result element C(i,j) is computed as:\n```\nC(i,j) = SUM(A(i,:) * B(:,j))\n       = A(i,1)*B(1,j) + A(i,2)*B(2,j) + ... + A(i,m)*B(m,j)\n```\n\n**For logical types**, the result uses logical operations:\n```\nC(i,j) = ANY(A(i,:) .AND. B(:,j))\n```\n\n### Result Shape Rules\n\n| MATRIX_A Shape | MATRIX_B Shape | Result Shape | Result Rank |\n|----------------|----------------|--------------|-------------|\n| (n, m)         | (m, k)         | (n, k)       | 2           |\n| (m)            | (m, k)         | (k)          | 1           |\n| (n, m)         | (m)            | (n)          | 1           |\n\n**Note**: Both arguments cannot be rank-1 simultaneously.\n\n## Options\n**MATRIX_A**\n: A numeric or logical array of rank 1 or 2. If rank-1, it is treated as a row vector with shape (1, m). The last dimension must match the first dimension of MATRIX_B.\n\n**MATRIX_B**\n: A numeric or logical array of rank 1 or 2. If rank-1, it is treated as a column vector with shape (m, 1). Must be the same type class as MATRIX_A. The first dimension must match the last dimension of MATRIX_A.\n\n## Result\n- **Type**: Numeric or logical array matching the argument types\n- **Rank**: 2 if both arguments are rank-2; 1 if either argument is rank-1\n- **Shape**: Determined by the rules in the table above\n- **Kind**: Follows standard type promotion rules\n\n## Examples\n\n### Example 1: Matrix-Matrix Multiplication\n```fortran\nprogram example_matmul_matrix\n    implicit none\n    integer :: a(2,3), b(3,2), c(2,2)\n    integer :: i, j\n\n    ! Initialize A (2x3 matrix)\n    a = reshape([2,3, 3,4, 4,5], [2,3])\n    ! A = | 2 3 4 |\n    !     | 3 4 5 |\n\n    ! Initialize B (3x2 matrix)\n    b = reshape([2,3,4, 3,4,5], [3,2])\n    ! B = | 2 3 |\n    !     | 3 4 |\n    !     | 4 5 |\n\n    c = matmul(a, b)\n\n    print '(A)', 'Matrix A (2x3):'\n    do i = 1, 2\n        print '(3I4)', (a(i,j), j=1,3)\n    end do\n\n    print '(A)', 'Matrix B (3x2):'\n    do i = 1, 3\n        print '(2I4)', (b(i,j), j=1,2)\n    end do\n\n    print '(A)', 'Result C = A*B (2x2):'\n    do i = 1, 2\n        print '(2I4)', (c(i,j), j=1,2)\n    end do\n    ! C(1,1) = 2*2 + 3*3 + 4*4 = 4+9+16 = 29\n    ! C(1,2) = 2*3 + 3*4 + 4*5 = 6+12+20 = 38\n    ! C(2,1) = 3*2 + 4*3 + 5*4 = 6+12+20 = 38\n    ! C(2,2) = 3*3 + 4*4 + 5*5 = 9+16+25 = 50\nend program example_matmul_matrix\n```\n**Output:**\n```\nMatrix A (2x3):\n   2   3   4\n   3   4   5\nMatrix B (3x2):\n   2   3\n   3   4\n   4   5\nResult C = A*B (2x2):\n  29  38\n  38  50\n```\n\n### Example 2: Vector-Matrix Multiplication\n```fortran\nprogram example_matmul_vec_mat\n    implicit none\n    integer :: x(2), a(2,3), result(3)\n\n    x = [1, 2]\n    a = reshape([2,3, 3,4, 4,5], [2,3])\n    ! A = | 2 3 4 |\n    !     | 3 4 5 |\n\n    result = matmul(x, a)  ! (2) x (2,3) -> (3)\n\n    print '(A,3I4)', 'Vector x = ', x\n    print '(A)', 'Matrix A (2x3):'\n    print '(3I4)', a(1,:)\n    print '(3I4)', a(2,:)\n    print '(A,3I4)', 'x * A = ', result\n    ! result(1) = 1*2 + 2*3 = 8\n    ! result(2) = 1*3 + 2*4 = 11\n    ! result(3) = 1*4 + 2*5 = 14\nend program example_matmul_vec_mat\n```\n**Output:**\n```\nVector x =    1   2\nMatrix A (2x3):\n   2   3   4\n   3   4   5\nx * A =    8  11  14\n```\n\n### Example 3: Matrix-Vector Multiplication\n```fortran\nprogram example_matmul_mat_vec\n    implicit none\n    integer :: a(2,3), y(3), result(2)\n\n    a = reshape([2,3, 3,4, 4,5], [2,3])\n    y = [1, 2, 3]\n\n    result = matmul(a, y)  ! (2,3) x (3) -> (2)\n\n    print '(A)', 'Matrix A (2x3):'\n    print '(3I4)', a(1,:)\n    print '(3I4)', a(2,:)\n    print '(A,3I4)', 'Vector y = ', y\n    print '(A,2I4)', 'A * y = ', result\n    ! result(1) = 2*1 + 3*2 + 4*3 = 2+6+12 = 20\n    ! result(2) = 3*1 + 4*2 + 5*3 = 3+8+15 = 26\nend program example_matmul_mat_vec\n```\n**Output:**\n```\nMatrix A (2x3):\n   2   3   4\n   3   4   5\nVector y =    1   2   3\nA * y =   20  26\n```\n\n### Example 4: Real Matrix Multiplication\n```fortran\nprogram example_matmul_real\n    implicit none\n    real :: a(3,3), b(3,3), c(3,3)\n    integer :: i, j\n\n    ! Identity-like multiplication demo\n    do i = 1, 3\n        do j = 1, 3\n            a(i,j) = real(i + j)\n            b(i,j) = real(i * j)\n        end do\n    end do\n\n    c = matmul(a, b)\n\n    print '(A)', 'Matrix A:'\n    do i = 1, 3\n        print '(3F8.1)', (a(i,j), j=1,3)\n    end do\n\n    print '(A)', 'Matrix B:'\n    do i = 1, 3\n        print '(3F8.1)', (b(i,j), j=1,3)\n    end do\n\n    print '(A)', 'Result C = A*B:'\n    do i = 1, 3\n        print '(3F8.1)', (c(i,j), j=1,3)\n    end do\nend program example_matmul_real\n```\n**Output:**\n```\nMatrix A:\n     2.0     3.0     4.0\n     3.0     4.0     5.0\n     4.0     5.0     6.0\nMatrix B:\n     1.0     2.0     3.0\n     2.0     4.0     6.0\n     3.0     6.0     9.0\nResult C = A*B:\n    20.0    40.0    60.0\n    26.0    52.0    78.0\n    32.0    64.0    96.0\n```\n\n### Example 5: Logical Matrix Multiplication\n```fortran\nprogram example_matmul_logical\n    implicit none\n    logical :: a(2,3), b(3,2), c(2,2)\n\n    a = reshape([.true.,.false., .false.,.true., .true.,.true.], [2,3])\n    b = reshape([.true.,.false.,.true., .false.,.true.,.false.], [3,2])\n\n    c = matmul(a, b)\n\n    print '(A)', 'Logical A:'\n    print '(3L2)', a(1,:)\n    print '(3L2)', a(2,:)\n    print '(A)', 'Logical B:'\n    print '(2L2)', b(1,:)\n    print '(2L2)', b(2,:)\n    print '(2L2)', b(3,:)\n    print '(A)', 'Logical C = A*B:'\n    print '(2L2)', c(1,:)\n    print '(2L2)', c(2,:)\n    ! c(i,j) = ANY(a(i,:) .AND. b(:,j))\nend program example_matmul_logical\n```\n**Output:**\n```\nLogical A:\n T F T\n F T T\nLogical B:\n T F\n F T\n T F\nLogical C = A*B:\n T F\n T T\n```\n\n## Standard\nFortran 90 and later\n\n## See Also\n- **dot_product** - Dot product of two vectors\n- **transpose** - Matrix transpose\n- **reshape** - Reshape an array\n- **sum** - Sum of array elements\n- **product** - Product of array elements",
  "dot_product": "**dot_product** - [ARRAY:MATRIX] Computes the dot product of two vectors\n\n## Synopsis\n```fortran\nresult = DOT_PRODUCT(VECTOR_A, VECTOR_B)\n```\n\n### Interface\n```fortran\ninterface dot_product\n    function dot_product(vector_a, vector_b) result(res)\n        ! For numeric types:\n        integer|real|complex, intent(in) :: vector_a(:)\n        integer|real|complex, intent(in) :: vector_b(:)\n        integer|real|complex :: res  ! scalar\n        ! For logical types:\n        logical, intent(in) :: vector_a(:)\n        logical, intent(in) :: vector_b(:)\n        logical :: res  ! scalar\n    end function\nend interface\n```\n\n## Characteristics\n- **Classification**: Transformational function\n- **Type constraints**: Both arguments must be of the same numeric type (INTEGER, REAL, COMPLEX) or both must be LOGICAL\n- **Rank constraints**: Both arguments must be rank-1 arrays (vectors)\n- **Conformability**: Both vectors must have the same size (number of elements)\n- **Result type**: Scalar of the same type and kind as the arguments (after type promotion if kinds differ)\n\n## Description\n`DOT_PRODUCT` computes the inner product (dot product) of two vectors. The mathematical operation depends on the argument types:\n\n**Numeric types (INTEGER, REAL)**:\n```\nresult = SUM(VECTOR_A * VECTOR_B)\nresult = a1*b1 + a2*b2 + ... + an*bn\n```\n\n**Complex types**:\n```\nresult = SUM(CONJG(VECTOR_A) * VECTOR_B)\nresult = conjg(a1)*b1 + conjg(a2)*b2 + ... + conjg(an)*bn\n```\nThis computes the Hermitian inner product, conjugating the first argument.\n\n**Logical types**:\n```\nresult = ANY(VECTOR_A .AND. VECTOR_B)\n```\nReturns `.TRUE.` if any corresponding pair of elements are both `.TRUE.`.\n\n## Options\n**VECTOR_A**\n: A rank-1 array of numeric (INTEGER, REAL, COMPLEX) or LOGICAL type. For complex dot products, this is the vector that gets conjugated.\n\n**VECTOR_B**\n: A rank-1 array with the same type class and size as VECTOR_A. Must be numeric if VECTOR_A is numeric, or LOGICAL if VECTOR_A is LOGICAL.\n\n## Result\n- **Type**: Scalar (rank-0) of the same type as the arguments\n- **Kind**: Follows standard type promotion rules when argument kinds differ\n- **Value**: The dot product as defined above for each type\n\n## Examples\n\n### Example 1: Integer Dot Product\n```fortran\nprogram example_dot_product_int\n    implicit none\n    integer, dimension(3) :: a, b\n    integer :: result\n\n    a = [1, 2, 3]\n    b = [4, 5, 6]\n\n    result = dot_product(a, b)\n    print '(A,I0)', 'Integer dot product: ', result\n    ! Calculation: 1*4 + 2*5 + 3*6 = 4 + 10 + 18 = 32\nend program example_dot_product_int\n```\n**Output:**\n```\nInteger dot product: 32\n```\n\n### Example 2: Real Dot Product\n```fortran\nprogram example_dot_product_real\n    implicit none\n    real, dimension(5) :: a, b\n    real :: result\n    integer :: i\n\n    a = [(real(i), i=1,5)]       ! [1.0, 2.0, 3.0, 4.0, 5.0]\n    b = [(real(i*2), i=1,5)]    ! [2.0, 4.0, 6.0, 8.0, 10.0]\n\n    result = dot_product(a, b)\n    print '(A,F8.1)', 'Real dot product: ', result\n    ! Calculation: 1*2 + 2*4 + 3*6 + 4*8 + 5*10 = 2+8+18+32+50 = 110\nend program example_dot_product_real\n```\n**Output:**\n```\nReal dot product:    110.0\n```\n\n### Example 3: Complex Dot Product (Hermitian)\n```fortran\nprogram example_dot_product_complex\n    implicit none\n    complex, dimension(2) :: a, b\n    complex :: result\n\n    a = [(1.0, 2.0), (3.0, 4.0)]   ! [1+2i, 3+4i]\n    b = [(5.0, 6.0), (7.0, 8.0)]   ! [5+6i, 7+8i]\n\n    result = dot_product(a, b)\n    print '(A,2F8.1)', 'Complex dot product: ', real(result), aimag(result)\n    ! Calculation: conjg(1+2i)*(5+6i) + conjg(3+4i)*(7+8i)\n    !            = (1-2i)*(5+6i) + (3-4i)*(7+8i)\n    !            = (5+6i-10i+12) + (21+24i-28i+32)\n    !            = (17-4i) + (53-4i) = 70-8i\nend program example_dot_product_complex\n```\n**Output:**\n```\nComplex dot product:     70.0    -8.0\n```\n\n### Example 4: Logical Dot Product\n```fortran\nprogram example_dot_product_logical\n    implicit none\n    logical, dimension(4) :: a, b\n    logical :: result\n\n    a = [.true., .false., .true., .false.]\n    b = [.false., .false., .true., .true.]\n\n    result = dot_product(a, b)\n    print '(A,L1)', 'Logical dot product: ', result\n    ! Calculation: ANY([F,F,T,F]) = .TRUE.\n    ! (Only position 3 has both .TRUE.)\nend program example_dot_product_logical\n```\n**Output:**\n```\nLogical dot product: T\n```\n\n## Standard\nFortran 90 and later\n\n## See Also\n- **matmul** - Matrix multiplication\n- **sum** - Sum of array elements\n- **product** - Product of array elements\n- **conjg** - Complex conjugate\n- **any** - Logical OR reduction",
  "maxloc": "## maxloc\n\n### **Name**\n\n**maxloc** - \\[ARRAY:LOCATION\\] Determine the location of the maximum value in an array\n\n### **Synopsis**\n```fortran\n    result = maxloc(array)\n    result = maxloc(array, mask)\n    result = maxloc(array, dim, mask)\n```\n```fortran\n     function maxloc(array, dim, mask) result(indices)\n\n      type(integer|real), intent(in) :: array(..)\n      integer, intent(in), optional  :: dim\n      logical, intent(in), optional  :: mask(..)\n      integer                        :: indices(..)\n```\n\n### **Characteristics**\n\n - **ARRAY** must be an array of intrinsic numeric type (INTEGER or REAL).\n - **DIM** must be a scalar integer with value in range 1 to n, where n is the rank of ARRAY.\n - **MASK** must be a logical array conformable with ARRAY.\n - The result is an array of default INTEGER type.\n - When DIM is absent, the result is a rank-one array with length equal to the rank of ARRAY.\n - When DIM is present, the result has rank one less than ARRAY.\n\n### **Description**\n\n **MAXLOC** determines the location of the element in the array with the\n maximum value. If the DIM argument is supplied, MAXLOC determines the\n locations of the maximum element along each row of the array in the DIM\n direction. If MASK is present, only elements for which MASK is .TRUE.\n are considered.\n\n### **Options**\n\n- **ARRAY**\n  : An array of intrinsic numeric type (INTEGER or REAL) to search for the\n  maximum value. This argument is required.\n\n- **DIM**\n  : A scalar integer indicating which dimension to search along. Must be a\n  value between 1 and the rank of ARRAY. When specified, the function\n  returns the locations of maxima along that dimension rather than the\n  location of the overall maximum. NOTE: The DIM argument was added in\n  Fortran 95.\n\n- **MASK**\n  : A logical array conformable with ARRAY. Only elements of ARRAY\n  corresponding to .TRUE. elements of MASK are considered. If all elements\n  of MASK are .FALSE., the result is an array of zeros.\n\n### **Result**\n\n  If DIM is absent, the result is a rank-one integer array with length\n  equal to the rank of ARRAY. The values are the subscripts of the location\n  of the maximum value.\n\n  If DIM is present, the result is an integer array with rank one less than\n  ARRAY. Each element contains the subscript along dimension DIM where the\n  maximum occurs in that particular row/column/etc.\n\n  If ARRAY has zero size, or all elements of MASK are .FALSE., the result\n  is an array of zeros.\n\n  If more than one element has the maximum value, the location of the first\n  such element in array element order is returned.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_maxloc\n  implicit none\n  integer :: i\n  integer, save :: ints(3,5) = reshape([&\n       1,  2,  3,  4,  5, &\n      10, 20, 30, 40, 50, &\n      11, 22, 33, 44, 55  &\n    ], shape(ints), order=[2,1])\n\n  ! Display the array\n  print '(A)', 'Array ints:'\n  do i = 1, 3\n    print '(5I4)', ints(i,:)\n  end do\n  print *\n\n  ! Location of overall maximum (55 at position 3,5)\n  print '(A,2I3)', 'maxloc(ints) = ', maxloc(ints)\n\n  ! Maximum location in each column (along dim=1)\n  print '(A,5I3)', 'maxloc(ints, dim=1) = ', maxloc(ints, dim=1)\n\n  ! Maximum location in each row (along dim=2)\n  print '(A,3I3)', 'maxloc(ints, dim=2) = ', maxloc(ints, dim=2)\n\n  ! With mask: find maximum among values less than 40\n  print '(A,2I3)', 'maxloc(ints, mask=ints<40) = ', &\n                   maxloc(ints, mask=ints < 40)\n\n  ! Simple 1D example\n  print '(A,I3)', 'maxloc([3,7,4,7]) = ', maxloc([3, 7, 4, 7])\n\nend program demo_maxloc\n```\nResults:\n```text\nArray ints:\n   1   2   3   4   5\n  10  20  30  40  50\n  11  22  33  44  55\n\nmaxloc(ints) =   3  5\nmaxloc(ints, dim=1) =   3  3  3  3  3\nmaxloc(ints, dim=2) =   5  5  5\nmaxloc(ints, mask=ints<40) =   3  3\nmaxloc([3,7,4,7]) =   2\n```\n\n### **Standard**\n\nFortran 90 (ARRAY and MASK arguments)\n\nFortran 95 added the DIM argument for consistency with MAXVAL and MINVAL.\n\nFortran 2003 added support for CHARACTER arrays and the KIND argument.\n\nFortran 2008 added the BACK argument.\n\n### **See Also**\n\n[**minloc**(3)](#minloc),\n[**maxval**(3)](#maxval),\n[**max**(3)](#max),\n[**findloc**(3)](#findloc)",
  "minloc": "## minloc\n\n### **Name**\n\n**minloc** - \\[ARRAY:LOCATION\\] Determine the location of the minimum value in an array\n\n### **Synopsis**\n```fortran\n    result = minloc(array)\n    result = minloc(array, mask)\n    result = minloc(array, dim, mask)\n```\n```fortran\n     function minloc(array, dim, mask) result(indices)\n\n      type(integer|real), intent(in) :: array(..)\n      integer, intent(in), optional  :: dim\n      logical, intent(in), optional  :: mask(..)\n      integer                        :: indices(..)\n```\n\n### **Characteristics**\n\n - **ARRAY** must be an array of intrinsic numeric type (INTEGER or REAL).\n - **DIM** must be a scalar integer with value in range 1 to n, where n is the rank of ARRAY.\n - **MASK** must be a logical array conformable with ARRAY.\n - The result is an array of default INTEGER type.\n - When DIM is absent, the result is a rank-one array with length equal to the rank of ARRAY.\n - When DIM is present, the result has rank one less than ARRAY.\n\n### **Description**\n\n **MINLOC** determines the location of the element in the array with the\n minimum value. If the DIM argument is supplied, MINLOC determines the\n locations of the minimum element along each row of the array in the DIM\n direction. If MASK is present, only elements for which MASK is .TRUE.\n are considered.\n\n### **Options**\n\n- **ARRAY**\n  : An array of intrinsic numeric type (INTEGER or REAL) to search for the\n  minimum value. This argument is required.\n\n- **DIM**\n  : A scalar integer indicating which dimension to search along. Must be a\n  value between 1 and the rank of ARRAY. When specified, the function\n  returns the locations of minima along that dimension rather than the\n  location of the overall minimum. NOTE: The DIM argument was added in\n  Fortran 95.\n\n- **MASK**\n  : A logical array conformable with ARRAY. Only elements of ARRAY\n  corresponding to .TRUE. elements of MASK are considered. If all elements\n  of MASK are .FALSE., the result is an array of zeros.\n\n### **Result**\n\n  If DIM is absent, the result is a rank-one integer array with length\n  equal to the rank of ARRAY. The values are the subscripts of the location\n  of the minimum value.\n\n  If DIM is present, the result is an integer array with rank one less than\n  ARRAY. Each element contains the subscript along dimension DIM where the\n  minimum occurs in that particular row/column/etc.\n\n  If ARRAY has zero size, or all elements of MASK are .FALSE., the result\n  is an array of zeros.\n\n  If more than one element has the minimum value, the location of the first\n  such element in array element order is returned.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_minloc\n  implicit none\n  integer :: i\n  integer, save :: ints(3,5) = reshape([&\n       4, 10,  1,  7, 13, &\n       9, 15,  6, 12,  3, &\n      14,  5, 11,  2,  8  &\n    ], shape(ints), order=[2,1])\n\n  ! Display the array\n  print '(A)', 'Array ints:'\n  do i = 1, 3\n    print '(5I4)', ints(i,:)\n  end do\n  print *\n\n  ! Location of overall minimum (1 at position 1,3)\n  print '(A,2I3)', 'minloc(ints) = ', minloc(ints)\n\n  ! Minimum location in each column (along dim=1)\n  print '(A,5I3)', 'minloc(ints, dim=1) = ', minloc(ints, dim=1)\n\n  ! Minimum location in each row (along dim=2)\n  print '(A,3I3)', 'minloc(ints, dim=2) = ', minloc(ints, dim=2)\n\n  ! With mask: find minimum among values greater than 10\n  print '(A,2I3)', 'minloc(ints, mask=ints>10) = ', &\n                   minloc(ints, mask=ints > 10)\n\n  ! Simple 1D example\n  print '(A,I3)', 'minloc([3,1,4,1]) = ', minloc([3, 1, 4, 1])\n\nend program demo_minloc\n```\nResults:\n```text\nArray ints:\n   4  10   1   7  13\n   9  15   6  12   3\n  14   5  11   2   8\n\nminloc(ints) =   1  3\nminloc(ints, dim=1) =   1  3  1  3  2\nminloc(ints, dim=2) =   3  5  4\nminloc(ints, mask=ints>10) =   1  5\nminloc([3,1,4,1]) =   2\n```\n\n### **Standard**\n\nFortran 90 (ARRAY and MASK arguments)\n\nFortran 95 added the DIM argument for consistency with MAXVAL and MINVAL.\n\nFortran 2003 added support for CHARACTER arrays and the KIND argument.\n\nFortran 2008 added the BACK argument.\n\n### **See Also**\n\n[**maxloc**(3)](#maxloc),\n[**minval**(3)](#minval),\n[**min**(3)](#min),\n[**findloc**(3)](#findloc)",
  "size": {
    "name": "**size** - [ARRAY:INQUIRY] Return the total number of elements or extent of an array",
    "synopsis": {
      "usage": "```fortran\nresult = size(array)\nresult = size(array, dim)\nresult = size(array, dim, kind)\n```",
      "interface": "```fortran\ninteger(kind=KIND) function size(array, dim, kind)\n\n  type(*), intent(in) :: array(..)\n  integer, intent(in), optional :: dim\n  integer, intent(in), optional :: kind\n```"
    },
    "characteristics": [
      "**array** shall be an array of any type. It cannot be an unallocated allocatable or disassociated pointer.",
      "**dim** is an optional scalar integer with value in range 1 to n, where n is the rank of **array**.",
      "**kind** is an optional scalar integer constant expression (Fortran 2003).",
      "If **dim** is absent, the result is a scalar equal to the total number of elements.",
      "If **dim** is present, the result is a scalar equal to the extent along that dimension.",
      "The result kind is **kind** if present, otherwise default integer kind."
    ],
    "description": "**size** returns the total number of elements in an array, or the extent (number of elements) along a specified dimension. When called without the **dim** argument, it returns the product of all extents. When **dim** is specified, it returns only the extent along that dimension. This function is fundamental for array processing, particularly when writing procedures that need to know the size of array arguments. Note that for assumed-size arrays (declared with `*` as the last dimension), **size** cannot determine the extent of the last dimension unless **dim** is specified with a value less than the array rank.",
    "options": {
      "array": "The array whose size or extent is to be determined. Must be an array of any type. If it is an allocatable array, it must be allocated. If it is a pointer, it must be associated. For assumed-size arrays, **dim** must be present with a value less than the rank.",
      "dim": "A scalar integer specifying which dimension's extent to return. Must be in the range 1 to n where n is the rank of **array**. If absent, the total number of elements is returned.",
      "kind": "A scalar integer constant expression specifying the kind of the result. If absent, the result is of default integer kind. Available in Fortran 2003 and later. Useful when array sizes may exceed the range of default integers."
    },
    "result": "If **dim** is absent, returns a scalar integer equal to the total number of elements in **array** (equivalent to `product(shape(array))`). If **dim** is present, returns a scalar integer equal to the extent (number of elements) along dimension **dim** (equivalent to `shape(array)(dim)`).",
    "examples": {
      "code": "program demo_size\n  implicit none\n  integer :: a(5)\n  integer :: b(3, 4)\n  integer :: c(2, 3, 4)\n  integer, allocatable :: d(:,:)\n  real :: matrix(10, 20, 30)\n\n  ! 1D array\n  print '(A)', '1D array a(5):'\n  print '(A,I0)', '  size(a) = ', size(a)\n\n  ! 2D array\n  print '(A)', '2D array b(3,4):'\n  print '(A,I0)', '  size(b)    = ', size(b)\n  print '(A,I0)', '  size(b, 1) = ', size(b, 1)\n  print '(A,I0)', '  size(b, 2) = ', size(b, 2)\n\n  ! 3D array\n  print '(A)', '3D array c(2,3,4):'\n  print '(A,I0)', '  size(c)    = ', size(c)\n  print '(A,I0)', '  size(c, 1) = ', size(c, 1)\n  print '(A,I0)', '  size(c, 2) = ', size(c, 2)\n  print '(A,I0)', '  size(c, 3) = ', size(c, 3)\n\n  ! Allocatable array\n  allocate(d(4, 5))\n  print '(A)', 'Allocatable d(4,5):'\n  print '(A,I0)', '  size(d) = ', size(d)\n\n  ! Large array - total elements\n  print '(A)', 'Large array matrix(10,20,30):'\n  print '(A,I0)', '  size(matrix) = ', size(matrix)\n  print '(A,I0,A,I0,A,I0)', '  10 * 20 * 30 = ', 10, ' * ', 20*30, ' = ', 10*20*30\n\n  ! Common use: loop bounds\n  print '(A)', 'Using size for loop bounds:'\n  call fill_array(b)\n\n  ! Relationship with shape\n  print '(A)', 'Relationships:'\n  print '(A,L1)', '  size(c) == product(shape(c)): ', size(c) == product(shape(c))\n  print '(A,L1)', '  size(c,1) == shape(c)(1): ', size(c,1) == shape(c)(1)\n\n  deallocate(d)\n\ncontains\n\n  subroutine fill_array(arr)\n    integer, intent(inout) :: arr(:,:)\n    integer :: i, j\n    do j = 1, size(arr, 2)\n      do i = 1, size(arr, 1)\n        arr(i, j) = i + (j - 1) * size(arr, 1)\n      end do\n    end do\n    print '(A,I0,A,I0,A)', '  Filled array of size ', &\n          size(arr,1), ' x ', size(arr,2), ' using size()'\n  end subroutine\n\nend program demo_size",
      "results": "```text\n1D array a(5):\n  size(a) = 5\n2D array b(3,4):\n  size(b)    = 12\n  size(b, 1) = 3\n  size(b, 2) = 4\n3D array c(2,3,4):\n  size(c)    = 24\n  size(c, 1) = 2\n  size(c, 2) = 3\n  size(c, 3) = 4\nAllocatable d(4,5):\n  size(d) = 20\nLarge array matrix(10,20,30):\n  size(matrix) = 6000\n  10 * 20 * 30 = 10 * 600 = 6000\nUsing size for loop bounds:\n  Filled array of size 3 x 4 using size()\nRelationships:\n  size(c) == product(shape(c)): T\n  size(c,1) == shape(c)(1): T\n```"
    },
    "standard": "Fortran 90; KIND argument Fortran 2003",
    "see_also": [
      "[**shape**](#shape) - Return the shape of an array",
      "[**lbound**](#lbound) - Return lower dimension bounds",
      "[**ubound**](#ubound) - Return upper dimension bounds",
      "[**allocated**](#allocated) - Check if allocatable is allocated"
    ]
  },
  "shape": {
    "name": "**shape** - [ARRAY:INQUIRY] Return the shape of an array or scalar",
    "synopsis": {
      "usage": "```fortran\nresult = shape(source)\nresult = shape(source, kind)\n```",
      "interface": "```fortran\ninteger(kind=KIND) function shape(source, kind)\n\n  type(*), intent(in) :: source(..)\n  integer, intent(in), optional :: kind\n```"
    },
    "characteristics": [
      "**source** shall be an array or scalar of any type.",
      "If **source** is a pointer, it must be associated.",
      "If **source** is allocatable, it must be allocated.",
      "**kind** is an optional scalar integer constant expression (Fortran 2003).",
      "The result is a rank-one integer array of size equal to the rank of **source**.",
      "For a scalar **source**, the result is a zero-size array."
    ],
    "description": "**shape** returns the shape of an array (or scalar) as a rank-one integer array. The shape is the vector of extents (number of elements) along each dimension. For an array of rank n, the result is an integer array of size n where each element gives the extent along the corresponding dimension. For a scalar, the result is a zero-size array (since scalars have rank 0). The shape is independent of the actual bounds - only the extents matter.",
    "options": {
      "source": "The array or scalar whose shape is to be determined. Can be of any type. If it is an allocatable array, it must be allocated. If it is a pointer, it must be associated. Cannot be an assumed-size array.",
      "kind": "A scalar integer constant expression specifying the kind of the result. If absent, the result is of default integer kind. Available in Fortran 2003 and later."
    },
    "result": "A rank-one integer array with size equal to the rank of **source**. Each element contains the extent (number of elements) along the corresponding dimension of **source**. For a scalar, returns a zero-size array. The result is independent of the declared bounds - an array dimensioned as `(-1:1, 0:3)` has the same shape as one dimensioned as `(1:3, 1:4)`, namely `(/ 3, 4 /)`.",
    "examples": {
      "code": "program demo_shape\n  implicit none\n  integer :: a(2, 3)\n  integer :: b(-1:1, -1:2)\n  real :: c(2, 3, 4)\n  integer :: scalar\n  integer, allocatable :: d(:,:,:)\n\n  ! Basic 2D array\n  print '(A)', '2D array a(2,3):'\n  print '(A,2I4)', '  shape(a) = ', shape(a)\n\n  ! Array with non-default bounds - same shape!\n  print '(A)', '2D array b(-1:1, -1:2):'\n  print '(A,2I4)', '  shape(b) = ', shape(b)\n  print '(A)', '  Note: b has 3x4 = 12 elements, same as a has 2x3 = 6?'\n  print '(A)', '  Actually b has 3x4 = 12 elements'\n\n  ! 3D array\n  print '(A)', '3D array c(2,3,4):'\n  print '(A,3I4)', '  shape(c) = ', shape(c)\n  print '(A,I0)', '  rank = size(shape(c)) = ', size(shape(c))\n\n  ! Scalar - returns zero-size array\n  print '(A)', 'Scalar:'\n  print '(A,I0)', '  size(shape(scalar)) = ', size(shape(scalar))\n\n  ! Allocatable array\n  allocate(d(2, 3, 4))\n  print '(A)', 'Allocatable d(2,3,4):'\n  print '(A,3I4)', '  shape(d) = ', shape(d)\n\n  ! Using shape for array construction\n  print '(A)', 'Using shape with reshape:'\n  a = reshape([1,2,3,4,5,6], shape(a))\n  print '(A)', '  a = reshape([1,2,3,4,5,6], shape(a))'\n  print '(A,6I4)', '  a = ', a\n\n  ! Relationship: product(shape) = size\n  print '(A)', 'Relationship: product(shape(c)) = size(c)'\n  print '(A,I0,A,I0)', '  ', product(shape(c)), ' = ', size(c)\n\n  deallocate(d)\n\nend program demo_shape",
      "results": "```text\n2D array a(2,3):\n  shape(a) =    2   3\n2D array b(-1:1, -1:2):\n  shape(b) =    3   4\n  Note: b has 3x4 = 12 elements, same as a has 2x3 = 6?\n  Actually b has 3x4 = 12 elements\n3D array c(2,3,4):\n  shape(c) =    2   3   4\n  rank = size(shape(c)) = 3\nScalar:\n  size(shape(scalar)) = 0\nAllocatable d(2,3,4):\n  shape(d) =    2   3   4\nUsing shape with reshape:\n  a = reshape([1,2,3,4,5,6], shape(a))\n  a =    1   2   3   4   5   6\nRelationship: product(shape(c)) = size(c)\n  24 = 24\n```"
    },
    "standard": "Fortran 90; KIND argument Fortran 2003",
    "see_also": [
      "[**size**](#size) - Return the total number of elements or extent",
      "[**lbound**](#lbound) - Return lower dimension bounds",
      "[**ubound**](#ubound) - Return upper dimension bounds",
      "[**reshape**](#reshape) - Reshape an array"
    ]
  },
  "lbound": {
    "name": "**lbound** - [ARRAY:INQUIRY] Return lower dimension bounds of an array",
    "synopsis": {
      "usage": "```fortran\nresult = lbound(array)\nresult = lbound(array, dim)\nresult = lbound(array, dim, kind)\n```",
      "interface": "```fortran\ninteger(kind=KIND) function lbound(array, dim, kind)\n\n  type(*), intent(in) :: array(..)\n  integer, intent(in), optional :: dim\n  integer, intent(in), optional :: kind\n```"
    },
    "characteristics": [
      "**array** shall be an array of any type. It cannot be an unallocated allocatable or disassociated pointer.",
      "**dim** is an optional scalar integer with value in range 1 to n, where n is the rank of **array**.",
      "**kind** is an optional scalar integer constant expression (Fortran 2003).",
      "If **dim** is absent, the result is a rank-one array of size equal to the rank of **array**.",
      "If **dim** is present, the result is a scalar.",
      "The result kind is **kind** if present, otherwise default integer kind."
    ],
    "description": "**lbound** returns the lower bounds of an array, or a single lower bound along a specified dimension. For a whole array or array structure component, the lower bound is as declared. However, for an array expression (such as an array section or function result), the lower bound is always 1. This is important when working with array sections where the bounds may differ from the parent array. For an array with zero extent along the relevant dimension, the lower bound is taken to be 1.",
    "options": {
      "array": "The array whose lower bounds are to be determined. Must be an array of any type. If it is an allocatable array, it must be allocated. If it is a pointer array, it must be associated. Cannot be an assumed-size array unless **dim** is present with a value less than the rank of the array.",
      "dim": "A scalar integer specifying which dimension's lower bound to return. Must be in the range 1 to n where n is the rank of **array**. If absent, an array of all lower bounds is returned.",
      "kind": "A scalar integer constant expression specifying the kind of the result. If absent, the result is of default integer kind. Available in Fortran 2003 and later."
    },
    "result": "If **dim** is absent, the result is a rank-one integer array with size equal to the rank of **array**. Element i of the result contains the lower bound of dimension i. If **dim** is present, the result is a scalar integer representing the lower bound along that dimension. For array expressions (not whole arrays), the lower bound is always 1.",
    "examples": {
      "code": "program demo_lbound\n  implicit none\n  integer :: a(5:10)\n  integer :: b(-3:3, 0:5)\n  integer :: c(2:4, -1:1, 0:2)\n  integer, allocatable :: d(:,:)\n\n  ! 1D array with explicit lower bound\n  print '(A)', '1D array a(5:10):'\n  print '(A,I0)', '  lbound(a) = ', lbound(a, 1)\n  print '(A,I0)', '  size(a)   = ', size(a)\n\n  ! 2D array with explicit bounds\n  print '(A)', '2D array b(-3:3, 0:5):'\n  print '(A,2I4)', '  lbound(b)    = ', lbound(b)\n  print '(A,I0)',  '  lbound(b, 1) = ', lbound(b, 1)\n  print '(A,I0)',  '  lbound(b, 2) = ', lbound(b, 2)\n\n  ! 3D array\n  print '(A)', '3D array c(2:4, -1:1, 0:2):'\n  print '(A,3I4)', '  lbound(c) = ', lbound(c)\n\n  ! Allocatable array - bounds set at allocation\n  allocate(d(0:4, -2:2))\n  print '(A)', 'Allocatable d(0:4, -2:2):'\n  print '(A,2I4)', '  lbound(d) = ', lbound(d)\n\n  ! IMPORTANT: Array sections always have lbound = 1\n  print '(A)', 'Array section a(6:8):'\n  print '(A,I0)', '  lbound(a(6:8), 1) = ', lbound(a(6:8), 1)\n\n  ! Array expression - always lbound = 1\n  print '(A)', 'Array expression b(:,1:3):'\n  print '(A,2I4)', '  lbound(b(:,1:3)) = ', lbound(b(:,1:3))\n\n  deallocate(d)\n\nend program demo_lbound",
      "results": "```text\n1D array a(5:10):\n  lbound(a) = 5\n  size(a)   = 6\n2D array b(-3:3, 0:5):\n  lbound(b)    =   -3   0\n  lbound(b, 1) = -3\n  lbound(b, 2) = 0\n3D array c(2:4, -1:1, 0:2):\n  lbound(c) =    2  -1   0\nAllocatable d(0:4, -2:2):\n  lbound(d) =    0  -2\nArray section a(6:8):\n  lbound(a(6:8), 1) = 1\nArray expression b(:,1:3):\n  lbound(b(:,1:3)) =    1   1\n```"
    },
    "standard": "Fortran 90; KIND argument Fortran 2003",
    "see_also": [
      "[**ubound**](#ubound) - Return upper dimension bounds of an array",
      "[**shape**](#shape) - Return the shape of an array",
      "[**size**](#size) - Return the total number of elements or extent"
    ]
  },
  "ubound": {
    "name": "**ubound** - [ARRAY:INQUIRY] Return upper dimension bounds of an array",
    "synopsis": {
      "usage": "```fortran\nresult = ubound(array)\nresult = ubound(array, dim)\nresult = ubound(array, dim, kind)\n```",
      "interface": "```fortran\ninteger(kind=KIND) function ubound(array, dim, kind)\n\n  type(*), intent(in) :: array(..)\n  integer, intent(in), optional :: dim\n  integer, intent(in), optional :: kind\n```"
    },
    "characteristics": [
      "**array** shall be an array of any type. It cannot be an unallocated allocatable or disassociated pointer.",
      "**dim** is an optional scalar integer with value in range 1 to n, where n is the rank of **array**.",
      "**kind** is an optional scalar integer constant expression (Fortran 2003).",
      "If **dim** is absent, the result is a rank-one array of size equal to the rank of **array**.",
      "If **dim** is present, the result is a scalar.",
      "The result kind is **kind** if present, otherwise default integer kind."
    ],
    "description": "**ubound** returns the upper bounds of an array, or a single upper bound along a specified dimension. For a whole array or array structure component, the upper bound is as declared. For an array expression (such as an array section or function result), the upper bound equals the number of elements along that dimension (since lower bound is 1 for expressions). For an array with zero extent along the relevant dimension, the upper bound is taken to be zero (one less than the lower bound of 1).",
    "options": {
      "array": "The array whose upper bounds are to be determined. Must be an array of any type. If it is an allocatable array, it must be allocated. If it is a pointer array, it must be associated. Cannot be an assumed-size array unless **dim** is present with a value less than the rank of the array.",
      "dim": "A scalar integer specifying which dimension's upper bound to return. Must be in the range 1 to n where n is the rank of **array**. If absent, an array of all upper bounds is returned.",
      "kind": "A scalar integer constant expression specifying the kind of the result. If absent, the result is of default integer kind. Available in Fortran 2003 and later."
    },
    "result": "If **dim** is absent, the result is a rank-one integer array with size equal to the rank of **array**. Element i of the result contains the upper bound of dimension i. If **dim** is present, the result is a scalar integer representing the upper bound along that dimension. For array expressions, the upper bound equals the extent (number of elements) along that dimension.",
    "examples": {
      "code": "program demo_ubound\n  implicit none\n  integer :: a(5:10)\n  integer :: b(-3:3, 0:5)\n  integer :: c(2:4, -1:1, 0:2)\n  integer, allocatable :: d(:,:)\n\n  ! 1D array with explicit bounds\n  print '(A)', '1D array a(5:10):'\n  print '(A,I0)', '  ubound(a) = ', ubound(a, 1)\n  print '(A,I0)', '  size(a)   = ', size(a)\n\n  ! 2D array with explicit bounds\n  print '(A)', '2D array b(-3:3, 0:5):'\n  print '(A,2I4)', '  ubound(b)    = ', ubound(b)\n  print '(A,I0)',  '  ubound(b, 1) = ', ubound(b, 1)\n  print '(A,I0)',  '  ubound(b, 2) = ', ubound(b, 2)\n\n  ! 3D array\n  print '(A)', '3D array c(2:4, -1:1, 0:2):'\n  print '(A,3I4)', '  ubound(c) = ', ubound(c)\n\n  ! Allocatable array\n  allocate(d(0:4, -2:2))\n  print '(A)', 'Allocatable d(0:4, -2:2):'\n  print '(A,2I4)', '  ubound(d) = ', ubound(d)\n\n  ! Array section - ubound = size of section (since lbound = 1)\n  print '(A)', 'Array section a(6:8):'\n  print '(A,I0)', '  ubound(a(6:8), 1) = ', ubound(a(6:8), 1)\n  print '(A,I0)', '  size(a(6:8))      = ', size(a(6:8))\n\n  ! Demonstrate lbound/ubound relationship\n  print '(A)', 'Relationship for b:'\n  print '(A,I0)', '  ubound(b,1) - lbound(b,1) + 1 = ', &\n                   ubound(b,1) - lbound(b,1) + 1\n  print '(A,I0)', '  size(b,1) = ', size(b, 1)\n\n  deallocate(d)\n\nend program demo_ubound",
      "results": "```text\n1D array a(5:10):\n  ubound(a) = 10\n  size(a)   = 6\n2D array b(-3:3, 0:5):\n  ubound(b)    =    3   5\n  ubound(b, 1) = 3\n  ubound(b, 2) = 5\n3D array c(2:4, -1:1, 0:2):\n  ubound(c) =    4   1   2\nAllocatable d(0:4, -2:2):\n  ubound(d) =    4   2\nArray section a(6:8):\n  ubound(a(6:8), 1) = 3\n  size(a(6:8))      = 3\nRelationship for b:\n  ubound(b,1) - lbound(b,1) + 1 = 7\n  size(b,1) = 7\n```"
    },
    "standard": "Fortran 90; KIND argument Fortran 2003",
    "see_also": [
      "[**lbound**](#lbound) - Return lower dimension bounds of an array",
      "[**shape**](#shape) - Return the shape of an array",
      "[**size**](#size) - Return the total number of elements or extent"
    ]
  },
  "allocated": {
    "name": "**allocated** - [ARRAY:INQUIRY] Determine if an allocatable array is allocated",
    "synopsis": {
      "usage": "```fortran\nresult = allocated(array)\nresult = allocated(scalar)\n```",
      "interface": "```fortran\nlogical function allocated(array)\n\n  type(*), allocatable, intent(in) :: array(..)\n  ! or\n  type(*), allocatable, intent(in) :: scalar\n```"
    },
    "characteristics": [
      "**array** must be an allocatable array of any type.",
      "**scalar** must be an allocatable scalar of any type (Fortran 2003).",
      "The result is a default logical scalar.",
      "The argument must have the ALLOCATABLE attribute.",
      "This is an inquiry function; the argument need not be defined."
    ],
    "description": "**allocated** checks whether an allocatable entity (array or scalar) has been allocated memory via the ALLOCATE statement. It returns `.TRUE.` if the entity is currently allocated, and `.FALSE.` otherwise. This function is essential for defensive programming when working with allocatable variables, allowing you to check allocation status before attempting to use or deallocate the variable. The function does not require the argument to be defined - only that it have the ALLOCATABLE attribute.",
    "options": {
      "array": "An allocatable array of any type and rank. The array must have the ALLOCATABLE attribute in its declaration. The function checks whether this array currently has storage associated with it.",
      "scalar": "An allocatable scalar of any type (Fortran 2003 and later). The scalar must have the ALLOCATABLE attribute. This extension allows checking allocation status of scalar allocatable variables."
    },
    "result": "Returns a default logical value: `.TRUE.` if the argument is currently allocated (has storage associated with it), `.FALSE.` if the argument is not allocated. The result is always a scalar of default logical kind.",
    "examples": {
      "code": "program demo_allocated\n  implicit none\n  real, allocatable :: x(:)\n  real, allocatable :: matrix(:,:)\n  integer :: i, n\n\n  ! Check before first allocation\n  print '(A,L1)', 'x allocated initially: ', allocated(x)\n\n  ! Safe allocation pattern\n  if (.not. allocated(x)) then\n    allocate(x(10))\n    print '(A)', 'Allocated x(10)'\n  end if\n\n  print '(A,L1)', 'x allocated after allocate: ', allocated(x)\n\n  ! Initialize the array\n  x = [(real(i), i = 1, 10)]\n  print '(A,10F5.1)', 'x = ', x\n\n  ! Safe deallocation pattern\n  if (allocated(x)) then\n    deallocate(x)\n    print '(A)', 'Deallocated x'\n  end if\n\n  print '(A,L1)', 'x allocated after deallocate: ', allocated(x)\n\n  ! Demonstrate with 2D array\n  n = 3\n  if (.not. allocated(matrix)) then\n    allocate(matrix(n, n))\n  end if\n  print '(A,L1)', 'matrix allocated: ', allocated(matrix)\n  print '(A,I0,A,I0)', 'matrix shape: ', size(matrix,1), ' x ', size(matrix,2)\n\n  if (allocated(matrix)) deallocate(matrix)\n\nend program demo_allocated",
      "results": "```text\nx allocated initially: F\nAllocated x(10)\nx allocated after allocate: T\nx = 1.0  2.0  3.0  4.0  5.0  6.0  7.0  8.0  9.0 10.0\nDeallocated x\nx allocated after deallocate: F\nmatrix allocated: T\nmatrix shape: 3 x 3\n```"
    },
    "standard": "Fortran 90 (arrays); Fortran 2003 (scalars)",
    "see_also": [
      "[**allocate**](#allocate) - Allocate storage for allocatable variables",
      "[**deallocate**](#deallocate) - Free storage for allocatable variables",
      "[**associated**](#associated) - Check pointer association status",
      "[**move_alloc**](#move_alloc) - Move allocation between variables"
    ]
  },
  "unpack": "## unpack\n\n### **Name**\n\n**unpack** - \\[ARRAY:MANIPULATION\\] Scatter vector elements into an array under mask control\n\n### **Synopsis**\n```fortran\n    result = unpack(vector, mask, field)\n```\n```fortran\n     function unpack(vector, mask, field) result(res)\n\n      type(any_type), intent(in) :: vector(:)\n      logical, intent(in)        :: mask(..)\n      type(same_as_vector), intent(in) :: field(..)\n      type(same_as_vector)       :: res(shape_of_mask)\n```\n\n### **Characteristics**\n\n - **vector** must be a rank-one array of any intrinsic or derived type with size >= count(mask).\n - **mask** must be a logical array of any shape.\n - **field** must have the same type as **vector** and be conformable with **mask** (same shape or scalar).\n - The result has the same type as **vector** and the same shape as **mask**.\n\n### **Description**\n\n **unpack** scatters elements from a rank-one **vector** into an array with\n the shape of **mask**. Elements of **vector** are placed at positions where\n **mask** is .true., in array element order. Positions where **mask** is .false.\n receive the corresponding value from **field**.\n\n This is the inverse operation of **pack**. Together, pack and unpack enable\n gathering selected elements for processing, then scattering results back.\n\n### **Options**\n\n- **vector**\n  : A rank-one array containing the values to scatter. Must have at least\n  as many elements as there are .true. values in **mask**.\n\n- **mask**\n  : A logical array defining where to place **vector** elements (.true.\n  positions) and where to use **field** values (.false. positions).\n\n- **field**\n  : An array or scalar of the same type as **vector** providing values for\n  positions where **mask** is .false. If scalar, that value fills all\n  .false. positions.\n\n### **Result**\n\n The result has the same shape as **mask** and the same type as **vector**.\n Position (i,j,...) of the result is:\n - vector(k) if mask(i,j,...) is the k-th .true. element of mask\n - field(i,j,...) if mask(i,j,...) is .false.\n\n### **Examples**\n\n Sample program:\n\n```fortran\nprogram demo_unpack\n  implicit none\n  integer :: i\n  integer :: v(3), result2d(2, 3)\n  integer :: field2d(2, 3)\n  logical :: mask2d(2, 3)\n\n  ! Basic unpack: scatter vector into 2D array\n  v = [10, 20, 30]\n  mask2d = reshape([.true., .false., .false., .true., .true., .false.], [2, 3])\n  field2d = 0\n\n  result2d = unpack(v, mask2d, field2d)\n\n  print '(a)', 'Mask (2x3):'\n  do i = 1, 2\n    print '(3l4)', mask2d(i, :)\n  end do\n\n  print *\n  print '(a,3i4)', 'Vector:       ', v\n  print *\n  print '(a)', 'Unpacked result (2x3):'\n  do i = 1, 2\n    print '(3i4)', result2d(i, :)\n  end do\n\n  ! Using scalar field value\n  result2d = unpack(v, mask2d, -1)\n  print *\n  print '(a)', 'With scalar field=-1:'\n  do i = 1, 2\n    print '(3i4)', result2d(i, :)\n  end do\n\n  ! Preserve existing array values\n  field2d = reshape([1, 2, 3, 4, 5, 6], [2, 3])\n  result2d = unpack(v, mask2d, field2d)\n  print *\n  print '(a)', 'Field array (2x3):'\n  do i = 1, 2\n    print '(3i4)', field2d(i, :)\n  end do\n  print *\n  print '(a)', 'Unpacked with field preservation:'\n  do i = 1, 2\n    print '(3i4)', result2d(i, :)\n  end do\n\n  ! Demonstrate pack/unpack roundtrip\n  print *\n  print '(a)', 'Pack/Unpack roundtrip:'\n  block\n    integer :: original(2, 3), processed(3), restored(2, 3)\n    logical :: m(2, 3)\n\n    original = reshape([1, 2, 3, 4, 5, 6], [2, 3])\n    m = original > 2  ! Select elements > 2\n\n    print '(a)', 'Original array:'\n    do i = 1, 2\n      print '(3i4)', original(i, :)\n    end do\n\n    ! Pack elements > 2\n    processed = pack(original, m)\n    print '(a,*(i4))', 'Packed (>2):  ', processed\n\n    ! Double the packed values\n    processed = processed * 2\n    print '(a,*(i4))', 'Doubled:      ', processed\n\n    ! Unpack back, keeping original values where mask is false\n    restored = unpack(processed, m, original)\n    print '(a)', 'Restored (doubled where >2):'\n    do i = 1, 2\n      print '(3i4)', restored(i, :)\n    end do\n  end block\n\n  ! Create sparse matrix\n  print *\n  print '(a)', 'Create sparse matrix with unpack:'\n  block\n    integer :: diag(3), sparse(3, 3)\n    logical :: diag_mask(3, 3)\n\n    diag = [1, 2, 3]\n    diag_mask = reshape([ &\n      .true., .false., .false., &\n      .false., .true., .false., &\n      .false., .false., .true.], [3, 3])\n\n    sparse = unpack(diag, diag_mask, 0)\n    print '(a)', 'Diagonal matrix:'\n    do i = 1, 3\n      print '(3i4)', sparse(i, :)\n    end do\n  end block\n\nend program demo_unpack\n```\n\n Results:\n\n```text\nMask (2x3):\n   T   F   T\n   F   T   F\n\nVector:         10  20  30\n\nUnpacked result (2x3):\n  10   0  30\n   0  20   0\n\nWith scalar field=-1:\n  10  -1  30\n  -1  20  -1\n\nField array (2x3):\n   1   3   5\n   2   4   6\n\nUnpacked with field preservation:\n  10   3  30\n   2  20   6\n\nPack/Unpack roundtrip:\nOriginal array:\n   1   3   5\n   2   4   6\nPacked (>2):     3   4   5   6\nDoubled:         6   8  10  12\nRestored (doubled where >2):\n   1   6  10\n   2   8  12\n\nCreate sparse matrix with unpack:\nDiagonal matrix:\n   1   0   0\n   0   2   0\n   0   0   3\n```\n\n### **Standard**\n\n Fortran 90\n\n### **See Also**\n\n - [**pack**](#pack) - Pack array elements into a rank-one array under mask control\n - [**merge**](#merge) - Merge two arrays under mask control\n - [**spread**](#spread) - Replicate an array by adding a dimension\n - [**reshape**](#reshape) - Construct an array with a specified shape",
  "sum": "**sum** - [ARRAY:REDUCTION] Compute the sum of array elements\n\n## Synopsis\n```fortran\nresult = sum(array)\nresult = sum(array, dim)\nresult = sum(array, mask)\nresult = sum(array, dim, mask)\n```\n\n### Interface\n```fortran\ninterface sum\n  pure function sum(array, dim, mask) result(res)\n    type(numeric), intent(in) :: array(..)\n    integer, intent(in), optional :: dim\n    logical, intent(in), optional :: mask(..)\n    type(numeric) :: res  ! same type/kind as array\n  end function sum\nend interface\n```\n\n## Characteristics\n- **array** must be integer, real, or complex type\n- **dim** is an integer scalar in range 1 <= dim <= rank(array)\n- **mask** is a logical array conformable with **array**\n- Result has same type and kind as **array**\n- Result is scalar when **dim** is absent\n- Result is array of rank n-1 when **dim** is present\n\n## Description\n`sum(array)` returns the sum of all elements in **array**, or of those elements selected by **mask** if present.\n\nWhen **dim** is specified, sums are computed along that dimension, returning an array of partial sums.\n\nFor empty arrays or when **mask** has no true elements, the result is 0 (the additive identity).\n\nThis is one of the most commonly used array reduction functions, essential for statistical calculations, numerical methods, and data analysis.\n\n## Options\n- **array** (required): Numeric array whose elements are to be summed.\n- **dim** (optional): Dimension along which to compute sums. Must be between 1 and rank of **array**.\n- **mask** (optional): Logical array selecting which elements to include. Must be conformable with **array**.\n\n## Result\n- If **dim** is absent: scalar sum of all (selected) elements\n- If **dim** is present: array of rank n-1 with sums along each slice\n- For empty sets: returns 0 (additive identity)\n\n## Examples\n\n### Example 1: Basic summation\n```fortran\nprogram example_sum_basic\n  implicit none\n  integer :: x(5) = [1, 2, 3, 4, 5]\n  real :: y(4) = [1.5, 2.5, 3.5, 4.5]\n  \n  print *, 'Integer sum:', sum(x)  ! Output: 15\n  print *, 'Real sum:', sum(y)     ! Output: 12.0\nend program example_sum_basic\n```\n\n### Example 2: Using DIM with 2D array\n```fortran\nprogram example_sum_dim\n  implicit none\n  integer :: matrix(2,3)\n  \n  matrix = reshape([4, 7, 2, 8, 3, 5], [2,3])\n  ! Matrix:\n  !   4  2  3\n  !   7  8  5\n  \n  print *, 'Total sum:', sum(matrix)            ! Output: 29\n  print *, 'Column sums:', sum(matrix, dim=1)   ! Output: 11 10 8\n  print *, 'Row sums:', sum(matrix, dim=2)      ! Output: 9 20\nend program example_sum_dim\n```\n\n### Example 3: Using MASK for conditional sum\n```fortran\nprogram example_sum_mask\n  implicit none\n  integer :: values(10) = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  \n  print *, 'Sum of all:', sum(values)                    ! Output: 55\n  print *, 'Sum of odds:', sum(values, mask=mod(values,2)==1)   ! Output: 25\n  print *, 'Sum of evens:', sum(values, mask=mod(values,2)==0)  ! Output: 30\n  print *, 'Sum > 5:', sum(values, mask=values > 5)      ! Output: 40\nend program example_sum_mask\n```\n\n### Example 4: Statistical calculations\n```fortran\nprogram example_sum_statistics\n  implicit none\n  real :: data(10) = [23.5, 18.2, 31.7, 25.0, 19.8, &\n                      27.3, 22.1, 29.6, 24.4, 20.9]\n  real :: mean_val, variance, std_dev\n  integer :: n\n  \n  n = size(data)\n  mean_val = sum(data) / real(n)\n  variance = sum((data - mean_val)**2) / real(n)\n  std_dev = sqrt(variance)\n  \n  print '(A,F7.2)', 'Mean:     ', mean_val\n  print '(A,F7.2)', 'Variance: ', variance\n  print '(A,F7.2)', 'Std Dev:  ', std_dev\nend program example_sum_statistics\n```\nOutput:\n```\nMean:       24.25\nVariance:   17.05\nStd Dev:     4.13\n```\n\n### Example 5: Weighted sum\n```fortran\nprogram example_sum_weighted\n  implicit none\n  real :: grades(5) = [85.0, 90.0, 78.0, 92.0, 88.0]\n  real :: weights(5) = [0.10, 0.20, 0.15, 0.25, 0.30]\n  real :: weighted_avg\n  \n  weighted_avg = sum(grades * weights)\n  print '(A,F6.2)', 'Weighted average: ', weighted_avg\nend program example_sum_weighted\n```\nOutput:\n```\nWeighted average:  87.80\n```\n\n### Example 6: Matrix operations\n```fortran\nprogram example_sum_matrix\n  implicit none\n  real :: A(3,3), row_sums(3), col_sums(3)\n  real :: trace_val\n  integer :: i\n  \n  A = reshape([1.0, 4.0, 7.0, 2.0, 5.0, 8.0, 3.0, 6.0, 9.0], [3,3])\n  ! A:\n  !   1  2  3\n  !   4  5  6\n  !   7  8  9\n  \n  row_sums = sum(A, dim=2)  ! Sum across columns\n  col_sums = sum(A, dim=1)  ! Sum across rows\n  \n  ! Trace (sum of diagonal elements)\n  trace_val = sum([(A(i,i), i=1,3)])\n  \n  print *, 'Row sums:', row_sums\n  print *, 'Col sums:', col_sums\n  print *, 'Trace:', trace_val\nend program example_sum_matrix\n```\nOutput:\n```\n Row sums:   6.0  15.0  24.0\n Col sums:  12.0  15.0  18.0\n Trace:  15.0\n```\n\n## Standard\nFortran 90\n\n## See Also\n- **product** - Product of array elements\n- **count** - Count true elements\n- **dot_product** - Vector dot product\n- **matmul** - Matrix multiplication",
  "product": "**product** - [ARRAY:REDUCTION] Compute the product of array elements\n\n## Synopsis\n```fortran\nresult = product(array)\nresult = product(array, dim)\nresult = product(array, mask)\nresult = product(array, dim, mask)\n```\n\n### Interface\n```fortran\ninterface product\n  pure function product(array, dim, mask) result(res)\n    type(numeric), intent(in) :: array(..)\n    integer, intent(in), optional :: dim\n    logical, intent(in), optional :: mask(..)\n    type(numeric) :: res  ! same type/kind as array\n  end function product\nend interface\n```\n\n## Characteristics\n- **array** must be integer, real, or complex type\n- **dim** is an integer scalar in range 1 <= dim <= rank(array)\n- **mask** is a logical array conformable with **array**\n- Result has same type and kind as **array**\n- Result is scalar when **dim** is absent\n- Result is array of rank n-1 when **dim** is present\n\n## Description\n`product(array)` returns the product of all elements in **array**, or of those elements selected by **mask** if present.\n\nWhen **dim** is specified, products are computed along that dimension, returning an array of results.\n\nFor empty arrays or when **mask** has no true elements, the result is 1 (the multiplicative identity).\n\n## Options\n- **array** (required): Numeric array whose elements are to be multiplied.\n- **dim** (optional): Dimension along which to compute products.\n- **mask** (optional): Logical array selecting which elements to include. Must be conformable with **array**.\n\n## Result\n- If **dim** is absent: scalar product of all (selected) elements\n- If **dim** is present: array of rank n-1 with products along each slice\n- For empty sets: returns 1 (multiplicative identity)\n\n## Examples\n\n### Example 1: Basic product (factorial)\n```fortran\nprogram example_product_basic\n  implicit none\n  integer :: n\n  \n  n = 5\n  print *, '5! =', product([(i, i=1,n, integer :: i)])  ! Output: 120\n  \n  print *, 'Product of 1-10:', product([(i, i=1,10, integer :: i)])\nend program example_product_basic\n```\n\n### Example 2: Using DIM with 2D array\n```fortran\nprogram example_product_dim\n  implicit none\n  integer :: matrix(2,3)\n  \n  matrix = reshape([1, 2, 3, 4, 5, 6], [2,3])\n  ! Matrix:\n  !   1  3  5\n  !   2  4  6\n  \n  print *, 'Total product:', product(matrix)           ! Output: 720\n  print *, 'Product per column:', product(matrix, dim=1)  ! Output: 2 12 30\n  print *, 'Product per row:', product(matrix, dim=2)     ! Output: 15 48\nend program example_product_dim\n```\n\n### Example 3: Using MASK for conditional product\n```fortran\nprogram example_product_mask\n  implicit none\n  integer :: values(6) = [2, 3, 0, 4, 5, 1]\n  \n  print *, 'Product of all:', product(values)  ! Output: 0\n  print *, 'Product of non-zero:', product(values, mask=values /= 0)\n  ! Output: 120\n  \n  print *, 'Product of evens:', product(values, mask=mod(values,2)==0)\n  ! Output: 0 (includes the zero)\nend program example_product_mask\n```\n\n### Example 4: Computing array size from shape\n```fortran\nprogram example_product_shape\n  implicit none\n  real :: tensor(3,4,5)\n  integer :: total_elements\n  \n  total_elements = product(shape(tensor))\n  print *, 'Total elements:', total_elements  ! Output: 60\n  print *, 'Verify with size:', size(tensor)  ! Output: 60\nend program example_product_shape\n```\n\n### Example 5: Empty set returns identity\n```fortran\nprogram example_product_empty\n  implicit none\n  real :: arr(0)  ! Zero-size array\n  real :: arr2(5) = [1.0, 2.0, 3.0, 4.0, 5.0]\n  \n  print *, 'Empty array product:', product(arr)  ! Output: 1.0\n  print *, 'No mask matches:', product(arr2, mask=arr2 > 100.0)\n  ! Output: 1.0 (identity for multiplication)\nend program example_product_empty\n```\n\n### Example 6: Combinatorics\n```fortran\nprogram example_product_combinatorics\n  implicit none\n  integer :: n, r\n  integer(8) :: perm, comb\n  \n  n = 10\n  r = 3\n  \n  ! Permutations P(n,r) = n!/(n-r)!\n  perm = product([(int(i,8), i=n-r+1,n)])\n  print *, 'P(10,3) =', perm  ! Output: 720\n  \n  ! Combinations via falling factorial / r!\n  comb = perm / product([(int(i,8), i=1,r)])\n  print *, 'C(10,3) =', comb  ! Output: 120\nend program example_product_combinatorics\n```\n\n## Standard\nFortran 90\n\n## See Also\n- **sum** - Sum array elements\n- **maxval** - Maximum value in array\n- **minval** - Minimum value in array\n- **dot_product** - Vector dot product",
  "maxval": "**maxval** - [ARRAY:REDUCTION] Determine the maximum value in an array\n\n## Synopsis\n```fortran\nresult = maxval(array)\nresult = maxval(array, dim)\nresult = maxval(array, mask)\nresult = maxval(array, dim, mask)\n```\n\n### Interface\n```fortran\ninterface maxval\n  pure function maxval(array, dim, mask) result(res)\n    type(numeric), intent(in) :: array(..)\n    integer, intent(in), optional :: dim\n    logical, intent(in), optional :: mask(..)\n    type(numeric) :: res  ! same type/kind as array\n  end function maxval\nend interface\n```\n\n## Characteristics\n- **array** must be integer, real, or character type\n- **dim** is an integer scalar in range 1 <= dim <= rank(array)\n- **mask** is a logical array conformable with **array**\n- Result has same type and kind as **array**\n- Result is scalar when **dim** is absent\n- Result is array of rank n-1 when **dim** is present\n\n## Description\n`maxval(array)` returns the maximum value of all elements in **array**, or of those elements selected by **mask** if present.\n\nWhen **dim** is specified, maximum values are computed along that dimension, returning an array of results.\n\nFor empty arrays or when **mask** has no true elements, the result is `-huge(array)` for numeric types, or a string of null characters (char(0)) for character type.\n\n## Options\n- **array** (required): Array of integer, real, or character type to search for maximum.\n- **dim** (optional): Dimension along which to find maxima. Cannot be an optional dummy argument.\n- **mask** (optional): Logical array selecting which elements to consider. Must be conformable with **array**.\n\n## Result\n- If **dim** is absent: scalar maximum value\n- If **dim** is present: array of rank n-1 containing maximum along each slice\n- For empty sets: returns `-huge(array)` (most negative representable value)\n\n## Examples\n\n### Example 1: Basic maximum\n```fortran\nprogram example_maxval_basic\n  implicit none\n  integer :: a(5) = [3, 1, 4, 1, 5]\n  real :: b(4) = [2.7, 1.8, 3.14, 0.5]\n  \n  print *, 'Max integer:', maxval(a)   ! Output: 5\n  print *, 'Max real:', maxval(b)      ! Output: 3.14\nend program example_maxval_basic\n```\n\n### Example 2: Using DIM with 2D array\n```fortran\nprogram example_maxval_dim\n  implicit none\n  integer :: matrix(2,3)\n  \n  matrix = reshape([1, 4, 5, 2, 3, 6], [2,3])\n  ! Matrix:\n  !   1  5  3\n  !   4  2  6\n  \n  print *, 'Overall max:', maxval(matrix)           ! Output: 6\n  print *, 'Max per column:', maxval(matrix, dim=1) ! Output: 4 5 6\n  print *, 'Max per row:', maxval(matrix, dim=2)    ! Output: 5 6\nend program example_maxval_dim\n```\n\n### Example 3: Using MASK for conditional maximum\n```fortran\nprogram example_maxval_mask\n  implicit none\n  real :: temps(7) = [22.5, 25.3, 18.2, 30.1, 27.8, 15.6, 28.9]\n  character(len=*), parameter :: days(7) = &\n    ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']\n  \n  print *, 'Max temperature:', maxval(temps)\n  print *, 'Max temp below 25:', maxval(temps, mask=temps < 25.0)\n  print *, 'Weekday max:', maxval(temps(1:5))\n  print *, 'Weekend max:', maxval(temps(6:7))\nend program example_maxval_mask\n```\nOutput:\n```\n Max temperature:   30.1\n Max temp below 25:   22.5\n Weekday max:   30.1\n Weekend max:   28.9\n```\n\n### Example 4: Empty set behavior\n```fortran\nprogram example_maxval_empty\n  implicit none\n  real :: arr(5) = [1.0, 2.0, 3.0, 4.0, 5.0]\n  real :: result\n  \n  ! No elements satisfy mask - returns -huge(arr)\n  result = maxval(arr, mask=arr > 100.0)\n  print *, 'Empty max:', result           ! Output: -3.40282347E+38\n  print *, 'Equals -huge:', result == -huge(arr)  ! Output: T\nend program example_maxval_empty\n```\n\n## Standard\nFortran 90\n\n## See Also\n- **minval** - Minimum value in array\n- **maxloc** - Location of maximum value\n- **max** - Elemental maximum of arguments\n- **huge** - Largest model number",
  "minval": "**minval** - [ARRAY:REDUCTION] Determine the minimum value in an array\n\n## Synopsis\n```fortran\nresult = minval(array)\nresult = minval(array, dim)\nresult = minval(array, mask)\nresult = minval(array, dim, mask)\n```\n\n### Interface\n```fortran\ninterface minval\n  pure function minval(array, dim, mask) result(res)\n    type(numeric), intent(in) :: array(..)\n    integer, intent(in), optional :: dim\n    logical, intent(in), optional :: mask(..)\n    type(numeric) :: res  ! same type/kind as array\n  end function minval\nend interface\n```\n\n## Characteristics\n- **array** must be integer, real, or character type\n- **dim** is an integer scalar in range 1 <= dim <= rank(array)\n- **mask** is a logical array conformable with **array**\n- Result has same type and kind as **array**\n- Result is scalar when **dim** is absent\n- Result is array of rank n-1 when **dim** is present\n\n## Description\n`minval(array)` returns the minimum value of all elements in **array**, or of those elements selected by **mask** if present.\n\nWhen **dim** is specified, minimum values are computed along that dimension, returning an array of results.\n\nFor empty arrays or when **mask** has no true elements, the result is `huge(array)` for numeric types, or a string of char(255) characters for character type.\n\n## Options\n- **array** (required): Array of integer, real, or character type to search for minimum.\n- **dim** (optional): Dimension along which to find minima. Cannot be an optional dummy argument.\n- **mask** (optional): Logical array selecting which elements to consider. Must be conformable with **array**.\n\n## Result\n- If **dim** is absent: scalar minimum value\n- If **dim** is present: array of rank n-1 containing minimum along each slice\n- For empty sets: returns `huge(array)` (largest representable value)\n\n## Examples\n\n### Example 1: Basic minimum\n```fortran\nprogram example_minval_basic\n  implicit none\n  integer :: a(5) = [3, 1, 4, 1, 5]\n  real :: b(4) = [2.7, 1.8, 3.14, 0.5]\n  \n  print *, 'Min integer:', minval(a)   ! Output: 1\n  print *, 'Min real:', minval(b)      ! Output: 0.5\nend program example_minval_basic\n```\n\n### Example 2: Using DIM with 2D array\n```fortran\nprogram example_minval_dim\n  implicit none\n  integer :: matrix(2,3)\n  \n  matrix = reshape([1, 4, 5, 2, 3, 6], [2,3])\n  ! Matrix:\n  !   1  5  3\n  !   4  2  6\n  \n  print *, 'Overall min:', minval(matrix)           ! Output: 1\n  print *, 'Min per column:', minval(matrix, dim=1) ! Output: 1 2 3\n  print *, 'Min per row:', minval(matrix, dim=2)    ! Output: 1 2\nend program example_minval_dim\n```\n\n### Example 3: Using MASK for conditional minimum\n```fortran\nprogram example_minval_mask\n  implicit none\n  real :: prices(6) = [15.99, 24.50, 8.75, 32.00, 12.25, 45.00]\n  \n  print *, 'Cheapest item:', minval(prices)\n  print *, 'Cheapest over $10:', minval(prices, mask=prices > 10.0)\n  print *, 'Cheapest under $20:', minval(prices, mask=prices < 20.0)\nend program example_minval_mask\n```\nOutput:\n```\n Cheapest item:   8.75\n Cheapest over $10:   12.25\n Cheapest under $20:   8.75\n```\n\n### Example 4: Finding range\n```fortran\nprogram example_minval_range\n  implicit none\n  real :: data(100)\n  real :: min_val, max_val, range_val\n  \n  call random_number(data)\n  data = data * 100.0  ! Scale to 0-100\n  \n  min_val = minval(data)\n  max_val = maxval(data)\n  range_val = max_val - min_val\n  \n  print '(A,F7.3)', 'Minimum: ', min_val\n  print '(A,F7.3)', 'Maximum: ', max_val\n  print '(A,F7.3)', 'Range:   ', range_val\nend program example_minval_range\n```\n\n### Example 5: Empty set behavior\n```fortran\nprogram example_minval_empty\n  implicit none\n  integer :: arr(5) = [1, 2, 3, 4, 5]\n  integer :: result\n  \n  ! No elements satisfy mask - returns huge(arr)\n  result = minval(arr, mask=arr > 100)\n  print *, 'Empty min:', result              ! Output: 2147483647\n  print *, 'Equals huge:', result == huge(arr)  ! Output: T\nend program example_minval_empty\n```\n\n## Standard\nFortran 90\n\n## See Also\n- **maxval** - Maximum value in array\n- **minloc** - Location of minimum value\n- **min** - Elemental minimum of arguments\n- **huge** - Largest model number",
  "all": "**all** - [ARRAY:REDUCTION] Determine if all values in a logical array are true\n\n## Synopsis\n```fortran\nresult = all(mask)\nresult = all(mask, dim)\n```\n\n### Interface\n```fortran\ninterface all\n  pure function all(mask, dim) result(res)\n    logical, intent(in) :: mask(..)\n    integer, intent(in), optional :: dim\n    logical :: res  ! scalar if dim absent, array of rank n-1 if present\n  end function all\nend interface\n```\n\n## Characteristics\n- **mask** is a logical array of any rank\n- **dim** is an integer scalar in range 1 <= dim <= rank(mask)\n- Result is logical with same kind as **mask**\n- Result is scalar when **dim** is absent\n- Result is array of rank n-1 when **dim** is present\n\n## Description\n`all(mask)` returns `.true.` if all elements of **mask** are `.true.`, or if **mask** has zero size. Otherwise it returns `.false.`.\n\nWhen **dim** is present, the function applies the all operation across the specified dimension, returning an array where each element represents whether all values along that dimension are true.\n\nFor rank-1 arrays, `all(mask, dim)` is equivalent to `all(mask)`.\n\n## Options\n- **mask** (required): A logical array to be tested. Must not be scalar.\n- **dim** (optional): Dimension along which to apply the reduction. Must be a scalar integer between 1 and the rank of **mask**. Cannot be an optional dummy argument in the calling procedure.\n\n## Result\n- If **dim** is absent: scalar logical, `.true.` if all elements are true or array is empty\n- If **dim** is present: array of rank n-1 with shape `(d1, d2, ..., d(dim-1), d(dim+1), ..., dn)` where original shape is `(d1, d2, ..., dn)`\n\n## Examples\n\n### Example 1: Basic scalar result\n```fortran\nprogram example_all_basic\n  implicit none\n  logical :: result\n  \n  result = all([.true., .true., .true.])\n  print *, 'All true:', result   ! Output: T\n  \n  result = all([.true., .false., .true.])\n  print *, 'Mixed:', result      ! Output: F\nend program example_all_basic\n```\n\n### Example 2: Using DIM with 2D array\n```fortran\nprogram example_all_dim\n  implicit none\n  logical :: a(2,3)\n  logical :: row_result(3), col_result(2)\n  \n  a = reshape([.true., .true., .false., .true., .true., .true.], [2,3])\n  ! Array a:\n  !   T  F  T\n  !   T  T  T\n  \n  row_result = all(a, dim=1)  ! Check each column\n  print *, 'Column-wise:', row_result  ! Output: T F T\n  \n  col_result = all(a, dim=2)  ! Check each row\n  print *, 'Row-wise:', col_result     ! Output: F T\nend program example_all_dim\n```\n\n### Example 3: Practical validation\n```fortran\nprogram example_all_validation\n  implicit none\n  real :: values(5) = [1.0, 2.0, 3.0, 4.0, 5.0]\n  \n  if (all(values > 0.0)) then\n    print *, 'All values are positive'\n  end if\n  \n  if (all(values < 10.0)) then\n    print *, 'All values less than 10'\n  end if\nend program example_all_validation\n```\nOutput:\n```\n All values are positive\n All values less than 10\n```\n\n## Standard\nFortran 90\n\n## See Also\n- **any** - True if any element is true\n- **count** - Count true elements\n- **merge** - Conditional array merge",
  "any": "**any** - [ARRAY:REDUCTION] Determine if any value in a logical array is true\n\n## Synopsis\n```fortran\nresult = any(mask)\nresult = any(mask, dim)\n```\n\n### Interface\n```fortran\ninterface any\n  pure function any(mask, dim) result(res)\n    logical, intent(in) :: mask(..)\n    integer, intent(in), optional :: dim\n    logical :: res  ! scalar if dim absent, array of rank n-1 if present\n  end function any\nend interface\n```\n\n## Characteristics\n- **mask** is a logical array of any rank\n- **dim** is an integer scalar in range 1 <= dim <= rank(mask)\n- Result is logical with same kind as **mask**\n- Result is scalar when **dim** is absent\n- Result is array of rank n-1 when **dim** is present\n\n## Description\n`any(mask)` returns `.true.` if any element of **mask** is `.true.`. It returns `.false.` if all elements are `.false.` or if **mask** has zero size.\n\nWhen **dim** is present, the function applies the any operation across the specified dimension, returning an array where each element represents whether any value along that dimension is true.\n\nFor rank-1 arrays, `any(mask, dim)` is equivalent to `any(mask)`.\n\n## Options\n- **mask** (required): A logical array to be tested. Must not be scalar.\n- **dim** (optional): Dimension along which to apply the reduction. Must be a scalar integer between 1 and the rank of **mask**. Cannot be an optional dummy argument.\n\n## Result\n- If **dim** is absent: scalar logical, `.true.` if any element is true\n- If **dim** is present: array of rank n-1 with shape `(d1, d2, ..., d(dim-1), d(dim+1), ..., dn)`\n- Returns `.false.` for zero-size arrays\n\n## Examples\n\n### Example 1: Basic scalar result\n```fortran\nprogram example_any_basic\n  implicit none\n  logical :: result\n  \n  result = any([.false., .true., .false.])\n  print *, 'Any true:', result   ! Output: T\n  \n  result = any([.false., .false., .false.])\n  print *, 'All false:', result  ! Output: F\nend program example_any_basic\n```\n\n### Example 2: Using DIM with 2D array\n```fortran\nprogram example_any_dim\n  implicit none\n  integer :: a(2,3), b(2,3)\n  logical :: row_result(3), col_result(2)\n  \n  a = reshape([1, 2, 3, 4, 5, 6], [2,3])\n  b = reshape([1, 7, 3, 4, 5, 8], [2,3])\n  ! Compare: where are a and b equal?\n  ! Comparison matrix:\n  !   T  T  T\n  !   F  T  F\n  \n  row_result = any(a == b, dim=1)  ! Any match in each column\n  print *, 'Column-wise:', row_result  ! Output: T T T\n  \n  col_result = any(a == b, dim=2)  ! Any match in each row\n  print *, 'Row-wise:', col_result     ! Output: T T\nend program example_any_dim\n```\n\n### Example 3: Error checking\n```fortran\nprogram example_any_errors\n  implicit none\n  real :: data(100)\n  \n  call random_number(data)\n  data = data * 200.0 - 100.0  ! Range: -100 to 100\n  \n  if (any(data < 0.0)) then\n    print *, 'Warning: negative values detected'\n    print *, 'Count:', count(data < 0.0)\n  end if\n  \n  if (any(ieee_is_nan(data))) then\n    print *, 'Error: NaN values present'\n  end if\nend program example_any_errors\n```\n\n## Standard\nFortran 90\n\n## See Also\n- **all** - True if all elements are true\n- **count** - Count true elements\n- **findloc** - Find location of value (F2008)",
  "count": "**count** - [ARRAY:REDUCTION] Count the number of true elements in a logical array\n\n## Synopsis\n```fortran\nresult = count(mask)\nresult = count(mask, dim)\nresult = count(mask, dim, kind)\n```\n\n### Interface\n```fortran\ninterface count\n  pure function count(mask, dim, kind) result(res)\n    logical, intent(in) :: mask(..)\n    integer, intent(in), optional :: dim\n    integer, intent(in), optional :: kind\n    integer(kind) :: res  ! scalar or array depending on dim\n  end function count\nend interface\n```\n\n## Characteristics\n- **mask** is a logical array of any rank\n- **dim** is an integer scalar in range 1 <= dim <= rank(mask)\n- **kind** is an integer initialization expression (F2003+)\n- Result is integer of specified **kind** (default integer if omitted)\n- Result is scalar when **dim** is absent\n- Result is array of rank n-1 when **dim** is present\n\n## Description\n`count(mask)` returns the number of `.true.` elements in the logical array **mask**. If the array has zero size or all elements are `.false.`, the result is 0.\n\nWhen **dim** is present, the function counts true elements along the specified dimension, returning an array of counts.\n\n## Options\n- **mask** (required): A logical array whose true elements are to be counted.\n- **dim** (optional): Dimension along which to count. Must be a scalar integer between 1 and rank of **mask**.\n- **kind** (optional): Integer kind parameter for the result. Fortran 2003 and later.\n\n## Result\n- If **dim** is absent: scalar integer count of true elements\n- If **dim** is present: integer array of rank n-1 with counts along each slice\n- Returns 0 for empty arrays or when all elements are false\n\n## Examples\n\n### Example 1: Basic counting\n```fortran\nprogram example_count_basic\n  implicit none\n  logical :: mask(5) = [.true., .false., .true., .true., .false.]\n  \n  print *, 'True count:', count(mask)          ! Output: 3\n  print *, 'False count:', count(.not. mask)   ! Output: 2\nend program example_count_basic\n```\n\n### Example 2: Counting with DIM\n```fortran\nprogram example_count_dim\n  implicit none\n  integer :: a(2,3), b(2,3)\n  logical :: mask(2,3)\n  \n  a = reshape([1, 2, 3, 4, 5, 6], [2,3])\n  b = reshape([0, 7, 3, 4, 5, 8], [2,3])\n  mask = a /= b\n  ! mask:\n  !   T  F  F\n  !   T  F  T\n  \n  print *, 'Total differences:', count(mask)       ! Output: 3\n  print *, 'Per column:', count(mask, dim=1)       ! Output: 2 0 1\n  print *, 'Per row:', count(mask, dim=2)          ! Output: 1 2\nend program example_count_dim\n```\n\n### Example 3: Statistical analysis\n```fortran\nprogram example_count_stats\n  implicit none\n  real :: scores(10) = [85.0, 72.0, 91.0, 68.0, 77.0, &\n                        95.0, 83.0, 59.0, 88.0, 74.0]\n  integer :: n_pass, n_fail, n_excellent\n  \n  n_pass = count(scores >= 70.0)\n  n_fail = count(scores < 70.0)\n  n_excellent = count(scores >= 90.0)\n  \n  print '(A,I2,A,I2)', 'Pass: ', n_pass, ', Fail: ', n_fail\n  print '(A,I2)', 'Excellent (>=90): ', n_excellent\n  print '(A,F5.1,A)', 'Pass rate: ', 100.0*real(n_pass)/size(scores), '%'\nend program example_count_stats\n```\nOutput:\n```\nPass:  8, Fail:  2\nExcellent (>=90):  2\nPass rate:  80.0%\n```\n\n## Standard\nFortran 90 (KIND argument: Fortran 2003)\n\n## See Also\n- **all** - True if all elements are true\n- **any** - True if any element is true\n- **sum** - Sum array elements (can use logical-to-integer conversion)",
  "epsilon": "## epsilon\n\n### **Name**\n\n**epsilon** - \\[NUMERIC:INQUIRY\\] Returns the smallest number that added to 1 produces a result greater than 1\n\n### **Synopsis**\n```fortran\n    result = epsilon(x)\n```\n```fortran\n     function epsilon(x) result(eps)\n\n      real(kind=k), intent(in) :: x\n      real(kind=k)             :: eps\n```\n\n### **Characteristics**\n\n - **X** must be of type REAL.\n - **X** may be a scalar or an array.\n - The result has the same type and kind as **X**.\n - The value of **X** is not used; only its type and kind determine the result.\n\n### **Description**\n\n **EPSILON(X)** returns the smallest positive number **E** of the same\n kind as **X** such that **1.0 + E > 1.0**. This value represents the\n relative spacing of representable numbers near 1.0, also known as\n machine epsilon or unit roundoff.\n\n For IEEE 754 floating-point arithmetic:\n - Single precision: epsilon is approximately 1.19209E-07 (2^-23)\n - Double precision: epsilon is approximately 2.22045E-16 (2^-52)\n\n This function is essential for:\n - Setting tolerances in iterative algorithms\n - Comparing floating-point numbers for approximate equality\n - Determining convergence criteria\n - Avoiding division by numbers too close to zero\n\n The mathematical relationship is:\n   epsilon(x) = radix(x)^(1-digits(x))\n\n### **Options**\n\n- **X**\n  : A variable or constant of REAL type. The actual value is irrelevant;\n  only the type and kind parameter matter. This argument is required.\n\n### **Result**\n\n  The result is a positive real value of the same kind as **X**,\n  representing the smallest distinguishable increment from 1.0 in that\n  floating-point representation.\n\n  This is the machine epsilon, useful for writing portable numerical\n  code that adapts to different precision levels.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_epsilon\n  implicit none\n  real             :: x = 1.0\n  real(kind=8)     :: y = 1.0d0\n  real             :: tolerance\n\n  print '(A)', 'Machine epsilon for different precisions:'\n  print '(A,ES15.8)', '  single precision: ', epsilon(x)\n  print '(A,ES23.16)', '  double precision: ', epsilon(y)\n\n  ! Demonstrate that 1 + epsilon > 1\n  print '(A)', ''\n  print '(A)', 'Verification that 1 + epsilon > 1:'\n  print '(A,L)', '  1.0 + epsilon(x) > 1.0: ', &\n                  (1.0 + epsilon(x)) > 1.0\n  print '(A,L)', '  1.0 + epsilon(x)/2 > 1.0: ', &\n                  (1.0 + epsilon(x)/2.0) > 1.0\n\n  ! Practical use: setting a tolerance for convergence\n  tolerance = 100.0 * epsilon(x)\n  print '(A)', ''\n  print '(A,ES12.5)', 'Practical tolerance (100*epsilon): ', tolerance\n\n  ! Comparing floating-point numbers\n  print '(A)', ''\n  print '(A)', 'Safe floating-point comparison example:'\n  call safe_compare(1.0/3.0, 0.333333343)\n\ncontains\n\n  subroutine safe_compare(a, b)\n    real, intent(in) :: a, b\n    real :: rel_diff\n    rel_diff = abs(a - b) / max(abs(a), abs(b), tiny(a))\n    if (rel_diff < 100.0 * epsilon(a)) then\n      print '(A)', '  Values are approximately equal'\n    else\n      print '(A)', '  Values differ significantly'\n    end if\n  end subroutine safe_compare\n\nend program demo_epsilon\n```\nResults (typical IEEE 754 system):\n```text\nMachine epsilon for different precisions:\n  single precision:  1.19209290E-07\n  double precision:  2.2204460492503131E-16\n\nVerification that 1 + epsilon > 1:\n  1.0 + epsilon(x) > 1.0: T\n  1.0 + epsilon(x)/2 > 1.0: F\n\nPractical tolerance (100*epsilon):  1.19209E-05\n\nSafe floating-point comparison example:\n  Values are approximately equal\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**tiny**(3)](#tiny),\n[**huge**(3)](#huge),\n[**digits**(3)](#digits),\n[**radix**(3)](#radix),\n[**precision**(3)](#precision),\n[**spacing**(3)](#spacing),\n[**nearest**(3)](#nearest)",
  "huge": "## huge\n\n### **Name**\n\n**huge** - \\[NUMERIC:INQUIRY\\] Returns the largest representable number in the numeric model\n\n### **Synopsis**\n```fortran\n    result = huge(x)\n```\n```fortran\n     function huge(x) result(largest)\n\n      type(integer|real), intent(in) :: x\n      type(same as x)                :: largest\n```\n\n### **Characteristics**\n\n - **X** must be of type INTEGER or REAL.\n - **X** may be a scalar or an array.\n - The result has the same type and kind as **X**.\n - The value of **X** is not used; only its type and kind determine the result.\n\n### **Description**\n\n **HUGE(X)** returns the largest number that is not an infinity in the\n model of the type of **X**. This represents the maximum finite value\n that can be stored in a variable of that type and kind.\n\n For the Fortran numeric model:\n - For integers: HUGE = radix^(digits) - 1\n - For reals: HUGE = (1 - radix^(-digits)) * radix^maxexponent\n\n Typical values on IEEE 754 systems:\n - INTEGER*4: 2147483647 (2^31 - 1)\n - INTEGER*8: 9223372036854775807 (2^63 - 1)\n - REAL*4: approximately 3.40282E+38\n - REAL*8: approximately 1.79769E+308\n\n This function is useful for:\n - Initializing variables to find minimum values\n - Checking for potential overflow conditions\n - Setting upper bounds in algorithms\n\n### **Options**\n\n- **X**\n  : A variable or constant of INTEGER or REAL type. The actual value is\n  irrelevant; only the type and kind parameter matter. This argument is\n  required.\n\n### **Result**\n\n  The result is a scalar value of the same type and kind as **X**,\n  containing the largest finite number representable in that type.\n\n  For INTEGER types, this is the largest positive integer.\n\n  For REAL types, this is the largest finite floating-point number\n  (operations producing values larger than this result in overflow\n  or infinity).\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_huge\n  implicit none\n  integer          :: i\n  integer(kind=2)  :: short_int\n  integer(kind=4)  :: default_int\n  integer(kind=8)  :: long_int\n  real             :: x\n  real(kind=8)     :: y\n\n  print '(A)', 'Largest representable values:'\n  print '(A)', ''\n  print '(A)', 'Integers:'\n  print '(A,I20)',   '  kind=2:  ', huge(short_int)\n  print '(A,I20)',   '  kind=4:  ', huge(default_int)\n  print '(A,I20)',   '  kind=8:  ', huge(long_int)\n\n  print '(A)', ''\n  print '(A)', 'Reals:'\n  print '(A,ES15.8)', '  single:  ', huge(x)\n  print '(A,ES24.16)', '  double:  ', huge(y)\n\n  ! Practical use: initialize minimum search\n  print '(A)', ''\n  print '(A)', 'Finding minimum value in array:'\n  call find_minimum([3.5, 1.2, 7.8, 0.5, 4.3])\n\n  ! Relationship with other model functions\n  print '(A)', ''\n  print '(A)', 'Model relationships for default real:'\n  print '(A,I5)',     '  maxexponent = ', maxexponent(x)\n  print '(A,ES15.8)', '  huge        = ', huge(x)\n  print '(A,ES15.8)', '  tiny        = ', tiny(x)\n\ncontains\n\n  subroutine find_minimum(arr)\n    real, intent(in) :: arr(:)\n    real :: min_val\n    integer :: i\n    min_val = huge(min_val)  ! Initialize to largest possible\n    do i = 1, size(arr)\n      if (arr(i) < min_val) min_val = arr(i)\n    end do\n    print '(A,F6.2)', '  Minimum found: ', min_val\n  end subroutine find_minimum\n\nend program demo_huge\n```\nResults (typical IEEE 754 system):\n```text\nLargest representable values:\n\nIntegers:\n  kind=2:                 32767\n  kind=4:            2147483647\n  kind=8:   9223372036854775807\n\nReals:\n  single:   3.40282347E+38\n  double:   1.7976931348623157E+308\n\nFinding minimum value in array:\n  Minimum found:   0.50\n\nModel relationships for default real:\n  maxexponent =   128\n  huge        =  3.40282347E+38\n  tiny        =  1.17549435E-38\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**tiny**(3)](#tiny),\n[**epsilon**(3)](#epsilon),\n[**maxexponent**(3)](#maxexponent),\n[**minexponent**(3)](#minexponent),\n[**range**(3)](#range),\n[**digits**(3)](#digits)",
  "tiny": "## tiny\n\n### **Name**\n\n**tiny** - \\[NUMERIC:INQUIRY\\] Returns the smallest positive number in the floating-point model\n\n### **Synopsis**\n```fortran\n    result = tiny(x)\n```\n```fortran\n     function tiny(x) result(smallest)\n\n      real(kind=k), intent(in) :: x\n      real(kind=k)             :: smallest\n```\n\n### **Characteristics**\n\n - **X** must be of type REAL.\n - **X** may be a scalar or an array.\n - The result has the same type and kind as **X**.\n - The value of **X** is not used; only its type and kind determine the result.\n\n### **Description**\n\n **TINY(X)** returns the smallest positive normalized number in the\n model of the type of **X**. This is the smallest floating-point value\n that can be represented without losing precision due to denormalization.\n\n For IEEE 754 floating-point:\n - Single precision (REAL*4): tiny is approximately 1.17549E-38\n - Double precision (REAL*8): tiny is approximately 2.22507E-308\n\n The relationship with model parameters is:\n   tiny(x) = radix(x)^(minexponent(x)-1)\n\n Note: Numbers smaller than TINY can exist as denormalized (subnormal)\n numbers in IEEE 754, but they have reduced precision. TINY returns the\n smallest normal number with full precision.\n\n This function is useful for:\n - Avoiding division by zero or near-zero\n - Setting minimum thresholds in algorithms\n - Detecting potential underflow conditions\n\n### **Options**\n\n- **X**\n  : A variable or constant of REAL type. The actual value is irrelevant;\n  only the type and kind parameter matter. This argument is required.\n\n### **Result**\n\n  The result is a positive real value of the same kind as **X**,\n  representing the smallest positive normalized number in that\n  floating-point representation.\n\n  Values smaller than this are either denormalized (with reduced\n  precision) or underflow to zero.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_tiny\n  implicit none\n  real             :: x\n  real(kind=8)     :: y\n\n  print '(A)', 'Smallest positive normalized numbers:'\n  print '(A,ES15.8)', '  single precision: ', tiny(x)\n  print '(A,ES24.16)', '  double precision: ', tiny(y)\n\n  print '(A)', ''\n  print '(A)', 'Comparison with huge (full representable range):'\n  print '(A,ES15.8,A,ES15.8)', '  single: ', tiny(x), ' to ', huge(x)\n  print '(A,ES24.16,A,ES24.16)', '  double: ', tiny(y), ' to ', huge(y)\n\n  print '(A)', ''\n  print '(A)', 'Relationship with model parameters:'\n  print '(A,ES15.8)', '  tiny(real)             = ', tiny(x)\n  print '(A,ES15.8)', '  2^(minexponent-1)      = ', &\n                       2.0**(minexponent(x)-1)\n  print '(A,I6)',     '  minexponent(real)      = ', minexponent(x)\n\n  print '(A)', ''\n  print '(A)', 'Practical use: safe division'\n  call safe_divide(1.0, 1.0e-40)\n  call safe_divide(1.0, 0.0)\n\ncontains\n\n  subroutine safe_divide(a, b)\n    real, intent(in) :: a, b\n    real :: result\n\n    if (abs(b) < tiny(b)) then\n      print '(A,ES10.3,A)', '  Cannot divide by ', b, ' (too small)'\n      result = sign(huge(a), a) * sign(1.0, b)  ! Return +/- huge\n    else\n      result = a / b\n      print '(A,ES10.3,A,ES10.3,A,ES12.5)', &\n            '  ', a, ' / ', b, ' = ', result\n    end if\n  end subroutine safe_divide\n\nend program demo_tiny\n```\nResults (typical IEEE 754 system):\n```text\nSmallest positive normalized numbers:\n  single precision:  1.17549435E-38\n  double precision:  2.2250738585072014E-308\n\nComparison with huge (full representable range):\n  single:  1.17549435E-38 to  3.40282347E+38\n  double:  2.2250738585072014E-308 to  1.7976931348623157E+308\n\nRelationship with model parameters:\n  tiny(real)             =  1.17549435E-38\n  2^(minexponent-1)      =  1.17549435E-38\n  minexponent(real)      =   -125\n\nPractical use: safe division\n  Cannot divide by  1.000E-40 (too small)\n  Cannot divide by  0.000E+00 (too small)\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**huge**(3)](#huge),\n[**epsilon**(3)](#epsilon),\n[**minexponent**(3)](#minexponent),\n[**maxexponent**(3)](#maxexponent),\n[**radix**(3)](#radix),\n[**digits**(3)](#digits),\n[**range**(3)](#range)",
  "precision": "## precision\n\n### **Name**\n\n**precision** - \\[NUMERIC:INQUIRY\\] Returns the decimal precision of a real or complex kind\n\n### **Synopsis**\n```fortran\n    result = precision(x)\n```\n```fortran\n     function precision(x) result(dec_prec)\n\n      type(real|complex), intent(in) :: x\n      integer                        :: dec_prec\n```\n\n### **Characteristics**\n\n - **X** must be of type REAL or COMPLEX.\n - **X** may be a scalar or an array.\n - The result is a default INTEGER scalar.\n - The value of **X** is not used; only its type and kind determine the result.\n\n### **Description**\n\n **PRECISION(X)** returns the decimal precision in the model of the\n type of **X**. This is the number of significant decimal digits that\n can be reliably represented in the floating-point format.\n\n The decimal precision is calculated as:\n   precision = INT((digits(x) - 1) * LOG10(radix(x)))\n\n For IEEE 754 floating-point:\n - Single precision (REAL*4): precision is typically 6\n - Double precision (REAL*8): precision is typically 15\n - Quad precision (REAL*16): precision is typically 33\n\n Note: While IEEE 754 single precision has about 7.22 decimal digits\n of precision (24 bits * log10(2) = 7.22), PRECISION returns 6 because\n only 6 digits are guaranteed to round-trip correctly for all values.\n\n This function is useful with SELECTED_REAL_KIND to request a specific\n decimal precision level.\n\n### **Options**\n\n- **X**\n  : A variable or constant of REAL or COMPLEX type. The actual value is\n  irrelevant; only the type and kind parameter matter. This argument is\n  required.\n\n### **Result**\n\n  The result is a scalar default integer equal to the number of\n  significant decimal digits that can be represented in the\n  floating-point model for the kind of **X**.\n\n  For COMPLEX arguments, the precision of the real component is returned\n  (both components have the same precision).\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_precision\n  implicit none\n  real             :: x\n  real(kind=8)     :: y\n  complex          :: cx\n  complex(kind=8)  :: cy\n\n  print '(A)', 'Decimal precision for different kinds:'\n  print '(A,I3)', '  single precision real:     ', precision(x)\n  print '(A,I3)', '  double precision real:     ', precision(y)\n  print '(A,I3)', '  single precision complex:  ', precision(cx)\n  print '(A,I3)', '  double precision complex:  ', precision(cy)\n\n  print '(A)', ''\n  print '(A)', 'Relationship between precision and digits:'\n  print '(A,I3)', '  digits(single) = ', digits(x)\n  print '(A,I3)', '  precision(single) = ', precision(x)\n  print '(A)',    '  Formula: INT((24-1) * LOG10(2)) = INT(6.92) = 6'\n\n  print '(A)', ''\n  print '(A,I3)', '  digits(double) = ', digits(y)\n  print '(A,I3)', '  precision(double) = ', precision(y)\n  print '(A)',    '  Formula: INT((53-1) * LOG10(2)) = INT(15.65) = 15'\n\n  print '(A)', ''\n  print '(A)', 'Using precision with SELECTED_REAL_KIND:'\n  call show_kind_selection()\n\ncontains\n\n  subroutine show_kind_selection()\n    integer, parameter :: sp = selected_real_kind(6)   ! At least 6 digits\n    integer, parameter :: dp = selected_real_kind(15)  ! At least 15 digits\n    real(kind=sp) :: single_val\n    real(kind=dp) :: double_val\n\n    print '(A,I3)', '  selected_real_kind(6) gives precision:  ', &\n                    precision(single_val)\n    print '(A,I3)', '  selected_real_kind(15) gives precision: ', &\n                    precision(double_val)\n  end subroutine show_kind_selection\n\nend program demo_precision\n```\nResults (typical IEEE 754 system):\n```text\nDecimal precision for different kinds:\n  single precision real:       6\n  double precision real:      15\n  single precision complex:    6\n  double precision complex:   15\n\nRelationship between precision and digits:\n  digits(single) =  24\n  precision(single) =   6\n  Formula: INT((24-1) * LOG10(2)) = INT(6.92) = 6\n\n  digits(double) =  53\n  precision(double) =  15\n  Formula: INT((53-1) * LOG10(2)) = INT(15.65) = 15\n\nUsing precision with SELECTED_REAL_KIND:\n  selected_real_kind(6) gives precision:    6\n  selected_real_kind(15) gives precision:  15\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**digits**(3)](#digits),\n[**range**(3)](#range),\n[**radix**(3)](#radix),\n[**epsilon**(3)](#epsilon),\n[**selected_real_kind**(3)](#selected_real_kind),\n[**selected_int_kind**(3)](#selected_int_kind)",
  "range": "## range\n\n### **Name**\n\n**range** - \\[NUMERIC:INQUIRY\\] Returns the decimal exponent range of a numeric kind\n\n### **Synopsis**\n```fortran\n    result = range(x)\n```\n```fortran\n     function range(x) result(dec_range)\n\n      type(integer|real|complex), intent(in) :: x\n      integer                                :: dec_range\n```\n\n### **Characteristics**\n\n - **X** must be of type INTEGER, REAL, or COMPLEX.\n - **X** may be a scalar or an array.\n - The result is a default INTEGER scalar.\n - The value of **X** is not used; only its type and kind determine the result.\n\n### **Description**\n\n **RANGE(X)** returns the decimal exponent range in the model of the\n type of **X**. This indicates the range of powers of 10 that can be\n represented: from 10^(-range) to 10^(+range).\n\n The decimal exponent range is calculated as:\n - For integers: INT(LOG10(huge(x)))\n - For reals: INT(MIN(LOG10(huge(x)), -LOG10(tiny(x))))\n\n For IEEE 754 floating-point:\n - Single precision (REAL*4): range is typically 37\n - Double precision (REAL*8): range is typically 307\n - Default integer (INTEGER*4): range is typically 9\n - Long integer (INTEGER*8): range is typically 18\n\n This function is useful with SELECTED_REAL_KIND to request a specific\n exponent range.\n\n### **Options**\n\n- **X**\n  : A variable or constant of INTEGER, REAL, or COMPLEX type. The actual\n  value is irrelevant; only the type and kind parameter matter. This\n  argument is required.\n\n### **Result**\n\n  The result is a scalar default integer equal to the decimal exponent\n  range for the model of the type and kind of **X**.\n\n  For INTEGER, this is INT(LOG10(huge(x))).\n\n  For REAL and COMPLEX, this is the minimum of the positive and negative\n  ranges, ensuring symmetric representation around 1.0.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_range\n  implicit none\n  integer          :: i\n  integer(kind=2)  :: short_i\n  integer(kind=8)  :: long_i\n  real             :: x\n  real(kind=8)     :: y\n  complex          :: cx\n  complex(kind=8)  :: cy\n\n  print '(A)', 'Decimal exponent ranges:'\n  print '(A)', ''\n  print '(A)', 'Integers:'\n  print '(A,I4)', '  kind=2 (short):    ', range(short_i)\n  print '(A,I4)', '  kind=4 (default):  ', range(i)\n  print '(A,I4)', '  kind=8 (long):     ', range(long_i)\n\n  print '(A)', ''\n  print '(A)', 'Reals:'\n  print '(A,I4)', '  single precision:  ', range(x)\n  print '(A,I4)', '  double precision:  ', range(y)\n\n  print '(A)', ''\n  print '(A)', 'Complex:'\n  print '(A,I4)', '  single precision:  ', range(cx)\n  print '(A,I4)', '  double precision:  ', range(cy)\n\n  print '(A)', ''\n  print '(A)', 'What range means for single precision (range=37):'\n  print '(A,ES12.5)', '  Can represent up to:   ', 1.0e37\n  print '(A,ES12.5)', '  Can represent down to: ', 1.0e-37\n  print '(A,ES12.5)', '  Actual huge:           ', huge(x)\n  print '(A,ES12.5)', '  Actual tiny:           ', tiny(x)\n\n  print '(A)', ''\n  print '(A)', 'Relationship with huge and tiny:'\n  print '(A,I4)', '  INT(LOG10(huge(x)))      = ', int(log10(huge(x)))\n  print '(A,I4)', '  INT(-LOG10(tiny(x)))     = ', int(-log10(tiny(x)))\n  print '(A,I4)', '  range(x) (minimum of above) = ', range(x)\n\n  print '(A)', ''\n  print '(A)', 'Using range with SELECTED_REAL_KIND:'\n  call show_kind_selection()\n\ncontains\n\n  subroutine show_kind_selection()\n    integer, parameter :: k1 = selected_real_kind(p=6, r=37)\n    integer, parameter :: k2 = selected_real_kind(p=15, r=307)\n    real(kind=k1) :: r1\n    real(kind=k2) :: r2\n\n    print '(A,I4)', '  selected_real_kind(6,37) gives range:   ', range(r1)\n    print '(A,I4)', '  selected_real_kind(15,307) gives range: ', range(r2)\n  end subroutine show_kind_selection\n\nend program demo_range\n```\nResults (typical IEEE 754 system):\n```text\nDecimal exponent ranges:\n\nIntegers:\n  kind=2 (short):       4\n  kind=4 (default):     9\n  kind=8 (long):       18\n\nReals:\n  single precision:    37\n  double precision:   307\n\nComplex:\n  single precision:    37\n  double precision:   307\n\nWhat range means for single precision (range=37):\n  Can represent up to:    1.00000E+37\n  Can represent down to:  1.00000E-37\n  Actual huge:            3.40282E+38\n  Actual tiny:            1.17549E-38\n\nRelationship with huge and tiny:\n  INT(LOG10(huge(x)))      =   38\n  INT(-LOG10(tiny(x)))     =   37\n  range(x) (minimum of above) =   37\n\nUsing range with SELECTED_REAL_KIND:\n  selected_real_kind(6,37) gives range:     37\n  selected_real_kind(15,307) gives range:  307\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**precision**(3)](#precision),\n[**digits**(3)](#digits),\n[**radix**(3)](#radix),\n[**huge**(3)](#huge),\n[**tiny**(3)](#tiny),\n[**selected_real_kind**(3)](#selected_real_kind),\n[**selected_int_kind**(3)](#selected_int_kind)",
  "digits": "## digits\n\n### **Name**\n\n**digits** - \\[NUMERIC:INQUIRY\\] Returns the number of significant binary digits in the numeric model\n\n### **Synopsis**\n```fortran\n    result = digits(x)\n```\n```fortran\n     function digits(x) result(num_digits)\n\n      type(integer|real), intent(in) :: x\n      integer                        :: num_digits\n```\n\n### **Characteristics**\n\n - **X** must be of type INTEGER or REAL.\n - **X** may be a scalar or an array.\n - The result is a default INTEGER scalar.\n - The value of **X** is not used; only its type and kind determine the result.\n\n### **Description**\n\n **DIGITS(X)** returns the number of significant binary digits in the\n internal model representation of the type and kind of **X**. This is\n an inquiry function that characterizes the numeric model, not the\n actual value of the argument.\n\n For the Fortran numeric model:\n - For integers: the number of bits used to represent the magnitude\n   (excluding the sign bit)\n - For reals: the number of bits in the significand (mantissa),\n   including the implicit leading bit for IEEE 754 formats\n\n On IEEE 754 systems:\n - Single precision (REAL*4): typically returns 24\n - Double precision (REAL*8): typically returns 53\n - Default integer (INTEGER*4): typically returns 31\n\n### **Options**\n\n- **X**\n  : A variable or constant of INTEGER or REAL type. The actual value is\n  irrelevant; only the type and kind parameter matter. This argument is\n  required.\n\n### **Result**\n\n  The result is a scalar default integer equal to the number of significant\n  binary digits in the model representation for the type and kind of **X**.\n\n  For INTEGER types, this equals the number of bits used for the magnitude.\n\n  For REAL types, this equals the number of mantissa bits including the\n  implicit leading bit (for normalized numbers in IEEE 754 format).\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_digits\n  implicit none\n  integer          :: i = 12345\n  real             :: x = 3.143\n  real(kind=8)     :: y = 2.33d0\n  integer(kind=2)  :: short_int = 100\n  integer(kind=8)  :: long_int = 10000000000_8\n\n  print '(A)', 'Number of significant binary digits:'\n  print '(A,I3)', '  default integer:     ', digits(i)\n  print '(A,I3)', '  short integer (2):   ', digits(short_int)\n  print '(A,I3)', '  long integer (8):    ', digits(long_int)\n  print '(A,I3)', '  default real:        ', digits(x)\n  print '(A,I3)', '  double precision:    ', digits(y)\n\n  ! Demonstrate relationship with other model functions\n  print '(A)', ''\n  print '(A)', 'For default real:'\n  print '(A,I3)',  '  radix  = ', radix(x)\n  print '(A,I3)',  '  digits = ', digits(x)\n  print '(A,ES12.5)', '  epsilon = ', epsilon(x)\n\nend program demo_digits\n```\nResults (typical IEEE 754 system):\n```text\nNumber of significant binary digits:\n  default integer:      31\n  short integer (2):    15\n  long integer (8):     63\n  default real:         24\n  double precision:     53\n\nFor default real:\n  radix  =   2\n  digits =  24\n  epsilon =  1.19209E-07\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**radix**(3)](#radix),\n[**epsilon**(3)](#epsilon),\n[**precision**(3)](#precision),\n[**range**(3)](#range),\n[**huge**(3)](#huge),\n[**tiny**(3)](#tiny)",
  "radix": "## radix\n\n### **Name**\n\n**radix** - \\[NUMERIC:INQUIRY\\] Returns the base of the numeric model\n\n### **Synopsis**\n```fortran\n    result = radix(x)\n```\n```fortran\n     function radix(x) result(base)\n\n      type(integer|real), intent(in) :: x\n      integer                        :: base\n```\n\n### **Characteristics**\n\n - **X** must be of type INTEGER or REAL.\n - **X** may be a scalar or an array.\n - The result is a default INTEGER scalar.\n - The value of **X** is not used; only its type and kind determine the result.\n\n### **Description**\n\n **RADIX(X)** returns the base of the model representing numbers of the\n type and kind of **X**. This is the fundamental base used in the\n internal representation of numeric values.\n\n On virtually all modern computers, RADIX returns 2 for both integer\n and real types, indicating binary representation. Historical systems\n (such as some IBM mainframes) used other bases like 16 (hexadecimal\n floating-point).\n\n The radix is fundamental to the Fortran numeric model:\n - For integers: value = s * SUM(digit_k * radix^k) for k=0 to digits-1\n - For reals: value = s * (SUM(f_k * radix^(-k))) * radix^e\n\n where s is the sign, digits/f_k are the mantissa digits, and e is\n the exponent.\n\n### **Options**\n\n- **X**\n  : A variable or constant of INTEGER or REAL type. The actual value is\n  irrelevant; only the type and kind parameter matter. This argument is\n  required.\n\n### **Result**\n\n  The result is a scalar default integer equal to the base of the\n  numeric model for the type and kind of **X**.\n\n  On IEEE 754 compliant systems (essentially all modern platforms),\n  this returns 2.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_radix\n  implicit none\n  integer          :: i\n  integer(kind=8)  :: long_i\n  real             :: x\n  real(kind=8)     :: y\n\n  print '(A)', 'Radix (base) for different types:'\n  print '(A,I3)', '  default integer:    ', radix(i)\n  print '(A,I3)', '  long integer:       ', radix(long_i)\n  print '(A,I3)', '  single precision:   ', radix(x)\n  print '(A,I3)', '  double precision:   ', radix(y)\n\n  print '(A)', ''\n  print '(A)', 'The numeric model uses radix as the base.'\n  print '(A)', 'For binary (radix=2) floating-point:'\n  print '(A)', '  value = sign * mantissa * 2^exponent'\n\n  print '(A)', ''\n  print '(A)', 'Complete model parameters for single precision:'\n  print '(A,I6)',     '  radix       = ', radix(x)\n  print '(A,I6)',     '  digits      = ', digits(x)\n  print '(A,I6)',     '  minexponent = ', minexponent(x)\n  print '(A,I6)',     '  maxexponent = ', maxexponent(x)\n  print '(A,I6)',     '  precision   = ', precision(x)\n  print '(A,I6)',     '  range       = ', range(x)\n\n  print '(A)', ''\n  print '(A)', 'Derived quantities:'\n  print '(A,ES15.8)', '  epsilon = radix^(1-digits)    = ', &\n                       real(radix(x))**(1-digits(x))\n  print '(A,ES15.8)', '  actual epsilon               = ', epsilon(x)\n  print '(A,ES15.8)', '  tiny = radix^(minexponent-1) = ', &\n                       real(radix(x))**(minexponent(x)-1)\n  print '(A,ES15.8)', '  actual tiny                  = ', tiny(x)\n\nend program demo_radix\n```\nResults (typical IEEE 754 system):\n```text\nRadix (base) for different types:\n  default integer:      2\n  long integer:         2\n  single precision:     2\n  double precision:     2\n\nThe numeric model uses radix as the base.\nFor binary (radix=2) floating-point:\n  value = sign * mantissa * 2^exponent\n\nComplete model parameters for single precision:\n  radix       =      2\n  digits      =     24\n  minexponent =   -125\n  maxexponent =    128\n  precision   =      6\n  range       =     37\n\nDerived quantities:\n  epsilon = radix^(1-digits)    =  1.19209290E-07\n  actual epsilon               =  1.19209290E-07\n  tiny = radix^(minexponent-1) =  1.17549435E-38\n  actual tiny                  =  1.17549435E-38\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**digits**(3)](#digits),\n[**epsilon**(3)](#epsilon),\n[**huge**(3)](#huge),\n[**tiny**(3)](#tiny),\n[**maxexponent**(3)](#maxexponent),\n[**minexponent**(3)](#minexponent),\n[**precision**(3)](#precision),\n[**range**(3)](#range)",
  "maxexponent": "## maxexponent\n\n### **Name**\n\n**maxexponent** - \\[NUMERIC:INQUIRY\\] Returns the maximum exponent in the floating-point model\n\n### **Synopsis**\n```fortran\n    result = maxexponent(x)\n```\n```fortran\n     function maxexponent(x) result(max_exp)\n\n      real(kind=k), intent(in) :: x\n      integer                  :: max_exp\n```\n\n### **Characteristics**\n\n - **X** must be of type REAL.\n - **X** may be a scalar or an array.\n - The result is a default INTEGER scalar.\n - The value of **X** is not used; only its type and kind determine the result.\n\n### **Description**\n\n **MAXEXPONENT(X)** returns the maximum exponent in the model of the\n type of **X**. This is the largest exponent that can be used in the\n floating-point representation before overflow occurs.\n\n For IEEE 754 floating-point:\n - Single precision (REAL*4): maxexponent is typically 128\n - Double precision (REAL*8): maxexponent is typically 1024\n\n The relationship with HUGE is:\n   huge(x) is approximately radix(x)^maxexponent(x)\n\n Note that the actual IEEE 754 exponent value stored differs due to\n bias: the stored exponent equals the actual exponent plus a bias\n (127 for single, 1023 for double). MAXEXPONENT returns the unbiased\n (actual) maximum exponent.\n\n### **Options**\n\n- **X**\n  : A variable or constant of REAL type. The actual value is irrelevant;\n  only the type and kind parameter matter. This argument is required.\n\n### **Result**\n\n  The result is a scalar default integer equal to the maximum exponent\n  in the floating-point model for the kind of **X**.\n\n  This value represents the largest power of the radix (base) that can\n  be used in the floating-point representation.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_maxexponent\n  implicit none\n  real             :: x\n  real(kind=8)     :: y\n  real(kind=16)    :: z  ! Quad precision if available\n\n  print '(A)', 'Maximum exponents for different precisions:'\n  print '(A,I6)', '  single precision (real*4):  ', maxexponent(x)\n  print '(A,I6)', '  double precision (real*8):  ', maxexponent(y)\n\n  print '(A)', ''\n  print '(A)', 'Complete floating-point model for single precision:'\n  print '(A,I6)',     '  radix       = ', radix(x)\n  print '(A,I6)',     '  digits      = ', digits(x)\n  print '(A,I6)',     '  minexponent = ', minexponent(x)\n  print '(A,I6)',     '  maxexponent = ', maxexponent(x)\n  print '(A,ES15.8)', '  tiny        = ', tiny(x)\n  print '(A,ES15.8)', '  huge        = ', huge(x)\n\n  print '(A)', ''\n  print '(A)', 'Complete floating-point model for double precision:'\n  print '(A,I6)',      '  radix       = ', radix(y)\n  print '(A,I6)',      '  digits      = ', digits(y)\n  print '(A,I6)',      '  minexponent = ', minexponent(y)\n  print '(A,I6)',      '  maxexponent = ', maxexponent(y)\n  print '(A,ES24.16)', '  tiny        = ', tiny(y)\n  print '(A,ES24.16)', '  huge        = ', huge(y)\n\n  ! Demonstrate relationship: huge ~ radix^maxexponent\n  print '(A)', ''\n  print '(A)', 'Verification: 2^maxexponent approximates huge'\n  print '(A,ES15.8)', '  2^128          = ', 2.0**128\n  print '(A,ES15.8)', '  huge(real)     = ', huge(x)\n\nend program demo_maxexponent\n```\nResults (typical IEEE 754 system):\n```text\nMaximum exponents for different precisions:\n  single precision (real*4):     128\n  double precision (real*8):    1024\n\nComplete floating-point model for single precision:\n  radix       =      2\n  digits      =     24\n  minexponent =   -125\n  maxexponent =    128\n  tiny        =  1.17549435E-38\n  huge        =  3.40282347E+38\n\nComplete floating-point model for double precision:\n  radix       =      2\n  digits      =     53\n  minexponent =  -1021\n  maxexponent =   1024\n  tiny        =  2.2250738585072014E-308\n  huge        =  1.7976931348623157E+308\n\nVerification: 2^maxexponent approximates huge\n  2^128          =  3.40282367E+38\n  huge(real)     =  3.40282347E+38\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**minexponent**(3)](#minexponent),\n[**huge**(3)](#huge),\n[**tiny**(3)](#tiny),\n[**radix**(3)](#radix),\n[**digits**(3)](#digits),\n[**exponent**(3)](#exponent),\n[**range**(3)](#range)",
  "minexponent": "## minexponent\n\n### **Name**\n\n**minexponent** - \\[NUMERIC:INQUIRY\\] Returns the minimum exponent in the floating-point model\n\n### **Synopsis**\n```fortran\n    result = minexponent(x)\n```\n```fortran\n     function minexponent(x) result(min_exp)\n\n      real(kind=k), intent(in) :: x\n      integer                  :: min_exp\n```\n\n### **Characteristics**\n\n - **X** must be of type REAL.\n - **X** may be a scalar or an array.\n - The result is a default INTEGER scalar.\n - The value of **X** is not used; only its type and kind determine the result.\n\n### **Description**\n\n **MINEXPONENT(X)** returns the minimum exponent in the model of the\n type of **X**. This is the smallest (most negative) exponent that can\n be used in the normalized floating-point representation before\n underflow to zero occurs.\n\n For IEEE 754 floating-point:\n - Single precision (REAL*4): minexponent is typically -125\n - Double precision (REAL*8): minexponent is typically -1021\n\n The relationship with TINY is:\n   tiny(x) = radix(x)^(minexponent(x)-1)\n\n Note that IEEE 754 reserves the smallest exponent (all zeros) for\n denormalized numbers and zero. MINEXPONENT returns the smallest\n exponent for normalized numbers.\n\n### **Options**\n\n- **X**\n  : A variable or constant of REAL type. The actual value is irrelevant;\n  only the type and kind parameter matter. This argument is required.\n\n### **Result**\n\n  The result is a scalar default integer equal to the minimum exponent\n  in the floating-point model for the kind of **X**.\n\n  This value represents the smallest (most negative) power of the radix\n  that can be used for normalized floating-point numbers.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_minexponent\n  implicit none\n  real             :: x\n  real(kind=8)     :: y\n\n  print '(A)', 'Minimum exponents for different precisions:'\n  print '(A,I6)', '  single precision (real*4):  ', minexponent(x)\n  print '(A,I6)', '  double precision (real*8):  ', minexponent(y)\n\n  print '(A)', ''\n  print '(A)', 'Exponent range comparison:'\n  print '(A,I6,A,I6)', '  single: ', minexponent(x), ' to ', maxexponent(x)\n  print '(A,I6,A,I6)', '  double: ', minexponent(y), ' to ', maxexponent(y)\n\n  print '(A)', ''\n  print '(A)', 'Relationship between minexponent and tiny:'\n  print '(A,ES15.8)', '  tiny(real)       = ', tiny(x)\n  print '(A,ES15.8)', '  2^(minexp-1)     = ', 2.0**(minexponent(x)-1)\n  print '(A)', '  (These should be equal)'\n\n  print '(A)', ''\n  print '(A)', 'Underflow detection example:'\n  call check_underflow(x)\n\ncontains\n\n  subroutine check_underflow(template)\n    real, intent(in) :: template\n    real :: val, small_val\n    integer :: exp_val\n\n    ! Get a very small but valid number\n    small_val = tiny(template)\n    exp_val = exponent(small_val)\n\n    print '(A,ES12.5)', '  tiny value:      ', small_val\n    print '(A,I6)',     '  its exponent:    ', exp_val\n    print '(A,I6)',     '  minexponent:     ', minexponent(template)\n\n    ! Dividing tiny by radix would underflow\n    val = small_val / real(radix(template))\n    print '(A,ES12.5)', '  tiny/radix:      ', val\n    print '(A)',        '  (denormalized or zero)'\n  end subroutine check_underflow\n\nend program demo_minexponent\n```\nResults (typical IEEE 754 system):\n```text\nMinimum exponents for different precisions:\n  single precision (real*4):    -125\n  double precision (real*8):   -1021\n\nExponent range comparison:\n  single:   -125 to    128\n  double:  -1021 to   1024\n\nRelationship between minexponent and tiny:\n  tiny(real)       =  1.17549435E-38\n  2^(minexp-1)     =  1.17549435E-38\n  (These should be equal)\n\nUnderflow detection example:\n  tiny value:       1.17549E-38\n  its exponent:      -125\n  minexponent:       -125\n  tiny/radix:        5.87747E-39\n  (denormalized or zero)\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**maxexponent**(3)](#maxexponent),\n[**tiny**(3)](#tiny),\n[**huge**(3)](#huge),\n[**radix**(3)](#radix),\n[**digits**(3)](#digits),\n[**exponent**(3)](#exponent),\n[**range**(3)](#range)",
  "trim": "## trim\n\n### **Name**\n\n**trim** - \\[CHARACTER:MANIPULATION\\] Remove trailing blank characters from a string\n\n### **Synopsis**\n```fortran\n    result = trim(string)\n```\n```fortran\n     pure function trim(string) result(res)\n\n      character(len=*), intent(in) :: string\n      character(len=:), allocatable :: res  ! length = len_trim(string)\n```\n\n### **Characteristics**\n\n - **string** is a scalar of type character.\n - The result is of type character with the same kind as **string**.\n - The result length equals `len(string)` minus the number of trailing blanks.\n - This is a transformational function (not elemental).\n\n### **Description**\n\n **trim** returns the argument **string** with all trailing blank characters\n removed. Leading blanks are preserved. If the string is entirely blank,\n the result is a zero-length string.\n\n This function is commonly used for:\n - Preparing strings for concatenation without unwanted spaces\n - Creating clean output without trailing padding\n - Comparing strings without regard to trailing blanks\n - Reducing memory usage by removing unnecessary characters\n\n### **Options**\n\n- **string**\n  : The character string to be trimmed. May be of any character kind.\n  Must be a scalar value. Trailing blank characters (spaces) are removed\n  from the result.\n\n### **Result**\n\n  A character string of the same kind as **string** with trailing blanks\n  removed. The length of the result is `len(string)` minus the count of\n  trailing blank characters. If **string** contains only blanks, the result\n  is a zero-length string.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_trim\n  implicit none\n  character(len=20) :: str1, str2\n  character(len=50) :: combined\n  character(len=10) :: words(3)\n  integer :: i\n\n  ! Basic trimming\n  str1 = 'Hello'\n  str2 = 'World'\n  print '(A,A,A)', 'str1: [', str1, ']'\n  print '(A,A,A)', 'trim(str1): [', trim(str1), ']'\n\n  ! Without trim, concatenation includes trailing blanks\n  combined = str1 // str2\n  print '(A)', ''\n  print '(A,A,A)', 'str1 // str2: [', combined, ']'\n\n  ! With trim, trailing blanks are removed before concatenation\n  combined = trim(str1) // ' ' // trim(str2) // '!'\n  print '(A,A,A)', 'trim concat:  [', trim(combined), ']'\n\n  ! Length comparison\n  print '(A)', ''\n  print '(A,I0)', 'len(str1):       ', len(str1)\n  print '(A,I0)', 'len(trim(str1)): ', len(trim(str1))\n\n  ! Trimming an all-blank string\n  str1 = '                    '\n  print '(A)', ''\n  print '(A,I0)', 'len(trim(all blanks)): ', len(trim(str1))\n\n  ! Building sentences from word arrays\n  words(1) = 'Fortran'\n  words(2) = 'is'\n  words(3) = 'great'\n\n  print '(A)', ''\n  print '(A)', 'Building sentence from array:'\n  combined = ''\n  do i = 1, 3\n    if (i > 1) combined = trim(combined) // ' '\n    combined = trim(combined) // trim(words(i))\n  end do\n  print '(A,A)', '  Result: ', trim(combined)\n\n  ! Using trim in formatted output\n  print '(A)', ''\n  print '(A)', 'Formatted output:'\n  str1 = 'Name:'\n  str2 = 'John Doe'\n  print '(A,A,1X,A)', '  ', trim(str1), trim(str2)\n\n  ! Combining with adjustl for clean strings\n  str1 = '   Leading spaces   '\n  print '(A)', ''\n  print '(A,A,A)', 'Original:            [', str1, ']'\n  print '(A,A,A)', 'trim:                [', trim(str1), ']'\n  print '(A,A,A)', 'adjustl:             [', adjustl(str1), ']'\n  print '(A,A,A)', 'trim(adjustl):       [', trim(adjustl(str1)), ']'\n\nend program demo_trim\n```\nResults:\n```text\nstr1: [Hello               ]\ntrim(str1): [Hello]\n\nstr1 // str2: [Hello               World               ]\ntrim concat:  [Hello World!]\n\nlen(str1):       20\nlen(trim(str1)): 5\n\nlen(trim(all blanks)): 0\n\nBuilding sentence from array:\n  Result: Fortran is great\n\nFormatted output:\n  Name: John Doe\n\nOriginal:            [   Leading spaces   ]\ntrim:                [   Leading spaces]\nadjustl:             [Leading spaces      ]\ntrim(adjustl):       [Leading spaces]\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**adjustl**(3)](#adjustl),\n[**adjustr**(3)](#adjustr),\n[**len_trim**(3)](#len_trim)",
  "adjustl": "## adjustl\n\n### **Name**\n\n**adjustl** - \\[CHARACTER:MANIPULATION\\] Left-justify a string by removing leading blanks\n\n### **Synopsis**\n```fortran\n    result = adjustl(string)\n```\n```fortran\n     elemental function adjustl(string) result(res)\n\n      character(len=*), intent(in) :: string\n      character(len=len(string))   :: res\n```\n\n### **Characteristics**\n\n - **string** is of type character and may be any kind.\n - The result is of type character with the same length and kind as **string**.\n - This is an elemental function: it operates element-by-element on arrays.\n\n### **Description**\n\n **adjustl** returns the argument **string** with leading blanks removed\n and the same number of trailing blanks appended. The string is effectively\n left-justified within its original length. The total length of the result\n is always equal to the length of the input string.\n\n This function is commonly used for:\n - Aligning text output to the left margin\n - Preparing strings for comparison operations\n - Normalizing user input that may have leading spaces\n - Cleaning up fixed-length character variables\n\n### **Options**\n\n- **string**\n  : The character string to be left-justified. Leading blanks (spaces) are\n  moved to the end of the string. May be of any character kind. The string\n  length is preserved.\n\n### **Result**\n\n  A character string of the same length and kind as **string**, with\n  leading blanks removed and appended as trailing blanks. If the string\n  contains only blanks, the result is unchanged. If there are no leading\n  blanks, the string is returned unchanged.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_adjustl\n  implicit none\n  character(len=20) :: str1, str2\n  character(len=20) :: names(3)\n  integer :: i\n\n  ! Basic left-justification\n  str1 = '     Hello World'\n  print '(A,A,A)', 'Original:    [', str1, ']'\n\n  str2 = adjustl(str1)\n  print '(A,A,A)', 'After adjustl: [', str2, ']'\n\n  ! Combining adjustl with trim for clean output\n  print '(A,A,A)', 'Trimmed:       [', trim(adjustl(str1)), ']'\n\n  ! Processing array of strings\n  names(1) = '   Alice'\n  names(2) = '      Bob'\n  names(3) = ' Charlie'\n\n  print '(A)', ''\n  print '(A)', 'Before adjustl:'\n  do i = 1, 3\n    print '(A,A,A)', '  [', names(i), ']'\n  end do\n\n  names = adjustl(names)  ! Elemental: works on whole array\n\n  print '(A)', 'After adjustl:'\n  do i = 1, 3\n    print '(A,A,A)', '  [', names(i), ']'\n  end do\n\n  ! String with no leading blanks is unchanged\n  str1 = 'NoLeadingBlanks'\n  str2 = adjustl(str1)\n  print '(A)', ''\n  print '(A,A,A)', 'No change needed: [', str2, ']'\n\n  ! All blanks remain all blanks\n  str1 = '                    '\n  str2 = adjustl(str1)\n  print '(A,I0)', 'All blanks - len_trim: ', len_trim(str2)\n\nend program demo_adjustl\n```\nResults:\n```text\nOriginal:    [     Hello World    ]\nAfter adjustl: [Hello World         ]\nTrimmed:       [Hello World]\n\nBefore adjustl:\n  [   Alice             ]\n  [      Bob            ]\n  [ Charlie             ]\nAfter adjustl:\n  [Alice               ]\n  [Bob                 ]\n  [Charlie             ]\n\nNo change needed: [NoLeadingBlanks     ]\nAll blanks - len_trim: 0\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**adjustr**(3)](#adjustr),\n[**trim**(3)](#trim),\n[**len_trim**(3)](#len_trim)",
  "adjustr": "## adjustr\n\n### **Name**\n\n**adjustr** - \\[CHARACTER:MANIPULATION\\] Right-justify a string by removing trailing blanks\n\n### **Synopsis**\n```fortran\n    result = adjustr(string)\n```\n```fortran\n     elemental function adjustr(string) result(res)\n\n      character(len=*), intent(in) :: string\n      character(len=len(string))   :: res\n```\n\n### **Characteristics**\n\n - **string** is of type character and may be any kind.\n - The result is of type character with the same length and kind as **string**.\n - This is an elemental function: it operates element-by-element on arrays.\n\n### **Description**\n\n **adjustr** returns the argument **string** with trailing blanks removed\n and the same number of leading blanks prepended. The string is effectively\n right-justified within its original length. The total length of the result\n is always equal to the length of the input string.\n\n This function is commonly used for:\n - Right-aligning text in columns for tabular output\n - Aligning numeric strings for display\n - Formatting fixed-width fields\n - Creating visually aligned output reports\n\n### **Options**\n\n- **string**\n  : The character string to be right-justified. Trailing blanks (spaces) are\n  moved to the beginning of the string. May be of any character kind. The\n  string length is preserved.\n\n### **Result**\n\n  A character string of the same length and kind as **string**, with\n  trailing blanks removed and prepended as leading blanks. If the string\n  contains only blanks, the result is unchanged. If there are no trailing\n  blanks, the string is returned unchanged.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_adjustr\n  implicit none\n  character(len=20) :: str1, str2\n  character(len=10) :: items(4)\n  real :: prices(4)\n  integer :: i\n\n  ! Basic right-justification\n  str1 = 'Hello World'\n  print '(A,A,A)', 'Original:    [', str1, ']'\n\n  str2 = adjustr(str1)\n  print '(A,A,A)', 'After adjustr: [', str2, ']'\n\n  ! Creating aligned columns\n  items = ['Apple', 'Banana', 'Cherry', 'Date']\n  prices = [1.50, 2.25, 3.00, 0.75]\n\n  print '(A)', ''\n  print '(A)', 'Right-aligned price list:'\n  print '(A)', '========================'\n  do i = 1, 4\n    print '(A,A,F6.2)', adjustr(items(i)), ' $', prices(i)\n  end do\n\n  ! Comparing left vs right justification\n  str1 = '  Centered?  '\n  print '(A)', ''\n  print '(A,A,A)', 'Original: [', str1, ']'\n  print '(A,A,A)', 'adjustl:  [', adjustl(str1), ']'\n  print '(A,A,A)', 'adjustr:  [', adjustr(str1), ']'\n\n  ! String already right-justified stays the same\n  str1 = '         RightSide'\n  str2 = adjustr(str1)\n  print '(A)', ''\n  print '(A,A,A)', 'Already right: [', str2, ']'\n\nend program demo_adjustr\n```\nResults:\n```text\nOriginal:    [Hello World         ]\nAfter adjustr: [         Hello World]\n\nRight-aligned price list:\n========================\n     Apple $  1.50\n    Banana $  2.25\n    Cherry $  3.00\n      Date $  0.75\n\nOriginal: [  Centered?       ]\nadjustl:  [Centered?         ]\nadjustr:  [         Centered?]\n\nAlready right: [         RightSide]\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**adjustl**(3)](#adjustl),\n[**trim**(3)](#trim),\n[**len_trim**(3)](#len_trim)",
  "len_trim": "## len_trim\n\n### **Name**\n\n**len_trim** - \\[CHARACTER:MANIPULATION\\] Length of a string without trailing blanks\n\n### **Synopsis**\n```fortran\n    result = len_trim(string)\n    result = len_trim(string, kind)\n```\n```fortran\n     elemental function len_trim(string, kind) result(res)\n\n      character(len=*), intent(in)  :: string\n      integer, intent(in), optional :: kind\n      integer(kind=KIND)            :: res\n```\n\n### **Characteristics**\n\n - **string** is of type character and may be any kind.\n - **kind** is a scalar integer constant expression (optional).\n - The result is of type integer. If **kind** is present, the result has\n   that kind; otherwise, it is default integer kind.\n - This is an elemental function: it operates element-by-element on arrays.\n\n### **Description**\n\n **len_trim** returns the length of **string** ignoring any trailing blanks.\n This is equivalent to `len(trim(string))` but is more efficient as it does\n not create an intermediate trimmed string. The function counts characters\n from the beginning up to and including the last non-blank character.\n\n Common uses include:\n - Determining actual content length for memory allocation\n - Computing string boundaries for substring operations\n - Formatting output with proper field widths\n - Validating that strings contain actual content\n\n### **Options**\n\n- **string**\n  : The character string whose trimmed length is to be determined.\n  May be of any character kind. Leading blanks are included in the count;\n  only trailing blanks are ignored.\n\n- **kind**\n  : Optional. An integer initialization expression indicating the kind\n  parameter of the result. Useful when working with very long strings\n  that might exceed default integer range.\n\n### **Result**\n\n  An integer representing the position of the last non-blank character\n  in **string**. If the string is entirely blank, the result is zero.\n  The kind of the result is determined by **kind** if present, otherwise\n  it is default integer kind.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_len_trim\n  implicit none\n  character(len=30) :: str\n  character(len=30) :: strings(3)\n  integer :: length, i\n\n  ! Basic usage\n  str = 'Hello World'\n  length = len_trim(str)\n  print '(A,I0)', 'Length of \"Hello World\": ', length\n\n  ! String with leading and trailing blanks\n  str = '   Padded Text   '\n  print '(A)', ''\n  print '(A,A,A)', 'String: [', str, ']'\n  print '(A,I0)', '  len():      ', len(str)\n  print '(A,I0)', '  len_trim(): ', len_trim(str)\n\n  ! All blanks gives zero\n  str = '                              '\n  print '(A)', ''\n  print '(A,I0)', 'All blanks - len_trim: ', len_trim(str)\n\n  ! Using with substring operations\n  str = 'Extract this part        '\n  print '(A)', ''\n  print '(A,A,A)', 'Content only: [', str(1:len_trim(str)), ']'\n\n  ! Array operations (elemental)\n  strings(1) = 'Short'\n  strings(2) = 'Medium length'\n  strings(3) = 'This is a longer string'\n\n  print '(A)', ''\n  print '(A)', 'Array of strings:'\n  do i = 1, 3\n    print '(A,I0,A,A,A)', '  len_trim = ', len_trim(strings(i)), &\n      ': [', trim(strings(i)), ']'\n  end do\n\n  ! Comparing len vs len_trim efficiency\n  str = 'Efficiency test'\n  print '(A)', ''\n  print '(A,I0)', 'len(str):           ', len(str)\n  print '(A,I0)', 'len_trim(str):      ', len_trim(str)\n  print '(A,I0)', 'len(trim(str)):     ', len(trim(str))  ! Same but less efficient\n\n  ! Using kind parameter\n  print '(A)', ''\n  print '(A,I0)', 'With kind=8: ', len_trim(str, kind=8)\n\nend program demo_len_trim\n```\nResults:\n```text\nLength of \"Hello World\": 11\n\nString: [   Padded Text               ]\n  len():      30\n  len_trim(): 14\n\nAll blanks - len_trim: 0\n\nContent only: [Extract this part]\n\nArray of strings:\n  len_trim = 5: [Short]\n  len_trim = 13: [Medium length]\n  len_trim = 23: [This is a longer string]\n\nlen(str):           30\nlen_trim(str):      15\nlen(trim(str)):     15\n\nWith kind=8: 15\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**len**(3)](#len),\n[**trim**(3)](#trim),\n[**adjustl**(3)](#adjustl),\n[**adjustr**(3)](#adjustr)",
  "repeat": "## repeat\n\n### **Name**\n\n**repeat** - \\[CHARACTER:MANIPULATION\\] Concatenate copies of a string\n\n### **Synopsis**\n```fortran\n    result = repeat(string, ncopies)\n```\n```fortran\n     pure function repeat(string, ncopies) result(res)\n\n      character(len=*), intent(in) :: string\n      integer, intent(in)          :: ncopies\n      character(len=len(string)*ncopies) :: res\n```\n\n### **Characteristics**\n\n - **string** is a scalar of type character.\n - **ncopies** is a scalar of type integer and must be non-negative.\n - The result is of type character with the same kind as **string**.\n - The result length is `len(string) * ncopies`.\n - This is a transformational function (not elemental).\n\n### **Description**\n\n **repeat** returns a string formed by concatenating **ncopies** copies\n of **string**. This is a convenient way to create repeated patterns,\n separator lines, padding, or any string that consists of a repeated\n substring without using explicit loops.\n\n Common uses include:\n - Creating horizontal separator lines for output\n - Building indentation strings\n - Generating repeated patterns for formatting\n - Creating padding of specific lengths\n\n### **Options**\n\n- **string**\n  : The character string to be repeated. May be of any character kind.\n  May be zero-length, in which case the result is also zero-length\n  regardless of **ncopies**.\n\n- **ncopies**\n  : The number of times to repeat **string**. Must be a non-negative\n  integer. If zero, the result is a zero-length string. Negative values\n  are not permitted and will cause an error.\n\n### **Result**\n\n  A character string of length `len(string) * ncopies` containing\n  **ncopies** concatenated copies of **string**. Has the same kind\n  as **string**. If **ncopies** is zero or **string** is zero-length,\n  the result is a zero-length string.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_repeat\n  implicit none\n  character(len=:), allocatable :: line, indent\n  character(len=3) :: abc\n  integer :: i\n\n  ! Create separator lines\n  line = repeat('-', 50)\n  print '(A)', line\n  print '(A)', 'Title'\n  print '(A)', line\n\n  ! Create a decorated box\n  print '(A)', ''\n  print '(A)', repeat('*', 30)\n  print '(A)', '*' // repeat(' ', 28) // '*'\n  print '(A)', '*      Hello, Fortran!      *'\n  print '(A)', '*' // repeat(' ', 28) // '*'\n  print '(A)', repeat('*', 30)\n\n  ! Create indentation for nested output\n  print '(A)', ''\n  print '(A)', 'Nested structure:'\n  do i = 0, 3\n    indent = repeat('  ', i)\n    print '(A,A,I0,A)', indent, 'Level ', i, ' item'\n  end do\n\n  ! Repeat a multi-character pattern\n  abc = '=-='\n  print '(A)', ''\n  print '(A)', repeat(abc, 10)\n\n  ! Zero copies gives empty string\n  print '(A)', ''\n  print '(A,I0,A)', 'Zero copies: [', len(repeat('x', 0)), ' chars]'\n\n  ! Create padding for right-alignment\n  print '(A)', ''\n  print '(A)', 'Right-aligned numbers:'\n  do i = 1, 1000, 333\n    print '(A,I0)', repeat(' ', 10 - int(log10(real(i))) - 1), i\n  end do\n\n  ! Build a simple progress bar\n  print '(A)', ''\n  print '(A)', 'Progress bar:'\n  do i = 1, 5\n    print '(A,A,A,I0,A)', '[', repeat('#', i*4), &\n      repeat(' ', 20-i*4), '] ', i*20, '%'\n  end do\n\nend program demo_repeat\n```\nResults:\n```text\n--------------------------------------------------\nTitle\n--------------------------------------------------\n\n******************************\n*                            *\n*      Hello, Fortran!      *\n*                            *\n******************************\n\nNested structure:\nLevel 0 item\n  Level 1 item\n    Level 2 item\n      Level 3 item\n\n=-==-==-==-==-==-==-==-==-==-=\n\nZero copies: [0 chars]\n\nRight-aligned numbers:\n         1\n       334\n       667\n      1000\n\nProgress bar:\n[####                ] 20%\n[########            ] 40%\n[############        ] 60%\n[################    ] 80%\n[####################] 100%\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**trim**(3)](#trim),\n[**len**(3)](#len),\n[**adjustl**(3)](#adjustl),\n[**adjustr**(3)](#adjustr)",
  "scan": "## scan\n\n### **Name**\n\n**scan** - \\[CHARACTER:MANIPULATION\\] Scan a string for any character in a set\n\n### **Synopsis**\n```fortran\n    result = scan(string, set)\n    result = scan(string, set, back)\n    result = scan(string, set, back, kind)\n```\n```fortran\n     elemental function scan(string, set, back, kind) result(res)\n\n      character(len=*), intent(in)           :: string\n      character(len=*), intent(in)           :: set\n      logical, intent(in), optional          :: back\n      integer, intent(in), optional          :: kind\n      integer(kind=KIND)                     :: res\n```\n\n### **Characteristics**\n\n - **string** is of type character.\n - **set** is of type character with the same kind as **string**.\n - **back** is of type logical (optional).\n - **kind** is a scalar integer constant expression (optional).\n - The result is of type integer with kind **kind** if present, else default.\n - This is an elemental function: it operates element-by-element on arrays.\n\n### **Description**\n\n **scan** searches **string** for the first occurrence of any character\n that is contained in **set**. If **back** is present and true, the search\n proceeds from the end of the string toward the beginning, returning the\n position of the last matching character.\n\n This function is useful for:\n - Finding delimiters in strings (commas, semicolons, etc.)\n - Locating specific character classes (vowels, digits, etc.)\n - Parsing structured text formats\n - Tokenizing input strings\n\n### **Options**\n\n- **string**\n  : The character string to be scanned for characters from **set**.\n\n- **set**\n  : The set of characters to search for. Any single character from this\n  set triggers a match. The order of characters in **set** does not matter.\n\n- **back**\n  : Optional. If present and `.true.`, scan from the rightmost position\n  toward the left, returning the position of the last matching character.\n  Default is `.false.` (scan left to right).\n\n- **kind**\n  : Optional. An integer initialization expression indicating the kind\n  parameter of the result.\n\n### **Result**\n\n  An integer indicating the position of the first (or last if `back=.true.`)\n  character in **string** that is also in **set**. Returns zero if:\n  - No character from **set** is found in **string**\n  - **string** is zero-length\n  - **set** is zero-length\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_scan\n  implicit none\n  character(len=50) :: str\n  character(len=*), parameter :: vowels = 'aeiouAEIOU'\n  character(len=*), parameter :: digits = '0123456789'\n  character(len=*), parameter :: delims = ',;:|'\n  integer :: pos, start\n\n  ! Find first vowel\n  str = 'Hello, World!'\n  pos = scan(str, vowels)\n  print '(A,I0,A,A)', 'First vowel at position ', pos, ': ', str(pos:pos)\n\n  ! Find last vowel\n  pos = scan(str, vowels, back=.true.)\n  print '(A,I0,A,A)', 'Last vowel at position ', pos, ': ', str(pos:pos)\n\n  ! Find first punctuation\n  pos = scan(str, ',.!?;:')\n  if (pos > 0) then\n    print '(A,I0,A,A)', 'First punctuation at ', pos, ': ', str(pos:pos)\n  end if\n\n  ! Search for characters not present\n  pos = scan(str, 'xyz')\n  print '(A,I0)', 'xyz not found, scan returns: ', pos\n\n  ! Find first digit in mixed string\n  str = 'Order #12345 received'\n  pos = scan(str, digits)\n  print '(A)', ''\n  print '(A,I0)', 'First digit at position: ', pos\n\n  ! Parse CSV: extract fields using scan\n  str = 'apple,banana,cherry,date'\n  print '(A)', ''\n  print '(A)', 'Parsing CSV:'\n  start = 1\n  do\n    pos = scan(str(start:), ',')\n    if (pos == 0) then\n      print '(A,A)', '  Field: ', trim(str(start:))\n      exit\n    else\n      print '(A,A)', '  Field: ', str(start:start+pos-2)\n      start = start + pos\n    end if\n  end do\n\n  ! Find any delimiter in a string with multiple delimiter types\n  str = 'field1,field2;field3|field4'\n  print '(A)', ''\n  print '(A,A)', 'String: ', trim(str)\n  pos = scan(str, delims)\n  print '(A,I0,A,A)', 'First delimiter at ', pos, ': ', str(pos:pos)\n  pos = scan(str, delims, back=.true.)\n  print '(A,I0,A,A)', 'Last delimiter at ', pos, ': ', str(pos:pos)\n\n  ! Check if string contains any whitespace\n  str = 'NoSpacesHere'\n  pos = scan(str, ' ' // achar(9))  ! space or tab\n  print '(A)', ''\n  if (pos == 0) then\n    print '(A,A,A)', '\"', trim(str), '\" contains no whitespace'\n  else\n    print '(A,A,A,I0)', '\"', trim(str), '\" has whitespace at ', pos\n  end if\n\nend program demo_scan\n```\nResults:\n```text\nFirst vowel at position 2: e\nLast vowel at position 8: o\nFirst punctuation at 6: ,\nxyz not found, scan returns: 0\n\nFirst digit at position: 8\n\nParsing CSV:\n  Field: apple\n  Field: banana\n  Field: cherry\n  Field: date\n\nString: field1,field2;field3|field4\nFirst delimiter at 7: ,\nLast delimiter at 21: |\n\n\"NoSpacesHere\" contains no whitespace\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**verify**(3)](#verify),\n[**index**(3)](#index),\n[**len_trim**(3)](#len_trim)",
  "verify": "## verify\n\n### **Name**\n\n**verify** - \\[CHARACTER:MANIPULATION\\] Find first character not in a given set\n\n### **Synopsis**\n```fortran\n    result = verify(string, set)\n    result = verify(string, set, back)\n    result = verify(string, set, back, kind)\n```\n```fortran\n     elemental function verify(string, set, back, kind) result(res)\n\n      character(len=*), intent(in)           :: string\n      character(len=*), intent(in)           :: set\n      logical, intent(in), optional          :: back\n      integer, intent(in), optional          :: kind\n      integer(kind=KIND)                     :: res\n```\n\n### **Characteristics**\n\n - **string** is of type character.\n - **set** is of type character with the same kind as **string**.\n - **back** is of type logical (optional).\n - **kind** is a scalar integer constant expression (optional).\n - The result is of type integer with kind **kind** if present, else default.\n - This is an elemental function: it operates element-by-element on arrays.\n\n### **Description**\n\n **verify** searches **string** for the first character that is NOT\n contained in **set**. If **back** is present and true, the search\n proceeds from the end of the string toward the beginning, returning the\n position of the last character not in **set**.\n\n This is the complement of **scan**: while scan finds characters that ARE\n in a set, verify finds characters that are NOT in a set.\n\n This function is useful for:\n - Validating that strings contain only allowed characters\n - Finding invalid characters in input\n - Checking string format compliance\n - Locating non-conforming characters in data\n\n### **Options**\n\n- **string**\n  : The character string to be verified against **set**.\n\n- **set**\n  : The set of allowed characters. Every character in **string** should\n  be in this set for verify to return zero.\n\n- **back**\n  : Optional. If present and `.true.`, scan from the rightmost position\n  toward the left, returning the position of the last non-matching character.\n  Default is `.false.` (scan left to right).\n\n- **kind**\n  : Optional. An integer initialization expression indicating the kind\n  parameter of the result.\n\n### **Result**\n\n  An integer indicating the position of the first (or last if `back=.true.`)\n  character in **string** that is NOT in **set**. Returns zero if:\n  - All characters in **string** are present in **set**\n  - **string** is zero-length\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_verify\n  implicit none\n  character(len=50) :: str\n  character(len=*), parameter :: digits = '0123456789'\n  character(len=*), parameter :: alpha_lower = 'abcdefghijklmnopqrstuvwxyz'\n  character(len=*), parameter :: alpha_upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  character(len=*), parameter :: alpha = alpha_lower // alpha_upper\n  character(len=*), parameter :: alphanum = alpha // digits\n  integer :: pos\n\n  ! Verify string contains only digits\n  str = '12345'\n  pos = verify(str, digits)\n  if (pos == 0) then\n    print '(A,A,A)', '\"', trim(str), '\" contains only digits'\n  else\n    print '(A,A,A,I0)', '\"', trim(str), '\" has non-digit at position ', pos\n  end if\n\n  ! Find first non-digit character\n  str = '123abc456'\n  pos = verify(str, digits)\n  print '(A)', ''\n  print '(A,A,A)', 'String: \"', trim(str), '\"'\n  print '(A,I0,A,A)', '  First non-digit at position ', pos, ': \"', str(pos:pos), '\"'\n\n  ! Find last non-digit character\n  pos = verify(str, digits, back=.true.)\n  print '(A,I0,A,A)', '  Last non-digit at position ', pos, ': \"', str(pos:pos), '\"'\n\n  ! Validate lowercase-only input\n  str = 'hello'\n  if (verify(str, alpha_lower) == 0) then\n    print '(A)', ''\n    print '(A,A,A)', '\"', trim(str), '\" is all lowercase letters'\n  end if\n\n  ! Find invalid character in supposedly lowercase input\n  str = 'helloWorld'\n  pos = verify(str, alpha_lower)\n  if (pos > 0) then\n    print '(A)', ''\n    print '(A,A,A)', 'String: \"', trim(str), '\"'\n    print '(A,I0,A,A,A)', '  Invalid char at position ', pos, ': \"', str(pos:pos), '\"'\n  end if\n\n  ! Validate identifier format (alphanumeric + underscore, starts with letter)\n  str = 'var_name_1'\n  print '(A)', ''\n  print '(A,A,A)', 'Validating identifier: \"', trim(str), '\"'\n  if (verify(str(1:1), alpha) /= 0) then\n    print '(A)', '  Invalid: must start with a letter'\n  else if (verify(trim(str), alphanum // '_') /= 0) then\n    pos = verify(trim(str), alphanum // '_')\n    print '(A,I0,A,A,A)', '  Invalid char at ', pos, ': \"', str(pos:pos), '\"'\n  else\n    print '(A)', '  Valid identifier!'\n  end if\n\n  ! Validate phone number format (digits, dashes, parentheses, spaces)\n  str = '(555) 123-4567'\n  print '(A)', ''\n  print '(A,A,A)', 'Phone number: \"', trim(str), '\"'\n  pos = verify(trim(str), digits // '()-. ')\n  if (pos == 0) then\n    print '(A)', '  Valid phone number format'\n  else\n    print '(A,I0,A,A,A)', '  Invalid char at ', pos, ': \"', str(pos:pos), '\"'\n  end if\n\nend program demo_verify\n```\nResults:\n```text\n\"12345\" contains only digits\n\nString: \"123abc456\"\n  First non-digit at position 4: \"a\"\n  Last non-digit at position 6: \"c\"\n\n\"hello\" is all lowercase letters\n\nString: \"helloWorld\"\n  Invalid char at position 6: \"W\"\n\nValidating identifier: \"var_name_1\"\n  Valid identifier!\n\nPhone number: \"(555) 123-4567\"\n  Valid phone number format\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**scan**(3)](#scan),\n[**index**(3)](#index),\n[**len_trim**(3)](#len_trim)",
  "achar": "## achar\n\n### **Name**\n\n**achar** - \\[CHARACTER:MANIPULATION\\] Return the character at a position in the ASCII collating sequence\n\n### **Synopsis**\n```fortran\n    result = achar(i)\n    result = achar(i, kind)\n```\n```fortran\n     elemental function achar(i, kind) result(res)\n\n      integer, intent(in)           :: i\n      integer, intent(in), optional :: kind\n      character(len=1, kind=KIND)   :: res\n```\n\n### **Characteristics**\n\n - **i** is of type integer.\n - **kind** is a scalar integer constant expression (optional).\n - The result is a single character of type character with kind **kind**\n   if present, otherwise default character kind.\n - This is an elemental function: it operates element-by-element on arrays.\n\n### **Description**\n\n **achar** returns the character located at position **i** in the ASCII\n collating sequence. This is the inverse of the **iachar** function.\n It always uses ASCII ordering regardless of the processor's native\n character set, making it portable across platforms.\n\n For standard ASCII characters (0-127), the mapping is well-defined:\n - 0-31: Control characters (NUL, TAB, LF, CR, etc.)\n - 32: Space\n - 48-57: Digits '0'-'9'\n - 65-90: Uppercase letters 'A'-'Z'\n - 97-122: Lowercase letters 'a'-'z'\n - 32-126: Printable characters\n - 127: DEL character\n\n### **Options**\n\n- **i**\n  : The integer code point in the ASCII sequence. Valid values are 0-127\n  for standard ASCII. Values outside this range produce processor-dependent\n  results. Negative values are not valid.\n\n- **kind**\n  : Optional. The kind type parameter of the result. If absent, the result\n  is default character kind. Use this for Unicode or other character kinds.\n\n### **Result**\n\n  A single character at position **i** in the ASCII collating sequence.\n  The result has length 1 and kind equal to **kind** if specified,\n  otherwise the default character kind.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_achar\n  implicit none\n  integer :: i\n  character(len=26) :: alphabet\n\n  ! Print some ASCII characters\n  print '(A,A)', 'ASCII 65 (A): ', achar(65)\n  print '(A,A)', 'ASCII 97 (a): ', achar(97)\n  print '(A,A)', 'ASCII 48 (0): ', achar(48)\n  print '(A,A)', 'ASCII 32 (space): [', achar(32), ']'\n\n  ! Build the uppercase alphabet\n  do i = 1, 26\n    alphabet(i:i) = achar(64 + i)\n  end do\n  print '(A,A)', 'Uppercase alphabet: ', alphabet\n\n  ! Build the lowercase alphabet\n  do i = 1, 26\n    alphabet(i:i) = achar(96 + i)\n  end do\n  print '(A,A)', 'Lowercase alphabet: ', alphabet\n\n  ! Create special characters for formatting\n  print '(A)', 'Tab character: [' // achar(9) // ']'\n  print '(A)', 'Using newline:'\n  print '(A)', 'Line 1' // achar(10) // 'Line 2'\n\n  ! Convert integer codes to string\n  print '(A)', 'Hello from codes: ' // &\n    achar(72) // achar(101) // achar(108) // achar(108) // achar(111)\n\nend program demo_achar\n```\nResults:\n```text\nASCII 65 (A): A\nASCII 97 (a): a\nASCII 48 (0): 0\nASCII 32 (space): [ ]\nUppercase alphabet: ABCDEFGHIJKLMNOPQRSTUVWXYZ\nLowercase alphabet: abcdefghijklmnopqrstuvwxyz\nTab character: [\\t]\nUsing newline:\nLine 1\nLine 2\nHello from codes: Hello\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**iachar**(3)](#iachar),\n[**char**(3)](#char),\n[**ichar**(3)](#ichar)",
  "iachar": "## iachar\n\n### **Name**\n\n**iachar** - \\[CHARACTER:MANIPULATION\\] Return the ASCII code of a character\n\n### **Synopsis**\n```fortran\n    result = iachar(c)\n    result = iachar(c, kind)\n```\n```fortran\n     elemental function iachar(c, kind) result(res)\n\n      character(len=1), intent(in)  :: c\n      integer, intent(in), optional :: kind\n      integer(kind=KIND)            :: res\n```\n\n### **Characteristics**\n\n - **c** is a single character of type character.\n - **kind** is a scalar integer constant expression (optional).\n - The result is of type integer with kind **kind** if present,\n   otherwise default integer kind.\n - This is an elemental function: it operates element-by-element on arrays.\n\n### **Description**\n\n **iachar** returns the position of the character **c** in the ASCII\n collating sequence. This is the inverse of the **achar** function.\n It always uses ASCII ordering regardless of the processor's native\n character set, making it portable across platforms.\n\n Key ASCII code ranges:\n - 0-31: Control characters\n - 32: Space\n - 48-57: Digits '0'-'9'\n - 65-90: Uppercase letters 'A'-'Z'\n - 97-122: Lowercase letters 'a'-'z'\n - 127: DEL character\n\n### **Options**\n\n- **c**\n  : A single character whose ASCII code is to be returned. Only the first\n  character is used if the argument has length greater than one. If the\n  character is not in the ASCII character set, the result is processor-dependent.\n\n- **kind**\n  : Optional. The kind type parameter of the result. If absent, the result\n  is default integer kind. Use this when you need a specific integer kind\n  for the result.\n\n### **Result**\n\n  An integer representing the position of **c** in the ASCII collating\n  sequence. Returns values 0-127 for standard ASCII characters.\n  The kind of the result is **kind** if present, otherwise default integer.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_iachar\n  implicit none\n  character :: c\n  character(len=26) :: str\n  integer :: code, i\n\n  ! Get ASCII codes for common characters\n  print '(A,I0)', 'ASCII code of A: ', iachar('A')\n  print '(A,I0)', 'ASCII code of Z: ', iachar('Z')\n  print '(A,I0)', 'ASCII code of a: ', iachar('a')\n  print '(A,I0)', 'ASCII code of z: ', iachar('z')\n  print '(A,I0)', 'ASCII code of 0: ', iachar('0')\n  print '(A,I0)', 'ASCII code of 9: ', iachar('9')\n  print '(A,I0)', 'ASCII code of space: ', iachar(' ')\n\n  ! Convert uppercase to lowercase using ASCII arithmetic\n  str = 'HELLO WORLD FORTRAN CODE'\n  print '(A)', ''\n  print '(A,A)', 'Original: ', str\n  do i = 1, len(str)\n    code = iachar(str(i:i))\n    if (code >= 65 .and. code <= 90) then\n      str(i:i) = achar(code + 32)\n    end if\n  end do\n  print '(A,A)', 'Lowercase: ', str\n\n  ! Check character classification\n  print '(A)', ''\n  print '(A)', 'Character classification:'\n  do i = 1, 5\n    c = 'aB1! '(i:i)\n    code = iachar(c)\n    print '(A,A,A,I0,A)', '  \"', c, '\" (code ', code, ') is ', &\n      classify_char(code)\n  end do\n\n  ! Using kind parameter\n  print '(A)', ''\n  print '(A,I0)', 'With kind=8: ', iachar('Z', kind=8)\n\ncontains\n\n  function classify_char(code) result(class)\n    integer, intent(in) :: code\n    character(len=20) :: class\n    if (code >= 65 .and. code <= 90) then\n      class = 'uppercase letter'\n    else if (code >= 97 .and. code <= 122) then\n      class = 'lowercase letter'\n    else if (code >= 48 .and. code <= 57) then\n      class = 'digit'\n    else if (code == 32) then\n      class = 'space'\n    else\n      class = 'other'\n    end if\n  end function classify_char\n\nend program demo_iachar\n```\nResults:\n```text\nASCII code of A: 65\nASCII code of Z: 90\nASCII code of a: 97\nASCII code of z: 122\nASCII code of 0: 48\nASCII code of 9: 57\nASCII code of space: 32\n\nOriginal: HELLO WORLD FORTRAN CODE\nLowercase: hello world fortran code\n\nCharacter classification:\n  \"a\" (code 97) is lowercase letter\n  \"B\" (code 66) is uppercase letter\n  \"1\" (code 49) is digit\n  \"!\" (code 33) is other\n  \" \" (code 32) is space\n\nWith kind=8: 90\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**achar**(3)](#achar),\n[**ichar**(3)](#ichar),\n[**char**(3)](#char)",
  "kind": "## kind\n\n### **Name**\n\n**kind** - \\[TYPE:KIND\\] Query the kind type parameter of a variable\n\n### **Synopsis**\n```fortran\n    result = kind(x)\n```\n```fortran\n     integer function kind(x)\n\n      type(*), intent(in) :: x(..)\n```\n\n### **Characteristics**\n\n - **x** may be any intrinsic type: INTEGER, REAL, COMPLEX, LOGICAL, or CHARACTER.\n - **x** may be a scalar or an array of any rank.\n - The value of **x** is not used; only its type and kind are queried.\n - The result is a default INTEGER scalar.\n\n### **Description**\n\n **kind** is an inquiry function that returns the kind type parameter value\n of its argument. The kind type parameter is a non-negative integer that\n characterizes the representation of a data type. Different kinds of the\n same intrinsic type may have different precisions, ranges, or storage sizes.\n\n The kind system in Fortran allows portable programming by enabling code\n to query and select appropriate numeric precision without relying on\n processor-dependent assumptions about storage sizes. Rather than assuming\n that REAL uses 4 bytes, portable code uses kind functions to ensure the\n required precision is available.\n\n Note that kind values are processor-dependent. A kind value of 4 on one\n processor may represent single precision, while on another processor the\n same precision might use a different kind value. This is why the\n SELECTED_INT_KIND and SELECTED_REAL_KIND functions are preferred for\n portable kind selection.\n\n### **Options**\n\n- **x**\n  : A variable, constant, or expression of any intrinsic type. May be\n  INTEGER, REAL, COMPLEX, LOGICAL, or CHARACTER. The actual value is\n  not examined; only the type and kind information is used.\n\n### **Result**\n\n  The result is a default integer scalar containing the kind type\n  parameter value of the argument. Common kind values include:\n\n  - INTEGER: typically 1, 2, 4, or 8 (bytes)\n  - REAL: typically 4, 8, or 16 (bytes)\n  - COMPLEX: typically 4, 8, or 16 (component size)\n  - LOGICAL: typically 1, 2, 4, or 8 (bytes)\n  - CHARACTER: typically 1 (default), 4 (UCS-4/ISO 10646)\n\n  However, these values are not mandated by the standard and may vary\n  between compilers. Always use SELECTED_INT_KIND or SELECTED_REAL_KIND\n  for portable kind selection.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_kind\n  use iso_fortran_env, only: int8, int16, int32, int64, &\n                             real32, real64, real128\n  implicit none\n\n  ! Query kind of various intrinsic types\n  print '(A)', 'Kind values for default types:'\n  print '(A,I0)', '  Default INTEGER:   ', kind(0)\n  print '(A,I0)', '  Default REAL:      ', kind(0.0)\n  print '(A,I0)', '  Default COMPLEX:   ', kind((0.0, 0.0))\n  print '(A,I0)', '  Default LOGICAL:   ', kind(.true.)\n  print '(A,I0)', '  Default CHARACTER: ', kind('A')\n\n  print '(A)', ''\n  print '(A)', 'Kind values for explicit kinds:'\n  print '(A,I0)', '  INTEGER(int8):   ', kind(0_int8)\n  print '(A,I0)', '  INTEGER(int16):  ', kind(0_int16)\n  print '(A,I0)', '  INTEGER(int32):  ', kind(0_int32)\n  print '(A,I0)', '  INTEGER(int64):  ', kind(0_int64)\n\n  print '(A)', ''\n  print '(A,I0)', '  REAL(real32):    ', kind(0.0_real32)\n  print '(A,I0)', '  REAL(real64):    ', kind(0.0_real64)\n  print '(A,I0)', '  REAL(real128):   ', kind(0.0_real128)\n\n  ! Demonstrate that value does not matter\n  print '(A)', ''\n  print '(A)', 'Value does not affect result:'\n  print '(A,L1)', '  kind(0) == kind(huge(0)): ', kind(0) == kind(huge(0))\n  print '(A,L1)', '  kind(0.0) == kind(1.0e30): ', kind(0.0) == kind(1.0e30)\n\n  ! Using kind for portable declarations\n  call demonstrate_portable_kinds()\n\ncontains\n\n  subroutine demonstrate_portable_kinds()\n    integer, parameter :: wp = kind(1.0d0)  ! Working precision\n    real(wp) :: x\n\n    x = 3.141592653589793_wp\n    print '(A)', ''\n    print '(A)', 'Using kind for portable working precision:'\n    print '(A,I0)', '  Working precision kind: ', wp\n    print '(A,G0)', '  Pi value: ', x\n  end subroutine\n\nend program demo_kind\n```\nResults:\n```text\nKind values for default types:\n  Default INTEGER:   4\n  Default REAL:      4\n  Default COMPLEX:   4\n  Default LOGICAL:   4\n  Default CHARACTER: 1\n\nKind values for explicit kinds:\n  INTEGER(int8):   1\n  INTEGER(int16):  2\n  INTEGER(int32):  4\n  INTEGER(int64):  8\n\n  REAL(real32):    4\n  REAL(real64):    8\n  REAL(real128):   16\n\nValue does not affect result:\n  kind(0) == kind(huge(0)): T\n  kind(0.0) == kind(1.0e30): T\n\nUsing kind for portable working precision:\n  Working precision kind: 8\n  Pi value: 3.141592653589793\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**selected_int_kind**(3)](#selected_int_kind),\n[**selected_real_kind**(3)](#selected_real_kind),\n[**precision**(3)](#precision),\n[**range**(3)](#range),\n[**digits**(3)](#digits),\n[**epsilon**(3)](#epsilon),\n[**huge**(3)](#huge),\n[**tiny**(3)](#tiny)",
  "selected_int_kind": "## selected_int_kind\n\n### **Name**\n\n**selected_int_kind** - \\[TYPE:KIND\\] Select integer kind for specified decimal range\n\n### **Synopsis**\n```fortran\n    result = selected_int_kind(r)\n```\n```fortran\n     integer function selected_int_kind(r)\n\n      integer, intent(in) :: r\n```\n\n### **Characteristics**\n\n - **r** is a scalar INTEGER specifying the desired decimal exponent range.\n - The result is a default INTEGER scalar.\n - This is a transformational function.\n\n### **Description**\n\n **selected_int_kind** returns the kind type parameter value for the smallest\n integer type that can represent all integer values n where:\n\n     -10^r < n < 10^r\n\n This function enables portable selection of integer kinds based on the\n required range of values, rather than relying on processor-dependent\n kind values. By specifying the number of decimal digits required, code\n can automatically adapt to different hardware architectures.\n\n For example, `selected_int_kind(9)` requests a kind that can hold values\n up to at least 999,999,999, which typically corresponds to a 32-bit\n integer. Using `selected_int_kind(18)` requests a kind for values up to\n at least 10^18-1, typically requiring a 64-bit integer.\n\n If multiple integer kinds satisfy the requirement, the one with the\n smallest decimal exponent range is returned. If multiple kinds have the\n same range, the smallest kind value is returned.\n\n### **Options**\n\n- **r**\n  : A scalar integer specifying the required decimal exponent range.\n  The function returns a kind that can represent all integers n\n  satisfying -10^r < n < 10^r. Typical useful values:\n  - r=2: values up to 99\n  - r=4: values up to 9,999\n  - r=9: values up to ~10^9 (32-bit)\n  - r=18: values up to ~10^18 (64-bit)\n\n### **Result**\n\n  The result is an integer kind type parameter value, or -1 if no\n  suitable integer kind exists on the processor.\n\n  Return values:\n  - **positive integer**: The kind parameter for the smallest integer\n    type supporting the requested range.\n  - **-1**: No integer type on the processor can represent the requested\n    range. This may occur for very large values of r.\n\n  Typical correspondences (processor-dependent):\n  - r <= 2:  kind for 8-bit integers\n  - r <= 4:  kind for 16-bit integers\n  - r <= 9:  kind for 32-bit integers\n  - r <= 18: kind for 64-bit integers\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_selected_int_kind\n  implicit none\n\n  ! Define portable integer kinds\n  integer, parameter :: i1 = selected_int_kind(2)   ! at least -99 to 99\n  integer, parameter :: i2 = selected_int_kind(4)   ! at least -9999 to 9999\n  integer, parameter :: i4 = selected_int_kind(9)   ! at least 9 digits\n  integer, parameter :: i8 = selected_int_kind(18)  ! at least 18 digits\n\n  ! Declare variables with specific precision\n  integer(kind=i1) :: small_int\n  integer(kind=i2) :: medium_int\n  integer(kind=i4) :: large_int\n  integer(kind=i8) :: very_large_int\n\n  print '(A)', 'Selected integer kinds and their ranges:'\n  print '(A)', ''\n\n  print '(A,I0)', 'selected_int_kind(2)  = ', i1\n  print '(A,I0,A,I0)', '  Range: ', -huge(small_int), ' to ', huge(small_int)\n  print '(A)', ''\n\n  print '(A,I0)', 'selected_int_kind(4)  = ', i2\n  print '(A,I0,A,I0)', '  Range: ', -huge(medium_int), ' to ', huge(medium_int)\n  print '(A)', ''\n\n  print '(A,I0)', 'selected_int_kind(9)  = ', i4\n  print '(A,I0,A,I0)', '  Range: ', -huge(large_int), ' to ', huge(large_int)\n  print '(A)', ''\n\n  print '(A,I0)', 'selected_int_kind(18) = ', i8\n  print '(A,I0,A,I0)', '  Range: ', -huge(very_large_int), ' to ', &\n        huge(very_large_int)\n\n  ! Verify the selected kinds meet requirements\n  print '(A)', ''\n  print '(A)', 'Verification that kinds meet requirements:'\n  print '(A,L1)', '  huge(i1) >= 10**2-1:  ', huge(small_int) >= 10_i1**2-1\n  print '(A,L1)', '  huge(i2) >= 10**4-1:  ', huge(medium_int) >= 10_i2**4-1\n  print '(A,L1)', '  huge(i4) >= 10**9-1:  ', huge(large_int) >= 10_i4**9-1\n  print '(A,L1)', '  huge(i8) >= 10**18-1: ', huge(very_large_int) >= 10_i8**18-1\n\n  ! Check for unavailable kinds\n  print '(A)', ''\n  print '(A)', 'Testing unavailable range:'\n  print '(A,I0)', '  selected_int_kind(100) = ', selected_int_kind(100)\n\n  ! Practical example: factorial calculation\n  call factorial_example()\n\ncontains\n\n  subroutine factorial_example()\n    integer, parameter :: fac_kind = selected_int_kind(18)\n    integer(fac_kind) :: factorial\n    integer :: n\n\n    print '(A)', ''\n    print '(A)', 'Factorial calculation with 64-bit integers:'\n    factorial = 1\n    do n = 1, 20\n      factorial = factorial * n\n      print '(A,I2,A,I0)', '  ', n, '! = ', factorial\n    end do\n  end subroutine\n\nend program demo_selected_int_kind\n```\nResults:\n```text\nSelected integer kinds and their ranges:\n\nselected_int_kind(2)  = 1\n  Range: -127 to 127\n\nselected_int_kind(4)  = 2\n  Range: -32767 to 32767\n\nselected_int_kind(9)  = 4\n  Range: -2147483647 to 2147483647\n\nselected_int_kind(18) = 8\n  Range: -9223372036854775807 to 9223372036854775807\n\nVerification that kinds meet requirements:\n  huge(i1) >= 10**2-1:  T\n  huge(i2) >= 10**4-1:  T\n  huge(i4) >= 10**9-1:  T\n  huge(i8) >= 10**18-1: T\n\nTesting unavailable range:\n  selected_int_kind(100) = -1\n\nFactorial calculation with 64-bit integers:\n   1! = 1\n   2! = 2\n   3! = 6\n   4! = 24\n   5! = 120\n   6! = 720\n   7! = 5040\n   8! = 40320\n   9! = 362880\n  10! = 3628800\n  11! = 39916800\n  12! = 479001600\n  13! = 6227020800\n  14! = 87178291200\n  15! = 1307674368000\n  16! = 20922789888000\n  17! = 355687428096000\n  18! = 6402373705728000\n  19! = 121645100408832000\n  20! = 2432902008176640000\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**kind**(3)](#kind),\n[**selected_real_kind**(3)](#selected_real_kind),\n[**huge**(3)](#huge),\n[**range**(3)](#range),\n[**digits**(3)](#digits),\n[**bit_size**(3)](#bit_size)",
  "selected_real_kind": "## selected_real_kind\n\n### **Name**\n\n**selected_real_kind** - \\[TYPE:KIND\\] Select real kind for specified precision and range\n\n### **Synopsis**\n```fortran\n    result = selected_real_kind([p] [,r] [,radix])\n```\n```fortran\n     integer function selected_real_kind(p, r, radix)\n\n      integer, intent(in), optional :: p\n      integer, intent(in), optional :: r\n      integer, intent(in), optional :: radix\n```\n\n### **Characteristics**\n\n - **p** is an optional scalar INTEGER specifying minimum decimal precision.\n - **r** is an optional scalar INTEGER specifying minimum decimal exponent range.\n - **radix** is an optional scalar INTEGER specifying the desired radix (Fortran 2008).\n - At least one of **p** or **r** must be present (before Fortran 2008).\n - The result is a default INTEGER scalar.\n - This is a transformational function.\n\n### **Description**\n\n **selected_real_kind** returns the kind type parameter value for a real\n data type with at least **p** decimal digits of precision and a decimal\n exponent range of at least **r**. This function is fundamental for writing\n portable numerical code that requires specific precision guarantees.\n\n The precision **p** specifies the minimum number of significant decimal\n digits. The range **r** specifies that the real type must be able to\n represent values from 10^(-r) to 10^(+r).\n\n For example, `selected_real_kind(6, 37)` requests single precision\n (approximately 6 significant digits, exponent range of about 10^-37 to\n 10^37), while `selected_real_kind(15, 307)` requests double precision.\n\n If multiple real kinds satisfy the requirements, the one with the\n smallest decimal precision is returned. If there are still multiple\n candidates, the smallest kind value is chosen.\n\n### **Options**\n\n- **p**\n  : Optional. Minimum decimal precision (number of significant digits).\n  If absent, treated as zero. Common values:\n  - p=6: single precision (~7 decimal digits)\n  - p=15: double precision (~15-16 decimal digits)\n  - p=33: quadruple precision (~33-34 decimal digits)\n\n- **r**\n  : Optional. Minimum decimal exponent range. The resulting type must\n  represent values from 10^(-r) to 10^(+r). If absent, treated as zero.\n  Common values:\n  - r=37: single precision range\n  - r=307: double precision range\n  - r=4931: quadruple precision range\n\n- **radix**\n  : Optional (Fortran 2008). The desired radix (base) for the real\n  representation. Almost all modern systems use radix 2 (binary).\n  If specified, the returned kind must have this radix.\n\n### **Result**\n\n  The result is an integer kind type parameter value, or a negative\n  value if no suitable real kind exists:\n\n  Return values:\n  - **positive integer**: The kind parameter for a real type meeting\n    all specified requirements.\n  - **-1**: Precision **p** is not achievable, but **r** (and **radix**)\n    requirements can be met.\n  - **-2**: Exponent range **r** is not achievable, but **p** (and\n    **radix**) requirements can be met.\n  - **-3**: Neither **p** nor **r** can be achieved (both fail), but\n    **radix** requirement can be met.\n  - **-4**: The **radix** requirement can be met, but not both **p**\n    and **r** together (one or the other fails).\n  - **-5**: No real type exists with the specified **radix**.\n\n  Typical correspondences (processor-dependent):\n  - p=6, r=37:   single precision (REAL*4)\n  - p=15, r=307: double precision (REAL*8)\n  - p=33, r=4931: quadruple precision (REAL*16, if available)\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_selected_real_kind\n  implicit none\n\n  ! Define portable real kinds by precision and range\n  integer, parameter :: sp = selected_real_kind(6, 37)    ! Single\n  integer, parameter :: dp = selected_real_kind(15, 307)  ! Double\n  integer, parameter :: qp = selected_real_kind(33, 4931) ! Quad\n\n  ! Alternative definitions using only precision\n  integer, parameter :: r6  = selected_real_kind(p=6)\n  integer, parameter :: r15 = selected_real_kind(p=15)\n\n  ! Alternative definitions using only range\n  integer, parameter :: rng300 = selected_real_kind(r=300)\n\n  ! Declare variables\n  real(sp) :: single_var\n  real(dp) :: double_var\n\n  print '(A)', 'Selected real kinds:'\n  print '(A,I0)', '  Single precision (p=6, r=37):    ', sp\n  print '(A,I0)', '  Double precision (p=15, r=307):  ', dp\n  print '(A,I0)', '  Quad precision (p=33, r=4931):   ', qp\n  print '(A)', ''\n\n  print '(A)', 'Kind properties:'\n  print '(A)', ''\n  print '(A,I0)', 'Single precision (kind=', sp, '):'\n  print '(A,I0)', '  Precision: ', precision(single_var)\n  print '(A,I0)', '  Range:     ', range(single_var)\n  print '(A,ES15.8)', '  Epsilon:   ', epsilon(single_var)\n  print '(A,ES15.8)', '  Tiny:      ', tiny(single_var)\n  print '(A,ES15.8)', '  Huge:      ', huge(single_var)\n  print '(A)', ''\n\n  print '(A,I0)', 'Double precision (kind=', dp, '):'\n  print '(A,I0)', '  Precision: ', precision(double_var)\n  print '(A,I0)', '  Range:     ', range(double_var)\n  print '(A,ES23.16)', '  Epsilon:   ', epsilon(double_var)\n  print '(A,ES23.16)', '  Tiny:      ', tiny(double_var)\n  print '(A,ES23.16)', '  Huge:      ', huge(double_var)\n  print '(A)', ''\n\n  ! Demonstrate error codes for unavailable kinds\n  print '(A)', 'Testing unavailable kind requests:'\n  print '(A,I0)', '  selected_real_kind(p=50):     ', selected_real_kind(p=50)\n  print '(A,I0)', '  selected_real_kind(r=10000):  ', selected_real_kind(r=10000)\n  print '(A,I0)', '  selected_real_kind(50,10000): ', selected_real_kind(50,10000)\n  print '(A)', ''\n\n  ! Practical numerical computation example\n  call numerical_example()\n\ncontains\n\n  subroutine numerical_example()\n    ! Working precision for numerical algorithms\n    integer, parameter :: wp = selected_real_kind(15, 307)\n    real(wp), parameter :: pi = 3.1415926535897932384626433832795_wp\n    real(wp) :: x, y, result\n    integer :: i\n\n    print '(A)', 'Numerical computation with working precision:'\n    print '(A,I0)', '  Working precision kind: ', wp\n    print '(A,G0)', '  Pi constant: ', pi\n    print '(A)', ''\n\n    ! Compute sin(x) for small x to verify precision\n    print '(A)', '  Verifying sin(x) ~ x for small x:'\n    x = 1.0e-10_wp\n    print '(A,ES23.16)', '    x        = ', x\n    print '(A,ES23.16)', '    sin(x)   = ', sin(x)\n    print '(A,ES23.16)', '    sin(x)-x = ', sin(x) - x\n    print '(A)', ''\n\n    ! Demonstrate range with exponential\n    print '(A)', '  Large range demonstration:'\n    x = 100.0_wp\n    y = exp(x)\n    print '(A,ES23.16)', '    exp(100) = ', y\n    x = -100.0_wp\n    y = exp(x)\n    print '(A,ES23.16)', '    exp(-100) = ', y\n  end subroutine\n\nend program demo_selected_real_kind\n```\nResults:\n```text\nSelected real kinds:\n  Single precision (p=6, r=37):    4\n  Double precision (p=15, r=307):  8\n  Quad precision (p=33, r=4931):   16\n\nKind properties:\n\nSingle precision (kind=4):\n  Precision: 6\n  Range:     37\n  Epsilon:    1.19209290E-07\n  Tiny:       1.17549435E-38\n  Huge:       3.40282347E+38\n\nDouble precision (kind=8):\n  Precision: 15\n  Range:     307\n  Epsilon:    2.2204460492503131E-16\n  Tiny:       2.2250738585072014E-308\n  Huge:       1.7976931348623157E+308\n\nTesting unavailable kind requests:\n  selected_real_kind(p=50):     -1\n  selected_real_kind(r=10000):  -2\n  selected_real_kind(50,10000): -3\n\nNumerical computation with working precision:\n  Working precision kind: 8\n  Pi constant: 3.1415926535897931\n\n  Verifying sin(x) ~ x for small x:\n    x        =  1.0000000000000000E-10\n    sin(x)   =  1.0000000000000000E-10\n    sin(x)-x =  0.0000000000000000E+00\n\n  Large range demonstration:\n    exp(100) =  2.6881171418161356E+43\n    exp(-100) =  3.7200759760208361E-44\n```\n\n### **Standard**\n\nFortran 90 (p, r arguments); Fortran 2008 (radix argument)\n\n### **See Also**\n\n[**kind**(3)](#kind),\n[**selected_int_kind**(3)](#selected_int_kind),\n[**precision**(3)](#precision),\n[**range**(3)](#range),\n[**epsilon**(3)](#epsilon),\n[**huge**(3)](#huge),\n[**tiny**(3)](#tiny),\n[**digits**(3)](#digits),\n[**radix**(3)](#radix)",
  "logical_conversion": "## logical\n\n### **Name**\n\n**logical** - \\[TYPE:CONVERSION\\] Convert between logical kinds\n\n### **Synopsis**\n```fortran\n    result = logical(l, kind)\n```\n```fortran\n     elemental function logical(l, kind) result(converted)\n\n      logical(kind=**), intent(in)           :: l\n      integer, intent(in), optional          :: kind\n      logical(kind=KIND)                     :: converted\n```\n\n### **Characteristics**\n\n - **l** is a logical value of any kind.\n - **kind** is an optional integer scalar that must be a constant expression.\n - The result is a logical value with the specified kind (or default logical kind if **kind** is absent).\n - This is an elemental function; it operates element-by-element on arrays.\n\n### **Description**\n\n **logical** converts a logical value from one kind to another. This is useful\n when interfacing with procedures that require a specific logical kind, when\n working with C-interoperable logical types, or when storage optimization\n requires a smaller logical representation. The logical value (.true. or\n .false.) is preserved; only the kind representation changes.\n\n### **Options**\n\n- **l**\n  : A logical expression of any kind to be converted. The value is preserved\n  during conversion; only the internal representation (kind) changes.\n\n- **kind**\n  : Optional. An integer constant expression specifying the kind type parameter\n  of the result. If absent, the result has default logical kind. Valid values\n  are processor-dependent but commonly include kinds that correspond to 1, 2,\n  4, or 8 byte storage.\n\n### **Result**\n\n  A logical value with the same truth value as **l** but with the specified\n  kind type parameter. If **kind** is absent, the result has default logical\n  kind.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_logical\nuse iso_c_binding, only: c_bool\nimplicit none\n  logical           :: default_log\n  logical(kind=1)   :: log1\n  logical(kind=4)   :: log4\n  logical(c_bool)   :: c_log\n\n  default_log = .true.\n\n  ! Convert to different kinds\n  log1 = logical(default_log, kind=1)\n  log4 = logical(default_log, kind=4)\n  c_log = logical(default_log, kind=c_bool)\n\n  print '(A,L1,A,I0)', 'Default logical: ', default_log, ', kind=', kind(default_log)\n  print '(A,L1,A,I0)', 'Kind 1 logical:  ', log1, ', kind=', kind(log1)\n  print '(A,L1,A,I0)', 'Kind 4 logical:  ', log4, ', kind=', kind(log4)\n  print '(A,L1,A,I0)', 'C_BOOL logical:  ', c_log, ', kind=', kind(c_log)\n\n  ! Elemental operation on array\n  print '(A)', 'Array conversion:'\n  print *, logical([.true., .false., .true.], kind=1)\n\n  ! Convert back to default kind\n  print '(A,L1)', 'Back to default:  ', logical(log1)\n\nend program demo_logical\n```\nResults:\n```text\nDefault logical: T, kind=4\nKind 1 logical:  T, kind=1\nKind 4 logical:  T, kind=4\nC_BOOL logical:  T, kind=1\nArray conversion:\n T F T\nBack to default:  T\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**kind**(3)](#kind),\n[**int**(3)](#int),\n[**real**(3)](#real)",
  "transfer": "## transfer\n\n### **Name**\n\n**transfer** - \\[TYPE:CONVERSION\\] Interpret bit pattern of source as a different type\n\n### **Synopsis**\n```fortran\n    result = transfer(source, mold)\n    result = transfer(source, mold, size)\n```\n```fortran\n     function transfer(source, mold, size) result(res)\n\n      type(SOURCE_TYPE), intent(in) :: source(..)\n      type(MOLD_TYPE), intent(in)   :: mold(..)\n      integer, intent(in), optional :: size\n      type(MOLD_TYPE)               :: res(..)\n```\n\n### **Characteristics**\n\n - **source** can be of any type; it may be a scalar or array.\n - **mold** can be of any type; it may be a scalar or array.\n - **size** is an optional scalar integer.\n - The result has the same type and kind as **mold**.\n - If **mold** is scalar and **size** is absent, the result is scalar.\n - If **mold** is an array or **size** is present, the result is a rank-1 array.\n - This is a transformational function.\n\n### **Description**\n\n **transfer** reinterprets the bit pattern of **source** as if it were the\n physical representation of a value of the type and kind of **mold**. This is\n not a type conversion in the mathematical sense; it is a bitwise reinterpretation\n similar to type punning or casting in C.\n\n The function copies the bits from **source** and interprets them according\n to the type of **mold**. This is useful for low-level operations such as:\n - Converting between integer and floating-point representations\n - Implementing C-like void pointer functionality\n - Serializing/deserializing data structures\n - Accessing the bit pattern of floating-point numbers\n\n **Warning:** When the resulting bit representation does not correspond to a\n valid value of the mold type, subsequent operations may produce undefined\n behavior. For example, transferring arbitrary integers to reals may produce\n NaN or other special values.\n\n### **Options**\n\n- **source**\n  : The data whose bit pattern is to be reinterpreted. May be of any type,\n  scalar or array. The total storage size of **source** provides the bits\n  to be transferred.\n\n- **mold**\n  : Determines the type, kind, and (for arrays) the element size of the result.\n  The actual value of **mold** is not used; only its type characteristics matter.\n  For scalar **mold** without **size**, the result is scalar. For array **mold**,\n  or when **size** is present, the result is a rank-1 array.\n\n- **size**\n  : (Optional) A scalar integer specifying the number of elements in the result\n  array. If present, the result is always a rank-1 array of this length,\n  regardless of whether **mold** is scalar or array.\n\n### **Result**\n\n  The result has the type and kind of **mold**, with its bit pattern derived\n  from **source**:\n\n  - If **size** is absent and **mold** is scalar: The result is a scalar\n    containing the first bits of **source** interpreted as the mold type.\n\n  - If **size** is absent and **mold** is an array: The result is a rank-1\n    array with enough elements to hold all bits of **source**.\n\n  - If **size** is present: The result is a rank-1 array with exactly **size**\n    elements.\n\n  If **source** has fewer bits than required by the result, the extra bits\n  are undefined. If **source** has more bits than needed, the excess is ignored.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_transfer\n  implicit none\n  integer :: i\n  real :: x\n  character(len=4) :: chars\n  integer(kind=1) :: bytes(4)\n  real(kind=8) :: dbl\n  integer(kind=8) :: long_int\n\n  ! View bit pattern of an integer as a real\n  i = 1065353216  ! This is the IEEE representation of 1.0\n  x = transfer(i, x)\n  print '(A,I0,A,F10.6)', 'Integer ', i, ' as real: ', x\n\n  ! View bit pattern of a real as an integer\n  x = 1.0\n  i = transfer(x, i)\n  print '(A,F4.1,A,I0)', 'Real ', x, ' as integer: ', i\n\n  ! Convert real to bytes (for I/O or network transmission)\n  x = 3.14159\n  bytes = transfer(x, bytes)\n  print '(A,4(Z2.2,1X))', 'Real as bytes (hex): ', bytes\n\n  ! Convert back from bytes\n  x = transfer(bytes, x)\n  print '(A,F10.5)', 'Bytes back to real: ', x\n\n  ! String to integer conversion (platform-dependent)\n  chars = 'ABCD'\n  i = transfer(chars, i)\n  print '(A,A,A,I0)', 'String \"', chars, '\" as integer: ', i\n\n  ! Using SIZE argument to get an array of specific length\n  dbl = 3.141592653589793d0\n  bytes = transfer(dbl, bytes, size=4)\n  print '(A,4(Z2.2,1X))', 'First 4 bytes of double: ', bytes\n\n  ! View double precision as long integer\n  dbl = 1.0d0\n  long_int = transfer(dbl, long_int)\n  print '(A,F4.1,A,I0)', 'Double ', dbl, ' as int64: ', long_int\n\nend program demo_transfer\n```\nResults (may vary by platform):\n```text\nInteger 1065353216 as real:   1.000000\nReal  1.0 as integer: 1065353216\nReal as bytes (hex): D0 0F 49 40\nBytes back to real:    3.14159\nString \"ABCD\" as integer: 1145258561\nFirst 4 bytes of double: 18 2D 44 54\nDouble  1.0 as int64: 4607182418800017408\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**reshape**(3)](#reshape),\n[**pack**(3)](#pack),\n[**unpack**(3)](#unpack),\n[**c_loc**(3)](#c_loc),\n[**c_f_pointer**(3)](#c_f_pointer)",
  "date_and_time": "## date_and_time\n\n### **Name**\n\n**date_and_time** - \\[SUBROUTINE:DATE_TIME\\] Returns date and time information from the real-time clock\n\n### **Synopsis**\n```fortran\n    call date_and_time(date, time, zone, values)\n```\n```fortran\n     subroutine date_and_time(date, time, zone, values)\n\n      character(len=*), intent(out), optional :: date\n      character(len=*), intent(out), optional :: time\n      character(len=*), intent(out), optional :: zone\n      integer,          intent(out), optional :: values(8)\n```\n\n### **Characteristics**\n\n - All arguments are **INTENT(OUT)** and **OPTIONAL**.\n - **date**, **time**, **zone** are default **CHARACTER** scalars.\n - **values** is a rank-1 **INTEGER** array with at least 8 elements.\n - At least one argument should be provided.\n - This is an intrinsic subroutine, not elemental.\n\n### **Description**\n\n **date_and_time** obtains date and time information from the real-time\n system clock. The information is returned in character strings and/or\n an integer array. When any argument is unavailable on the system,\n character arguments are filled with blanks and integer values are set\n to -HUGE(0).\n\n### **Options**\n\n- **date**\n  : Intent(out), optional. Character string of length 8 or more.\n  Returns the date in the format CCYYMMDD, where CC is the century,\n  YY is the year within the century, MM is the month, and DD is the day.\n\n- **time**\n  : Intent(out), optional. Character string of length 10 or more.\n  Returns the time in the format hhmmss.sss, where hh is the hour,\n  mm is the minutes, ss is the seconds, and sss is milliseconds.\n\n- **zone**\n  : Intent(out), optional. Character string of length 5 or more.\n  Returns the time difference from UTC in the format (+-)hhmm,\n  where hh is hours and mm is minutes offset from UTC.\n\n- **values**\n  : Intent(out), optional. Integer array of dimension 8 containing:\n    - values(1): Year (4 digits, e.g., 2024)\n    - values(2): Month of the year (1-12)\n    - values(3): Day of the month (1-31)\n    - values(4): Time difference from UTC in minutes\n    - values(5): Hour of the day (0-23)\n    - values(6): Minutes of the hour (0-59)\n    - values(7): Seconds of the minute (0-60, 60 for leap second)\n    - values(8): Milliseconds of the second (0-999)\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_date_and_time\nimplicit none\n  character(len=8)  :: date\n  character(len=10) :: time\n  character(len=5)  :: zone\n  integer           :: values(8)\n\n  ! Get all date and time information\n  call date_and_time(date, time, zone, values)\n\n  print '(A,A)',      'Date (CCYYMMDD): ', date\n  print '(A,A)',      'Time (hhmmss.sss): ', time\n  print '(A,A)',      'Zone (+-hhmm): ', zone\n  print '(A)',        'Values array:'\n  print '(A,I0)',     '  Year:        ', values(1)\n  print '(A,I0)',     '  Month:       ', values(2)\n  print '(A,I0)',     '  Day:         ', values(3)\n  print '(A,I0)',     '  UTC offset:  ', values(4), ' minutes'\n  print '(A,I0)',     '  Hour:        ', values(5)\n  print '(A,I0)',     '  Minute:      ', values(6)\n  print '(A,I0)',     '  Second:      ', values(7)\n  print '(A,I0)',     '  Millisecond: ', values(8)\n\n  ! Using keyword arguments for specific values only\n  call date_and_time(DATE=date)\n  print '(/,A,A)', 'Today is: ', date\n\n  call date_and_time(VALUES=values)\n  print '(A,I0,A,I0,A,I0)', 'Current time: ', &\n        values(5), ':', values(6), ':', values(7)\n\nend program demo_date_and_time\n```\nResults:\n```text\nDate (CCYYMMDD): 20240115\nTime (hhmmss.sss): 143025.123\nZone (+-hhmm): -0500\nValues array:\n  Year:        2024\n  Month:       1\n  Day:         15\n  UTC offset:  -300 minutes\n  Hour:        14\n  Minute:      30\n  Second:      25\n  Millisecond: 123\n\nToday is: 20240115\nCurrent time: 14:30:25\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**system_clock**(3)](#system_clock),\n[**cpu_time**(3)](#cpu_time)",
  "mvbits": "## mvbits\n\n### **Name**\n\n**mvbits** - \\[SUBROUTINE:BIT_MANIPULATION\\] Copies a sequence of bits from one integer to another\n\n### **Synopsis**\n```fortran\n    call mvbits(from, frompos, len, to, topos)\n```\n```fortran\n     elemental subroutine mvbits(from, frompos, len, to, topos)\n\n      integer(kind=**), intent(in)    :: from\n      integer,          intent(in)    :: frompos\n      integer,          intent(in)    :: len\n      integer(kind=**), intent(inout) :: to\n      integer,          intent(in)    :: topos\n```\n\n### **Characteristics**\n\n - **from** is **INTENT(IN)**, any INTEGER kind.\n - **frompos** is **INTENT(IN)**, default INTEGER.\n - **len** is **INTENT(IN)**, default INTEGER.\n - **to** is **INTENT(INOUT)**, same kind as **from**.\n - **topos** is **INTENT(IN)**, default INTEGER.\n - This is an **ELEMENTAL** subroutine.\n - **from** and **to** may be the same variable.\n\n### **Description**\n\n **mvbits** copies a sequence of bits from one integer to another.\n It moves **len** bits from positions **frompos** through **frompos+len-1**\n of **from** to positions **topos** through **topos+len-1** of **to**.\n The bits in **to** that are not affected by the move are unchanged.\n Bit positions are numbered from 0 (rightmost) to BIT_SIZE-1 (leftmost).\n\n### **Options**\n\n- **from**\n  : Intent(in). The source integer from which bits are copied.\n  Can be any integer kind.\n\n- **frompos**\n  : Intent(in). The starting bit position in **from**. Must be\n  non-negative and **frompos + len - 1** must be less than BIT_SIZE(from).\n\n- **len**\n  : Intent(in). The number of bits to copy. Must be non-negative.\n\n- **to**\n  : Intent(inout). The destination integer to which bits are copied.\n  Must be the same kind as **from**. Only the specified bit positions\n  are modified; all other bits retain their original values.\n\n- **topos**\n  : Intent(in). The starting bit position in **to** where bits are\n  placed. Must be non-negative and **topos + len - 1** must be less\n  than BIT_SIZE(to).\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_mvbits\nimplicit none\n  integer :: from, to\n  integer :: i\n\n  ! Example 1: Copy 4 bits from position 0 of 'from' to position 4 of 'to'\n  from = int(b'00001111')  ! 15 in decimal\n  to   = int(b'00000000')  ! 0 in decimal\n\n  print '(A,B8.8)', 'Before: from = ', from\n  print '(A,B8.8)', 'Before: to   = ', to\n\n  call mvbits(from, 0, 4, to, 4)\n\n  print '(A,B8.8)', 'After:  to   = ', to\n  print '(A,I0)',   'After:  to   = ', to\n\n  ! Example 2: Copy bits within the same variable\n  i = int(b'00000111')  ! bits 0-2 are set\n  print '(/,A,B8.8)', 'Before: i = ', i\n\n  call mvbits(i, 0, 3, i, 4)  ! copy bits 0-2 to positions 4-6\n\n  print '(A,B8.8)', 'After:  i = ', i\n  print '(A,I0)',   'After:  i = ', i\n\n  ! Example 3: Extract and insert a bit field\n  from = int(b'11110000')\n  to   = int(b'00001111')\n  print '(/,A,B8.8)', 'Before: from = ', from\n  print '(A,B8.8)',   'Before: to   = ', to\n\n  call mvbits(from, 4, 4, to, 0)  ! copy high nibble to low nibble\n\n  print '(A,B8.8)', 'After:  to   = ', to\n\nend program demo_mvbits\n```\nResults:\n```text\nBefore: from = 00001111\nBefore: to   = 00000000\nAfter:  to   = 11110000\nAfter:  to   = 240\n\nBefore: i = 00000111\nAfter:  i = 01110111\nAfter:  i = 119\n\nBefore: from = 11110000\nBefore: to   = 00001111\nAfter:  to   = 00001111\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**ibclr**(3)](#ibclr),\n[**ibset**(3)](#ibset),\n[**ibits**(3)](#ibits),\n[**iand**(3)](#iand),\n[**ior**(3)](#ior),\n[**ieor**(3)](#ieor),\n[**bit_size**(3)](#bit_size)",
  "random_seed": "## random_seed\n\n### **Name**\n\n**random_seed** - \\[SUBROUTINE:RANDOM\\] Initializes or queries the pseudorandom number generator state\n\n### **Synopsis**\n```fortran\n    call random_seed([size] [, put] [, get])\n```\n```fortran\n     subroutine random_seed(size, put, get)\n\n      integer, intent(out), optional :: size\n      integer, intent(in),  optional :: put(:)\n      integer, intent(out), optional :: get(:)\n```\n\n### **Characteristics**\n\n - All arguments are **OPTIONAL**.\n - **size** is **INTENT(OUT)**, scalar default INTEGER.\n - **put** is **INTENT(IN)**, rank-1 default INTEGER array.\n - **get** is **INTENT(OUT)**, rank-1 default INTEGER array.\n - Only one of **put** or **get** may be specified per call.\n - Without arguments, initializes with system-provided random data.\n\n### **Description**\n\n **random_seed** controls the state of the pseudorandom number generator\n used by **random_number**. It can query the required seed array size,\n retrieve the current generator state, or set a new state. When called\n without arguments, the generator is initialized using random data from\n the operating system, providing non-reproducible sequences.\n\n### **Options**\n\n- **size**\n  : Intent(out), optional. Returns the minimum size of the integer\n  array required for the **put** and **get** arguments. This size is\n  processor-dependent and must be queried before using **put** or **get**.\n\n- **put**\n  : Intent(in), optional. An integer array used to set the generator\n  state. The array size must be at least the value returned by **size**.\n  Using the same seed values produces the same sequence of random\n  numbers, enabling reproducible results.\n\n- **get**\n  : Intent(out), optional. An integer array that receives the current\n  generator state. The array size must be at least the value returned\n  by **size**. The retrieved state can be saved and later restored\n  using **put** to resume a sequence.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_random_seed\nimplicit none\n  integer              :: seed_size\n  integer, allocatable :: seed(:), saved_seed(:)\n  real                 :: x(5)\n  integer              :: i\n\n  ! Query the seed size required by this processor\n  call random_seed(size=seed_size)\n  print '(A,I0)', 'Seed size required: ', seed_size\n\n  allocate(seed(seed_size), saved_seed(seed_size))\n\n  ! Initialize with a known seed for reproducibility\n  seed = 12345  ! Simple seed (all elements same value)\n  call random_seed(put=seed)\n\n  call random_number(x)\n  print '(/,A)', 'First sequence with seed=12345:'\n  print '(5F10.6)', x\n\n  ! Reset to same seed - should get same sequence\n  call random_seed(put=seed)\n\n  call random_number(x)\n  print '(/,A)', 'Second sequence with seed=12345 (same):'\n  print '(5F10.6)', x\n\n  ! Save current state, generate numbers, restore, regenerate\n  call random_seed(get=saved_seed)\n  call random_number(x)\n  print '(/,A)', 'Sequence after get:'\n  print '(5F10.6)', x\n\n  ! Restore saved state - should reproduce the sequence\n  call random_seed(put=saved_seed)\n  call random_number(x)\n  print '(/,A)', 'Sequence after restoring saved state:'\n  print '(5F10.6)', x\n\n  ! Initialize with system randomness (non-reproducible)\n  call random_seed()\n  call random_number(x)\n  print '(/,A)', 'Sequence with system-random seed:'\n  print '(5F10.6)', x\n\n  deallocate(seed, saved_seed)\n\nend program demo_random_seed\n```\nResults:\n```text\nSeed size required: 8\n\nFirst sequence with seed=12345:\n  0.296578  0.188368  0.523687  0.712456  0.891234\n\nSecond sequence with seed=12345 (same):\n  0.296578  0.188368  0.523687  0.712456  0.891234\n\nSequence after get:\n  0.334578  0.892341  0.123456  0.567890  0.234567\n\nSequence after restoring saved state:\n  0.334578  0.892341  0.123456  0.567890  0.234567\n\nSequence with system-random seed:\n  0.847291  0.156823  0.934567  0.278345  0.612789\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**random_number**(3)](#random_number)",
  "merge": "## merge\n\n### **Name**\n\n**merge** - \\[ARRAY:MANIPULATION\\] Merge two arrays under mask control\n\n### **Synopsis**\n```fortran\n    result = merge(tsource, fsource, mask)\n```\n```fortran\n     elemental function merge(tsource, fsource, mask) result(res)\n\n      type(any_type), intent(in) :: tsource\n      type(same_as_tsource), intent(in) :: fsource\n      logical, intent(in) :: mask\n      type(same_as_tsource) :: res\n```\n\n### **Characteristics**\n\n - **tsource** can be of any type (intrinsic or derived).\n - **fsource** must have the same type and type parameters as **tsource**.\n - **mask** must be of type logical.\n - All three arguments must be conformable (same shape or scalar).\n - The result has the same type and type parameters as **tsource**.\n - This is an elemental function operating element-by-element.\n\n### **Description**\n\n **merge** selects values from two sources based on a logical mask. Where **mask**\n is .true., the result comes from **tsource** (\"true source\"); where **mask** is\n .false., the result comes from **fsource** (\"false source\"). This provides a\n compact way to perform conditional selection without explicit loops or\n if-then-else constructs.\n\n The function is elemental, meaning it operates element-by-element when given\n array arguments, making it highly efficient for array operations.\n\n### **Options**\n\n- **tsource**\n  : The value(s) to use where **mask** is .true. Can be any intrinsic or\n  derived type. May be a scalar or array.\n\n- **fsource**\n  : The value(s) to use where **mask** is .false. Must have the same type\n  and type parameters as **tsource**. May be a scalar or array.\n\n- **mask**\n  : A logical value or array that determines the selection. Where .true.,\n  **tsource** is selected; where .false., **fsource** is selected.\n\n### **Result**\n\n The result has the same type, type parameters, and shape as **tsource** and\n **fsource** (after broadcasting). Element (i,j,...) of the result equals\n tsource(i,j,...) if mask(i,j,...) is .true., and fsource(i,j,...) otherwise.\n\n### **Examples**\n\n Sample program:\n\n```fortran\nprogram demo_merge\n  implicit none\n  integer :: i\n  integer :: a(5), b(5), c(5)\n  real :: x(4), y(4)\n  logical :: mask(5)\n\n  ! Basic scalar merge\n  print *, 'Scalar merge:'\n  print *, 'merge(10, 20, .true.)  = ', merge(10, 20, .true.)\n  print *, 'merge(10, 20, .false.) = ', merge(10, 20, .false.)\n\n  ! Array merge with mask\n  a = [1, 2, 3, 4, 5]\n  b = [10, 20, 30, 40, 50]\n  mask = [.true., .false., .true., .false., .true.]\n\n  c = merge(a, b, mask)\n  print *\n  print '(a,5i4)', 'Array a:    ', a\n  print '(a,5i4)', 'Array b:    ', b\n  print '(a,5l4)', 'Mask:       ', mask\n  print '(a,5i4)', 'merge(a,b): ', c\n\n  ! Using expression as mask - select positive values\n  x = [-1.5, 2.0, -3.5, 4.0]\n  y = merge(x, 0.0, x > 0.0)\n  print *\n  print '(a,4f6.1)', 'Original x:          ', x\n  print '(a,4f6.1)', 'Positive only:       ', y\n\n  ! Clamp values to range [0, 10]\n  a = [-5, 3, 15, 7, 12]\n  c = merge(0, a, a < 0)       ! Replace negatives with 0\n  c = merge(10, c, c > 10)     ! Replace values > 10 with 10\n  print *\n  print '(a,5i4)', 'Before clamp:', a\n  print '(a,5i4)', 'After clamp: ', c\n\n  ! Absolute value using merge\n  a = [-3, 2, -5, 4, -1]\n  c = merge(-a, a, a < 0)\n  print *\n  print '(a,5i4)', 'Values:   ', a\n  print '(a,5i4)', 'Absolute: ', c\n\nend program demo_merge\n```\n\n Results:\n\n```text\n Scalar merge:\n merge(10, 20, .true.)  =           10\n merge(10, 20, .false.) =           20\n\nArray a:       1   2   3   4   5\nArray b:      10  20  30  40  50\nMask:          T   F   T   F   T\nmerge(a,b):    1  20   3  40   5\n\nOriginal x:            -1.5   2.0  -3.5   4.0\nPositive only:          0.0   2.0   0.0   4.0\n\nBefore clamp:  -5   3  15   7  12\nAfter clamp:    0   3  10   7  10\n\nValues:       -3   2  -5   4  -1\nAbsolute:      3   2   5   4   1\n```\n\n### **Standard**\n\n Fortran 90\n\n### **See Also**\n\n - [**pack**](#pack) - Pack array elements into a vector under mask control\n - [**unpack**](#unpack) - Unpack a vector into an array under mask control\n - [**where**](#where) - Masked array assignment construct",
  "spread": "## spread\n\n### **Name**\n\n**spread** - \\[ARRAY:MANIPULATION\\] Replicate an array by adding a dimension\n\n### **Synopsis**\n```fortran\n    result = spread(source, dim, ncopies)\n```\n```fortran\n     function spread(source, dim, ncopies) result(res)\n\n      type(any_type), intent(in) :: source(..)\n      integer, intent(in)        :: dim\n      integer, intent(in)        :: ncopies\n      type(same_as_source)       :: res(..)\n```\n\n### **Characteristics**\n\n - **source** can be a scalar or array of any intrinsic or derived type with rank < 15.\n - **dim** must be a scalar integer with value in range 1 <= dim <= n+1, where n is the rank of **source**.\n - **ncopies** must be a scalar integer specifying the extent of the new dimension.\n - The result has rank n+1 (one more than **source**) and the same type as **source**.\n\n### **Description**\n\n **spread** replicates **source** by adding a new dimension at position **dim**\n with extent **ncopies**. Each element along the new dimension contains a copy\n of **source**. This is useful for broadcasting operations where you need to\n expand an array to match another array's shape.\n\n For a scalar **source**, the result is a rank-one array of **ncopies** copies.\n For an array **source** of rank n, the result has rank n+1 with the new\n dimension inserted at position **dim**.\n\n### **Options**\n\n- **source**\n  : The scalar or array to replicate. Can be of any type. Maximum rank is 14\n  (since result has rank n+1 and maximum rank is 15).\n\n- **dim**\n  : The position for the new dimension in the result. Must satisfy\n  1 <= dim <= rank(source) + 1. DIM=1 inserts at the front, DIM=n+1 at the end.\n\n- **ncopies**\n  : The number of copies (extent of the new dimension). If ncopies <= 0,\n  the result has zero size along that dimension.\n\n### **Result**\n\n The result has rank n+1 where n is the rank of **source**. The shape is\n the shape of **source** with **ncopies** inserted at position **dim**.\n Each section along dimension **dim** is a copy of **source**.\n\n### **Examples**\n\n Sample program:\n\n```fortran\nprogram demo_spread\n  implicit none\n  integer :: i\n  integer :: a, v(3), m(2, 3)\n  integer :: spread_scalar(4), spread_v1(4, 3), spread_v2(3, 4)\n  integer :: spread_m(2, 3, 2)\n\n  ! Spread a scalar to create a vector\n  a = 5\n  spread_scalar = spread(a, dim=1, ncopies=4)\n  print '(a,4i3)', 'Spread scalar 5, ncopies=4: ', spread_scalar\n\n  ! Spread a vector along dim=1 (add rows)\n  v = [1, 2, 3]\n  spread_v1 = spread(v, dim=1, ncopies=4)\n  print *\n  print '(a)', 'Spread vector [1,2,3] along dim=1, ncopies=4:'\n  print '(a)', '(Result is 4x3 - vector becomes columns, repeated 4 times)'\n  do i = 1, 4\n    print '(3i4)', spread_v1(i, :)\n  end do\n\n  ! Spread a vector along dim=2 (add columns)\n  spread_v2 = spread(v, dim=2, ncopies=4)\n  print *\n  print '(a)', 'Spread vector [1,2,3] along dim=2, ncopies=4:'\n  print '(a)', '(Result is 3x4 - vector becomes rows, repeated 4 times)'\n  do i = 1, 3\n    print '(4i4)', spread_v2(i, :)\n  end do\n\n  ! Spread a 2D array along dim=3\n  m = reshape([1, 2, 3, 4, 5, 6], [2, 3])\n  print *\n  print '(a)', 'Original 2x3 matrix:'\n  do i = 1, 2\n    print '(3i4)', m(i, :)\n  end do\n\n  spread_m = spread(m, dim=3, ncopies=2)\n  print *\n  print '(a)', 'Spread matrix along dim=3, ncopies=2:'\n  print '(a)', 'Layer 1:'\n  do i = 1, 2\n    print '(3i4)', spread_m(i, :, 1)\n  end do\n  print '(a)', 'Layer 2:'\n  do i = 1, 2\n    print '(3i4)', spread_m(i, :, 2)\n  end do\n\n  ! Practical use: outer product via spread\n  print *\n  print '(a)', 'Outer product of [1,2,3] and [10,20] using spread:'\n  v = [1, 2, 3]\n  m(1:3, 1:2) = spread(v, dim=2, ncopies=2) * spread([10, 20], dim=1, ncopies=3)\n  do i = 1, 3\n    print '(2i6)', m(i, 1:2)\n  end do\n\nend program demo_spread\n```\n\n Results:\n\n```text\nSpread scalar 5, ncopies=4:   5  5  5  5\n\nSpread vector [1,2,3] along dim=1, ncopies=4:\n(Result is 4x3 - vector becomes columns, repeated 4 times)\n   1   2   3\n   1   2   3\n   1   2   3\n   1   2   3\n\nSpread vector [1,2,3] along dim=2, ncopies=4:\n(Result is 3x4 - vector becomes rows, repeated 4 times)\n   1   1   1   1\n   2   2   2   2\n   3   3   3   3\n\nOriginal 2x3 matrix:\n   1   3   5\n   2   4   6\n\nSpread matrix along dim=3, ncopies=2:\nLayer 1:\n   1   3   5\n   2   4   6\nLayer 2:\n   1   3   5\n   2   4   6\n\nOuter product of [1,2,3] and [10,20] using spread:\n    10    20\n    20    40\n    30    60\n```\n\n### **Standard**\n\n Fortran 90\n\n### **See Also**\n\n - [**reshape**](#reshape) - Construct an array with a specified shape\n - [**pack**](#pack) - Pack array elements into a rank-one array\n - [**unpack**](#unpack) - Unpack a vector into an array\n - [**merge**](#merge) - Merge two arrays under mask control",
  "cshift": "## cshift\n\n### **Name**\n\n**cshift** - \\[ARRAY:MANIPULATION\\] Perform circular shift of array elements\n\n### **Synopsis**\n```fortran\n    result = cshift(array, shift [, dim])\n```\n```fortran\n     function cshift(array, shift, dim) result(res)\n\n      type(any_type), intent(in) :: array(..)\n      integer, intent(in)        :: shift\n      integer, intent(in), optional :: dim\n      type(same_as_array)        :: res(same_shape_as_array)\n```\n\n### **Characteristics**\n\n - **array** can be any array of any intrinsic or derived type with any rank.\n - **shift** must be of type integer. If **array** has rank one, **shift** must be a scalar. If **array** has rank greater than one, **shift** can be a scalar or an array of rank n-1 conformable with the shape of **array** with dimension **dim** removed.\n - **dim** must be a scalar integer with a value in the range 1 <= dim <= n, where n is the rank of **array**. If absent, it defaults to 1.\n - The result has the same type, type parameters, and shape as **array**.\n\n### **Description**\n\n **cshift** performs a circular shift on elements of **array** along the dimension\n specified by **dim**. Elements shifted out one end of each rank-one section are\n shifted back in at the other end. A positive **shift** causes a shift to the left\n (toward lower indices), while a negative **shift** causes a shift to the right\n (toward higher indices). A zero **shift** leaves the array unchanged.\n\n If **array** has rank one, then all elements are shifted by **shift** places.\n If **array** has rank greater than one, each complete rank-one section along\n dimension **dim** is shifted independently.\n\n### **Options**\n\n- **array**\n  : The array to be shifted. It can be of any intrinsic or derived type and\n  any rank from 1 to 15.\n\n- **shift**\n  : The number of positions to shift. Positive values shift toward lower\n  indices (left for rows, up for columns). Negative values shift toward\n  higher indices (right for rows, down for columns). For multi-dimensional\n  arrays, **shift** can be an array specifying different shift amounts for\n  different sections.\n\n- **dim**\n  : (Optional) The dimension along which to shift. Must be a positive integer\n  not exceeding the rank of **array**. Default is 1.\n\n### **Result**\n\n The result is an array with the same shape, type, and type parameters as\n **array**. Each rank-one section along dimension **dim** contains the elements\n of the corresponding section of **array**, circularly shifted by the\n corresponding element of **shift**.\n\n### **Examples**\n\n Sample program:\n\n```fortran\nprogram demo_cshift\n  implicit none\n  integer :: i\n  integer :: v(6)\n  integer :: a(3, 4)\n\n  ! One-dimensional circular shift\n  v = [1, 2, 3, 4, 5, 6]\n  print '(a,6i3)', 'Original:     ', v\n  print '(a,6i3)', 'Shift left 2: ', cshift(v, shift=2)\n  print '(a,6i3)', 'Shift right 2:', cshift(v, shift=-2)\n\n  ! Two-dimensional array\n  a = reshape([(i, i=1,12)], [3, 4])\n  print *\n  print '(a)', 'Original 3x4 array:'\n  do i = 1, 3\n    print '(4i4)', a(i, :)\n  end do\n\n  ! Shift along dimension 1 (columns shift down/up)\n  print *\n  print '(a)', 'After cshift(a, shift=1, dim=1):'\n  do i = 1, 3\n    print '(4i4)', cshift(a, shift=1, dim=1)(i, :)\n  end do\n\n  ! Shift along dimension 2 (rows shift left/right)\n  print *\n  print '(a)', 'After cshift(a, shift=1, dim=2):'\n  do i = 1, 3\n    print '(4i4)', cshift(a, shift=1, dim=2)(i, :)\n  end do\n\n  ! Different shifts for each row\n  print *\n  print '(a)', 'After cshift(a, shift=[1,2,3], dim=2):'\n  do i = 1, 3\n    print '(4i4)', cshift(a, shift=[1, 2, 3], dim=2)(i, :)\n  end do\n\nend program demo_cshift\n```\n\n Results:\n\n```text\nOriginal:       1  2  3  4  5  6\nShift left 2:   3  4  5  6  1  2\nShift right 2:  5  6  1  2  3  4\n\nOriginal 3x4 array:\n   1   4   7  10\n   2   5   8  11\n   3   6   9  12\n\nAfter cshift(a, shift=1, dim=1):\n   2   5   8  11\n   3   6   9  12\n   1   4   7  10\n\nAfter cshift(a, shift=1, dim=2):\n   4   7  10   1\n   5   8  11   2\n   6   9  12   3\n\nAfter cshift(a, shift=[1,2,3], dim=2):\n   4   7  10   1\n   8  11   2   5\n  12   3   6   9\n```\n\n### **Standard**\n\n Fortran 90\n\n### **See Also**\n\n - [**eoshift**](#eoshift) - End-off shift elements of an array\n - [**transpose**](#transpose) - Transpose a rank-two array\n - [**reshape**](#reshape) - Reshape an array",
  "exponent": "## exponent\n\n### **Name**\n\n**exponent** - \\[NUMERIC:MANIPULATION\\] Extract the exponent part of a floating-point number\n\n### **Synopsis**\n```fortran\n    result = exponent(x)\n```\n```fortran\n     elemental function exponent(x) result(i)\n       real(kind=**), intent(in) :: x\n       integer                   :: i\n```\n\n### **Characteristics**\n\n - **x** must be of type REAL, of any kind.\n - The result is a default INTEGER.\n - This is an elemental function, operating element-wise on arrays.\n\n### **Description**\n\n**exponent(x)** extracts the exponent component from the floating-point representation of **x** according to the Fortran numeric model:\n\n    x = fraction(x) * radix(x)**exponent(x)\n\nwhere **fraction(x)** is the fractional part (mantissa) satisfying 0.5 <= |fraction(x)| < 1.0 for normalized numbers, and **radix(x)** is the base of the floating-point system (typically 2 for IEEE binary floating-point).\n\nFor IEEE 754 floating-point numbers, **exponent** returns the unbiased exponent. The function is useful for analyzing the magnitude and representation of floating-point values, implementing numerical algorithms that need to manipulate the exponent directly, and understanding floating-point precision characteristics.\n\n### **Options**\n\n - **x**\n   : A real number of any kind. The value whose exponent part is to be extracted.\n\n### **Result**\n\nThe result is a default integer representing the exponent of **x** in the model representation.\n\n - If **x** is zero, the result is zero.\n - If **x** is an IEEE infinity, the result is a large positive integer (implementation-dependent).\n - If **x** is an IEEE NaN, the result is unspecified.\n - For normalized numbers, the exponent e satisfies: radix(x)**(e-1) <= |x| < radix(x)**e\n\n### **Examples**\n\n```fortran\nprogram demo_exponent\n  implicit none\n  real :: x\n  real(kind=selected_real_kind(15)) :: dx\n  integer :: i\n\n  ! Basic usage\n  x = 1.0\n  print '(A,G0,A,I0)', 'exponent(', x, ') = ', exponent(x)\n\n  x = 8.0\n  print '(A,G0,A,I0)', 'exponent(', x, ') = ', exponent(x)\n\n  ! Powers of 2\n  do i = -3, 3\n    x = 2.0**i\n    print '(A,G0,A,I0)', 'exponent(', x, ') = ', exponent(x)\n  end do\n\n  ! Verify the model: x = fraction(x) * radix(x)**exponent(x)\n  x = 178.1387e-4\n  print *\n  print '(A,ES15.8)', 'x                              = ', x\n  print '(A,F15.8)',  'fraction(x)                    = ', fraction(x)\n  print '(A,I0)',     'exponent(x)                    = ', exponent(x)\n  print '(A,I0)',     'radix(x)                       = ', radix(x)\n  print '(A,ES15.8)', 'fraction(x) * radix(x)**exp(x) = ', &\n        fraction(x) * real(radix(x))**exponent(x)\n\n  ! Special cases\n  print *\n  print '(A,I0)', 'exponent(0.0) = ', exponent(0.0)\n\n  ! Double precision\n  dx = 1.0d0\n  print '(A,I0)', 'exponent(1.0d0) = ', exponent(dx)\n\nend program demo_exponent\n```\n\n**Results:**\n```text\nexponent(1.0) = 1\nexponent(8.0) = 4\nexponent(.125) = -2\nexponent(.25) = -1\nexponent(.5) = 0\nexponent(1.0) = 1\nexponent(2.0) = 2\nexponent(4.0) = 3\nexponent(8.0) = 4\n\nx                              =   1.78138707E-02\nfraction(x)                    =      0.91207018\nexponent(x)                    = -5\nradix(x)                       = 2\nfraction(x) * radix(x)**exp(x) =   1.78138707E-02\n\nexponent(0.0) = 0\nexponent(1.0d0) = 1\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n - [**fraction**](#fraction) - Extract fractional part of floating-point model\n - [**set_exponent**](#set_exponent) - Construct number with given exponent\n - [**scale**](#scale) - Scale by power of radix\n - [**radix**](#radix) - Base of the numeric model\n - [**digits**](#digits) - Number of significant digits\n - [**spacing**](#spacing) - Absolute spacing of model numbers",
  "fraction": "## fraction\n\n### **Name**\n\n**fraction** - \\[NUMERIC:MANIPULATION\\] Extract the fractional part of the floating-point model representation\n\n### **Synopsis**\n```fortran\n    result = fraction(x)\n```\n```fortran\n     elemental function fraction(x) result(frac)\n       real(kind=**), intent(in) :: x\n       real(kind=**)             :: frac\n```\n\n### **Characteristics**\n\n - **x** must be of type REAL, of any kind.\n - The result is REAL with the same kind as **x**.\n - This is an elemental function, operating element-wise on arrays.\n\n### **Description**\n\n**fraction(x)** returns the fractional part (also called mantissa or significand) of the floating-point representation of **x** according to the Fortran numeric model:\n\n    x = fraction(x) * radix(x)**exponent(x)\n\nThe fractional part satisfies:\n - 0.5 <= |fraction(x)| < 1.0 for normalized nonzero numbers\n - fraction(0.0) = 0.0\n\nThis is computed as:\n\n    fraction(x) = x * radix(x)**(-exponent(x))\n\nThe function is essential for algorithms that need to separate the magnitude (exponent) from the precision bits (fraction) of a floating-point number, such as in normalization, range reduction, and precision analysis.\n\n### **Options**\n\n - **x**\n   : A real number of any kind. The value whose fractional part is to be extracted.\n\n### **Result**\n\nThe fractional part of the model representation of **x**, having the same type and kind as **x**.\n\n - If **x** is zero, the result is zero.\n - If **x** is an IEEE infinity, the result is an IEEE NaN.\n - For normalized numbers, 0.5 <= |result| < 1.0\n - The sign of the result matches the sign of **x**.\n\n### **Examples**\n\n```fortran\nprogram demo_fraction\n  implicit none\n  real :: x, frac\n  real(kind=selected_real_kind(15)) :: dx\n  integer :: i\n\n  ! Basic usage\n  x = 178.1387e-4\n  frac = fraction(x)\n  print '(A,ES15.8)', 'x         = ', x\n  print '(A,F15.8)',  'fraction  = ', frac\n\n  ! Verify the relationship\n  print '(A,ES15.8)', 'Reconstructed = ', frac * real(radix(x))**exponent(x)\n\n  ! The fraction is always between 0.5 and 1.0 (for nonzero)\n  print *\n  print '(A)', 'Demonstrating fraction range:'\n  do i = -3, 3\n    x = 2.0**i\n    print '(A,G10.3,A,F10.6)', 'fraction(', x, ') = ', fraction(x)\n  end do\n\n  ! Negative numbers preserve sign\n  print *\n  x = -3.5\n  print '(A,G0,A,F10.6)', 'fraction(', x, ') = ', fraction(x)\n\n  ! Zero case\n  print '(A,F10.6)', 'fraction(0.0) = ', fraction(0.0)\n\n  ! Double precision example\n  dx = 123.456789012345d0\n  print *\n  print '(A,ES25.16)', 'dx                = ', dx\n  print '(A,F25.16)',  'fraction(dx)      = ', fraction(dx)\n  print '(A,I0)',      'exponent(dx)      = ', exponent(dx)\n\nend program demo_fraction\n```\n\n**Results:**\n```text\nx         =   1.78138707E-02\nfraction  =      0.91207018\nReconstructed =   1.78138707E-02\n\nDemonstrating fraction range:\nfraction(     0.125) =   0.500000\nfraction(     0.250) =   0.500000\nfraction(     0.500) =   0.500000\nfraction(      1.00) =   0.500000\nfraction(      2.00) =   0.500000\nfraction(      4.00) =   0.500000\nfraction(      8.00) =   0.500000\n\nfraction(-3.5) =  -0.875000\nfraction(0.0) =   0.000000\n\ndx                =  1.2345678901234500E+02\nfraction(dx)      =  0.9645061641589453\nexponent(dx)      = 7\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n - [**exponent**](#exponent) - Extract exponent part of floating-point model\n - [**set_exponent**](#set_exponent) - Construct number with given exponent\n - [**scale**](#scale) - Scale by power of radix\n - [**radix**](#radix) - Base of the numeric model\n - [**nearest**](#nearest) - Nearest representable number",
  "nearest": "## nearest\n\n### **Name**\n\n**nearest** - \\[NUMERIC:MANIPULATION\\] Return the nearest representable floating-point number in a specified direction\n\n### **Synopsis**\n```fortran\n    result = nearest(x, s)\n```\n```fortran\n     elemental function nearest(x, s) result(neighbor)\n       real(kind=**), intent(in) :: x\n       real(kind=**), intent(in) :: s\n       real(kind=**)             :: neighbor\n```\n\n### **Characteristics**\n\n - **x** must be of type REAL, of any kind.\n - **s** must be of type REAL (any kind) and must not be zero.\n - The result is REAL with the same kind as **x**.\n - This is an elemental function, operating element-wise on arrays.\n\n### **Description**\n\n**nearest(x, s)** returns the processor-representable floating-point number nearest to **x** in the direction indicated by the sign of **s**:\n\n - If **s** > 0, returns the smallest representable number greater than **x**\n - If **s** < 0, returns the largest representable number less than **x**\n\nThis function is essential for understanding and working with floating-point precision. It reveals the discrete nature of floating-point representation and is useful for:\n\n - Implementing robust numerical comparisons\n - Understanding machine epsilon and spacing\n - Creating test cases that probe floating-point boundaries\n - Implementing interval arithmetic\n\nThe difference between **x** and **nearest(x, s)** equals **spacing(x)** for most values.\n\n### **Options**\n\n - **x**\n   : A real number of any kind. The reference value from which to find the nearest neighbor.\n\n - **s**\n   : A real number that indicates the direction. Only the sign matters:\n   - s > 0: search in the positive direction (toward +infinity)\n   - s < 0: search in the negative direction (toward -infinity)\n   - s must not be zero (undefined behavior)\n\n### **Result**\n\nThe nearest distinct representable floating-point number to **x** in the direction of **s**, having the same type and kind as **x**.\n\n - If **x** is the largest finite number and s > 0, the result may be +infinity.\n - If **x** is the smallest finite number and s < 0, the result may be -infinity.\n - The spacing between **x** and the result is the unit in the last place (ULP) for **x**.\n\n### **Examples**\n\n```fortran\nprogram demo_nearest\n  implicit none\n  real :: x, up, down, diff\n  real(kind=selected_real_kind(15)) :: dx, dup, ddown\n  integer :: i\n\n  ! Basic usage: find neighbors of 42.0\n  x = 42.0\n  up = nearest(x, 1.0)     ! Next larger\n  down = nearest(x, -1.0)  ! Next smaller\n\n  print '(A)', 'Nearest neighbors of 42.0:'\n  print '(A,G20.14)', '  x      = ', x\n  print '(A,G20.14)', '  up     = ', up\n  print '(A,G20.14)', '  down   = ', down\n  print '(A,G20.14)', '  up - x = ', up - x\n  print '(A,G20.14)', '  x - down = ', x - down\n\n  ! Relationship with spacing\n  print *\n  print '(A,G20.14)', 'spacing(42.0) = ', spacing(x)\n\n  ! The spacing varies with magnitude\n  print *\n  print '(A)', 'Spacing at different magnitudes:'\n  do i = -2, 6\n    x = 10.0**i\n    diff = nearest(x, 1.0) - x\n    print '(A,G12.5,A,G12.5)', '  x=', x, '  spacing=', diff\n  end do\n\n  ! Double precision has much finer spacing\n  print *\n  dx = 1.0d0\n  dup = nearest(dx, 1.0d0)\n  ddown = nearest(dx, -1.0d0)\n  print '(A)', 'Double precision neighbors of 1.0:'\n  print '(A,G25.17)', '  dx        = ', dx\n  print '(A,G25.17)', '  dup       = ', dup\n  print '(A,G25.17)', '  dup - dx  = ', dup - dx\n\n  ! Practical use: robust comparison\n  print *\n  x = 1.0\n  print '(A,L1)', 'Is 1.0 + tiny less than nearest(1.0, 1.0)? ', &\n        (x + tiny(x)) < nearest(x, 1.0)\n\nend program demo_nearest\n```\n\n**Results:**\n```text\nNearest neighbors of 42.0:\n  x      =    42.000000000000\n  up     =    42.000003814697\n  down   =    41.999996185303\n  up - x =   3.8146972656250E-06\n  x - down =   3.8146972656250E-06\n\nspacing(42.0) =   3.8146972656250E-06\n\nSpacing at different magnitudes:\n  x=  0.10000E-01  spacing=  9.3132E-10\n  x=  0.10000      spacing=  7.4506E-09\n  x=   1.0000      spacing=  1.1921E-07\n  x=   10.000      spacing=  9.5367E-07\n  x=   100.00      spacing=  7.6294E-06\n  x=   1000.0      spacing=  6.1035E-05\n  x=   10000.      spacing=  9.7656E-04\n  x=  0.10000E+06  spacing=  7.8125E-03\n  x=  0.10000E+07  spacing=  6.2500E-02\n\nDouble precision neighbors of 1.0:\n  dx        =   1.0000000000000000\n  dup       =   1.0000000000000002\n  dup - dx  =  2.2204460492503131E-16\n\nIs 1.0 + tiny less than nearest(1.0, 1.0)? T\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n - [**spacing**](#spacing) - Absolute spacing of model numbers\n - [**rrspacing**](#rrspacing) - Reciprocal of relative spacing\n - [**epsilon**](#epsilon) - Machine epsilon\n - [**tiny**](#tiny) - Smallest positive number\n - [**huge**](#huge) - Largest representable number",
  "rrspacing": "## rrspacing\n\n### **Name**\n\n**rrspacing** - \\[NUMERIC:MANIPULATION\\] Return the reciprocal of relative spacing of model numbers near the argument\n\n### **Synopsis**\n```fortran\n    result = rrspacing(x)\n```\n```fortran\n     elemental function rrspacing(x) result(rrs)\n       real(kind=**), intent(in) :: x\n       real(kind=**)             :: rrs\n```\n\n### **Characteristics**\n\n - **x** must be of type REAL, of any kind.\n - The result is REAL with the same kind as **x**.\n - This is an elemental function, operating element-wise on arrays.\n\n### **Description**\n\n**rrspacing(x)** returns the reciprocal of the relative spacing of model numbers near **x**. It is computed as:\n\n    rrspacing(x) = |fraction(x)| * radix(x)**digits(x)\n\nThis value represents how many distinct floating-point numbers exist between 0 and |x| when measured in units of the smallest representable increment at the magnitude of x.\n\nThe relative spacing at **x** is:\n\n    relative_spacing = spacing(x) / |x| = radix(x)**(1-digits(x))\n\nThus **rrspacing** is the reciprocal of this relative spacing, which is independent of the magnitude of **x** for normalized numbers.\n\n**rrspacing** is useful for:\n - Analyzing floating-point precision characteristics\n - Understanding the relative precision available at a given magnitude\n - Implementing algorithms that need to account for relative precision\n - Computing the number of significant bits in a floating-point value\n\n### **Options**\n\n - **x**\n   : A real number of any kind. The value at which to compute the reciprocal of relative spacing.\n\n### **Result**\n\nThe reciprocal of the relative spacing of model numbers near **x**, having the same type and kind as **x**.\n\n - For normalized numbers, this equals |fraction(x)| * radix(x)**digits(x)\n - If **x** is zero, the result is zero.\n - The result is always non-negative.\n - For normalized numbers, 0.5 * radix(x)**digits(x) <= rrspacing(x) < radix(x)**digits(x)\n\n### **Examples**\n\n```fortran\nprogram demo_rrspacing\n  implicit none\n  real :: x, rrs\n  real(kind=selected_real_kind(15)) :: dx\n  integer :: i\n\n  ! Basic usage\n  x = 178.1387e-4\n  rrs = rrspacing(x)\n\n  print '(A,ES15.8)', 'x          = ', x\n  print '(A,ES15.8)', 'rrspacing  = ', rrs\n\n  ! Verify the formula: |fraction(x)| * radix(x)**digits(x)\n  print '(A,ES15.8)', 'Computed   = ', &\n        abs(fraction(x)) * real(radix(x))**digits(x)\n\n  ! rrspacing is nearly constant for normalized numbers\n  print *\n  print '(A)', 'rrspacing at different magnitudes (single precision):'\n  do i = -10, 10, 5\n    x = 2.0**i\n    print '(A,G12.5,A,ES15.8)', '  x=', x, '  rrspacing=', rrspacing(x)\n  end do\n\n  ! For powers of radix, fraction is exactly 0.5\n  print *\n  print '(A)', 'For powers of 2, rrspacing = 0.5 * 2**24 (single):'\n  x = 1.0\n  print '(A,ES15.8)', 'rrspacing(1.0)    = ', rrspacing(x)\n  print '(A,ES15.8)', '0.5 * 2**24       = ', 0.5 * 2.0**24\n\n  ! Relationship between spacing and rrspacing\n  print *\n  x = 100.0\n  print '(A,G0)',     'x                        = ', x\n  print '(A,ES15.8)', 'spacing(x)               = ', spacing(x)\n  print '(A,ES15.8)', 'rrspacing(x)             = ', rrspacing(x)\n  print '(A,ES15.8)', 'spacing * rrspacing / x  = ', &\n        spacing(x) * rrspacing(x) / abs(x)\n\n  ! Double precision has more digits\n  print *\n  dx = 1.0d0\n  print '(A,I0)',     'digits(double) = ', digits(dx)\n  print '(A,ES25.16)', 'rrspacing(1.0d0) = ', rrspacing(dx)\n  print '(A,ES25.16)', '0.5 * 2**53      = ', 0.5d0 * 2.0d0**53\n\nend program demo_rrspacing\n```\n\n**Results:**\n```text\nx          =   1.78138707E-02\nrrspacing  =   7.65581568E+06\nComputed   =   7.65581568E+06\n\nrrspacing at different magnitudes (single precision):\n  x=  9.7656E-04  rrspacing=  8.00000000E+06\n  x= 0.31250E-01  rrspacing=  8.38860800E+06\n  x=   1.0000     rrspacing=  8.38860800E+06\n  x=   32.000     rrspacing=  8.38860800E+06\n  x=   1024.0     rrspacing=  8.38860800E+06\n\nFor powers of 2, rrspacing = 0.5 * 2**24 (single):\nrrspacing(1.0)    =   8.38860800E+06\n0.5 * 2**24       =   8.38860800E+06\n\nx                        = 100.0\nspacing(x)               =   7.62939453E-06\nrrspacing(x)             =   1.31072000E+07\nspacing * rrspacing / x  =   1.00000000E+00\n\ndigits(double) = 53\nrrspacing(1.0d0) =  4.5035996273704960E+15\n0.5 * 2**53      =  4.5035996273704960E+15\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n - [**spacing**](#spacing) - Absolute spacing of model numbers\n - [**nearest**](#nearest) - Nearest representable number\n - [**fraction**](#fraction) - Extract fractional part\n - [**digits**](#digits) - Number of significant digits\n - [**radix**](#radix) - Base of the numeric model\n - [**epsilon**](#epsilon) - Machine epsilon",
  "scale": "## scale\n\n### **Name**\n\n**scale** - \\[NUMERIC:MANIPULATION\\] Scale a real value by a power of the radix\n\n### **Synopsis**\n```fortran\n    result = scale(x, i)\n```\n```fortran\n     elemental function scale(x, i) result(scaled)\n       real(kind=**), intent(in)    :: x\n       integer(kind=**), intent(in) :: i\n       real(kind=**)                :: scaled\n```\n\n### **Characteristics**\n\n - **x** must be of type REAL, of any kind.\n - **i** must be of type INTEGER, of any kind.\n - The result is REAL with the same kind as **x**.\n - This is an elemental function, operating element-wise on arrays.\n\n### **Description**\n\n**scale(x, i)** multiplies **x** by the radix of **x** raised to power **i**:\n\n    scale(x, i) = x * radix(x)**i\n\nSince the radix is almost always 2 on modern systems (IEEE binary floating-point), this is typically equivalent to:\n\n    scale(x, i) = x * 2**i\n\n**scale** performs this operation efficiently by directly adjusting the exponent of **x** rather than computing an actual multiplication. This makes it:\n\n - Faster than explicit multiplication by powers of 2\n - Exact (no rounding error) for valid results\n - Useful for implementing fast multiplication/division by powers of 2\n - Essential for scaling operations in numerical algorithms\n\nCare must be taken that the result remains within the representable range; if i is too large or too small, overflow or underflow may occur.\n\n### **Options**\n\n - **x**\n   : A real number of any kind. The value to be scaled.\n\n - **i**\n   : An integer of any kind. The power of the radix by which to scale **x**.\n   - Positive **i** increases the magnitude (multiplies by radix**i)\n   - Negative **i** decreases the magnitude (divides by radix**|i|)\n   - **i** = 0 returns **x** unchanged\n\n### **Result**\n\nThe value x * radix(x)**i, having the same type and kind as **x**.\n\n - If the result would overflow, it may return infinity or raise an exception.\n - If the result would underflow, it may return zero or a denormalized number.\n - The operation preserves the fraction (mantissa) of **x**.\n - scale(x, i) is equivalent to set_exponent(x, exponent(x) + i).\n\n### **Examples**\n\n```fortran\nprogram demo_scale\n  implicit none\n  real :: x, scaled\n  real(kind=selected_real_kind(15)) :: dx\n  integer :: i\n\n  ! Basic usage\n  x = 178.1387e-4\n  i = 5\n\n  scaled = scale(x, i)\n  print '(A,ES15.8)', 'x                  = ', x\n  print '(A,I0)',     'i                  = ', i\n  print '(A,ES15.8)', 'scale(x, i)        = ', scaled\n  print '(A,ES15.8)', 'x * radix(x)**i    = ', x * real(radix(x))**i\n  print '(A,ES15.8)', 'x * 2**i           = ', x * 2.0**i\n\n  ! Scale is equivalent to adjusting exponent\n  print *\n  print '(A,I0)',     'exponent(x)        = ', exponent(x)\n  print '(A,I0)',     'exponent(scale)    = ', exponent(scaled)\n  print '(A,ES15.8)', 'fraction unchanged = ', fraction(scaled)\n  print '(A,ES15.8)', 'fraction(x)        = ', fraction(x)\n\n  ! Practical use: fast multiply/divide by powers of 2\n  print *\n  print '(A)', 'Fast scaling operations:'\n  x = 100.0\n  print '(A,G0)',     'x            = ', x\n  print '(A,G0)',     'x * 2        = ', scale(x, 1)   ! Double\n  print '(A,G0)',     'x / 2        = ', scale(x, -1)  ! Halve\n  print '(A,G0)',     'x * 8        = ', scale(x, 3)   ! Multiply by 8\n  print '(A,G0)',     'x / 16       = ', scale(x, -4)  ! Divide by 16\n\n  ! Scaling preserves full precision\n  print *\n  dx = 1.234567890123456d0\n  print '(A,G25.16)', 'dx                 = ', dx\n  print '(A,G25.16)', 'scale(dx, 10)      = ', scale(dx, 10)\n  print '(A,G25.16)', 'scale back         = ', scale(scale(dx, 10), -10)\n\n  ! Demonstrate exponent limits\n  print *\n  x = 1.0\n  print '(A,I0)', 'maxexponent(x) = ', maxexponent(x)\n  print '(A,I0)', 'minexponent(x) = ', minexponent(x)\n\nend program demo_scale\n```\n\n**Results:**\n```text\nx                  =   1.78138707E-02\ni                  = 5\nscale(x, i)        =   5.70043862E-01\nx * radix(x)**i    =   5.70043862E-01\nx * 2**i           =   5.70043862E-01\n\nexponent(x)        = -5\nexponent(scale)    = 0\nfraction unchanged =   9.12070155E-01\nfraction(x)        =   9.12070155E-01\n\nFast scaling operations:\nx            = 100.0\nx * 2        = 200.0\nx / 2        = 50.0\nx * 8        = 800.0\nx / 16       = 6.25\n\ndx                 =  1.234567890123456\nscale(dx, 10)      =  1264.197295486419\nscale back         =  1.234567890123456\n\nmaxexponent(x) = 128\nminexponent(x) = -125\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n - [**set_exponent**](#set_exponent) - Set the exponent of a number\n - [**exponent**](#exponent) - Extract exponent part\n - [**fraction**](#fraction) - Extract fractional part\n - [**radix**](#radix) - Base of the numeric model\n - [**maxexponent**](#maxexponent) - Maximum exponent\n - [**minexponent**](#minexponent) - Minimum exponent",
  "set_exponent": "## set_exponent\n\n### **Name**\n\n**set_exponent** - \\[NUMERIC:MANIPULATION\\] Construct a floating-point number with given fractional part and exponent\n\n### **Synopsis**\n```fortran\n    result = set_exponent(x, i)\n```\n```fortran\n     elemental function set_exponent(x, i) result(y)\n       real(kind=**), intent(in)    :: x\n       integer(kind=**), intent(in) :: i\n       real(kind=**)                :: y\n```\n\n### **Characteristics**\n\n - **x** must be of type REAL, of any kind.\n - **i** must be of type INTEGER, of any kind.\n - The result is REAL with the same kind as **x**.\n - This is an elemental function, operating element-wise on arrays.\n\n### **Description**\n\n**set_exponent(x, i)** returns a real number with the fractional part of **x** and an exponent of **i**. The result is computed as:\n\n    set_exponent(x, i) = fraction(x) * radix(x)**i\n\nThis function allows direct manipulation of the exponent while preserving the significand (fractional part). It is the inverse operation to extracting the exponent: if you extract the fraction with **fraction(x)** and the exponent with **exponent(x)**, you can reconstruct **x** using **set_exponent**.\n\n**set_exponent** is useful for:\n - Normalizing numbers to a specific exponent range\n - Constructing test values with specific characteristics\n - Implementing algorithms that manipulate floating-point representations\n - Rescaling values while preserving precision\n\n### **Options**\n\n - **x**\n   : A real number of any kind. Provides the fractional part (mantissa) for the result.\n\n - **i**\n   : An integer of any kind. The desired exponent for the result.\n   - Should be within [minexponent(x), maxexponent(x)] for normalized results\n   - Values outside this range may cause overflow, underflow, or denormalized results\n\n### **Result**\n\nA real number with the same type and kind as **x**, having the fractional part of **x** and exponent **i**.\n\n - result = fraction(x) * radix(x)**i\n - If **x** is zero, the result is zero (regardless of **i**).\n - If **i** is greater than maxexponent(x), overflow may occur.\n - If **i** is less than minexponent(x), underflow may occur.\n - The sign of the result matches the sign of **x**.\n\n### **Examples**\n\n```fortran\nprogram demo_set_exponent\n  implicit none\n  real :: x, y\n  real(kind=selected_real_kind(15)) :: dx, dy\n  integer :: i, exp_x\n\n  ! Basic usage\n  x = 178.1387e-4\n  i = 17\n\n  y = set_exponent(x, i)\n  print '(A,ES15.8)', 'x                        = ', x\n  print '(A,I0)',     'i (new exponent)         = ', i\n  print '(A,ES15.8)', 'set_exponent(x, i)       = ', y\n  print '(A,ES15.8)', 'fraction(x) * radix**i   = ', &\n        fraction(x) * real(radix(x))**i\n\n  ! Verify: the fraction is preserved\n  print *\n  print '(A,F15.8)', 'fraction(x)              = ', fraction(x)\n  print '(A,F15.8)', 'fraction(result)         = ', fraction(y)\n  print '(A,I0)',    'exponent(result)         = ', exponent(y)\n\n  ! Relationship with scale\n  print *\n  print '(A)', 'Relationship with scale:'\n  exp_x = exponent(x)\n  print '(A,ES15.8)', 'set_exponent(x, 10)      = ', set_exponent(x, 10)\n  print '(A,ES15.8)', 'scale(x, 10 - exp(x))    = ', scale(x, 10 - exp_x)\n\n  ! Practical use: normalize to exponent = 0\n  print *\n  print '(A)', 'Normalizing numbers to exponent 0:'\n  x = 12345.67\n  print '(A,G15.7,A,F12.8)', 'x=', x, ' -> ', set_exponent(x, 0)\n  x = 0.000123\n  print '(A,G15.7,A,F12.8)', 'x=', x, ' -> ', set_exponent(x, 0)\n  x = -987.654\n  print '(A,G15.7,A,F12.8)', 'x=', x, ' -> ', set_exponent(x, 0)\n\n  ! Double precision example\n  print *\n  dx = 123.456789012345d0\n  dy = set_exponent(dx, 0)\n  print '(A,ES25.16)', 'dx                      = ', dx\n  print '(A,ES25.16)', 'set_exponent(dx, 0)     = ', dy\n  print '(A,F25.16)',  'fraction preserved      = ', fraction(dy)\n\n  ! Reconstruct original from fraction and exponent\n  print *\n  x = 42.5\n  print '(A,G0)',     'Original x              = ', x\n  print '(A,G0)',     'Reconstructed           = ', &\n        set_exponent(x, exponent(x))\n\nend program demo_set_exponent\n```\n\n**Results:**\n```text\nx                        =   1.78138707E-02\ni (new exponent)         = 17\nset_exponent(x, i)       =   1.19505920E+05\nfraction(x) * radix**i   =   1.19505920E+05\n\nfraction(x)              =      0.91207018\nfraction(result)         =      0.91207018\nexponent(result)         = 17\n\nRelationship with scale:\nset_exponent(x, 10)      =   9.33956299E+02\nscale(x, 10 - exp(x))    =   9.33956299E+02\n\nNormalizing numbers to exponent 0:\nx=   12345.67     ->   0.75378418\nx=  0.1230000E-03 ->   0.80609345\nx=  -987.654     ->  -0.96255469\n\ndx                      =  1.2345678901234500E+02\nset_exponent(dx, 0)     =  9.6450617197144141E-01\nfraction preserved      =  0.9645061719714414\n\nOriginal x              = 42.5\nReconstructed           = 42.5\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n - [**exponent**](#exponent) - Extract exponent part of floating-point model\n - [**fraction**](#fraction) - Extract fractional part\n - [**scale**](#scale) - Scale by power of radix\n - [**radix**](#radix) - Base of the numeric model\n - [**maxexponent**](#maxexponent) - Maximum exponent\n - [**minexponent**](#minexponent) - Minimum exponent",
  "spacing": "## spacing\n\n### **Name**\n\n**spacing** - \\[NUMERIC:MANIPULATION\\] Return the absolute spacing of model numbers near the argument\n\n### **Synopsis**\n```fortran\n    result = spacing(x)\n```\n```fortran\n     elemental function spacing(x) result(sp)\n       real(kind=**), intent(in) :: x\n       real(kind=**)             :: sp\n```\n\n### **Characteristics**\n\n - **x** must be of type REAL, of any kind.\n - The result is REAL with the same kind as **x**.\n - This is an elemental function, operating element-wise on arrays.\n\n### **Description**\n\n**spacing(x)** determines the absolute spacing between adjacent floating-point numbers at the magnitude of **x**. It returns the distance to the nearest adjacent representable number of the same type.\n\nFor a floating-point number **x**, **spacing(x)** is the difference between **x** and the nearest distinct floating-point number, which equals:\n\n    spacing(x) = radix(x)**(exponent(x) - digits(x))\n\nfor normalized numbers. This is also known as the \"unit in the last place\" (ULP) or \"machine epsilon at x\".\n\nKey characteristics of floating-point spacing:\n - Spacing increases with magnitude (larger numbers have larger gaps)\n - Spacing is constant between consecutive powers of the radix\n - spacing(x) = nearest(x, 1.0) - x for most values\n - spacing(1.0) is related to but not equal to epsilon(1.0)\n\n**spacing** is essential for:\n - Understanding floating-point precision at a given magnitude\n - Implementing robust numerical comparisons\n - Analyzing numerical algorithm stability\n - Determining appropriate tolerances for iterative methods\n\n### **Options**\n\n - **x**\n   : A real number of any kind. The value at which to determine the spacing.\n\n### **Result**\n\nThe absolute spacing of model numbers near **x**, having the same type and kind as **x**.\n\n - For normalized numbers: radix(x)**(exponent(x) - digits(x))\n - If **x** is zero, the result is tiny(x) (smallest positive normalized number)\n - The result is always positive.\n - For denormalized numbers near zero, the result may be the smallest representable positive number.\n\n### **Examples**\n\n```fortran\nprogram demo_spacing\n  implicit none\n  integer, parameter :: SGL = selected_real_kind(p=6, r=37)\n  integer, parameter :: DBL = selected_real_kind(p=13, r=200)\n  real(SGL) :: x_sgl\n  real(DBL) :: x_dbl\n  integer :: i\n\n  ! Basic usage\n  print '(A)', 'Spacing at 1.0 for different precisions:'\n  print '(A,ES15.8)', 'Single precision: ', spacing(1.0_SGL)\n  print '(A,ES15.8)', 'Double precision: ', spacing(1.0_DBL)\n\n  ! Verify spacing equals difference to nearest neighbor\n  print *\n  x_sgl = 1.0_SGL\n  print '(A,ES15.8)', 'spacing(1.0)              = ', spacing(x_sgl)\n  print '(A,ES15.8)', 'nearest(1.0, 1.0) - 1.0   = ', nearest(x_sgl, 1.0) - x_sgl\n\n  ! Spacing varies with magnitude\n  print *\n  print '(A)', 'Spacing at different magnitudes (single precision):'\n  print '(A)', '    Value            Spacing'\n  do i = -6, 6, 2\n    x_sgl = 10.0_SGL ** i\n    print '(ES15.3, ES15.3)', x_sgl, spacing(x_sgl)\n  end do\n\n  ! Spacing is constant between powers of radix\n  print *\n  print '(A)', 'Spacing between powers of 2:'\n  x_sgl = 1.0_SGL\n  print '(A,ES15.8)', 'spacing(1.0)   = ', spacing(x_sgl)\n  x_sgl = 1.5_SGL\n  print '(A,ES15.8)', 'spacing(1.5)   = ', spacing(x_sgl)\n  x_sgl = 1.99_SGL\n  print '(A,ES15.8)', 'spacing(1.99)  = ', spacing(x_sgl)\n  x_sgl = 2.0_SGL\n  print '(A,ES15.8)', 'spacing(2.0)   = ', spacing(x_sgl)  ! Doubles!\n\n  ! Relationship with epsilon\n  print *\n  print '(A)', 'Spacing vs epsilon:'\n  print '(A,ES15.8)', 'spacing(1.0)   = ', spacing(1.0_SGL)\n  print '(A,ES15.8)', 'epsilon(1.0)   = ', epsilon(1.0_SGL)\n  print '(A)', 'Note: epsilon = spacing(1.0) for single precision'\n\n  ! Special case: spacing at zero\n  print *\n  print '(A,ES15.8)', 'spacing(0.0)   = ', spacing(0.0_SGL)\n  print '(A,ES15.8)', 'tiny(1.0)      = ', tiny(1.0_SGL)\n\n  ! Practical use: checking for \"essentially equal\"\n  print *\n  print '(A)', 'Robust comparison example:'\n  x_sgl = 1.0_SGL / 3.0_SGL\n  print '(A,L1)', 'x*3 == 1.0 (exact)?              ', (x_sgl * 3.0_SGL == 1.0_SGL)\n  print '(A,L1)', '|x*3 - 1.0| < 2*spacing(1.0)?    ', &\n        abs(x_sgl * 3.0_SGL - 1.0_SGL) < 2.0_SGL * spacing(1.0_SGL)\n\nend program demo_spacing\n```\n\n**Results:**\n```text\nSpacing at 1.0 for different precisions:\nSingle precision:   1.19209290E-07\nDouble precision:   2.22044605E-16\n\nspacing(1.0)              =   1.19209290E-07\nnearest(1.0, 1.0) - 1.0   =   1.19209290E-07\n\nSpacing at different magnitudes (single precision):\n    Value            Spacing\n      1.000E-06       5.605E-14\n      1.000E-04       5.960E-12\n      1.000E-02       7.451E-10\n      1.000E+00       1.192E-07\n      1.000E+02       7.629E-06\n      1.000E+04       9.766E-04\n      1.000E+06       6.250E-02\n\nSpacing between powers of 2:\nspacing(1.0)   =   1.19209290E-07\nspacing(1.5)   =   1.19209290E-07\nspacing(1.99)  =   1.19209290E-07\nspacing(2.0)   =   2.38418579E-07\n\nSpacing vs epsilon:\nspacing(1.0)   =   1.19209290E-07\nepsilon(1.0)   =   1.19209290E-07\nNote: epsilon = spacing(1.0) for single precision\n\nspacing(0.0)   =   1.17549435E-38\ntiny(1.0)      =   1.17549435E-38\n\nRobust comparison example:\nx*3 == 1.0 (exact)?              F\n|x*3 - 1.0| < 2*spacing(1.0)?    T\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n - [**nearest**](#nearest) - Nearest representable number\n - [**rrspacing**](#rrspacing) - Reciprocal of relative spacing\n - [**epsilon**](#epsilon) - Machine epsilon (relative precision)\n - [**tiny**](#tiny) - Smallest positive normalized number\n - [**digits**](#digits) - Number of significant digits\n - [**radix**](#radix) - Base of the numeric model",
  "iand": "## **iand** - \\[BIT:MANIPULATION\\] Performs bitwise logical AND on two integers\n\n### **Synopsis**\n```fortran\nresult = iand(i, j)\n```\n\n```fortran\nelemental integer(kind=**) function iand(i, j)\n  integer(kind=**), intent(in) :: i\n  integer(kind=**), intent(in) :: j\nend function iand\n```\n\n### **Characteristics**\n- **i** and **j** must be of type `integer` with the same kind\n- The result has the same type and kind as the arguments\n- This is an elemental function\n\n### **Description**\n**iand** returns the bitwise logical AND of **i** and **j**. For each bit position, the result bit is 1 only if both corresponding bits in **i** and **j** are 1; otherwise the result bit is 0.\n\nTruth table for AND:\n```\ni bit | j bit | result\n------+-------+--------\n  0   |   0   |   0\n  0   |   1   |   0\n  1   |   0   |   0\n  1   |   1   |   1\n```\n\n### **Options**\n- **i**\n  : First `integer` operand.\n\n- **j**\n  : Second `integer` operand. Must have the same kind as **i**.\n\n### **Result**\nThe result is an `integer` of the same kind as the arguments, containing the bitwise AND of **i** and **j**.\n\n### **Examples**\n```fortran\nprogram demo_iand\n  implicit none\n  integer :: a, b, result\n  \n  a = 13   ! binary: 1101\n  b = 11   ! binary: 1011\n  \n  result = iand(a, b)  ! binary: 1001 = 9\n  \n  print '(a,i0,a,b8.8)', 'a      = ', a, '  binary: ', a\n  print '(a,i0,a,b8.8)', 'b      = ', b, '  binary: ', b\n  print '(a,i0,a,b8.8)', 'iand   = ', result, '  binary: ', result\n  \n  ! Practical: masking to extract lower 4 bits\n  print *\n  print '(a,i0)', 'Lower 4 bits of 255: ', iand(255, 15)\n  \n  ! Check if bit 2 is set using mask\n  print '(a,l1)', 'Bit 2 of 13 set? ', iand(13, 4) /= 0\nend program demo_iand\n```\nExpected output:\n```\na      = 13  binary: 00001101\nb      = 11  binary: 00001011\niand   = 9  binary: 00001001\n\nLower 4 bits of 255: 15\nBit 2 of 13 set? T\n```\n\n### **Standard**\nFortran 90\n\n### **See Also**\n[ior](#), [ieor](#), [not](#), [btest](#), [ibclr](#), [ibits](#), [ibset](#), [ishft](#), [ishftc](#), [bit_size](#)",
  "ior": "## **ior** - \\[BIT:MANIPULATION\\] Performs bitwise logical inclusive OR on two integers\n\n### **Synopsis**\n```fortran\nresult = ior(i, j)\n```\n\n```fortran\nelemental integer(kind=**) function ior(i, j)\n  integer(kind=**), intent(in) :: i\n  integer(kind=**), intent(in) :: j\nend function ior\n```\n\n### **Characteristics**\n- **i** and **j** must be of type `integer` with the same kind\n- The result has the same type and kind as the arguments\n- This is an elemental function\n\n### **Description**\n**ior** returns the bitwise logical inclusive OR of **i** and **j**. For each bit position, the result bit is 1 if either or both corresponding bits in **i** and **j** are 1; the result bit is 0 only if both input bits are 0.\n\nTruth table for OR:\n```\ni bit | j bit | result\n------+-------+--------\n  0   |   0   |   0\n  0   |   1   |   1\n  1   |   0   |   1\n  1   |   1   |   1\n```\n\n### **Options**\n- **i**\n  : First `integer` operand.\n\n- **j**\n  : Second `integer` operand. Must have the same kind as **i**.\n\n### **Result**\nThe result is an `integer` of the same kind as the arguments, containing the bitwise inclusive OR of **i** and **j**.\n\n### **Examples**\n```fortran\nprogram demo_ior\n  implicit none\n  integer :: a, b, result\n  \n  a = 12   ! binary: 1100\n  b = 10   ! binary: 1010\n  \n  result = ior(a, b)  ! binary: 1110 = 14\n  \n  print '(a,i0,a,b8.8)', 'a     = ', a, '  binary: ', a\n  print '(a,i0,a,b8.8)', 'b     = ', b, '  binary: ', b\n  print '(a,i0,a,b8.8)', 'ior   = ', result, '  binary: ', result\n  \n  ! Practical: setting specific bits\n  print *\n  print '(a,i0)', 'Set bit 3 of 1: ', ior(1, 8)   ! 1 + 8 = 9\n  \n  ! Combining flags\n  integer :: read_flag, write_flag, permissions\n  read_flag = 4    ! binary: 100\n  write_flag = 2   ! binary: 010\n  permissions = ior(read_flag, write_flag)  ! binary: 110 = 6\n  print '(a,i0)', 'Combined permissions: ', permissions\nend program demo_ior\n```\nExpected output:\n```\na     = 12  binary: 00001100\nb     = 10  binary: 00001010\nior   = 14  binary: 00001110\n\nSet bit 3 of 1: 9\nCombined permissions: 6\n```\n\n### **Standard**\nFortran 90\n\n### **See Also**\n[iand](#), [ieor](#), [not](#), [btest](#), [ibclr](#), [ibits](#), [ibset](#), [ishft](#), [ishftc](#), [bit_size](#)",
  "ieor": "## **ieor** - \\[BIT:MANIPULATION\\] Performs bitwise logical exclusive OR on two integers\n\n### **Synopsis**\n```fortran\nresult = ieor(i, j)\n```\n\n```fortran\nelemental integer(kind=**) function ieor(i, j)\n  integer(kind=**), intent(in) :: i\n  integer(kind=**), intent(in) :: j\nend function ieor\n```\n\n### **Characteristics**\n- **i** and **j** must be of type `integer` with the same kind\n- The result has the same type and kind as the arguments\n- This is an elemental function\n\n### **Description**\n**ieor** returns the bitwise logical exclusive OR (XOR) of **i** and **j**. For each bit position, the result bit is 1 if exactly one of the corresponding bits in **i** and **j** is 1; the result bit is 0 if both bits are the same.\n\nTruth table for XOR:\n```\ni bit | j bit | result\n------+-------+--------\n  0   |   0   |   0\n  0   |   1   |   1\n  1   |   0   |   1\n  1   |   1   |   0\n```\n\n### **Options**\n- **i**\n  : First `integer` operand.\n\n- **j**\n  : Second `integer` operand. Must have the same kind as **i**.\n\n### **Result**\nThe result is an `integer` of the same kind as the arguments, containing the bitwise exclusive OR of **i** and **j**.\n\n### **Examples**\n```fortran\nprogram demo_ieor\n  implicit none\n  integer :: a, b, result\n  \n  a = 13   ! binary: 1101\n  b = 11   ! binary: 1011\n  \n  result = ieor(a, b)  ! binary: 0110 = 6\n  \n  print '(a,i0,a,b8.8)', 'a      = ', a, '  binary: ', a\n  print '(a,i0,a,b8.8)', 'b      = ', b, '  binary: ', b\n  print '(a,i0,a,b8.8)', 'ieor   = ', result, '  binary: ', result\n  \n  ! Practical: toggle specific bits\n  print *\n  print '(a,i0)', 'Toggle bit 0 of 14: ', ieor(14, 1)  ! 14 -> 15\n  print '(a,i0)', 'Toggle bit 0 of 15: ', ieor(15, 1)  ! 15 -> 14\n  \n  ! XOR swap (without temporary variable)\n  integer :: x, y\n  x = 5\n  y = 9\n  print '(a,i0,a,i0)', 'Before swap: x=', x, ' y=', y\n  x = ieor(x, y)\n  y = ieor(y, x)\n  x = ieor(x, y)\n  print '(a,i0,a,i0)', 'After swap:  x=', x, ' y=', y\nend program demo_ieor\n```\nExpected output:\n```\na      = 13  binary: 00001101\nb      = 11  binary: 00001011\nieor   = 6  binary: 00000110\n\nToggle bit 0 of 14: 15\nToggle bit 0 of 15: 14\nBefore swap: x=5 y=9\nAfter swap:  x=9 y=5\n```\n\n### **Standard**\nFortran 90\n\n### **See Also**\n[iand](#), [ior](#), [not](#), [btest](#), [ibclr](#), [ibits](#), [ibset](#), [ishft](#), [ishftc](#), [bit_size](#)",
  "not": "## **not** - \\[BIT:MANIPULATION\\] Returns the bitwise logical complement\n\n### **Synopsis**\n```fortran\nresult = not(i)\n```\n\n```fortran\nelemental integer(kind=**) function not(i)\n  integer(kind=**), intent(in) :: i\nend function not\n```\n\n### **Characteristics**\n- **i** is of type `integer` (any kind)\n- The result has the same type and kind as **i**\n- This is an elemental function\n\n### **Description**\n**not** returns the bitwise logical complement (one's complement) of **i**. Each bit of the result is the opposite of the corresponding bit in **i**: 0 becomes 1, and 1 becomes 0.\n\nTruth table for NOT:\n```\ni bit | result\n------+--------\n  0   |   1\n  1   |   0\n```\n\nFor signed integers, `not(i)` is equivalent to `-(i + 1)` in two's complement representation.\n\n### **Options**\n- **i**\n  : The `integer` value to complement.\n\n### **Result**\nThe result is an `integer` of the same kind as **i**, containing the bitwise complement of **i**.\n\n### **Examples**\n```fortran\nprogram demo_not\n  implicit none\n  integer :: val, result\n  integer(kind=1) :: byte\n  \n  ! Simple complement\n  val = 0\n  result = not(val)\n  print '(a,i0,a,i0)', 'not(0) = ', result, '  (all bits set to 1 = -1)'\n  \n  val = -1  ! All bits are 1\n  result = not(val)\n  print '(a,i0)', 'not(-1) = ', result\n  \n  ! Working with bytes for clearer visualization\n  print *\n  byte = 0_1\n  print '(a,b8.8,a,b8.8)', 'not(00000000) = ', byte, ' -> ', not(byte)\n  \n  byte = 15_1  ! binary: 00001111\n  print '(a,b8.8,a,b8.8)', 'not(00001111) = ', byte, ' -> ', not(byte)\n  \n  byte = -86_1  ! binary: 10101010\n  print '(a,b8.8,a,b8.8)', 'not(10101010) = ', byte, ' -> ', not(byte)\n  \n  ! Practical: create bitmask with all bits set except one\n  print *\n  integer :: mask\n  mask = not(ishft(1, 3))  ! All bits except bit 3\n  print '(a,b32.32)', 'Mask with bit 3 clear: ', mask\n  \n  ! Use with iand to clear a specific bit\n  val = 255\n  result = iand(val, not(ishft(1, 4)))  ! Clear bit 4\n  print '(a,i0,a,b8.8)', 'Clear bit 4 of 255: ', result, '  binary: ', result\nend program demo_not\n```\nExpected output:\n```\nnot(0) = -1  (all bits set to 1 = -1)\nnot(-1) = 0\n\nnot(00000000) = 00000000 -> 11111111\nnot(00001111) = 00001111 -> 11110000\nnot(10101010) = 10101010 -> 01010101\n\nMask with bit 3 clear: 11111111111111111111111111110111\nClear bit 4 of 255: 239  binary: 11101111\n```\n\n### **Standard**\nFortran 90\n\n### **See Also**\n[iand](#), [ior](#), [ieor](#), [btest](#), [ibclr](#), [ibits](#), [ibset](#), [ishft](#), [ishftc](#), [bit_size](#)",
  "btest": "## **btest** - \\[BIT:MANIPULATION\\] Tests a specific bit of an integer value\n\n### **Synopsis**\n```fortran\nresult = btest(i, pos)\n```\n\n```fortran\nelemental logical function btest(i, pos)\n  integer(kind=**), intent(in) :: i\n  integer(kind=**), intent(in) :: pos\nend function btest\n```\n\n### **Characteristics**\n- **i** is of type `integer` (any kind)\n- **pos** is of type `integer` (any kind)\n- The result is of type `logical` (default kind)\n- This is an elemental function\n\n### **Description**\n**btest** returns `.true.` if the bit at position **pos** in integer **i** is set to 1, and `.false.` if it is set to 0. Bit positions are numbered from right to left, starting at 0 for the least significant bit.\n\nThe bit position must satisfy `0 <= pos < bit_size(i)`.\n\n### **Options**\n- **i**\n  : The `integer` value whose bit is to be tested.\n\n- **pos**\n  : The bit position to test. Must be non-negative and less than `bit_size(i)`.\n\n### **Result**\nThe result is `.true.` if bit **pos** of **i** is 1, otherwise `.false.`.\n\n### **Examples**\n```fortran\nprogram demo_btest\n  implicit none\n  integer :: i, pos\n  \n  ! Test value 13 = binary 1101\n  i = 13\n  print '(a,i0,a,b8.8)', 'Value: ', i, ' Binary: ', i\n  \n  do pos = 0, 7\n    if (btest(i, pos)) then\n      print '(a,i0,a)', '  Bit ', pos, ' is SET'\n    else\n      print '(a,i0,a)', '  Bit ', pos, ' is CLEAR'\n    end if\n  end do\n  \n  ! Practical example: check if number is odd (bit 0 set)\n  print *\n  print '(a,l1)', 'Is 13 odd? ', btest(13, 0)\n  print '(a,l1)', 'Is 14 odd? ', btest(14, 0)\nend program demo_btest\n```\nExpected output:\n```\nValue: 13 Binary: 00001101\n  Bit 0 is SET\n  Bit 1 is CLEAR\n  Bit 2 is SET\n  Bit 3 is SET\n  Bit 4 is CLEAR\n  Bit 5 is CLEAR\n  Bit 6 is CLEAR\n  Bit 7 is CLEAR\n\nIs 13 odd? T\nIs 14 odd? F\n```\n\n### **Standard**\nFortran 90\n\n### **See Also**\n[bit_size](#), [ibclr](#), [ibits](#), [ibset](#), [iand](#), [ieor](#), [ior](#), [ishft](#), [ishftc](#), [not](#)",
  "ibset": "## **ibset** - \\[BIT:MANIPULATION\\] Sets a specific bit to one\n\n### **Synopsis**\n```fortran\nresult = ibset(i, pos)\n```\n\n```fortran\nelemental integer(kind=**) function ibset(i, pos)\n  integer(kind=**), intent(in) :: i\n  integer(kind=**), intent(in) :: pos\nend function ibset\n```\n\n### **Characteristics**\n- **i** is of type `integer` (any kind)\n- **pos** is of type `integer` (any kind)\n- The result has the same type and kind as **i**\n- This is an elemental function\n\n### **Description**\n**ibset** returns the value of **i** with the bit at position **pos** set to one. All other bits remain unchanged. Bit positions are numbered from 0 (least significant) to `bit_size(i) - 1` (most significant).\n\nThe constraint `0 <= pos < bit_size(i)` must be satisfied.\n\n### **Options**\n- **i**\n  : The `integer` value to be modified.\n\n- **pos**\n  : The bit position to set. Must be non-negative and less than `bit_size(i)`.\n\n### **Result**\nThe result is the value of **i** with bit **pos** set to 1.\n\n### **Examples**\n```fortran\nprogram demo_ibset\n  implicit none\n  integer :: val, pos, result\n  \n  val = 0   ! binary: 0000\n  \n  print '(a,i0,a,b8.8)', 'Original value: ', val, '  binary: ', val\n  print *\n  \n  ! Set bits one at a time to build powers of 2\n  do pos = 0, 3\n    result = ibset(val, pos)\n    print '(a,i0,a,i0,a,i2,a,b8.8)', &\n      'ibset(', val, ',', pos, ') = ', result, '  binary: ', result\n  end do\n  \n  ! Build a value by setting multiple bits\n  print *\n  val = 0\n  val = ibset(val, 0)  ! Set bit 0: val = 1\n  val = ibset(val, 2)  ! Set bit 2: val = 5\n  val = ibset(val, 3)  ! Set bit 3: val = 13\n  print '(a,i0,a,b8.8)', 'After setting bits 0,2,3: ', val, '  binary: ', val\nend program demo_ibset\n```\nExpected output:\n```\nOriginal value: 0  binary: 00000000\n\nibset(0,0) =  1  binary: 00000001\nibset(0,1) =  2  binary: 00000010\nibset(0,2) =  4  binary: 00000100\nibset(0,3) =  8  binary: 00001000\n\nAfter setting bits 0,2,3: 13  binary: 00001101\n```\n\n### **Standard**\nFortran 90\n\n### **See Also**\n[ibclr](#), [ibits](#), [btest](#), [iand](#), [ieor](#), [ior](#), [ishft](#), [ishftc](#), [not](#), [bit_size](#)",
  "ibclr": "## **ibclr** - \\[BIT:MANIPULATION\\] Clears a specific bit to zero\n\n### **Synopsis**\n```fortran\nresult = ibclr(i, pos)\n```\n\n```fortran\nelemental integer(kind=**) function ibclr(i, pos)\n  integer(kind=**), intent(in) :: i\n  integer(kind=**), intent(in) :: pos\nend function ibclr\n```\n\n### **Characteristics**\n- **i** is of type `integer` (any kind)\n- **pos** is of type `integer` (any kind)\n- The result has the same type and kind as **i**\n- This is an elemental function\n\n### **Description**\n**ibclr** returns the value of **i** with the bit at position **pos** set to zero. All other bits remain unchanged. Bit positions are numbered from 0 (least significant) to `bit_size(i) - 1` (most significant).\n\nThe constraint `0 <= pos < bit_size(i)` must be satisfied.\n\n### **Options**\n- **i**\n  : The `integer` value to be modified.\n\n- **pos**\n  : The bit position to clear. Must be non-negative and less than `bit_size(i)`.\n\n### **Result**\nThe result is the value of **i** with bit **pos** set to 0.\n\n### **Examples**\n```fortran\nprogram demo_ibclr\n  implicit none\n  integer :: val, pos, result\n  \n  val = 15   ! binary: 1111\n  \n  print '(a,i0,a,b8.8)', 'Original value: ', val, '  binary: ', val\n  print *\n  \n  do pos = 0, 3\n    result = ibclr(val, pos)\n    print '(a,i0,a,i0,a,b8.8)', 'ibclr(', val, ',', pos, ') = ', result\n  end do\n  \n  ! Practical: clear specific flag\n  print *\n  integer :: flags\n  flags = 255  ! All 8 bits set\n  print '(a,b8.8)', 'Before clearing bit 4: ', flags\n  flags = ibclr(flags, 4)\n  print '(a,b8.8)', 'After clearing bit 4:  ', flags\nend program demo_ibclr\n```\nExpected output:\n```\nOriginal value: 15  binary: 00001111\n\nibclr(15,0) =         14\nibclr(15,1) =         13\nibclr(15,2) =         11\nibclr(15,3) =          7\n\nBefore clearing bit 4: 11111111\nAfter clearing bit 4:  11101111\n```\n\n### **Standard**\nFortran 90\n\n### **See Also**\n[ibset](#), [ibits](#), [btest](#), [iand](#), [ieor](#), [ior](#), [ishft](#), [ishftc](#), [not](#), [bit_size](#)",
  "ibits": "## **ibits** - \\[BIT:MANIPULATION\\] Extracts a contiguous field of bits\n\n### **Synopsis**\n```fortran\nresult = ibits(i, pos, len)\n```\n\n```fortran\nelemental integer(kind=**) function ibits(i, pos, len)\n  integer(kind=**), intent(in) :: i\n  integer(kind=**), intent(in) :: pos\n  integer(kind=**), intent(in) :: len\nend function ibits\n```\n\n### **Characteristics**\n- **i** is of type `integer` (any kind)\n- **pos** is of type `integer` (any kind)\n- **len** is of type `integer` (any kind)\n- The result has the same type and kind as **i**\n- This is an elemental function\n\n### **Description**\n**ibits** extracts a field of **len** bits from **i**, starting at bit position **pos**, and returns them right-justified with all other bits set to zero. The extracted bits occupy positions 0 through **len**-1 in the result.\n\nThe constraints `pos >= 0`, `len >= 0`, and `pos + len <= bit_size(i)` must be satisfied.\n\n### **Options**\n- **i**\n  : The `integer` value from which to extract bits.\n\n- **pos**\n  : The starting bit position for extraction (0 = least significant).\n\n- **len**\n  : The number of bits to extract.\n\n### **Result**\nThe result contains the **len** bits from positions **pos** to **pos+len-1** of **i**, right-justified in the result with remaining bits set to zero.\n\n### **Examples**\n```fortran\nprogram demo_ibits\n  implicit none\n  integer :: val, extracted\n  \n  val = 255  ! binary: 11111111\n  \n  print '(a,i0,a,b8.8)', 'Original: ', val, '  binary: ', val\n  print *\n  \n  ! Extract different bit fields\n  extracted = ibits(val, 0, 4)  ! Lower 4 bits\n  print '(a,i0,a,b8.8)', 'ibits(255,0,4) = ', extracted, '  binary: ', extracted\n  \n  extracted = ibits(val, 4, 4)  ! Upper 4 bits\n  print '(a,i0,a,b8.8)', 'ibits(255,4,4) = ', extracted, '  binary: ', extracted\n  \n  ! Extract from a specific pattern\n  val = 182  ! binary: 10110110\n  print *\n  print '(a,i0,a,b8.8)', 'Value: ', val, '  binary: ', val\n  \n  ! Extract bits 2-4 (3 bits starting at position 2)\n  extracted = ibits(val, 2, 3)\n  print '(a,i0,a,b8.8)', 'ibits(182,2,3) = ', extracted, '  binary: ', extracted\n  \n  ! Practical: extract byte from 32-bit integer\n  integer :: word\n  word = 305419896  ! hex: 0x12345678\n  print *\n  print '(a,z8.8)', 'Word in hex: ', word\n  print '(a,z2.2)', 'Byte 0 (bits 0-7):   ', ibits(word, 0, 8)\n  print '(a,z2.2)', 'Byte 1 (bits 8-15):  ', ibits(word, 8, 8)\n  print '(a,z2.2)', 'Byte 2 (bits 16-23): ', ibits(word, 16, 8)\n  print '(a,z2.2)', 'Byte 3 (bits 24-31): ', ibits(word, 24, 8)\nend program demo_ibits\n```\nExpected output:\n```\nOriginal: 255  binary: 11111111\n\nibits(255,0,4) = 15  binary: 00001111\nibits(255,4,4) = 15  binary: 00001111\n\nValue: 182  binary: 10110110\nibits(182,2,3) = 5  binary: 00000101\n\nWord in hex: 12345678\nByte 0 (bits 0-7):   78\nByte 1 (bits 8-15):  56\nByte 2 (bits 16-23): 34\nByte 3 (bits 24-31): 12\n```\n\n### **Standard**\nFortran 90\n\n### **See Also**\n[ibclr](#), [ibset](#), [btest](#), [iand](#), [ieor](#), [ior](#), [ishft](#), [ishftc](#), [not](#), [bit_size](#), [mvbits](#)",
  "ishft": "## **ishft** - \\[BIT:MANIPULATION\\] Performs logical shift of bits\n\n### **Synopsis**\n```fortran\nresult = ishft(i, shift)\n```\n\n```fortran\nelemental integer(kind=**) function ishft(i, shift)\n  integer(kind=**), intent(in) :: i\n  integer(kind=**), intent(in) :: shift\nend function ishft\n```\n\n### **Characteristics**\n- **i** is of type `integer` (any kind)\n- **shift** is of type `integer` (any kind)\n- The result has the same type and kind as **i**\n- This is an elemental function\n\n### **Description**\n**ishft** returns the value of **i** with all bits shifted **shift** positions. Positive **shift** values shift bits left (toward higher bit positions), negative values shift bits right (toward lower bit positions), and zero means no shift.\n\nBits shifted out of either end are lost. Zeros are shifted in from the opposite end. The constraint `|shift| <= bit_size(i)` must be satisfied.\n\nThis is a *logical* shift, not an arithmetic shift - the sign bit receives the same treatment as other bits.\n\n### **Options**\n- **i**\n  : The `integer` value to be shifted.\n\n- **shift**\n  : The number of bit positions to shift. Positive shifts left, negative shifts right.\n\n### **Result**\nThe result is **i** with bits shifted **shift** positions, with zeros filling vacated positions.\n\n### **Examples**\n```fortran\nprogram demo_ishft\n  implicit none\n  integer :: val, result\n  \n  val = 1  ! binary: 00000001\n  \n  print '(a,i0,a,b8.8)', 'Original: ', val, '  binary: ', val\n  print *\n  \n  ! Left shifts (multiply by powers of 2)\n  print '(a)', 'Left shifts:'\n  result = ishft(val, 1)  ! 1 * 2 = 2\n  print '(a,i0,a,b8.8)', '  ishft(1,1)  = ', result, '  binary: ', result\n  result = ishft(val, 3)  ! 1 * 8 = 8\n  print '(a,i0,a,b8.8)', '  ishft(1,3)  = ', result, '  binary: ', result\n  result = ishft(val, 7)  ! 1 * 128 = 128\n  print '(a,i0,a,b8.8)', '  ishft(1,7)  = ', result, '  binary: ', result\n  \n  ! Right shifts (divide by powers of 2)\n  print *\n  val = 128  ! binary: 10000000\n  print '(a)', 'Right shifts:'\n  result = ishft(val, -1)  ! 128 / 2 = 64\n  print '(a,i0,a,b8.8)', '  ishft(128,-1) = ', result, '  binary: ', result\n  result = ishft(val, -3)  ! 128 / 8 = 16\n  print '(a,i0,a,b8.8)', '  ishft(128,-3) = ', result, '  binary: ', result\n  \n  ! Bits shifted out are lost\n  print *\n  val = 255  ! binary: 11111111\n  print '(a,i0,a,b8.8)', 'Original: ', val, '  binary: ', val\n  result = ishft(val, 4)\n  print '(a,i0,a,b16.16)', '  ishft(255,4) = ', result, '  binary: ', result\nend program demo_ishft\n```\nExpected output:\n```\nOriginal: 1  binary: 00000001\n\nLeft shifts:\n  ishft(1,1)  = 2  binary: 00000010\n  ishft(1,3)  = 8  binary: 00001000\n  ishft(1,7)  = 128  binary: 10000000\n\nRight shifts:\n  ishft(128,-1) = 64  binary: 01000000\n  ishft(128,-3) = 16  binary: 00010000\n\nOriginal: 255  binary: 11111111\n  ishft(255,4) = 4080  binary: 0000111111110000\n```\n\n### **Standard**\nFortran 90\n\n### **See Also**\n[ishftc](#), [ibits](#), [ibclr](#), [ibset](#), [btest](#), [iand](#), [ieor](#), [ior](#), [not](#), [bit_size](#)",
  "ishftc": "## **ishftc** - \\[BIT:MANIPULATION\\] Performs circular shift of bits\n\n### **Synopsis**\n```fortran\nresult = ishftc(i, shift [, size])\n```\n\n```fortran\nelemental integer(kind=**) function ishftc(i, shift, size)\n  integer(kind=**), intent(in) :: i\n  integer(kind=**), intent(in) :: shift\n  integer(kind=**), intent(in), optional :: size\nend function ishftc\n```\n\n### **Characteristics**\n- **i** is of type `integer` (any kind)\n- **shift** is of type `integer` (any kind)\n- **size** (optional) is of type `integer` (any kind)\n- The result has the same type and kind as **i**\n- This is an elemental function\n\n### **Description**\n**ishftc** returns the value of **i** with the rightmost **size** bits shifted circularly **shift** positions. Bits shifted out of one end are shifted into the other end. Positive **shift** rotates left, negative rotates right.\n\nIf **size** is omitted, it defaults to `bit_size(i)`, rotating all bits. The constraints `|shift| <= size` and `0 < size <= bit_size(i)` must be satisfied.\n\n### **Options**\n- **i**\n  : The `integer` value to be rotated.\n\n- **shift**\n  : The number of bit positions to rotate. Positive rotates left, negative rotates right.\n\n- **size**\n  : (Optional) The number of rightmost bits to include in the rotation. Defaults to `bit_size(i)`.\n\n### **Result**\nThe result is **i** with the rightmost **size** bits circularly shifted **shift** positions.\n\n### **Examples**\n```fortran\nprogram demo_ishftc\n  implicit none\n  integer :: val, result\n  \n  val = 1  ! binary: 00000001\n  \n  print '(a,i0,a,b8.8)', 'Original: ', val, '  binary: ', val\n  print *\n  \n  ! Circular left shift (within 8 bits for clarity)\n  print '(a)', 'Circular left shifts in 8 bits:'\n  result = ishftc(val, 1, 8)\n  print '(a,i0,a,b8.8)', '  ishftc(1,1,8)  = ', result, '  binary: ', result\n  result = ishftc(val, 7, 8)\n  print '(a,i0,a,b8.8)', '  ishftc(1,7,8)  = ', result, '  binary: ', result\n  result = ishftc(val, 8, 8)  ! Full rotation returns to original\n  print '(a,i0,a,b8.8)', '  ishftc(1,8,8)  = ', result, '  binary: ', result\n  \n  ! Circular right shift\n  print *\n  val = 128  ! binary: 10000000\n  print '(a)', 'Circular right shifts in 8 bits:'\n  result = ishftc(val, -1, 8)\n  print '(a,i0,a,b8.8)', '  ishftc(128,-1,8) = ', result, '  binary: ', result\n  result = ishftc(val, -7, 8)\n  print '(a,i0,a,b8.8)', '  ishftc(128,-7,8) = ', result, '  binary: ', result\n  \n  ! Partial rotation (only lower 4 bits)\n  print *\n  val = 15  ! binary: 00001111\n  print '(a,i0,a,b8.8)', 'Original: ', val, '  binary: ', val\n  result = ishftc(val, 2, 4)  ! Rotate lower 4 bits left by 2\n  print '(a,i0,a,b8.8)', '  ishftc(15,2,4)  = ', result, '  binary: ', result\n  ! Lower 4 bits: 1111 -> rotate left 2 -> 1111 (no change for all 1s)\n  \n  val = 9  ! binary: 00001001\n  print '(a,i0,a,b8.8)', 'Original: ', val, '  binary: ', val\n  result = ishftc(val, 2, 4)  ! Lower 4 bits: 1001 -> 0110 = 6\n  print '(a,i0,a,b8.8)', '  ishftc(9,2,4)   = ', result, '  binary: ', result\nend program demo_ishftc\n```\nExpected output:\n```\nOriginal: 1  binary: 00000001\n\nCircular left shifts in 8 bits:\n  ishftc(1,1,8)  = 2  binary: 00000010\n  ishftc(1,7,8)  = 128  binary: 10000000\n  ishftc(1,8,8)  = 1  binary: 00000001\n\nCircular right shifts in 8 bits:\n  ishftc(128,-1,8) = 64  binary: 01000000\n  ishftc(128,-7,8) = 1  binary: 00000001\n\nOriginal: 15  binary: 00001111\n  ishftc(15,2,4)  = 15  binary: 00001111\nOriginal: 9  binary: 00001001\n  ishftc(9,2,4)   = 6  binary: 00000110\n```\n\n### **Standard**\nFortran 90\n\n### **See Also**\n[ishft](#), [ibits](#), [ibclr](#), [ibset](#), [btest](#), [iand](#), [ieor](#), [ior](#), [not](#), [bit_size](#)",
  "bit_size": "## **bit_size** - \\[BIT:MANIPULATION\\] Returns the number of bits in the integer model\n\n### **Synopsis**\n```fortran\nresult = bit_size(i)\n```\n\n```fortran\ninteger function bit_size(i)\n  integer(kind=**), intent(in) :: i\nend function bit_size\n```\n\n### **Characteristics**\n- **i** is of type `integer` (any kind)\n- The result is a default `integer` scalar\n- This is an inquiry function - the result depends only on the type of **i**, not its value\n\n### **Description**\n**bit_size** returns the number of bits (including the sign bit) used to represent integers of the same kind as the argument **i**. This is the bit model size `s` such that integers of this kind can represent values in the range `-2^(s-1)` to `2^(s-1) - 1`.\n\nBit positions are numbered from `0` (least significant) to `bit_size(i) - 1` (most significant, sign bit).\n\n### **Options**\n- **i**\n  : An `integer` of any kind. The value is not used; only the kind type parameter matters.\n\n### **Result**\nThe result is a default `integer` containing the number of bits in the integer model for the kind of **i**. Common values are 8, 16, 32, or 64.\n\n### **Examples**\n```fortran\nprogram demo_bit_size\n  implicit none\n  integer :: i\n  integer(kind=1) :: i1\n  integer(kind=2) :: i2\n  integer(kind=4) :: i4\n  integer(kind=8) :: i8\n\n  print '(a,i0)', 'Default integer bit_size: ', bit_size(i)\n  print '(a,i0)', 'Integer(1) bit_size:      ', bit_size(i1)\n  print '(a,i0)', 'Integer(2) bit_size:      ', bit_size(i2)\n  print '(a,i0)', 'Integer(4) bit_size:      ', bit_size(i4)\n  print '(a,i0)', 'Integer(8) bit_size:      ', bit_size(i8)\nend program demo_bit_size\n```\nExpected output:\n```\nDefault integer bit_size: 32\nInteger(1) bit_size:      8\nInteger(2) bit_size:      16\nInteger(4) bit_size:      32\nInteger(8) bit_size:      64\n```\n\n### **Standard**\nFortran 90\n\n### **See Also**\n[btest](#), [ibclr](#), [ibits](#), [ibset](#), [iand](#), [ieor](#), [ior](#), [ishft](#), [ishftc](#), [not](#)",
  "eoshift": "## eoshift\n\n### **Name**\n\n**eoshift** - \\[ARRAY:MANIPULATION\\] Perform end-off shift of array elements\n\n### **Synopsis**\n```fortran\n    result = eoshift(array, shift [, boundary] [, dim])\n```\n```fortran\n     function eoshift(array, shift, boundary, dim) result(res)\n\n      type(any_type), intent(in) :: array(..)\n      integer, intent(in)        :: shift\n      type(same_as_array), intent(in), optional :: boundary\n      integer, intent(in), optional :: dim\n      type(same_as_array)        :: res(same_shape_as_array)\n```\n\n### **Characteristics**\n\n - **array** can be any array of any intrinsic or derived type with any rank.\n - **shift** must be of type integer. If **array** has rank one, **shift** must be a scalar. If **array** has rank greater than one, **shift** can be a scalar or an array of rank n-1.\n - **boundary** must have the same type and type parameters as **array**. It can be a scalar or an array of rank n-1. If absent, default values are used.\n - **dim** must be a scalar integer with a value in the range 1 <= dim <= n. If absent, defaults to 1.\n - The result has the same type, type parameters, and shape as **array**.\n\n### **Description**\n\n **eoshift** performs an end-off shift on elements of **array** along the dimension\n specified by **dim**. Elements shifted out one end are lost, and vacated positions\n are filled with values from **boundary** (or a default value if **boundary** is\n absent). A positive **shift** shifts toward lower indices (left), and a negative\n **shift** shifts toward higher indices (right).\n\n Unlike **cshift**, elements shifted out are discarded rather than wrapped around.\n\n### **Options**\n\n- **array**\n  : The array to be shifted. It can be of any intrinsic or derived type.\n\n- **shift**\n  : The number of positions to shift. Positive values shift toward lower\n  indices, negative values shift toward higher indices. Can be an array\n  for multi-dimensional shifting.\n\n- **boundary**\n  : (Optional) The value used to fill vacated positions. Must have the same\n  type as **array**. If absent, the following defaults are used:\n  - INTEGER: 0\n  - REAL: 0.0\n  - COMPLEX: (0.0, 0.0)\n  - LOGICAL: .false.\n  - CHARACTER: blanks\n\n- **dim**\n  : (Optional) The dimension along which to shift. Must be a positive integer\n  not exceeding the rank of **array**. Default is 1.\n\n### **Result**\n\n The result is an array with the same shape, type, and type parameters as\n **array**. Each rank-one section along dimension **dim** contains the elements\n shifted by the specified amount, with vacated positions filled by **boundary**\n values.\n\n### **Examples**\n\n Sample program:\n\n```fortran\nprogram demo_eoshift\n  implicit none\n  integer :: i\n  integer :: v(6)\n  integer :: a(3, 4)\n  character(len=3) :: c(4)\n\n  ! One-dimensional end-off shift\n  v = [1, 2, 3, 4, 5, 6]\n  print '(a,6i3)', 'Original:        ', v\n  print '(a,6i3)', 'Shift left 2:    ', eoshift(v, shift=2)\n  print '(a,6i3)', 'Shift right 2:   ', eoshift(v, shift=-2)\n  print '(a,6i3)', 'With boundary=9: ', eoshift(v, shift=2, boundary=9)\n\n  ! Character array shift\n  c = ['abc', 'def', 'ghi', 'jkl']\n  print *\n  print '(a,4(a4))', 'Char original: ', c\n  print '(a,4(a4))', 'Char shifted:  ', eoshift(c, shift=1)\n\n  ! Two-dimensional array\n  a = reshape([(i, i=1,12)], [3, 4])\n  print *\n  print '(a)', 'Original 3x4 array:'\n  do i = 1, 3\n    print '(4i4)', a(i, :)\n  end do\n\n  ! Shift along dimension 1 with default boundary (0)\n  print *\n  print '(a)', 'After eoshift(a, shift=1, dim=1):'\n  do i = 1, 3\n    print '(4i4)', eoshift(a, shift=1, dim=1)(i, :)\n  end do\n\n  ! Shift along dimension 2 with custom boundary\n  print *\n  print '(a)', 'After eoshift(a, shift=2, boundary=-1, dim=2):'\n  do i = 1, 3\n    print '(4i4)', eoshift(a, shift=2, boundary=-1, dim=2)(i, :)\n  end do\n\nend program demo_eoshift\n```\n\n Results:\n\n```text\nOriginal:         1  2  3  4  5  6\nShift left 2:     3  4  5  6  0  0\nShift right 2:    0  0  1  2  3  4\nWith boundary=9:  3  4  5  6  9  9\n\nChar original:  abc def ghi jkl\nChar shifted:   def ghi jkl    \n\nOriginal 3x4 array:\n   1   4   7  10\n   2   5   8  11\n   3   6   9  12\n\nAfter eoshift(a, shift=1, dim=1):\n   2   5   8  11\n   3   6   9  12\n   0   0   0   0\n\nAfter eoshift(a, shift=2, boundary=-1, dim=2):\n   7  10  -1  -1\n   8  11  -1  -1\n   9  12  -1  -1\n```\n\n### **Standard**\n\n Fortran 90\n\n### **See Also**\n\n - [**cshift**](#cshift) - Circular shift elements of an array\n - [**transpose**](#transpose) - Transpose a rank-two array\n - [**reshape**](#reshape) - Reshape an array",
  "logical": "## logical\n\n### **Name**\n\n**logical** - \\[TYPE:CONVERSION\\] Convert between logical kinds\n\n### **Synopsis**\n```fortran\n    result = logical(l)\n    result = logical(l, kind)\n```\n```fortran\n     elemental logical(kind=KIND) function logical(l, kind)\n\n      logical(kind=**), intent(in) :: l\n      integer, intent(in), optional :: kind\n```\n\n### **Characteristics**\n\n - **l** must be of type LOGICAL with any kind.\n - **kind** is an optional scalar integer constant expression.\n - The result is of type LOGICAL.\n - If **kind** is present, the result has that kind; otherwise, it has default logical kind.\n - This is an elemental function: it operates element-by-element on arrays.\n\n### **Description**\n\n **logical** converts a logical value from one kind to another. Different\n Fortran processors may support multiple logical kinds with different storage\n sizes (e.g., 1-byte, 2-byte, 4-byte, or 8-byte logicals). This function allows\n conversion between these representations while preserving the logical value.\n\n The function is elemental, so when applied to an array, it returns an array\n of the same shape with each element converted to the specified kind.\n\n### **Options**\n\n- **l**\n  : A logical value or array to be converted. The value (.TRUE. or .FALSE.)\n  is preserved during conversion; only the kind type parameter changes.\n\n- **kind**\n  : (Optional) A scalar integer constant expression specifying the kind type\n  parameter of the result. If omitted, the result has default logical kind.\n  The value must be a supported logical kind on the processor.\n\n### **Result**\n\n  A logical value with the same value (.TRUE. or .FALSE.) as **l**, but with\n  the kind type parameter specified by **kind** (or default logical kind if\n  **kind** is absent). For array arguments, the result is an array of the\n  same shape with each element converted.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_logical\n  use iso_fortran_env, only: logical_kinds\n  implicit none\n  logical :: default_log\n  logical(kind=1) :: byte_log\n  logical(kind=4) :: word_log\n  logical :: array_log(3)\n  logical(kind=1) :: array_byte(3)\n\n  ! Show available logical kinds\n  print '(A,*(I0,:,\", \"))', 'Available logical kinds: ', logical_kinds\n\n  ! Simple conversions\n  default_log = .true.\n  byte_log = logical(default_log, kind=1)\n  word_log = logical(byte_log, kind=4)\n\n  print '(A,L1)', 'default_log: ', default_log\n  print '(A,L1)', 'byte_log: ', byte_log\n  print '(A,L1)', 'word_log: ', word_log\n\n  ! Verify values are preserved\n  print '(A,L1)', 'All equal: ', (default_log .eqv. byte_log) .and. &\n                                 (byte_log .eqv. word_log)\n\n  ! Array conversion\n  array_log = [.true., .false., .true.]\n  array_byte = logical(array_log, kind=1)\n  print '(A,3L2)', 'array_log: ', array_log\n  print '(A,3L2)', 'array_byte: ', array_byte\n\n  ! Converting back to default kind\n  default_log = logical(byte_log)\n  print '(A,L1)', 'Converted back: ', default_log\n\nend program demo_logical\n```\nResults:\n```text\nAvailable logical kinds: 1, 2, 4, 8, 16\ndefault_log: T\nbyte_log: T\nword_log: T\nAll equal: T\narray_log:  T F T\narray_byte:  T F T\nConverted back: T\n```\n\n### **Standard**\n\nFortran 90\n\n**Note:** The KIND argument was present from Fortran 90. The available\nlogical kinds are processor-dependent; common values include 1, 2, 4, and 8.\n\n### **See Also**\n\n[**int**(3)](#int),\n[**real**(3)](#real),\n[**cmplx**(3)](#cmplx),\n[**kind**(3)](#kind)"
}