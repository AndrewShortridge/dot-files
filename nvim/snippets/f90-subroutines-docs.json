{
  "date_and_time": "## date_and_time\n\n### **Name**\n\n**date_and_time** - \\[SUBROUTINE:DATE_TIME\\] Returns date and time information from the real-time clock\n\n### **Synopsis**\n```fortran\n    call date_and_time(date, time, zone, values)\n```\n```fortran\n     subroutine date_and_time(date, time, zone, values)\n\n      character(len=*), intent(out), optional :: date\n      character(len=*), intent(out), optional :: time\n      character(len=*), intent(out), optional :: zone\n      integer,          intent(out), optional :: values(8)\n```\n\n### **Characteristics**\n\n - All arguments are **INTENT(OUT)** and **OPTIONAL**.\n - **date**, **time**, **zone** are default **CHARACTER** scalars.\n - **values** is a rank-1 **INTEGER** array with at least 8 elements.\n - At least one argument should be provided.\n - This is an intrinsic subroutine, not elemental.\n\n### **Description**\n\n **date_and_time** obtains date and time information from the real-time\n system clock. The information is returned in character strings and/or\n an integer array. When any argument is unavailable on the system,\n character arguments are filled with blanks and integer values are set\n to -HUGE(0).\n\n### **Options**\n\n- **date**\n  : Intent(out), optional. Character string of length 8 or more.\n  Returns the date in the format CCYYMMDD, where CC is the century,\n  YY is the year within the century, MM is the month, and DD is the day.\n\n- **time**\n  : Intent(out), optional. Character string of length 10 or more.\n  Returns the time in the format hhmmss.sss, where hh is the hour,\n  mm is the minutes, ss is the seconds, and sss is milliseconds.\n\n- **zone**\n  : Intent(out), optional. Character string of length 5 or more.\n  Returns the time difference from UTC in the format (+-)hhmm,\n  where hh is hours and mm is minutes offset from UTC.\n\n- **values**\n  : Intent(out), optional. Integer array of dimension 8 containing:\n    - values(1): Year (4 digits, e.g., 2024)\n    - values(2): Month of the year (1-12)\n    - values(3): Day of the month (1-31)\n    - values(4): Time difference from UTC in minutes\n    - values(5): Hour of the day (0-23)\n    - values(6): Minutes of the hour (0-59)\n    - values(7): Seconds of the minute (0-60, 60 for leap second)\n    - values(8): Milliseconds of the second (0-999)\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_date_and_time\nimplicit none\n  character(len=8)  :: date\n  character(len=10) :: time\n  character(len=5)  :: zone\n  integer           :: values(8)\n\n  ! Get all date and time information\n  call date_and_time(date, time, zone, values)\n\n  print '(A,A)',      'Date (CCYYMMDD): ', date\n  print '(A,A)',      'Time (hhmmss.sss): ', time\n  print '(A,A)',      'Zone (+-hhmm): ', zone\n  print '(A)',        'Values array:'\n  print '(A,I0)',     '  Year:        ', values(1)\n  print '(A,I0)',     '  Month:       ', values(2)\n  print '(A,I0)',     '  Day:         ', values(3)\n  print '(A,I0)',     '  UTC offset:  ', values(4), ' minutes'\n  print '(A,I0)',     '  Hour:        ', values(5)\n  print '(A,I0)',     '  Minute:      ', values(6)\n  print '(A,I0)',     '  Second:      ', values(7)\n  print '(A,I0)',     '  Millisecond: ', values(8)\n\n  ! Using keyword arguments for specific values only\n  call date_and_time(DATE=date)\n  print '(/,A,A)', 'Today is: ', date\n\n  call date_and_time(VALUES=values)\n  print '(A,I0,A,I0,A,I0)', 'Current time: ', &\n        values(5), ':', values(6), ':', values(7)\n\nend program demo_date_and_time\n```\nResults:\n```text\nDate (CCYYMMDD): 20240115\nTime (hhmmss.sss): 143025.123\nZone (+-hhmm): -0500\nValues array:\n  Year:        2024\n  Month:       1\n  Day:         15\n  UTC offset:  -300 minutes\n  Hour:        14\n  Minute:      30\n  Second:      25\n  Millisecond: 123\n\nToday is: 20240115\nCurrent time: 14:30:25\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**system_clock**(3)](#system_clock),\n[**cpu_time**(3)](#cpu_time)",

  "mvbits": "## mvbits\n\n### **Name**\n\n**mvbits** - \\[SUBROUTINE:BIT_MANIPULATION\\] Copies a sequence of bits from one integer to another\n\n### **Synopsis**\n```fortran\n    call mvbits(from, frompos, len, to, topos)\n```\n```fortran\n     elemental subroutine mvbits(from, frompos, len, to, topos)\n\n      integer(kind=**), intent(in)    :: from\n      integer,          intent(in)    :: frompos\n      integer,          intent(in)    :: len\n      integer(kind=**), intent(inout) :: to\n      integer,          intent(in)    :: topos\n```\n\n### **Characteristics**\n\n - **from** is **INTENT(IN)**, any INTEGER kind.\n - **frompos** is **INTENT(IN)**, default INTEGER.\n - **len** is **INTENT(IN)**, default INTEGER.\n - **to** is **INTENT(INOUT)**, same kind as **from**.\n - **topos** is **INTENT(IN)**, default INTEGER.\n - This is an **ELEMENTAL** subroutine.\n - **from** and **to** may be the same variable.\n\n### **Description**\n\n **mvbits** copies a sequence of bits from one integer to another.\n It moves **len** bits from positions **frompos** through **frompos+len-1**\n of **from** to positions **topos** through **topos+len-1** of **to**.\n The bits in **to** that are not affected by the move are unchanged.\n Bit positions are numbered from 0 (rightmost) to BIT_SIZE-1 (leftmost).\n\n### **Options**\n\n- **from**\n  : Intent(in). The source integer from which bits are copied.\n  Can be any integer kind.\n\n- **frompos**\n  : Intent(in). The starting bit position in **from**. Must be\n  non-negative and **frompos + len - 1** must be less than BIT_SIZE(from).\n\n- **len**\n  : Intent(in). The number of bits to copy. Must be non-negative.\n\n- **to**\n  : Intent(inout). The destination integer to which bits are copied.\n  Must be the same kind as **from**. Only the specified bit positions\n  are modified; all other bits retain their original values.\n\n- **topos**\n  : Intent(in). The starting bit position in **to** where bits are\n  placed. Must be non-negative and **topos + len - 1** must be less\n  than BIT_SIZE(to).\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_mvbits\nimplicit none\n  integer :: from, to\n  integer :: i\n\n  ! Example 1: Copy 4 bits from position 0 of 'from' to position 4 of 'to'\n  from = int(b'00001111')  ! 15 in decimal\n  to   = int(b'00000000')  ! 0 in decimal\n\n  print '(A,B8.8)', 'Before: from = ', from\n  print '(A,B8.8)', 'Before: to   = ', to\n\n  call mvbits(from, 0, 4, to, 4)\n\n  print '(A,B8.8)', 'After:  to   = ', to\n  print '(A,I0)',   'After:  to   = ', to\n\n  ! Example 2: Copy bits within the same variable\n  i = int(b'00000111')  ! bits 0-2 are set\n  print '(/,A,B8.8)', 'Before: i = ', i\n\n  call mvbits(i, 0, 3, i, 4)  ! copy bits 0-2 to positions 4-6\n\n  print '(A,B8.8)', 'After:  i = ', i\n  print '(A,I0)',   'After:  i = ', i\n\n  ! Example 3: Extract and insert a bit field\n  from = int(b'11110000')\n  to   = int(b'00001111')\n  print '(/,A,B8.8)', 'Before: from = ', from\n  print '(A,B8.8)',   'Before: to   = ', to\n\n  call mvbits(from, 4, 4, to, 0)  ! copy high nibble to low nibble\n\n  print '(A,B8.8)', 'After:  to   = ', to\n\nend program demo_mvbits\n```\nResults:\n```text\nBefore: from = 00001111\nBefore: to   = 00000000\nAfter:  to   = 11110000\nAfter:  to   = 240\n\nBefore: i = 00000111\nAfter:  i = 01110111\nAfter:  i = 119\n\nBefore: from = 11110000\nBefore: to   = 00001111\nAfter:  to   = 00001111\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**ibclr**(3)](#ibclr),\n[**ibset**(3)](#ibset),\n[**ibits**(3)](#ibits),\n[**iand**(3)](#iand),\n[**ior**(3)](#ior),\n[**ieor**(3)](#ieor),\n[**bit_size**(3)](#bit_size)",

  "random_number": "## random_number\n\n### **Name**\n\n**random_number** - \\[SUBROUTINE:RANDOM\\] Returns pseudorandom numbers from a uniform distribution\n\n### **Synopsis**\n```fortran\n    call random_number(harvest)\n```\n```fortran\n     subroutine random_number(harvest)\n\n      real(kind=**), intent(out) :: harvest(..)\n```\n\n### **Characteristics**\n\n - **harvest** is **INTENT(OUT)**, type **REAL** of any kind.\n - **harvest** can be a scalar or an array of any rank.\n - This is an intrinsic subroutine (not elemental).\n - The generated values satisfy 0 <= x < 1.\n\n### **Description**\n\n **random_number** returns one or more pseudorandom numbers from a\n uniform distribution over the interval [0, 1). The numbers are\n generated using a pseudorandom number generator (PRNG). The specific\n algorithm is processor-dependent, but modern implementations typically\n use high-quality generators like xoshiro256**. The sequence is\n deterministic given the same seed state.\n\n### **Options**\n\n- **harvest**\n  : Intent(out). A scalar or array of type REAL that receives the\n  pseudorandom values. Each element is set to a value in the range\n  0 <= harvest < 1. When **harvest** is an array, all elements are\n  filled with independent random values.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_random_number\nimplicit none\n  real              :: x, y\n  real              :: array(5)\n  real, allocatable :: matrix(:,:)\n  integer           :: i\n\n  ! Generate a single random number\n  call random_number(x)\n  print '(A,F10.8)', 'Single random number: ', x\n\n  ! Generate multiple random numbers into an array\n  call random_number(array)\n  print '(A)', 'Array of random numbers:'\n  do i = 1, 5\n    print '(2X,I1,A,F10.8)', i, ': ', array(i)\n  end do\n\n  ! Generate random numbers into a 2D array\n  allocate(matrix(3, 3))\n  call random_number(matrix)\n  print '(/,A)', 'Random 3x3 matrix:'\n  do i = 1, 3\n    print '(3F10.6)', matrix(i, :)\n  end do\n\n  ! Generate random numbers in a different range [a, b)\n  ! Formula: a + (b - a) * random\n  call random_number(x)\n  y = 10.0 + (20.0 - 10.0) * x  ! Random in [10, 20)\n  print '(/,A,F10.4)', 'Random in [10, 20): ', y\n\n  ! Generate random integers in range [1, 6] (dice roll)\n  call random_number(x)\n  i = 1 + int(6.0 * x)  ! 1 to 6\n  print '(A,I1)', 'Dice roll: ', i\n\n  deallocate(matrix)\n\nend program demo_random_number\n```\nResults:\n```text\nSingle random number: 0.37454012\nArray of random numbers:\n  1: 0.95071429\n  2: 0.73199391\n  3: 0.59865850\n  4: 0.15601864\n  5: 0.15599452\n\nRandom 3x3 matrix:\n  0.058084  0.866176  0.601115\n  0.708073  0.020584  0.969910\n  0.832443  0.212339  0.181825\n\nRandom in [10, 20):    13.4556\nDice roll: 4\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**random_seed**(3)](#random_seed)",

  "random_seed": "## random_seed\n\n### **Name**\n\n**random_seed** - \\[SUBROUTINE:RANDOM\\] Initializes or queries the pseudorandom number generator state\n\n### **Synopsis**\n```fortran\n    call random_seed([size] [, put] [, get])\n```\n```fortran\n     subroutine random_seed(size, put, get)\n\n      integer, intent(out), optional :: size\n      integer, intent(in),  optional :: put(:)\n      integer, intent(out), optional :: get(:)\n```\n\n### **Characteristics**\n\n - All arguments are **OPTIONAL**.\n - **size** is **INTENT(OUT)**, scalar default INTEGER.\n - **put** is **INTENT(IN)**, rank-1 default INTEGER array.\n - **get** is **INTENT(OUT)**, rank-1 default INTEGER array.\n - Only one of **put** or **get** may be specified per call.\n - Without arguments, initializes with system-provided random data.\n\n### **Description**\n\n **random_seed** controls the state of the pseudorandom number generator\n used by **random_number**. It can query the required seed array size,\n retrieve the current generator state, or set a new state. When called\n without arguments, the generator is initialized using random data from\n the operating system, providing non-reproducible sequences.\n\n### **Options**\n\n- **size**\n  : Intent(out), optional. Returns the minimum size of the integer\n  array required for the **put** and **get** arguments. This size is\n  processor-dependent and must be queried before using **put** or **get**.\n\n- **put**\n  : Intent(in), optional. An integer array used to set the generator\n  state. The array size must be at least the value returned by **size**.\n  Using the same seed values produces the same sequence of random\n  numbers, enabling reproducible results.\n\n- **get**\n  : Intent(out), optional. An integer array that receives the current\n  generator state. The array size must be at least the value returned\n  by **size**. The retrieved state can be saved and later restored\n  using **put** to resume a sequence.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_random_seed\nimplicit none\n  integer              :: seed_size\n  integer, allocatable :: seed(:), saved_seed(:)\n  real                 :: x(5)\n  integer              :: i\n\n  ! Query the seed size required by this processor\n  call random_seed(size=seed_size)\n  print '(A,I0)', 'Seed size required: ', seed_size\n\n  allocate(seed(seed_size), saved_seed(seed_size))\n\n  ! Initialize with a known seed for reproducibility\n  seed = 12345  ! Simple seed (all elements same value)\n  call random_seed(put=seed)\n\n  call random_number(x)\n  print '(/,A)', 'First sequence with seed=12345:'\n  print '(5F10.6)', x\n\n  ! Reset to same seed - should get same sequence\n  call random_seed(put=seed)\n\n  call random_number(x)\n  print '(/,A)', 'Second sequence with seed=12345 (same):'\n  print '(5F10.6)', x\n\n  ! Save current state, generate numbers, restore, regenerate\n  call random_seed(get=saved_seed)\n  call random_number(x)\n  print '(/,A)', 'Sequence after get:'\n  print '(5F10.6)', x\n\n  ! Restore saved state - should reproduce the sequence\n  call random_seed(put=saved_seed)\n  call random_number(x)\n  print '(/,A)', 'Sequence after restoring saved state:'\n  print '(5F10.6)', x\n\n  ! Initialize with system randomness (non-reproducible)\n  call random_seed()\n  call random_number(x)\n  print '(/,A)', 'Sequence with system-random seed:'\n  print '(5F10.6)', x\n\n  deallocate(seed, saved_seed)\n\nend program demo_random_seed\n```\nResults:\n```text\nSeed size required: 8\n\nFirst sequence with seed=12345:\n  0.296578  0.188368  0.523687  0.712456  0.891234\n\nSecond sequence with seed=12345 (same):\n  0.296578  0.188368  0.523687  0.712456  0.891234\n\nSequence after get:\n  0.334578  0.892341  0.123456  0.567890  0.234567\n\nSequence after restoring saved state:\n  0.334578  0.892341  0.123456  0.567890  0.234567\n\nSequence with system-random seed:\n  0.847291  0.156823  0.934567  0.278345  0.612789\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**random_number**(3)](#random_number)",

  "system_clock": "## system_clock\n\n### **Name**\n\n**system_clock** - \\[SUBROUTINE:TIME\\] Returns processor clock information for timing measurements\n\n### **Synopsis**\n```fortran\n    call system_clock([count] [, count_rate] [, count_max])\n```\n```fortran\n     subroutine system_clock(count, count_rate, count_max)\n\n      integer, intent(out), optional :: count\n      integer, intent(out), optional :: count_rate  ! or REAL\n      integer, intent(out), optional :: count_max\n```\n\n### **Characteristics**\n\n - All arguments are **OPTIONAL** and **INTENT(OUT)**.\n - **count** is a scalar **INTEGER**.\n - **count_rate** is a scalar **INTEGER** or **REAL**.\n - **count_max** is a scalar **INTEGER**.\n - Using larger integer kinds (e.g., INTEGER(8)) provides higher resolution.\n - If no clock is available, **count** is set to -HUGE(count).\n\n### **Description**\n\n **system_clock** returns data from the processor's real-time clock.\n It is commonly used for measuring elapsed wall-clock time by calling\n it twice and computing the difference. The clock value increments\n from 0 to **count_max**, then wraps around to 0. The resolution\n depends on the integer kind used: default integer typically gives\n millisecond resolution, while 8-byte integers can provide microsecond\n or nanosecond resolution.\n\n### **Options**\n\n- **count**\n  : Intent(out), optional. Returns the current clock count value.\n  This is a processor-dependent value that increases with time.\n  The count is modulo **count_max**, meaning it wraps to 0 after\n  reaching **count_max**. If the clock query fails, it is set to\n  -HUGE(count).\n\n- **count_rate**\n  : Intent(out), optional. Returns the number of clock counts per\n  second. To convert a count difference to seconds, divide by\n  **count_rate**. Can be INTEGER or REAL. If the clock query fails,\n  it is set to 0. The value depends on the kind of the argument.\n\n- **count_max**\n  : Intent(out), optional. Returns the maximum value of **count**\n  before it wraps to 0. Typically equals HUGE(count_max) for the\n  given integer kind. If the clock query fails, it is set to 0.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_system_clock\nimplicit none\n  integer         :: count_start, count_end, count_rate, count_max\n  integer(kind=8) :: count8_start, count8_end, rate8, max8\n  real            :: elapsed_time\n  integer         :: i\n  real            :: sum\n\n  ! Query clock properties with default integer\n  call system_clock(count_rate=count_rate, count_max=count_max)\n  print '(A,I0)',     'Count rate (ticks/sec): ', count_rate\n  print '(A,I0)',     'Count max:              ', count_max\n  print '(A,F10.6)', 'Max measurable time (s): ', &\n                      real(count_max) / real(count_rate)\n\n  ! Time a computation with default integer\n  call system_clock(count_start)\n\n  sum = 0.0\n  do i = 1, 10000000\n    sum = sum + sqrt(real(i))\n  end do\n\n  call system_clock(count_end)\n\n  elapsed_time = real(count_end - count_start) / real(count_rate)\n  print '(/,A,F10.6,A)', 'Computation took: ', elapsed_time, ' seconds'\n  print '(A,ES12.5)',    'Result: ', sum\n\n  ! Higher precision timing with 8-byte integers\n  call system_clock(count8_start, rate8, max8)\n  print '(/,A,I0)', 'High-precision rate: ', rate8\n\n  sum = 0.0\n  do i = 1, 10000000\n    sum = sum + sqrt(real(i))\n  end do\n\n  call system_clock(count8_end)\n\n  elapsed_time = real(count8_end - count8_start) / real(rate8)\n  print '(A,F12.9,A)', 'High-precision time: ', elapsed_time, ' seconds'\n\nend program demo_system_clock\n```\nResults:\n```text\nCount rate (ticks/sec): 1000\nCount max:              2147483647\nMax measurable time (s):  2147483.500000\n\nComputation took:   0.125000 seconds\nResult: 2.10819E+10\n\nHigh-precision rate: 1000000000\nHigh-precision time: 0.124567890 seconds\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**date_and_time**(3)](#date_and_time),\n[**cpu_time**(3)](#cpu_time)"
}
