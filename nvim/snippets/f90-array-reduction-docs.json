{
  "all": "**all** - [ARRAY:REDUCTION] Determine if all values in a logical array are true\n\n## Synopsis\n```fortran\nresult = all(mask)\nresult = all(mask, dim)\n```\n\n### Interface\n```fortran\ninterface all\n  pure function all(mask, dim) result(res)\n    logical, intent(in) :: mask(..)\n    integer, intent(in), optional :: dim\n    logical :: res  ! scalar if dim absent, array of rank n-1 if present\n  end function all\nend interface\n```\n\n## Characteristics\n- **mask** is a logical array of any rank\n- **dim** is an integer scalar in range 1 <= dim <= rank(mask)\n- Result is logical with same kind as **mask**\n- Result is scalar when **dim** is absent\n- Result is array of rank n-1 when **dim** is present\n\n## Description\n`all(mask)` returns `.true.` if all elements of **mask** are `.true.`, or if **mask** has zero size. Otherwise it returns `.false.`.\n\nWhen **dim** is present, the function applies the all operation across the specified dimension, returning an array where each element represents whether all values along that dimension are true.\n\nFor rank-1 arrays, `all(mask, dim)` is equivalent to `all(mask)`.\n\n## Options\n- **mask** (required): A logical array to be tested. Must not be scalar.\n- **dim** (optional): Dimension along which to apply the reduction. Must be a scalar integer between 1 and the rank of **mask**. Cannot be an optional dummy argument in the calling procedure.\n\n## Result\n- If **dim** is absent: scalar logical, `.true.` if all elements are true or array is empty\n- If **dim** is present: array of rank n-1 with shape `(d1, d2, ..., d(dim-1), d(dim+1), ..., dn)` where original shape is `(d1, d2, ..., dn)`\n\n## Examples\n\n### Example 1: Basic scalar result\n```fortran\nprogram example_all_basic\n  implicit none\n  logical :: result\n  \n  result = all([.true., .true., .true.])\n  print *, 'All true:', result   ! Output: T\n  \n  result = all([.true., .false., .true.])\n  print *, 'Mixed:', result      ! Output: F\nend program example_all_basic\n```\n\n### Example 2: Using DIM with 2D array\n```fortran\nprogram example_all_dim\n  implicit none\n  logical :: a(2,3)\n  logical :: row_result(3), col_result(2)\n  \n  a = reshape([.true., .true., .false., .true., .true., .true.], [2,3])\n  ! Array a:\n  !   T  F  T\n  !   T  T  T\n  \n  row_result = all(a, dim=1)  ! Check each column\n  print *, 'Column-wise:', row_result  ! Output: T F T\n  \n  col_result = all(a, dim=2)  ! Check each row\n  print *, 'Row-wise:', col_result     ! Output: F T\nend program example_all_dim\n```\n\n### Example 3: Practical validation\n```fortran\nprogram example_all_validation\n  implicit none\n  real :: values(5) = [1.0, 2.0, 3.0, 4.0, 5.0]\n  \n  if (all(values > 0.0)) then\n    print *, 'All values are positive'\n  end if\n  \n  if (all(values < 10.0)) then\n    print *, 'All values less than 10'\n  end if\nend program example_all_validation\n```\nOutput:\n```\n All values are positive\n All values less than 10\n```\n\n## Standard\nFortran 90\n\n## See Also\n- **any** - True if any element is true\n- **count** - Count true elements\n- **merge** - Conditional array merge",

  "any": "**any** - [ARRAY:REDUCTION] Determine if any value in a logical array is true\n\n## Synopsis\n```fortran\nresult = any(mask)\nresult = any(mask, dim)\n```\n\n### Interface\n```fortran\ninterface any\n  pure function any(mask, dim) result(res)\n    logical, intent(in) :: mask(..)\n    integer, intent(in), optional :: dim\n    logical :: res  ! scalar if dim absent, array of rank n-1 if present\n  end function any\nend interface\n```\n\n## Characteristics\n- **mask** is a logical array of any rank\n- **dim** is an integer scalar in range 1 <= dim <= rank(mask)\n- Result is logical with same kind as **mask**\n- Result is scalar when **dim** is absent\n- Result is array of rank n-1 when **dim** is present\n\n## Description\n`any(mask)` returns `.true.` if any element of **mask** is `.true.`. It returns `.false.` if all elements are `.false.` or if **mask** has zero size.\n\nWhen **dim** is present, the function applies the any operation across the specified dimension, returning an array where each element represents whether any value along that dimension is true.\n\nFor rank-1 arrays, `any(mask, dim)` is equivalent to `any(mask)`.\n\n## Options\n- **mask** (required): A logical array to be tested. Must not be scalar.\n- **dim** (optional): Dimension along which to apply the reduction. Must be a scalar integer between 1 and the rank of **mask**. Cannot be an optional dummy argument.\n\n## Result\n- If **dim** is absent: scalar logical, `.true.` if any element is true\n- If **dim** is present: array of rank n-1 with shape `(d1, d2, ..., d(dim-1), d(dim+1), ..., dn)`\n- Returns `.false.` for zero-size arrays\n\n## Examples\n\n### Example 1: Basic scalar result\n```fortran\nprogram example_any_basic\n  implicit none\n  logical :: result\n  \n  result = any([.false., .true., .false.])\n  print *, 'Any true:', result   ! Output: T\n  \n  result = any([.false., .false., .false.])\n  print *, 'All false:', result  ! Output: F\nend program example_any_basic\n```\n\n### Example 2: Using DIM with 2D array\n```fortran\nprogram example_any_dim\n  implicit none\n  integer :: a(2,3), b(2,3)\n  logical :: row_result(3), col_result(2)\n  \n  a = reshape([1, 2, 3, 4, 5, 6], [2,3])\n  b = reshape([1, 7, 3, 4, 5, 8], [2,3])\n  ! Compare: where are a and b equal?\n  ! Comparison matrix:\n  !   T  T  T\n  !   F  T  F\n  \n  row_result = any(a == b, dim=1)  ! Any match in each column\n  print *, 'Column-wise:', row_result  ! Output: T T T\n  \n  col_result = any(a == b, dim=2)  ! Any match in each row\n  print *, 'Row-wise:', col_result     ! Output: T T\nend program example_any_dim\n```\n\n### Example 3: Error checking\n```fortran\nprogram example_any_errors\n  implicit none\n  real :: data(100)\n  \n  call random_number(data)\n  data = data * 200.0 - 100.0  ! Range: -100 to 100\n  \n  if (any(data < 0.0)) then\n    print *, 'Warning: negative values detected'\n    print *, 'Count:', count(data < 0.0)\n  end if\n  \n  if (any(ieee_is_nan(data))) then\n    print *, 'Error: NaN values present'\n  end if\nend program example_any_errors\n```\n\n## Standard\nFortran 90\n\n## See Also\n- **all** - True if all elements are true\n- **count** - Count true elements\n- **findloc** - Find location of value (F2008)",

  "count": "**count** - [ARRAY:REDUCTION] Count the number of true elements in a logical array\n\n## Synopsis\n```fortran\nresult = count(mask)\nresult = count(mask, dim)\nresult = count(mask, dim, kind)\n```\n\n### Interface\n```fortran\ninterface count\n  pure function count(mask, dim, kind) result(res)\n    logical, intent(in) :: mask(..)\n    integer, intent(in), optional :: dim\n    integer, intent(in), optional :: kind\n    integer(kind) :: res  ! scalar or array depending on dim\n  end function count\nend interface\n```\n\n## Characteristics\n- **mask** is a logical array of any rank\n- **dim** is an integer scalar in range 1 <= dim <= rank(mask)\n- **kind** is an integer initialization expression (F2003+)\n- Result is integer of specified **kind** (default integer if omitted)\n- Result is scalar when **dim** is absent\n- Result is array of rank n-1 when **dim** is present\n\n## Description\n`count(mask)` returns the number of `.true.` elements in the logical array **mask**. If the array has zero size or all elements are `.false.`, the result is 0.\n\nWhen **dim** is present, the function counts true elements along the specified dimension, returning an array of counts.\n\n## Options\n- **mask** (required): A logical array whose true elements are to be counted.\n- **dim** (optional): Dimension along which to count. Must be a scalar integer between 1 and rank of **mask**.\n- **kind** (optional): Integer kind parameter for the result. Fortran 2003 and later.\n\n## Result\n- If **dim** is absent: scalar integer count of true elements\n- If **dim** is present: integer array of rank n-1 with counts along each slice\n- Returns 0 for empty arrays or when all elements are false\n\n## Examples\n\n### Example 1: Basic counting\n```fortran\nprogram example_count_basic\n  implicit none\n  logical :: mask(5) = [.true., .false., .true., .true., .false.]\n  \n  print *, 'True count:', count(mask)          ! Output: 3\n  print *, 'False count:', count(.not. mask)   ! Output: 2\nend program example_count_basic\n```\n\n### Example 2: Counting with DIM\n```fortran\nprogram example_count_dim\n  implicit none\n  integer :: a(2,3), b(2,3)\n  logical :: mask(2,3)\n  \n  a = reshape([1, 2, 3, 4, 5, 6], [2,3])\n  b = reshape([0, 7, 3, 4, 5, 8], [2,3])\n  mask = a /= b\n  ! mask:\n  !   T  F  F\n  !   T  F  T\n  \n  print *, 'Total differences:', count(mask)       ! Output: 3\n  print *, 'Per column:', count(mask, dim=1)       ! Output: 2 0 1\n  print *, 'Per row:', count(mask, dim=2)          ! Output: 1 2\nend program example_count_dim\n```\n\n### Example 3: Statistical analysis\n```fortran\nprogram example_count_stats\n  implicit none\n  real :: scores(10) = [85.0, 72.0, 91.0, 68.0, 77.0, &\n                        95.0, 83.0, 59.0, 88.0, 74.0]\n  integer :: n_pass, n_fail, n_excellent\n  \n  n_pass = count(scores >= 70.0)\n  n_fail = count(scores < 70.0)\n  n_excellent = count(scores >= 90.0)\n  \n  print '(A,I2,A,I2)', 'Pass: ', n_pass, ', Fail: ', n_fail\n  print '(A,I2)', 'Excellent (>=90): ', n_excellent\n  print '(A,F5.1,A)', 'Pass rate: ', 100.0*real(n_pass)/size(scores), '%'\nend program example_count_stats\n```\nOutput:\n```\nPass:  8, Fail:  2\nExcellent (>=90):  2\nPass rate:  80.0%\n```\n\n## Standard\nFortran 90 (KIND argument: Fortran 2003)\n\n## See Also\n- **all** - True if all elements are true\n- **any** - True if any element is true\n- **sum** - Sum array elements (can use logical-to-integer conversion)",

  "maxval": "**maxval** - [ARRAY:REDUCTION] Determine the maximum value in an array\n\n## Synopsis\n```fortran\nresult = maxval(array)\nresult = maxval(array, dim)\nresult = maxval(array, mask)\nresult = maxval(array, dim, mask)\n```\n\n### Interface\n```fortran\ninterface maxval\n  pure function maxval(array, dim, mask) result(res)\n    type(numeric), intent(in) :: array(..)\n    integer, intent(in), optional :: dim\n    logical, intent(in), optional :: mask(..)\n    type(numeric) :: res  ! same type/kind as array\n  end function maxval\nend interface\n```\n\n## Characteristics\n- **array** must be integer, real, or character type\n- **dim** is an integer scalar in range 1 <= dim <= rank(array)\n- **mask** is a logical array conformable with **array**\n- Result has same type and kind as **array**\n- Result is scalar when **dim** is absent\n- Result is array of rank n-1 when **dim** is present\n\n## Description\n`maxval(array)` returns the maximum value of all elements in **array**, or of those elements selected by **mask** if present.\n\nWhen **dim** is specified, maximum values are computed along that dimension, returning an array of results.\n\nFor empty arrays or when **mask** has no true elements, the result is `-huge(array)` for numeric types, or a string of null characters (char(0)) for character type.\n\n## Options\n- **array** (required): Array of integer, real, or character type to search for maximum.\n- **dim** (optional): Dimension along which to find maxima. Cannot be an optional dummy argument.\n- **mask** (optional): Logical array selecting which elements to consider. Must be conformable with **array**.\n\n## Result\n- If **dim** is absent: scalar maximum value\n- If **dim** is present: array of rank n-1 containing maximum along each slice\n- For empty sets: returns `-huge(array)` (most negative representable value)\n\n## Examples\n\n### Example 1: Basic maximum\n```fortran\nprogram example_maxval_basic\n  implicit none\n  integer :: a(5) = [3, 1, 4, 1, 5]\n  real :: b(4) = [2.7, 1.8, 3.14, 0.5]\n  \n  print *, 'Max integer:', maxval(a)   ! Output: 5\n  print *, 'Max real:', maxval(b)      ! Output: 3.14\nend program example_maxval_basic\n```\n\n### Example 2: Using DIM with 2D array\n```fortran\nprogram example_maxval_dim\n  implicit none\n  integer :: matrix(2,3)\n  \n  matrix = reshape([1, 4, 5, 2, 3, 6], [2,3])\n  ! Matrix:\n  !   1  5  3\n  !   4  2  6\n  \n  print *, 'Overall max:', maxval(matrix)           ! Output: 6\n  print *, 'Max per column:', maxval(matrix, dim=1) ! Output: 4 5 6\n  print *, 'Max per row:', maxval(matrix, dim=2)    ! Output: 5 6\nend program example_maxval_dim\n```\n\n### Example 3: Using MASK for conditional maximum\n```fortran\nprogram example_maxval_mask\n  implicit none\n  real :: temps(7) = [22.5, 25.3, 18.2, 30.1, 27.8, 15.6, 28.9]\n  character(len=*), parameter :: days(7) = &\n    ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']\n  \n  print *, 'Max temperature:', maxval(temps)\n  print *, 'Max temp below 25:', maxval(temps, mask=temps < 25.0)\n  print *, 'Weekday max:', maxval(temps(1:5))\n  print *, 'Weekend max:', maxval(temps(6:7))\nend program example_maxval_mask\n```\nOutput:\n```\n Max temperature:   30.1\n Max temp below 25:   22.5\n Weekday max:   30.1\n Weekend max:   28.9\n```\n\n### Example 4: Empty set behavior\n```fortran\nprogram example_maxval_empty\n  implicit none\n  real :: arr(5) = [1.0, 2.0, 3.0, 4.0, 5.0]\n  real :: result\n  \n  ! No elements satisfy mask - returns -huge(arr)\n  result = maxval(arr, mask=arr > 100.0)\n  print *, 'Empty max:', result           ! Output: -3.40282347E+38\n  print *, 'Equals -huge:', result == -huge(arr)  ! Output: T\nend program example_maxval_empty\n```\n\n## Standard\nFortran 90\n\n## See Also\n- **minval** - Minimum value in array\n- **maxloc** - Location of maximum value\n- **max** - Elemental maximum of arguments\n- **huge** - Largest model number",

  "minval": "**minval** - [ARRAY:REDUCTION] Determine the minimum value in an array\n\n## Synopsis\n```fortran\nresult = minval(array)\nresult = minval(array, dim)\nresult = minval(array, mask)\nresult = minval(array, dim, mask)\n```\n\n### Interface\n```fortran\ninterface minval\n  pure function minval(array, dim, mask) result(res)\n    type(numeric), intent(in) :: array(..)\n    integer, intent(in), optional :: dim\n    logical, intent(in), optional :: mask(..)\n    type(numeric) :: res  ! same type/kind as array\n  end function minval\nend interface\n```\n\n## Characteristics\n- **array** must be integer, real, or character type\n- **dim** is an integer scalar in range 1 <= dim <= rank(array)\n- **mask** is a logical array conformable with **array**\n- Result has same type and kind as **array**\n- Result is scalar when **dim** is absent\n- Result is array of rank n-1 when **dim** is present\n\n## Description\n`minval(array)` returns the minimum value of all elements in **array**, or of those elements selected by **mask** if present.\n\nWhen **dim** is specified, minimum values are computed along that dimension, returning an array of results.\n\nFor empty arrays or when **mask** has no true elements, the result is `huge(array)` for numeric types, or a string of char(255) characters for character type.\n\n## Options\n- **array** (required): Array of integer, real, or character type to search for minimum.\n- **dim** (optional): Dimension along which to find minima. Cannot be an optional dummy argument.\n- **mask** (optional): Logical array selecting which elements to consider. Must be conformable with **array**.\n\n## Result\n- If **dim** is absent: scalar minimum value\n- If **dim** is present: array of rank n-1 containing minimum along each slice\n- For empty sets: returns `huge(array)` (largest representable value)\n\n## Examples\n\n### Example 1: Basic minimum\n```fortran\nprogram example_minval_basic\n  implicit none\n  integer :: a(5) = [3, 1, 4, 1, 5]\n  real :: b(4) = [2.7, 1.8, 3.14, 0.5]\n  \n  print *, 'Min integer:', minval(a)   ! Output: 1\n  print *, 'Min real:', minval(b)      ! Output: 0.5\nend program example_minval_basic\n```\n\n### Example 2: Using DIM with 2D array\n```fortran\nprogram example_minval_dim\n  implicit none\n  integer :: matrix(2,3)\n  \n  matrix = reshape([1, 4, 5, 2, 3, 6], [2,3])\n  ! Matrix:\n  !   1  5  3\n  !   4  2  6\n  \n  print *, 'Overall min:', minval(matrix)           ! Output: 1\n  print *, 'Min per column:', minval(matrix, dim=1) ! Output: 1 2 3\n  print *, 'Min per row:', minval(matrix, dim=2)    ! Output: 1 2\nend program example_minval_dim\n```\n\n### Example 3: Using MASK for conditional minimum\n```fortran\nprogram example_minval_mask\n  implicit none\n  real :: prices(6) = [15.99, 24.50, 8.75, 32.00, 12.25, 45.00]\n  \n  print *, 'Cheapest item:', minval(prices)\n  print *, 'Cheapest over $10:', minval(prices, mask=prices > 10.0)\n  print *, 'Cheapest under $20:', minval(prices, mask=prices < 20.0)\nend program example_minval_mask\n```\nOutput:\n```\n Cheapest item:   8.75\n Cheapest over $10:   12.25\n Cheapest under $20:   8.75\n```\n\n### Example 4: Finding range\n```fortran\nprogram example_minval_range\n  implicit none\n  real :: data(100)\n  real :: min_val, max_val, range_val\n  \n  call random_number(data)\n  data = data * 100.0  ! Scale to 0-100\n  \n  min_val = minval(data)\n  max_val = maxval(data)\n  range_val = max_val - min_val\n  \n  print '(A,F7.3)', 'Minimum: ', min_val\n  print '(A,F7.3)', 'Maximum: ', max_val\n  print '(A,F7.3)', 'Range:   ', range_val\nend program example_minval_range\n```\n\n### Example 5: Empty set behavior\n```fortran\nprogram example_minval_empty\n  implicit none\n  integer :: arr(5) = [1, 2, 3, 4, 5]\n  integer :: result\n  \n  ! No elements satisfy mask - returns huge(arr)\n  result = minval(arr, mask=arr > 100)\n  print *, 'Empty min:', result              ! Output: 2147483647\n  print *, 'Equals huge:', result == huge(arr)  ! Output: T\nend program example_minval_empty\n```\n\n## Standard\nFortran 90\n\n## See Also\n- **maxval** - Maximum value in array\n- **minloc** - Location of minimum value\n- **min** - Elemental minimum of arguments\n- **huge** - Largest model number",

  "product": "**product** - [ARRAY:REDUCTION] Compute the product of array elements\n\n## Synopsis\n```fortran\nresult = product(array)\nresult = product(array, dim)\nresult = product(array, mask)\nresult = product(array, dim, mask)\n```\n\n### Interface\n```fortran\ninterface product\n  pure function product(array, dim, mask) result(res)\n    type(numeric), intent(in) :: array(..)\n    integer, intent(in), optional :: dim\n    logical, intent(in), optional :: mask(..)\n    type(numeric) :: res  ! same type/kind as array\n  end function product\nend interface\n```\n\n## Characteristics\n- **array** must be integer, real, or complex type\n- **dim** is an integer scalar in range 1 <= dim <= rank(array)\n- **mask** is a logical array conformable with **array**\n- Result has same type and kind as **array**\n- Result is scalar when **dim** is absent\n- Result is array of rank n-1 when **dim** is present\n\n## Description\n`product(array)` returns the product of all elements in **array**, or of those elements selected by **mask** if present.\n\nWhen **dim** is specified, products are computed along that dimension, returning an array of results.\n\nFor empty arrays or when **mask** has no true elements, the result is 1 (the multiplicative identity).\n\n## Options\n- **array** (required): Numeric array whose elements are to be multiplied.\n- **dim** (optional): Dimension along which to compute products.\n- **mask** (optional): Logical array selecting which elements to include. Must be conformable with **array**.\n\n## Result\n- If **dim** is absent: scalar product of all (selected) elements\n- If **dim** is present: array of rank n-1 with products along each slice\n- For empty sets: returns 1 (multiplicative identity)\n\n## Examples\n\n### Example 1: Basic product (factorial)\n```fortran\nprogram example_product_basic\n  implicit none\n  integer :: n\n  \n  n = 5\n  print *, '5! =', product([(i, i=1,n, integer :: i)])  ! Output: 120\n  \n  print *, 'Product of 1-10:', product([(i, i=1,10, integer :: i)])\nend program example_product_basic\n```\n\n### Example 2: Using DIM with 2D array\n```fortran\nprogram example_product_dim\n  implicit none\n  integer :: matrix(2,3)\n  \n  matrix = reshape([1, 2, 3, 4, 5, 6], [2,3])\n  ! Matrix:\n  !   1  3  5\n  !   2  4  6\n  \n  print *, 'Total product:', product(matrix)           ! Output: 720\n  print *, 'Product per column:', product(matrix, dim=1)  ! Output: 2 12 30\n  print *, 'Product per row:', product(matrix, dim=2)     ! Output: 15 48\nend program example_product_dim\n```\n\n### Example 3: Using MASK for conditional product\n```fortran\nprogram example_product_mask\n  implicit none\n  integer :: values(6) = [2, 3, 0, 4, 5, 1]\n  \n  print *, 'Product of all:', product(values)  ! Output: 0\n  print *, 'Product of non-zero:', product(values, mask=values /= 0)\n  ! Output: 120\n  \n  print *, 'Product of evens:', product(values, mask=mod(values,2)==0)\n  ! Output: 0 (includes the zero)\nend program example_product_mask\n```\n\n### Example 4: Computing array size from shape\n```fortran\nprogram example_product_shape\n  implicit none\n  real :: tensor(3,4,5)\n  integer :: total_elements\n  \n  total_elements = product(shape(tensor))\n  print *, 'Total elements:', total_elements  ! Output: 60\n  print *, 'Verify with size:', size(tensor)  ! Output: 60\nend program example_product_shape\n```\n\n### Example 5: Empty set returns identity\n```fortran\nprogram example_product_empty\n  implicit none\n  real :: arr(0)  ! Zero-size array\n  real :: arr2(5) = [1.0, 2.0, 3.0, 4.0, 5.0]\n  \n  print *, 'Empty array product:', product(arr)  ! Output: 1.0\n  print *, 'No mask matches:', product(arr2, mask=arr2 > 100.0)\n  ! Output: 1.0 (identity for multiplication)\nend program example_product_empty\n```\n\n### Example 6: Combinatorics\n```fortran\nprogram example_product_combinatorics\n  implicit none\n  integer :: n, r\n  integer(8) :: perm, comb\n  \n  n = 10\n  r = 3\n  \n  ! Permutations P(n,r) = n!/(n-r)!\n  perm = product([(int(i,8), i=n-r+1,n)])\n  print *, 'P(10,3) =', perm  ! Output: 720\n  \n  ! Combinations via falling factorial / r!\n  comb = perm / product([(int(i,8), i=1,r)])\n  print *, 'C(10,3) =', comb  ! Output: 120\nend program example_product_combinatorics\n```\n\n## Standard\nFortran 90\n\n## See Also\n- **sum** - Sum array elements\n- **maxval** - Maximum value in array\n- **minval** - Minimum value in array\n- **dot_product** - Vector dot product",

  "sum": "**sum** - [ARRAY:REDUCTION] Compute the sum of array elements\n\n## Synopsis\n```fortran\nresult = sum(array)\nresult = sum(array, dim)\nresult = sum(array, mask)\nresult = sum(array, dim, mask)\n```\n\n### Interface\n```fortran\ninterface sum\n  pure function sum(array, dim, mask) result(res)\n    type(numeric), intent(in) :: array(..)\n    integer, intent(in), optional :: dim\n    logical, intent(in), optional :: mask(..)\n    type(numeric) :: res  ! same type/kind as array\n  end function sum\nend interface\n```\n\n## Characteristics\n- **array** must be integer, real, or complex type\n- **dim** is an integer scalar in range 1 <= dim <= rank(array)\n- **mask** is a logical array conformable with **array**\n- Result has same type and kind as **array**\n- Result is scalar when **dim** is absent\n- Result is array of rank n-1 when **dim** is present\n\n## Description\n`sum(array)` returns the sum of all elements in **array**, or of those elements selected by **mask** if present.\n\nWhen **dim** is specified, sums are computed along that dimension, returning an array of partial sums.\n\nFor empty arrays or when **mask** has no true elements, the result is 0 (the additive identity).\n\nThis is one of the most commonly used array reduction functions, essential for statistical calculations, numerical methods, and data analysis.\n\n## Options\n- **array** (required): Numeric array whose elements are to be summed.\n- **dim** (optional): Dimension along which to compute sums. Must be between 1 and rank of **array**.\n- **mask** (optional): Logical array selecting which elements to include. Must be conformable with **array**.\n\n## Result\n- If **dim** is absent: scalar sum of all (selected) elements\n- If **dim** is present: array of rank n-1 with sums along each slice\n- For empty sets: returns 0 (additive identity)\n\n## Examples\n\n### Example 1: Basic summation\n```fortran\nprogram example_sum_basic\n  implicit none\n  integer :: x(5) = [1, 2, 3, 4, 5]\n  real :: y(4) = [1.5, 2.5, 3.5, 4.5]\n  \n  print *, 'Integer sum:', sum(x)  ! Output: 15\n  print *, 'Real sum:', sum(y)     ! Output: 12.0\nend program example_sum_basic\n```\n\n### Example 2: Using DIM with 2D array\n```fortran\nprogram example_sum_dim\n  implicit none\n  integer :: matrix(2,3)\n  \n  matrix = reshape([4, 7, 2, 8, 3, 5], [2,3])\n  ! Matrix:\n  !   4  2  3\n  !   7  8  5\n  \n  print *, 'Total sum:', sum(matrix)            ! Output: 29\n  print *, 'Column sums:', sum(matrix, dim=1)   ! Output: 11 10 8\n  print *, 'Row sums:', sum(matrix, dim=2)      ! Output: 9 20\nend program example_sum_dim\n```\n\n### Example 3: Using MASK for conditional sum\n```fortran\nprogram example_sum_mask\n  implicit none\n  integer :: values(10) = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n  \n  print *, 'Sum of all:', sum(values)                    ! Output: 55\n  print *, 'Sum of odds:', sum(values, mask=mod(values,2)==1)   ! Output: 25\n  print *, 'Sum of evens:', sum(values, mask=mod(values,2)==0)  ! Output: 30\n  print *, 'Sum > 5:', sum(values, mask=values > 5)      ! Output: 40\nend program example_sum_mask\n```\n\n### Example 4: Statistical calculations\n```fortran\nprogram example_sum_statistics\n  implicit none\n  real :: data(10) = [23.5, 18.2, 31.7, 25.0, 19.8, &\n                      27.3, 22.1, 29.6, 24.4, 20.9]\n  real :: mean_val, variance, std_dev\n  integer :: n\n  \n  n = size(data)\n  mean_val = sum(data) / real(n)\n  variance = sum((data - mean_val)**2) / real(n)\n  std_dev = sqrt(variance)\n  \n  print '(A,F7.2)', 'Mean:     ', mean_val\n  print '(A,F7.2)', 'Variance: ', variance\n  print '(A,F7.2)', 'Std Dev:  ', std_dev\nend program example_sum_statistics\n```\nOutput:\n```\nMean:       24.25\nVariance:   17.05\nStd Dev:     4.13\n```\n\n### Example 5: Weighted sum\n```fortran\nprogram example_sum_weighted\n  implicit none\n  real :: grades(5) = [85.0, 90.0, 78.0, 92.0, 88.0]\n  real :: weights(5) = [0.10, 0.20, 0.15, 0.25, 0.30]\n  real :: weighted_avg\n  \n  weighted_avg = sum(grades * weights)\n  print '(A,F6.2)', 'Weighted average: ', weighted_avg\nend program example_sum_weighted\n```\nOutput:\n```\nWeighted average:  87.80\n```\n\n### Example 6: Matrix operations\n```fortran\nprogram example_sum_matrix\n  implicit none\n  real :: A(3,3), row_sums(3), col_sums(3)\n  real :: trace_val\n  integer :: i\n  \n  A = reshape([1.0, 4.0, 7.0, 2.0, 5.0, 8.0, 3.0, 6.0, 9.0], [3,3])\n  ! A:\n  !   1  2  3\n  !   4  5  6\n  !   7  8  9\n  \n  row_sums = sum(A, dim=2)  ! Sum across columns\n  col_sums = sum(A, dim=1)  ! Sum across rows\n  \n  ! Trace (sum of diagonal elements)\n  trace_val = sum([(A(i,i), i=1,3)])\n  \n  print *, 'Row sums:', row_sums\n  print *, 'Col sums:', col_sums\n  print *, 'Trace:', trace_val\nend program example_sum_matrix\n```\nOutput:\n```\n Row sums:   6.0  15.0  24.0\n Col sums:  12.0  15.0  18.0\n Trace:  15.0\n```\n\n## Standard\nFortran 90\n\n## See Also\n- **product** - Product of array elements\n- **count** - Count true elements\n- **dot_product** - Vector dot product\n- **matmul** - Matrix multiplication"
}
