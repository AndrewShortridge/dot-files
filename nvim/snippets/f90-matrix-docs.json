{
  "dot_product": "**dot_product** - [ARRAY:MATRIX] Computes the dot product of two vectors\n\n## Synopsis\n```fortran\nresult = DOT_PRODUCT(VECTOR_A, VECTOR_B)\n```\n\n### Interface\n```fortran\ninterface dot_product\n    function dot_product(vector_a, vector_b) result(res)\n        ! For numeric types:\n        integer|real|complex, intent(in) :: vector_a(:)\n        integer|real|complex, intent(in) :: vector_b(:)\n        integer|real|complex :: res  ! scalar\n        ! For logical types:\n        logical, intent(in) :: vector_a(:)\n        logical, intent(in) :: vector_b(:)\n        logical :: res  ! scalar\n    end function\nend interface\n```\n\n## Characteristics\n- **Classification**: Transformational function\n- **Type constraints**: Both arguments must be of the same numeric type (INTEGER, REAL, COMPLEX) or both must be LOGICAL\n- **Rank constraints**: Both arguments must be rank-1 arrays (vectors)\n- **Conformability**: Both vectors must have the same size (number of elements)\n- **Result type**: Scalar of the same type and kind as the arguments (after type promotion if kinds differ)\n\n## Description\n`DOT_PRODUCT` computes the inner product (dot product) of two vectors. The mathematical operation depends on the argument types:\n\n**Numeric types (INTEGER, REAL)**:\n```\nresult = SUM(VECTOR_A * VECTOR_B)\nresult = a1*b1 + a2*b2 + ... + an*bn\n```\n\n**Complex types**:\n```\nresult = SUM(CONJG(VECTOR_A) * VECTOR_B)\nresult = conjg(a1)*b1 + conjg(a2)*b2 + ... + conjg(an)*bn\n```\nThis computes the Hermitian inner product, conjugating the first argument.\n\n**Logical types**:\n```\nresult = ANY(VECTOR_A .AND. VECTOR_B)\n```\nReturns `.TRUE.` if any corresponding pair of elements are both `.TRUE.`.\n\n## Options\n**VECTOR_A**\n: A rank-1 array of numeric (INTEGER, REAL, COMPLEX) or LOGICAL type. For complex dot products, this is the vector that gets conjugated.\n\n**VECTOR_B**\n: A rank-1 array with the same type class and size as VECTOR_A. Must be numeric if VECTOR_A is numeric, or LOGICAL if VECTOR_A is LOGICAL.\n\n## Result\n- **Type**: Scalar (rank-0) of the same type as the arguments\n- **Kind**: Follows standard type promotion rules when argument kinds differ\n- **Value**: The dot product as defined above for each type\n\n## Examples\n\n### Example 1: Integer Dot Product\n```fortran\nprogram example_dot_product_int\n    implicit none\n    integer, dimension(3) :: a, b\n    integer :: result\n\n    a = [1, 2, 3]\n    b = [4, 5, 6]\n\n    result = dot_product(a, b)\n    print '(A,I0)', 'Integer dot product: ', result\n    ! Calculation: 1*4 + 2*5 + 3*6 = 4 + 10 + 18 = 32\nend program example_dot_product_int\n```\n**Output:**\n```\nInteger dot product: 32\n```\n\n### Example 2: Real Dot Product\n```fortran\nprogram example_dot_product_real\n    implicit none\n    real, dimension(5) :: a, b\n    real :: result\n    integer :: i\n\n    a = [(real(i), i=1,5)]       ! [1.0, 2.0, 3.0, 4.0, 5.0]\n    b = [(real(i*2), i=1,5)]    ! [2.0, 4.0, 6.0, 8.0, 10.0]\n\n    result = dot_product(a, b)\n    print '(A,F8.1)', 'Real dot product: ', result\n    ! Calculation: 1*2 + 2*4 + 3*6 + 4*8 + 5*10 = 2+8+18+32+50 = 110\nend program example_dot_product_real\n```\n**Output:**\n```\nReal dot product:    110.0\n```\n\n### Example 3: Complex Dot Product (Hermitian)\n```fortran\nprogram example_dot_product_complex\n    implicit none\n    complex, dimension(2) :: a, b\n    complex :: result\n\n    a = [(1.0, 2.0), (3.0, 4.0)]   ! [1+2i, 3+4i]\n    b = [(5.0, 6.0), (7.0, 8.0)]   ! [5+6i, 7+8i]\n\n    result = dot_product(a, b)\n    print '(A,2F8.1)', 'Complex dot product: ', real(result), aimag(result)\n    ! Calculation: conjg(1+2i)*(5+6i) + conjg(3+4i)*(7+8i)\n    !            = (1-2i)*(5+6i) + (3-4i)*(7+8i)\n    !            = (5+6i-10i+12) + (21+24i-28i+32)\n    !            = (17-4i) + (53-4i) = 70-8i\nend program example_dot_product_complex\n```\n**Output:**\n```\nComplex dot product:     70.0    -8.0\n```\n\n### Example 4: Logical Dot Product\n```fortran\nprogram example_dot_product_logical\n    implicit none\n    logical, dimension(4) :: a, b\n    logical :: result\n\n    a = [.true., .false., .true., .false.]\n    b = [.false., .false., .true., .true.]\n\n    result = dot_product(a, b)\n    print '(A,L1)', 'Logical dot product: ', result\n    ! Calculation: ANY([F,F,T,F]) = .TRUE.\n    ! (Only position 3 has both .TRUE.)\nend program example_dot_product_logical\n```\n**Output:**\n```\nLogical dot product: T\n```\n\n## Standard\nFortran 90 and later\n\n## See Also\n- **matmul** - Matrix multiplication\n- **sum** - Sum of array elements\n- **product** - Product of array elements\n- **conjg** - Complex conjugate\n- **any** - Logical OR reduction",

  "matmul": "**matmul** - [ARRAY:MATRIX] Performs matrix multiplication of numeric or logical arrays\n\n## Synopsis\n```fortran\nresult = MATMUL(MATRIX_A, MATRIX_B)\n```\n\n### Interface\n```fortran\ninterface matmul\n    function matmul(matrix_a, matrix_b) result(res)\n        ! Matrix-matrix: (n,m) x (m,k) -> (n,k)\n        integer|real|complex, intent(in) :: matrix_a(:,:)\n        integer|real|complex, intent(in) :: matrix_b(:,:)\n        integer|real|complex :: res(size(matrix_a,1), size(matrix_b,2))\n\n        ! Vector-matrix: (m) x (m,k) -> (k)\n        integer|real|complex, intent(in) :: matrix_a(:)\n        integer|real|complex, intent(in) :: matrix_b(:,:)\n        integer|real|complex :: res(size(matrix_b,2))\n\n        ! Matrix-vector: (n,m) x (m) -> (n)\n        integer|real|complex, intent(in) :: matrix_a(:,:)\n        integer|real|complex, intent(in) :: matrix_b(:)\n        integer|real|complex :: res(size(matrix_a,1))\n\n        ! Logical versions follow the same shape rules\n        logical, intent(in) :: matrix_a(:,:), matrix_b(:,:)\n        logical :: res(:,:)\n    end function\nend interface\n```\n\n## Characteristics\n- **Classification**: Transformational function\n- **Type constraints**: Both arguments must be numeric (INTEGER, REAL, COMPLEX) or both must be LOGICAL\n- **Rank constraints**: Arguments must be rank-1 or rank-2; at least one argument must be rank-2 (both cannot be vectors)\n- **Conformability**: The last dimension of MATRIX_A must equal the first dimension of MATRIX_B\n- **Result type**: Array of same type as arguments (following type promotion rules)\n\n## Description\n`MATMUL` performs standard matrix multiplication following linear algebra conventions.\n\n**For numeric types**, the result element C(i,j) is computed as:\n```\nC(i,j) = SUM(A(i,:) * B(:,j))\n       = A(i,1)*B(1,j) + A(i,2)*B(2,j) + ... + A(i,m)*B(m,j)\n```\n\n**For logical types**, the result uses logical operations:\n```\nC(i,j) = ANY(A(i,:) .AND. B(:,j))\n```\n\n### Result Shape Rules\n\n| MATRIX_A Shape | MATRIX_B Shape | Result Shape | Result Rank |\n|----------------|----------------|--------------|-------------|\n| (n, m)         | (m, k)         | (n, k)       | 2           |\n| (m)            | (m, k)         | (k)          | 1           |\n| (n, m)         | (m)            | (n)          | 1           |\n\n**Note**: Both arguments cannot be rank-1 simultaneously.\n\n## Options\n**MATRIX_A**\n: A numeric or logical array of rank 1 or 2. If rank-1, it is treated as a row vector with shape (1, m). The last dimension must match the first dimension of MATRIX_B.\n\n**MATRIX_B**\n: A numeric or logical array of rank 1 or 2. If rank-1, it is treated as a column vector with shape (m, 1). Must be the same type class as MATRIX_A. The first dimension must match the last dimension of MATRIX_A.\n\n## Result\n- **Type**: Numeric or logical array matching the argument types\n- **Rank**: 2 if both arguments are rank-2; 1 if either argument is rank-1\n- **Shape**: Determined by the rules in the table above\n- **Kind**: Follows standard type promotion rules\n\n## Examples\n\n### Example 1: Matrix-Matrix Multiplication\n```fortran\nprogram example_matmul_matrix\n    implicit none\n    integer :: a(2,3), b(3,2), c(2,2)\n    integer :: i, j\n\n    ! Initialize A (2x3 matrix)\n    a = reshape([2,3, 3,4, 4,5], [2,3])\n    ! A = | 2 3 4 |\n    !     | 3 4 5 |\n\n    ! Initialize B (3x2 matrix)\n    b = reshape([2,3,4, 3,4,5], [3,2])\n    ! B = | 2 3 |\n    !     | 3 4 |\n    !     | 4 5 |\n\n    c = matmul(a, b)\n\n    print '(A)', 'Matrix A (2x3):'\n    do i = 1, 2\n        print '(3I4)', (a(i,j), j=1,3)\n    end do\n\n    print '(A)', 'Matrix B (3x2):'\n    do i = 1, 3\n        print '(2I4)', (b(i,j), j=1,2)\n    end do\n\n    print '(A)', 'Result C = A*B (2x2):'\n    do i = 1, 2\n        print '(2I4)', (c(i,j), j=1,2)\n    end do\n    ! C(1,1) = 2*2 + 3*3 + 4*4 = 4+9+16 = 29\n    ! C(1,2) = 2*3 + 3*4 + 4*5 = 6+12+20 = 38\n    ! C(2,1) = 3*2 + 4*3 + 5*4 = 6+12+20 = 38\n    ! C(2,2) = 3*3 + 4*4 + 5*5 = 9+16+25 = 50\nend program example_matmul_matrix\n```\n**Output:**\n```\nMatrix A (2x3):\n   2   3   4\n   3   4   5\nMatrix B (3x2):\n   2   3\n   3   4\n   4   5\nResult C = A*B (2x2):\n  29  38\n  38  50\n```\n\n### Example 2: Vector-Matrix Multiplication\n```fortran\nprogram example_matmul_vec_mat\n    implicit none\n    integer :: x(2), a(2,3), result(3)\n\n    x = [1, 2]\n    a = reshape([2,3, 3,4, 4,5], [2,3])\n    ! A = | 2 3 4 |\n    !     | 3 4 5 |\n\n    result = matmul(x, a)  ! (2) x (2,3) -> (3)\n\n    print '(A,3I4)', 'Vector x = ', x\n    print '(A)', 'Matrix A (2x3):'\n    print '(3I4)', a(1,:)\n    print '(3I4)', a(2,:)\n    print '(A,3I4)', 'x * A = ', result\n    ! result(1) = 1*2 + 2*3 = 8\n    ! result(2) = 1*3 + 2*4 = 11\n    ! result(3) = 1*4 + 2*5 = 14\nend program example_matmul_vec_mat\n```\n**Output:**\n```\nVector x =    1   2\nMatrix A (2x3):\n   2   3   4\n   3   4   5\nx * A =    8  11  14\n```\n\n### Example 3: Matrix-Vector Multiplication\n```fortran\nprogram example_matmul_mat_vec\n    implicit none\n    integer :: a(2,3), y(3), result(2)\n\n    a = reshape([2,3, 3,4, 4,5], [2,3])\n    y = [1, 2, 3]\n\n    result = matmul(a, y)  ! (2,3) x (3) -> (2)\n\n    print '(A)', 'Matrix A (2x3):'\n    print '(3I4)', a(1,:)\n    print '(3I4)', a(2,:)\n    print '(A,3I4)', 'Vector y = ', y\n    print '(A,2I4)', 'A * y = ', result\n    ! result(1) = 2*1 + 3*2 + 4*3 = 2+6+12 = 20\n    ! result(2) = 3*1 + 4*2 + 5*3 = 3+8+15 = 26\nend program example_matmul_mat_vec\n```\n**Output:**\n```\nMatrix A (2x3):\n   2   3   4\n   3   4   5\nVector y =    1   2   3\nA * y =   20  26\n```\n\n### Example 4: Real Matrix Multiplication\n```fortran\nprogram example_matmul_real\n    implicit none\n    real :: a(3,3), b(3,3), c(3,3)\n    integer :: i, j\n\n    ! Identity-like multiplication demo\n    do i = 1, 3\n        do j = 1, 3\n            a(i,j) = real(i + j)\n            b(i,j) = real(i * j)\n        end do\n    end do\n\n    c = matmul(a, b)\n\n    print '(A)', 'Matrix A:'\n    do i = 1, 3\n        print '(3F8.1)', (a(i,j), j=1,3)\n    end do\n\n    print '(A)', 'Matrix B:'\n    do i = 1, 3\n        print '(3F8.1)', (b(i,j), j=1,3)\n    end do\n\n    print '(A)', 'Result C = A*B:'\n    do i = 1, 3\n        print '(3F8.1)', (c(i,j), j=1,3)\n    end do\nend program example_matmul_real\n```\n**Output:**\n```\nMatrix A:\n     2.0     3.0     4.0\n     3.0     4.0     5.0\n     4.0     5.0     6.0\nMatrix B:\n     1.0     2.0     3.0\n     2.0     4.0     6.0\n     3.0     6.0     9.0\nResult C = A*B:\n    20.0    40.0    60.0\n    26.0    52.0    78.0\n    32.0    64.0    96.0\n```\n\n### Example 5: Logical Matrix Multiplication\n```fortran\nprogram example_matmul_logical\n    implicit none\n    logical :: a(2,3), b(3,2), c(2,2)\n\n    a = reshape([.true.,.false., .false.,.true., .true.,.true.], [2,3])\n    b = reshape([.true.,.false.,.true., .false.,.true.,.false.], [3,2])\n\n    c = matmul(a, b)\n\n    print '(A)', 'Logical A:'\n    print '(3L2)', a(1,:)\n    print '(3L2)', a(2,:)\n    print '(A)', 'Logical B:'\n    print '(2L2)', b(1,:)\n    print '(2L2)', b(2,:)\n    print '(2L2)', b(3,:)\n    print '(A)', 'Logical C = A*B:'\n    print '(2L2)', c(1,:)\n    print '(2L2)', c(2,:)\n    ! c(i,j) = ANY(a(i,:) .AND. b(:,j))\nend program example_matmul_logical\n```\n**Output:**\n```\nLogical A:\n T F T\n F T T\nLogical B:\n T F\n F T\n T F\nLogical C = A*B:\n T F\n T T\n```\n\n## Standard\nFortran 90 and later\n\n## See Also\n- **dot_product** - Dot product of two vectors\n- **transpose** - Matrix transpose\n- **reshape** - Reshape an array\n- **sum** - Sum of array elements\n- **product** - Product of array elements"
}
