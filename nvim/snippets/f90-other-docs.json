{
  "associated": "## associated\n\n### **Name**\n\n**associated** - \\[POINTER:INQUIRY\\] Determine the association status of a pointer\n\n### **Synopsis**\n```fortran\n    result = associated(pointer)\n    result = associated(pointer, target)\n```\n```fortran\n     function associated(pointer, target) result(res)\n\n      type(*), pointer, intent(in) :: pointer(..)\n      type(*), intent(in), target, optional :: target(..)\n      logical :: res\n```\n\n### **Characteristics**\n\n - **pointer** must have the POINTER attribute; it can be of any type and any rank.\n - **target** is optional; if present, it must be a pointer or have the TARGET attribute.\n - **target** must have the same type, kind type parameters, and rank as **pointer**.\n - The association status of neither **pointer** nor **target** shall be undefined.\n - Returns a default logical scalar value.\n\n### **Description**\n\n **associated** determines the association status of a pointer, or tests whether\n a pointer is associated with a specific target. When called with only the\n **pointer** argument, it returns .TRUE. if the pointer is currently associated\n with any target, and .FALSE. if the pointer has been nullified or was never\n associated. When the optional **target** argument is present, it returns .TRUE.\n only if **pointer** is associated with that specific target.\n\n This intrinsic is essential for safe pointer operations in Fortran, as\n dereferencing a disassociated or undefined pointer is not allowed. It is good\n practice to nullify pointers that are not immediately associated and to test\n their status before use.\n\n### **Options**\n\n- **pointer**\n  : A pointer of any type and rank whose association status is to be queried.\n  The pointer must not have undefined association status (i.e., it should be\n  either associated with a target or explicitly nullified).\n\n- **target**\n  : (Optional) A variable with the TARGET attribute or a pointer. If present,\n  the function tests whether **pointer** is specifically associated with this\n  target. Must have the same type, kind, and rank as **pointer**.\n\n### **Result**\n\n  A default logical scalar. The result is determined as follows:\n\n  - If **target** is absent: .TRUE. if **pointer** is associated with any target,\n    .FALSE. if **pointer** is disassociated (nullified).\n\n  - If **target** is present and is not a pointer: .TRUE. if **pointer** is\n    associated with **target** and both occupy the same storage; for arrays,\n    they must have the same shape and occupy the same storage units.\n\n  - If **target** is present and is a pointer: .TRUE. if both pointers are\n    associated with the same target, or both are disassociated; .FALSE. otherwise.\n\n  - For zero-sized arrays: The result is .FALSE. because there are no storage\n    units to compare.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_associated\n  implicit none\n  real, target  :: tgt(2) = [1.0, 2.0]\n  real, target  :: other(2) = [3.0, 4.0]\n  real, pointer :: ptr(:)\n  real, pointer :: ptr2(:)\n\n  ! Initially nullify pointers for safe testing\n  nullify(ptr)\n  nullify(ptr2)\n\n  ! Test unassociated pointer\n  print '(A,L1)', 'ptr associated (before): ', associated(ptr)\n\n  ! Associate pointer with target\n  ptr => tgt\n  print '(A,L1)', 'ptr associated (after): ', associated(ptr)\n\n  ! Test association with specific target\n  print '(A,L1)', 'ptr associated with tgt: ', associated(ptr, tgt)\n  print '(A,L1)', 'ptr associated with other: ', associated(ptr, other)\n\n  ! Test two pointers to same target\n  ptr2 => tgt\n  print '(A,L1)', 'ptr associated with ptr2 target: ', associated(ptr, ptr2)\n\n  ! Point ptr2 to different target\n  ptr2 => other\n  print '(A,L1)', 'ptr associated with ptr2 (different): ', associated(ptr, ptr2)\n\n  ! Nullify and test again\n  nullify(ptr)\n  print '(A,L1)', 'ptr associated (after nullify): ', associated(ptr)\n\nend program demo_associated\n```\nResults:\n```text\nptr associated (before): F\nptr associated (after): T\nptr associated with tgt: T\nptr associated with other: F\nptr associated with ptr2 target: T\nptr associated with ptr2 (different): F\nptr associated (after nullify): F\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**null**(3)](#null),\n[**pointer**(7)](#pointer),\n[**target**(7)](#target),\n[**nullify**(7)](#nullify)",

  "logical": "## logical\n\n### **Name**\n\n**logical** - \\[TYPE:CONVERSION\\] Convert between logical kinds\n\n### **Synopsis**\n```fortran\n    result = logical(l)\n    result = logical(l, kind)\n```\n```fortran\n     elemental logical(kind=KIND) function logical(l, kind)\n\n      logical(kind=**), intent(in) :: l\n      integer, intent(in), optional :: kind\n```\n\n### **Characteristics**\n\n - **l** must be of type LOGICAL with any kind.\n - **kind** is an optional scalar integer constant expression.\n - The result is of type LOGICAL.\n - If **kind** is present, the result has that kind; otherwise, it has default logical kind.\n - This is an elemental function: it operates element-by-element on arrays.\n\n### **Description**\n\n **logical** converts a logical value from one kind to another. Different\n Fortran processors may support multiple logical kinds with different storage\n sizes (e.g., 1-byte, 2-byte, 4-byte, or 8-byte logicals). This function allows\n conversion between these representations while preserving the logical value.\n\n The function is elemental, so when applied to an array, it returns an array\n of the same shape with each element converted to the specified kind.\n\n### **Options**\n\n- **l**\n  : A logical value or array to be converted. The value (.TRUE. or .FALSE.)\n  is preserved during conversion; only the kind type parameter changes.\n\n- **kind**\n  : (Optional) A scalar integer constant expression specifying the kind type\n  parameter of the result. If omitted, the result has default logical kind.\n  The value must be a supported logical kind on the processor.\n\n### **Result**\n\n  A logical value with the same value (.TRUE. or .FALSE.) as **l**, but with\n  the kind type parameter specified by **kind** (or default logical kind if\n  **kind** is absent). For array arguments, the result is an array of the\n  same shape with each element converted.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_logical\n  use iso_fortran_env, only: logical_kinds\n  implicit none\n  logical :: default_log\n  logical(kind=1) :: byte_log\n  logical(kind=4) :: word_log\n  logical :: array_log(3)\n  logical(kind=1) :: array_byte(3)\n\n  ! Show available logical kinds\n  print '(A,*(I0,:,\", \"))', 'Available logical kinds: ', logical_kinds\n\n  ! Simple conversions\n  default_log = .true.\n  byte_log = logical(default_log, kind=1)\n  word_log = logical(byte_log, kind=4)\n\n  print '(A,L1)', 'default_log: ', default_log\n  print '(A,L1)', 'byte_log: ', byte_log\n  print '(A,L1)', 'word_log: ', word_log\n\n  ! Verify values are preserved\n  print '(A,L1)', 'All equal: ', (default_log .eqv. byte_log) .and. &\n                                 (byte_log .eqv. word_log)\n\n  ! Array conversion\n  array_log = [.true., .false., .true.]\n  array_byte = logical(array_log, kind=1)\n  print '(A,3L2)', 'array_log: ', array_log\n  print '(A,3L2)', 'array_byte: ', array_byte\n\n  ! Converting back to default kind\n  default_log = logical(byte_log)\n  print '(A,L1)', 'Converted back: ', default_log\n\nend program demo_logical\n```\nResults:\n```text\nAvailable logical kinds: 1, 2, 4, 8, 16\ndefault_log: T\nbyte_log: T\nword_log: T\nAll equal: T\narray_log:  T F T\narray_byte:  T F T\nConverted back: T\n```\n\n### **Standard**\n\nFortran 90\n\n**Note:** The KIND argument was present from Fortran 90. The available\nlogical kinds are processor-dependent; common values include 1, 2, 4, and 8.\n\n### **See Also**\n\n[**int**(3)](#int),\n[**real**(3)](#real),\n[**cmplx**(3)](#cmplx),\n[**kind**(3)](#kind)",

  "present": "## present\n\n### **Name**\n\n**present** - \\[PROCEDURE:ARGUMENT\\] Determine whether an optional dummy argument is present\n\n### **Synopsis**\n```fortran\n    result = present(a)\n```\n```fortran\n     function present(a) result(res)\n\n      type(*), intent(in), optional :: a\n      logical                       :: res\n```\n\n### **Characteristics**\n\n - **a** must be an optional dummy argument in the current procedure.\n - Returns .TRUE. if the argument was provided by the caller.\n - Returns .FALSE. if the argument was omitted.\n - Must be called before referencing the optional argument.\n - This is an inquiry function.\n\n### **Description**\n\n **present** determines whether an optional dummy argument was provided by\n the caller. This intrinsic must be used to check the presence of optional\n arguments before they can be safely referenced, as using an absent optional\n argument is not allowed and results in undefined behavior.\n\n An important feature is that an absent optional argument can be passed to\n another procedure that also declares it as optional, without first checking\n with PRESENT. The \"absent-ness\" is propagated to the called procedure.\n\n### **Options**\n\n- **a**\n  : An optional dummy argument of the current procedure. May be of any type,\n  any rank, and may have any other attributes such as POINTER, ALLOCATABLE,\n  or TARGET. The argument **a** must be declared with the OPTIONAL attribute\n  in the procedure where PRESENT is called.\n\n### **Result**\n\n  A default logical value: .TRUE. if the actual argument corresponding to\n  **a** was provided in the procedure call, .FALSE. if the argument was\n  omitted. The result is always a scalar, even if **a** is an array.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_present\n  implicit none\n\n  ! Call with different argument combinations\n  call example_sub(10)\n  print '(A)', '---'\n  call example_sub(10, 20)\n  print '(A)', '---'\n  call example_sub(10, c=30)\n  print '(A)', '---'\n  call example_sub(10, 20, 30)\n\ncontains\n\n  subroutine example_sub(a, b, c)\n    integer, intent(in) :: a\n    integer, intent(in), optional :: b, c\n\n    print '(A,I0)', 'a = ', a\n    print '(A,L1)', 'b is present: ', present(b)\n    print '(A,L1)', 'c is present: ', present(c)\n\n    ! Safe to use b only if present\n    if (present(b)) then\n      print '(A,I0)', 'b = ', b\n    else\n      print '(A)', 'b was not provided'\n    end if\n\n    ! Safe to use c only if present\n    if (present(c)) then\n      print '(A,I0)', 'c = ', c\n    else\n      print '(A)', 'c was not provided'\n    end if\n\n    ! Compute sum based on what is present\n    if (present(b) .and. present(c)) then\n      print '(A,I0)', 'a + b + c = ', a + b + c\n    else if (present(b)) then\n      print '(A,I0)', 'a + b = ', a + b\n    else if (present(c)) then\n      print '(A,I0)', 'a + c = ', a + c\n    else\n      print '(A,I0)', 'Just a = ', a\n    end if\n\n  end subroutine example_sub\n\nend program demo_present\n```\nResults:\n```text\na = 10\nb is present: F\nc is present: F\nb was not provided\nc was not provided\nJust a = 10\n---\na = 10\nb is present: T\nc is present: F\nb = 20\nc was not provided\na + b = 30\n---\na = 10\nb is present: F\nc is present: T\nb was not provided\nc = 30\na + c = 40\n---\na = 10\nb is present: T\nc is present: T\nb = 20\nc = 30\na + b + c = 60\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**optional**(7)](#optional),\n[**intent**(7)](#intent)",

  "transfer": "## transfer\n\n### **Name**\n\n**transfer** - \\[TYPE:CONVERSION\\] Interpret bit pattern of source as a different type\n\n### **Synopsis**\n```fortran\n    result = transfer(source, mold)\n    result = transfer(source, mold, size)\n```\n```fortran\n     function transfer(source, mold, size) result(res)\n\n      type(SOURCE_TYPE), intent(in) :: source(..)\n      type(MOLD_TYPE), intent(in)   :: mold(..)\n      integer, intent(in), optional :: size\n      type(MOLD_TYPE)               :: res(..)\n```\n\n### **Characteristics**\n\n - **source** can be of any type; it may be a scalar or array.\n - **mold** can be of any type; it may be a scalar or array.\n - **size** is an optional scalar integer.\n - The result has the same type and kind as **mold**.\n - If **mold** is scalar and **size** is absent, the result is scalar.\n - If **mold** is an array or **size** is present, the result is a rank-1 array.\n - This is a transformational function.\n\n### **Description**\n\n **transfer** reinterprets the bit pattern of **source** as if it were the\n physical representation of a value of the type and kind of **mold**. This is\n not a type conversion in the mathematical sense; it is a bitwise reinterpretation\n similar to type punning or casting in C.\n\n The function copies the bits from **source** and interprets them according\n to the type of **mold**. This is useful for low-level operations such as:\n - Converting between integer and floating-point representations\n - Implementing C-like void pointer functionality\n - Serializing/deserializing data structures\n - Accessing the bit pattern of floating-point numbers\n\n **Warning:** When the resulting bit representation does not correspond to a\n valid value of the mold type, subsequent operations may produce undefined\n behavior. For example, transferring arbitrary integers to reals may produce\n NaN or other special values.\n\n### **Options**\n\n- **source**\n  : The data whose bit pattern is to be reinterpreted. May be of any type,\n  scalar or array. The total storage size of **source** provides the bits\n  to be transferred.\n\n- **mold**\n  : Determines the type, kind, and (for arrays) the element size of the result.\n  The actual value of **mold** is not used; only its type characteristics matter.\n  For scalar **mold** without **size**, the result is scalar. For array **mold**,\n  or when **size** is present, the result is a rank-1 array.\n\n- **size**\n  : (Optional) A scalar integer specifying the number of elements in the result\n  array. If present, the result is always a rank-1 array of this length,\n  regardless of whether **mold** is scalar or array.\n\n### **Result**\n\n  The result has the type and kind of **mold**, with its bit pattern derived\n  from **source**:\n\n  - If **size** is absent and **mold** is scalar: The result is a scalar\n    containing the first bits of **source** interpreted as the mold type.\n\n  - If **size** is absent and **mold** is an array: The result is a rank-1\n    array with enough elements to hold all bits of **source**.\n\n  - If **size** is present: The result is a rank-1 array with exactly **size**\n    elements.\n\n  If **source** has fewer bits than required by the result, the extra bits\n  are undefined. If **source** has more bits than needed, the excess is ignored.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_transfer\n  implicit none\n  integer :: i\n  real :: x\n  character(len=4) :: chars\n  integer(kind=1) :: bytes(4)\n  real(kind=8) :: dbl\n  integer(kind=8) :: long_int\n\n  ! View bit pattern of an integer as a real\n  i = 1065353216  ! This is the IEEE representation of 1.0\n  x = transfer(i, x)\n  print '(A,I0,A,F10.6)', 'Integer ', i, ' as real: ', x\n\n  ! View bit pattern of a real as an integer\n  x = 1.0\n  i = transfer(x, i)\n  print '(A,F4.1,A,I0)', 'Real ', x, ' as integer: ', i\n\n  ! Convert real to bytes (for I/O or network transmission)\n  x = 3.14159\n  bytes = transfer(x, bytes)\n  print '(A,4(Z2.2,1X))', 'Real as bytes (hex): ', bytes\n\n  ! Convert back from bytes\n  x = transfer(bytes, x)\n  print '(A,F10.5)', 'Bytes back to real: ', x\n\n  ! String to integer conversion (platform-dependent)\n  chars = 'ABCD'\n  i = transfer(chars, i)\n  print '(A,A,A,I0)', 'String \"', chars, '\" as integer: ', i\n\n  ! Using SIZE argument to get an array of specific length\n  dbl = 3.141592653589793d0\n  bytes = transfer(dbl, bytes, size=4)\n  print '(A,4(Z2.2,1X))', 'First 4 bytes of double: ', bytes\n\n  ! View double precision as long integer\n  dbl = 1.0d0\n  long_int = transfer(dbl, long_int)\n  print '(A,F4.1,A,I0)', 'Double ', dbl, ' as int64: ', long_int\n\nend program demo_transfer\n```\nResults (may vary by platform):\n```text\nInteger 1065353216 as real:   1.000000\nReal  1.0 as integer: 1065353216\nReal as bytes (hex): D0 0F 49 40\nBytes back to real:    3.14159\nString \"ABCD\" as integer: 1145258561\nFirst 4 bytes of double: 18 2D 44 54\nDouble  1.0 as int64: 4607182418800017408\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**reshape**(3)](#reshape),\n[**pack**(3)](#pack),\n[**unpack**(3)](#unpack),\n[**c_loc**(3)](#c_loc),\n[**c_f_pointer**(3)](#c_f_pointer)"
}
