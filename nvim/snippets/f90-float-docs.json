{
  "exponent": "## exponent\n\n### **Name**\n\n**exponent** - \\[NUMERIC:MANIPULATION\\] Extract the exponent part of a floating-point number\n\n### **Synopsis**\n```fortran\n    result = exponent(x)\n```\n```fortran\n     elemental function exponent(x) result(i)\n       real(kind=**), intent(in) :: x\n       integer                   :: i\n```\n\n### **Characteristics**\n\n - **x** must be of type REAL, of any kind.\n - The result is a default INTEGER.\n - This is an elemental function, operating element-wise on arrays.\n\n### **Description**\n\n**exponent(x)** extracts the exponent component from the floating-point representation of **x** according to the Fortran numeric model:\n\n    x = fraction(x) * radix(x)**exponent(x)\n\nwhere **fraction(x)** is the fractional part (mantissa) satisfying 0.5 <= |fraction(x)| < 1.0 for normalized numbers, and **radix(x)** is the base of the floating-point system (typically 2 for IEEE binary floating-point).\n\nFor IEEE 754 floating-point numbers, **exponent** returns the unbiased exponent. The function is useful for analyzing the magnitude and representation of floating-point values, implementing numerical algorithms that need to manipulate the exponent directly, and understanding floating-point precision characteristics.\n\n### **Options**\n\n - **x**\n   : A real number of any kind. The value whose exponent part is to be extracted.\n\n### **Result**\n\nThe result is a default integer representing the exponent of **x** in the model representation.\n\n - If **x** is zero, the result is zero.\n - If **x** is an IEEE infinity, the result is a large positive integer (implementation-dependent).\n - If **x** is an IEEE NaN, the result is unspecified.\n - For normalized numbers, the exponent e satisfies: radix(x)**(e-1) <= |x| < radix(x)**e\n\n### **Examples**\n\n```fortran\nprogram demo_exponent\n  implicit none\n  real :: x\n  real(kind=selected_real_kind(15)) :: dx\n  integer :: i\n\n  ! Basic usage\n  x = 1.0\n  print '(A,G0,A,I0)', 'exponent(', x, ') = ', exponent(x)\n\n  x = 8.0\n  print '(A,G0,A,I0)', 'exponent(', x, ') = ', exponent(x)\n\n  ! Powers of 2\n  do i = -3, 3\n    x = 2.0**i\n    print '(A,G0,A,I0)', 'exponent(', x, ') = ', exponent(x)\n  end do\n\n  ! Verify the model: x = fraction(x) * radix(x)**exponent(x)\n  x = 178.1387e-4\n  print *\n  print '(A,ES15.8)', 'x                              = ', x\n  print '(A,F15.8)',  'fraction(x)                    = ', fraction(x)\n  print '(A,I0)',     'exponent(x)                    = ', exponent(x)\n  print '(A,I0)',     'radix(x)                       = ', radix(x)\n  print '(A,ES15.8)', 'fraction(x) * radix(x)**exp(x) = ', &\n        fraction(x) * real(radix(x))**exponent(x)\n\n  ! Special cases\n  print *\n  print '(A,I0)', 'exponent(0.0) = ', exponent(0.0)\n\n  ! Double precision\n  dx = 1.0d0\n  print '(A,I0)', 'exponent(1.0d0) = ', exponent(dx)\n\nend program demo_exponent\n```\n\n**Results:**\n```text\nexponent(1.0) = 1\nexponent(8.0) = 4\nexponent(.125) = -2\nexponent(.25) = -1\nexponent(.5) = 0\nexponent(1.0) = 1\nexponent(2.0) = 2\nexponent(4.0) = 3\nexponent(8.0) = 4\n\nx                              =   1.78138707E-02\nfraction(x)                    =      0.91207018\nexponent(x)                    = -5\nradix(x)                       = 2\nfraction(x) * radix(x)**exp(x) =   1.78138707E-02\n\nexponent(0.0) = 0\nexponent(1.0d0) = 1\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n - [**fraction**](#fraction) - Extract fractional part of floating-point model\n - [**set_exponent**](#set_exponent) - Construct number with given exponent\n - [**scale**](#scale) - Scale by power of radix\n - [**radix**](#radix) - Base of the numeric model\n - [**digits**](#digits) - Number of significant digits\n - [**spacing**](#spacing) - Absolute spacing of model numbers",

  "fraction": "## fraction\n\n### **Name**\n\n**fraction** - \\[NUMERIC:MANIPULATION\\] Extract the fractional part of the floating-point model representation\n\n### **Synopsis**\n```fortran\n    result = fraction(x)\n```\n```fortran\n     elemental function fraction(x) result(frac)\n       real(kind=**), intent(in) :: x\n       real(kind=**)             :: frac\n```\n\n### **Characteristics**\n\n - **x** must be of type REAL, of any kind.\n - The result is REAL with the same kind as **x**.\n - This is an elemental function, operating element-wise on arrays.\n\n### **Description**\n\n**fraction(x)** returns the fractional part (also called mantissa or significand) of the floating-point representation of **x** according to the Fortran numeric model:\n\n    x = fraction(x) * radix(x)**exponent(x)\n\nThe fractional part satisfies:\n - 0.5 <= |fraction(x)| < 1.0 for normalized nonzero numbers\n - fraction(0.0) = 0.0\n\nThis is computed as:\n\n    fraction(x) = x * radix(x)**(-exponent(x))\n\nThe function is essential for algorithms that need to separate the magnitude (exponent) from the precision bits (fraction) of a floating-point number, such as in normalization, range reduction, and precision analysis.\n\n### **Options**\n\n - **x**\n   : A real number of any kind. The value whose fractional part is to be extracted.\n\n### **Result**\n\nThe fractional part of the model representation of **x**, having the same type and kind as **x**.\n\n - If **x** is zero, the result is zero.\n - If **x** is an IEEE infinity, the result is an IEEE NaN.\n - For normalized numbers, 0.5 <= |result| < 1.0\n - The sign of the result matches the sign of **x**.\n\n### **Examples**\n\n```fortran\nprogram demo_fraction\n  implicit none\n  real :: x, frac\n  real(kind=selected_real_kind(15)) :: dx\n  integer :: i\n\n  ! Basic usage\n  x = 178.1387e-4\n  frac = fraction(x)\n  print '(A,ES15.8)', 'x         = ', x\n  print '(A,F15.8)',  'fraction  = ', frac\n\n  ! Verify the relationship\n  print '(A,ES15.8)', 'Reconstructed = ', frac * real(radix(x))**exponent(x)\n\n  ! The fraction is always between 0.5 and 1.0 (for nonzero)\n  print *\n  print '(A)', 'Demonstrating fraction range:'\n  do i = -3, 3\n    x = 2.0**i\n    print '(A,G10.3,A,F10.6)', 'fraction(', x, ') = ', fraction(x)\n  end do\n\n  ! Negative numbers preserve sign\n  print *\n  x = -3.5\n  print '(A,G0,A,F10.6)', 'fraction(', x, ') = ', fraction(x)\n\n  ! Zero case\n  print '(A,F10.6)', 'fraction(0.0) = ', fraction(0.0)\n\n  ! Double precision example\n  dx = 123.456789012345d0\n  print *\n  print '(A,ES25.16)', 'dx                = ', dx\n  print '(A,F25.16)',  'fraction(dx)      = ', fraction(dx)\n  print '(A,I0)',      'exponent(dx)      = ', exponent(dx)\n\nend program demo_fraction\n```\n\n**Results:**\n```text\nx         =   1.78138707E-02\nfraction  =      0.91207018\nReconstructed =   1.78138707E-02\n\nDemonstrating fraction range:\nfraction(     0.125) =   0.500000\nfraction(     0.250) =   0.500000\nfraction(     0.500) =   0.500000\nfraction(      1.00) =   0.500000\nfraction(      2.00) =   0.500000\nfraction(      4.00) =   0.500000\nfraction(      8.00) =   0.500000\n\nfraction(-3.5) =  -0.875000\nfraction(0.0) =   0.000000\n\ndx                =  1.2345678901234500E+02\nfraction(dx)      =  0.9645061641589453\nexponent(dx)      = 7\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n - [**exponent**](#exponent) - Extract exponent part of floating-point model\n - [**set_exponent**](#set_exponent) - Construct number with given exponent\n - [**scale**](#scale) - Scale by power of radix\n - [**radix**](#radix) - Base of the numeric model\n - [**nearest**](#nearest) - Nearest representable number",

  "nearest": "## nearest\n\n### **Name**\n\n**nearest** - \\[NUMERIC:MANIPULATION\\] Return the nearest representable floating-point number in a specified direction\n\n### **Synopsis**\n```fortran\n    result = nearest(x, s)\n```\n```fortran\n     elemental function nearest(x, s) result(neighbor)\n       real(kind=**), intent(in) :: x\n       real(kind=**), intent(in) :: s\n       real(kind=**)             :: neighbor\n```\n\n### **Characteristics**\n\n - **x** must be of type REAL, of any kind.\n - **s** must be of type REAL (any kind) and must not be zero.\n - The result is REAL with the same kind as **x**.\n - This is an elemental function, operating element-wise on arrays.\n\n### **Description**\n\n**nearest(x, s)** returns the processor-representable floating-point number nearest to **x** in the direction indicated by the sign of **s**:\n\n - If **s** > 0, returns the smallest representable number greater than **x**\n - If **s** < 0, returns the largest representable number less than **x**\n\nThis function is essential for understanding and working with floating-point precision. It reveals the discrete nature of floating-point representation and is useful for:\n\n - Implementing robust numerical comparisons\n - Understanding machine epsilon and spacing\n - Creating test cases that probe floating-point boundaries\n - Implementing interval arithmetic\n\nThe difference between **x** and **nearest(x, s)** equals **spacing(x)** for most values.\n\n### **Options**\n\n - **x**\n   : A real number of any kind. The reference value from which to find the nearest neighbor.\n\n - **s**\n   : A real number that indicates the direction. Only the sign matters:\n   - s > 0: search in the positive direction (toward +infinity)\n   - s < 0: search in the negative direction (toward -infinity)\n   - s must not be zero (undefined behavior)\n\n### **Result**\n\nThe nearest distinct representable floating-point number to **x** in the direction of **s**, having the same type and kind as **x**.\n\n - If **x** is the largest finite number and s > 0, the result may be +infinity.\n - If **x** is the smallest finite number and s < 0, the result may be -infinity.\n - The spacing between **x** and the result is the unit in the last place (ULP) for **x**.\n\n### **Examples**\n\n```fortran\nprogram demo_nearest\n  implicit none\n  real :: x, up, down, diff\n  real(kind=selected_real_kind(15)) :: dx, dup, ddown\n  integer :: i\n\n  ! Basic usage: find neighbors of 42.0\n  x = 42.0\n  up = nearest(x, 1.0)     ! Next larger\n  down = nearest(x, -1.0)  ! Next smaller\n\n  print '(A)', 'Nearest neighbors of 42.0:'\n  print '(A,G20.14)', '  x      = ', x\n  print '(A,G20.14)', '  up     = ', up\n  print '(A,G20.14)', '  down   = ', down\n  print '(A,G20.14)', '  up - x = ', up - x\n  print '(A,G20.14)', '  x - down = ', x - down\n\n  ! Relationship with spacing\n  print *\n  print '(A,G20.14)', 'spacing(42.0) = ', spacing(x)\n\n  ! The spacing varies with magnitude\n  print *\n  print '(A)', 'Spacing at different magnitudes:'\n  do i = -2, 6\n    x = 10.0**i\n    diff = nearest(x, 1.0) - x\n    print '(A,G12.5,A,G12.5)', '  x=', x, '  spacing=', diff\n  end do\n\n  ! Double precision has much finer spacing\n  print *\n  dx = 1.0d0\n  dup = nearest(dx, 1.0d0)\n  ddown = nearest(dx, -1.0d0)\n  print '(A)', 'Double precision neighbors of 1.0:'\n  print '(A,G25.17)', '  dx        = ', dx\n  print '(A,G25.17)', '  dup       = ', dup\n  print '(A,G25.17)', '  dup - dx  = ', dup - dx\n\n  ! Practical use: robust comparison\n  print *\n  x = 1.0\n  print '(A,L1)', 'Is 1.0 + tiny less than nearest(1.0, 1.0)? ', &\n        (x + tiny(x)) < nearest(x, 1.0)\n\nend program demo_nearest\n```\n\n**Results:**\n```text\nNearest neighbors of 42.0:\n  x      =    42.000000000000\n  up     =    42.000003814697\n  down   =    41.999996185303\n  up - x =   3.8146972656250E-06\n  x - down =   3.8146972656250E-06\n\nspacing(42.0) =   3.8146972656250E-06\n\nSpacing at different magnitudes:\n  x=  0.10000E-01  spacing=  9.3132E-10\n  x=  0.10000      spacing=  7.4506E-09\n  x=   1.0000      spacing=  1.1921E-07\n  x=   10.000      spacing=  9.5367E-07\n  x=   100.00      spacing=  7.6294E-06\n  x=   1000.0      spacing=  6.1035E-05\n  x=   10000.      spacing=  9.7656E-04\n  x=  0.10000E+06  spacing=  7.8125E-03\n  x=  0.10000E+07  spacing=  6.2500E-02\n\nDouble precision neighbors of 1.0:\n  dx        =   1.0000000000000000\n  dup       =   1.0000000000000002\n  dup - dx  =  2.2204460492503131E-16\n\nIs 1.0 + tiny less than nearest(1.0, 1.0)? T\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n - [**spacing**](#spacing) - Absolute spacing of model numbers\n - [**rrspacing**](#rrspacing) - Reciprocal of relative spacing\n - [**epsilon**](#epsilon) - Machine epsilon\n - [**tiny**](#tiny) - Smallest positive number\n - [**huge**](#huge) - Largest representable number",

  "rrspacing": "## rrspacing\n\n### **Name**\n\n**rrspacing** - \\[NUMERIC:MANIPULATION\\] Return the reciprocal of relative spacing of model numbers near the argument\n\n### **Synopsis**\n```fortran\n    result = rrspacing(x)\n```\n```fortran\n     elemental function rrspacing(x) result(rrs)\n       real(kind=**), intent(in) :: x\n       real(kind=**)             :: rrs\n```\n\n### **Characteristics**\n\n - **x** must be of type REAL, of any kind.\n - The result is REAL with the same kind as **x**.\n - This is an elemental function, operating element-wise on arrays.\n\n### **Description**\n\n**rrspacing(x)** returns the reciprocal of the relative spacing of model numbers near **x**. It is computed as:\n\n    rrspacing(x) = |fraction(x)| * radix(x)**digits(x)\n\nThis value represents how many distinct floating-point numbers exist between 0 and |x| when measured in units of the smallest representable increment at the magnitude of x.\n\nThe relative spacing at **x** is:\n\n    relative_spacing = spacing(x) / |x| = radix(x)**(1-digits(x))\n\nThus **rrspacing** is the reciprocal of this relative spacing, which is independent of the magnitude of **x** for normalized numbers.\n\n**rrspacing** is useful for:\n - Analyzing floating-point precision characteristics\n - Understanding the relative precision available at a given magnitude\n - Implementing algorithms that need to account for relative precision\n - Computing the number of significant bits in a floating-point value\n\n### **Options**\n\n - **x**\n   : A real number of any kind. The value at which to compute the reciprocal of relative spacing.\n\n### **Result**\n\nThe reciprocal of the relative spacing of model numbers near **x**, having the same type and kind as **x**.\n\n - For normalized numbers, this equals |fraction(x)| * radix(x)**digits(x)\n - If **x** is zero, the result is zero.\n - The result is always non-negative.\n - For normalized numbers, 0.5 * radix(x)**digits(x) <= rrspacing(x) < radix(x)**digits(x)\n\n### **Examples**\n\n```fortran\nprogram demo_rrspacing\n  implicit none\n  real :: x, rrs\n  real(kind=selected_real_kind(15)) :: dx\n  integer :: i\n\n  ! Basic usage\n  x = 178.1387e-4\n  rrs = rrspacing(x)\n\n  print '(A,ES15.8)', 'x          = ', x\n  print '(A,ES15.8)', 'rrspacing  = ', rrs\n\n  ! Verify the formula: |fraction(x)| * radix(x)**digits(x)\n  print '(A,ES15.8)', 'Computed   = ', &\n        abs(fraction(x)) * real(radix(x))**digits(x)\n\n  ! rrspacing is nearly constant for normalized numbers\n  print *\n  print '(A)', 'rrspacing at different magnitudes (single precision):'\n  do i = -10, 10, 5\n    x = 2.0**i\n    print '(A,G12.5,A,ES15.8)', '  x=', x, '  rrspacing=', rrspacing(x)\n  end do\n\n  ! For powers of radix, fraction is exactly 0.5\n  print *\n  print '(A)', 'For powers of 2, rrspacing = 0.5 * 2**24 (single):'\n  x = 1.0\n  print '(A,ES15.8)', 'rrspacing(1.0)    = ', rrspacing(x)\n  print '(A,ES15.8)', '0.5 * 2**24       = ', 0.5 * 2.0**24\n\n  ! Relationship between spacing and rrspacing\n  print *\n  x = 100.0\n  print '(A,G0)',     'x                        = ', x\n  print '(A,ES15.8)', 'spacing(x)               = ', spacing(x)\n  print '(A,ES15.8)', 'rrspacing(x)             = ', rrspacing(x)\n  print '(A,ES15.8)', 'spacing * rrspacing / x  = ', &\n        spacing(x) * rrspacing(x) / abs(x)\n\n  ! Double precision has more digits\n  print *\n  dx = 1.0d0\n  print '(A,I0)',     'digits(double) = ', digits(dx)\n  print '(A,ES25.16)', 'rrspacing(1.0d0) = ', rrspacing(dx)\n  print '(A,ES25.16)', '0.5 * 2**53      = ', 0.5d0 * 2.0d0**53\n\nend program demo_rrspacing\n```\n\n**Results:**\n```text\nx          =   1.78138707E-02\nrrspacing  =   7.65581568E+06\nComputed   =   7.65581568E+06\n\nrrspacing at different magnitudes (single precision):\n  x=  9.7656E-04  rrspacing=  8.00000000E+06\n  x= 0.31250E-01  rrspacing=  8.38860800E+06\n  x=   1.0000     rrspacing=  8.38860800E+06\n  x=   32.000     rrspacing=  8.38860800E+06\n  x=   1024.0     rrspacing=  8.38860800E+06\n\nFor powers of 2, rrspacing = 0.5 * 2**24 (single):\nrrspacing(1.0)    =   8.38860800E+06\n0.5 * 2**24       =   8.38860800E+06\n\nx                        = 100.0\nspacing(x)               =   7.62939453E-06\nrrspacing(x)             =   1.31072000E+07\nspacing * rrspacing / x  =   1.00000000E+00\n\ndigits(double) = 53\nrrspacing(1.0d0) =  4.5035996273704960E+15\n0.5 * 2**53      =  4.5035996273704960E+15\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n - [**spacing**](#spacing) - Absolute spacing of model numbers\n - [**nearest**](#nearest) - Nearest representable number\n - [**fraction**](#fraction) - Extract fractional part\n - [**digits**](#digits) - Number of significant digits\n - [**radix**](#radix) - Base of the numeric model\n - [**epsilon**](#epsilon) - Machine epsilon",

  "scale": "## scale\n\n### **Name**\n\n**scale** - \\[NUMERIC:MANIPULATION\\] Scale a real value by a power of the radix\n\n### **Synopsis**\n```fortran\n    result = scale(x, i)\n```\n```fortran\n     elemental function scale(x, i) result(scaled)\n       real(kind=**), intent(in)    :: x\n       integer(kind=**), intent(in) :: i\n       real(kind=**)                :: scaled\n```\n\n### **Characteristics**\n\n - **x** must be of type REAL, of any kind.\n - **i** must be of type INTEGER, of any kind.\n - The result is REAL with the same kind as **x**.\n - This is an elemental function, operating element-wise on arrays.\n\n### **Description**\n\n**scale(x, i)** multiplies **x** by the radix of **x** raised to power **i**:\n\n    scale(x, i) = x * radix(x)**i\n\nSince the radix is almost always 2 on modern systems (IEEE binary floating-point), this is typically equivalent to:\n\n    scale(x, i) = x * 2**i\n\n**scale** performs this operation efficiently by directly adjusting the exponent of **x** rather than computing an actual multiplication. This makes it:\n\n - Faster than explicit multiplication by powers of 2\n - Exact (no rounding error) for valid results\n - Useful for implementing fast multiplication/division by powers of 2\n - Essential for scaling operations in numerical algorithms\n\nCare must be taken that the result remains within the representable range; if i is too large or too small, overflow or underflow may occur.\n\n### **Options**\n\n - **x**\n   : A real number of any kind. The value to be scaled.\n\n - **i**\n   : An integer of any kind. The power of the radix by which to scale **x**.\n   - Positive **i** increases the magnitude (multiplies by radix**i)\n   - Negative **i** decreases the magnitude (divides by radix**|i|)\n   - **i** = 0 returns **x** unchanged\n\n### **Result**\n\nThe value x * radix(x)**i, having the same type and kind as **x**.\n\n - If the result would overflow, it may return infinity or raise an exception.\n - If the result would underflow, it may return zero or a denormalized number.\n - The operation preserves the fraction (mantissa) of **x**.\n - scale(x, i) is equivalent to set_exponent(x, exponent(x) + i).\n\n### **Examples**\n\n```fortran\nprogram demo_scale\n  implicit none\n  real :: x, scaled\n  real(kind=selected_real_kind(15)) :: dx\n  integer :: i\n\n  ! Basic usage\n  x = 178.1387e-4\n  i = 5\n\n  scaled = scale(x, i)\n  print '(A,ES15.8)', 'x                  = ', x\n  print '(A,I0)',     'i                  = ', i\n  print '(A,ES15.8)', 'scale(x, i)        = ', scaled\n  print '(A,ES15.8)', 'x * radix(x)**i    = ', x * real(radix(x))**i\n  print '(A,ES15.8)', 'x * 2**i           = ', x * 2.0**i\n\n  ! Scale is equivalent to adjusting exponent\n  print *\n  print '(A,I0)',     'exponent(x)        = ', exponent(x)\n  print '(A,I0)',     'exponent(scale)    = ', exponent(scaled)\n  print '(A,ES15.8)', 'fraction unchanged = ', fraction(scaled)\n  print '(A,ES15.8)', 'fraction(x)        = ', fraction(x)\n\n  ! Practical use: fast multiply/divide by powers of 2\n  print *\n  print '(A)', 'Fast scaling operations:'\n  x = 100.0\n  print '(A,G0)',     'x            = ', x\n  print '(A,G0)',     'x * 2        = ', scale(x, 1)   ! Double\n  print '(A,G0)',     'x / 2        = ', scale(x, -1)  ! Halve\n  print '(A,G0)',     'x * 8        = ', scale(x, 3)   ! Multiply by 8\n  print '(A,G0)',     'x / 16       = ', scale(x, -4)  ! Divide by 16\n\n  ! Scaling preserves full precision\n  print *\n  dx = 1.234567890123456d0\n  print '(A,G25.16)', 'dx                 = ', dx\n  print '(A,G25.16)', 'scale(dx, 10)      = ', scale(dx, 10)\n  print '(A,G25.16)', 'scale back         = ', scale(scale(dx, 10), -10)\n\n  ! Demonstrate exponent limits\n  print *\n  x = 1.0\n  print '(A,I0)', 'maxexponent(x) = ', maxexponent(x)\n  print '(A,I0)', 'minexponent(x) = ', minexponent(x)\n\nend program demo_scale\n```\n\n**Results:**\n```text\nx                  =   1.78138707E-02\ni                  = 5\nscale(x, i)        =   5.70043862E-01\nx * radix(x)**i    =   5.70043862E-01\nx * 2**i           =   5.70043862E-01\n\nexponent(x)        = -5\nexponent(scale)    = 0\nfraction unchanged =   9.12070155E-01\nfraction(x)        =   9.12070155E-01\n\nFast scaling operations:\nx            = 100.0\nx * 2        = 200.0\nx / 2        = 50.0\nx * 8        = 800.0\nx / 16       = 6.25\n\ndx                 =  1.234567890123456\nscale(dx, 10)      =  1264.197295486419\nscale back         =  1.234567890123456\n\nmaxexponent(x) = 128\nminexponent(x) = -125\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n - [**set_exponent**](#set_exponent) - Set the exponent of a number\n - [**exponent**](#exponent) - Extract exponent part\n - [**fraction**](#fraction) - Extract fractional part\n - [**radix**](#radix) - Base of the numeric model\n - [**maxexponent**](#maxexponent) - Maximum exponent\n - [**minexponent**](#minexponent) - Minimum exponent",

  "set_exponent": "## set_exponent\n\n### **Name**\n\n**set_exponent** - \\[NUMERIC:MANIPULATION\\] Construct a floating-point number with given fractional part and exponent\n\n### **Synopsis**\n```fortran\n    result = set_exponent(x, i)\n```\n```fortran\n     elemental function set_exponent(x, i) result(y)\n       real(kind=**), intent(in)    :: x\n       integer(kind=**), intent(in) :: i\n       real(kind=**)                :: y\n```\n\n### **Characteristics**\n\n - **x** must be of type REAL, of any kind.\n - **i** must be of type INTEGER, of any kind.\n - The result is REAL with the same kind as **x**.\n - This is an elemental function, operating element-wise on arrays.\n\n### **Description**\n\n**set_exponent(x, i)** returns a real number with the fractional part of **x** and an exponent of **i**. The result is computed as:\n\n    set_exponent(x, i) = fraction(x) * radix(x)**i\n\nThis function allows direct manipulation of the exponent while preserving the significand (fractional part). It is the inverse operation to extracting the exponent: if you extract the fraction with **fraction(x)** and the exponent with **exponent(x)**, you can reconstruct **x** using **set_exponent**.\n\n**set_exponent** is useful for:\n - Normalizing numbers to a specific exponent range\n - Constructing test values with specific characteristics\n - Implementing algorithms that manipulate floating-point representations\n - Rescaling values while preserving precision\n\n### **Options**\n\n - **x**\n   : A real number of any kind. Provides the fractional part (mantissa) for the result.\n\n - **i**\n   : An integer of any kind. The desired exponent for the result.\n   - Should be within [minexponent(x), maxexponent(x)] for normalized results\n   - Values outside this range may cause overflow, underflow, or denormalized results\n\n### **Result**\n\nA real number with the same type and kind as **x**, having the fractional part of **x** and exponent **i**.\n\n - result = fraction(x) * radix(x)**i\n - If **x** is zero, the result is zero (regardless of **i**).\n - If **i** is greater than maxexponent(x), overflow may occur.\n - If **i** is less than minexponent(x), underflow may occur.\n - The sign of the result matches the sign of **x**.\n\n### **Examples**\n\n```fortran\nprogram demo_set_exponent\n  implicit none\n  real :: x, y\n  real(kind=selected_real_kind(15)) :: dx, dy\n  integer :: i, exp_x\n\n  ! Basic usage\n  x = 178.1387e-4\n  i = 17\n\n  y = set_exponent(x, i)\n  print '(A,ES15.8)', 'x                        = ', x\n  print '(A,I0)',     'i (new exponent)         = ', i\n  print '(A,ES15.8)', 'set_exponent(x, i)       = ', y\n  print '(A,ES15.8)', 'fraction(x) * radix**i   = ', &\n        fraction(x) * real(radix(x))**i\n\n  ! Verify: the fraction is preserved\n  print *\n  print '(A,F15.8)', 'fraction(x)              = ', fraction(x)\n  print '(A,F15.8)', 'fraction(result)         = ', fraction(y)\n  print '(A,I0)',    'exponent(result)         = ', exponent(y)\n\n  ! Relationship with scale\n  print *\n  print '(A)', 'Relationship with scale:'\n  exp_x = exponent(x)\n  print '(A,ES15.8)', 'set_exponent(x, 10)      = ', set_exponent(x, 10)\n  print '(A,ES15.8)', 'scale(x, 10 - exp(x))    = ', scale(x, 10 - exp_x)\n\n  ! Practical use: normalize to exponent = 0\n  print *\n  print '(A)', 'Normalizing numbers to exponent 0:'\n  x = 12345.67\n  print '(A,G15.7,A,F12.8)', 'x=', x, ' -> ', set_exponent(x, 0)\n  x = 0.000123\n  print '(A,G15.7,A,F12.8)', 'x=', x, ' -> ', set_exponent(x, 0)\n  x = -987.654\n  print '(A,G15.7,A,F12.8)', 'x=', x, ' -> ', set_exponent(x, 0)\n\n  ! Double precision example\n  print *\n  dx = 123.456789012345d0\n  dy = set_exponent(dx, 0)\n  print '(A,ES25.16)', 'dx                      = ', dx\n  print '(A,ES25.16)', 'set_exponent(dx, 0)     = ', dy\n  print '(A,F25.16)',  'fraction preserved      = ', fraction(dy)\n\n  ! Reconstruct original from fraction and exponent\n  print *\n  x = 42.5\n  print '(A,G0)',     'Original x              = ', x\n  print '(A,G0)',     'Reconstructed           = ', &\n        set_exponent(x, exponent(x))\n\nend program demo_set_exponent\n```\n\n**Results:**\n```text\nx                        =   1.78138707E-02\ni (new exponent)         = 17\nset_exponent(x, i)       =   1.19505920E+05\nfraction(x) * radix**i   =   1.19505920E+05\n\nfraction(x)              =      0.91207018\nfraction(result)         =      0.91207018\nexponent(result)         = 17\n\nRelationship with scale:\nset_exponent(x, 10)      =   9.33956299E+02\nscale(x, 10 - exp(x))    =   9.33956299E+02\n\nNormalizing numbers to exponent 0:\nx=   12345.67     ->   0.75378418\nx=  0.1230000E-03 ->   0.80609345\nx=  -987.654     ->  -0.96255469\n\ndx                      =  1.2345678901234500E+02\nset_exponent(dx, 0)     =  9.6450617197144141E-01\nfraction preserved      =  0.9645061719714414\n\nOriginal x              = 42.5\nReconstructed           = 42.5\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n - [**exponent**](#exponent) - Extract exponent part of floating-point model\n - [**fraction**](#fraction) - Extract fractional part\n - [**scale**](#scale) - Scale by power of radix\n - [**radix**](#radix) - Base of the numeric model\n - [**maxexponent**](#maxexponent) - Maximum exponent\n - [**minexponent**](#minexponent) - Minimum exponent",

  "spacing": "## spacing\n\n### **Name**\n\n**spacing** - \\[NUMERIC:MANIPULATION\\] Return the absolute spacing of model numbers near the argument\n\n### **Synopsis**\n```fortran\n    result = spacing(x)\n```\n```fortran\n     elemental function spacing(x) result(sp)\n       real(kind=**), intent(in) :: x\n       real(kind=**)             :: sp\n```\n\n### **Characteristics**\n\n - **x** must be of type REAL, of any kind.\n - The result is REAL with the same kind as **x**.\n - This is an elemental function, operating element-wise on arrays.\n\n### **Description**\n\n**spacing(x)** determines the absolute spacing between adjacent floating-point numbers at the magnitude of **x**. It returns the distance to the nearest adjacent representable number of the same type.\n\nFor a floating-point number **x**, **spacing(x)** is the difference between **x** and the nearest distinct floating-point number, which equals:\n\n    spacing(x) = radix(x)**(exponent(x) - digits(x))\n\nfor normalized numbers. This is also known as the \"unit in the last place\" (ULP) or \"machine epsilon at x\".\n\nKey characteristics of floating-point spacing:\n - Spacing increases with magnitude (larger numbers have larger gaps)\n - Spacing is constant between consecutive powers of the radix\n - spacing(x) = nearest(x, 1.0) - x for most values\n - spacing(1.0) is related to but not equal to epsilon(1.0)\n\n**spacing** is essential for:\n - Understanding floating-point precision at a given magnitude\n - Implementing robust numerical comparisons\n - Analyzing numerical algorithm stability\n - Determining appropriate tolerances for iterative methods\n\n### **Options**\n\n - **x**\n   : A real number of any kind. The value at which to determine the spacing.\n\n### **Result**\n\nThe absolute spacing of model numbers near **x**, having the same type and kind as **x**.\n\n - For normalized numbers: radix(x)**(exponent(x) - digits(x))\n - If **x** is zero, the result is tiny(x) (smallest positive normalized number)\n - The result is always positive.\n - For denormalized numbers near zero, the result may be the smallest representable positive number.\n\n### **Examples**\n\n```fortran\nprogram demo_spacing\n  implicit none\n  integer, parameter :: SGL = selected_real_kind(p=6, r=37)\n  integer, parameter :: DBL = selected_real_kind(p=13, r=200)\n  real(SGL) :: x_sgl\n  real(DBL) :: x_dbl\n  integer :: i\n\n  ! Basic usage\n  print '(A)', 'Spacing at 1.0 for different precisions:'\n  print '(A,ES15.8)', 'Single precision: ', spacing(1.0_SGL)\n  print '(A,ES15.8)', 'Double precision: ', spacing(1.0_DBL)\n\n  ! Verify spacing equals difference to nearest neighbor\n  print *\n  x_sgl = 1.0_SGL\n  print '(A,ES15.8)', 'spacing(1.0)              = ', spacing(x_sgl)\n  print '(A,ES15.8)', 'nearest(1.0, 1.0) - 1.0   = ', nearest(x_sgl, 1.0) - x_sgl\n\n  ! Spacing varies with magnitude\n  print *\n  print '(A)', 'Spacing at different magnitudes (single precision):'\n  print '(A)', '    Value            Spacing'\n  do i = -6, 6, 2\n    x_sgl = 10.0_SGL ** i\n    print '(ES15.3, ES15.3)', x_sgl, spacing(x_sgl)\n  end do\n\n  ! Spacing is constant between powers of radix\n  print *\n  print '(A)', 'Spacing between powers of 2:'\n  x_sgl = 1.0_SGL\n  print '(A,ES15.8)', 'spacing(1.0)   = ', spacing(x_sgl)\n  x_sgl = 1.5_SGL\n  print '(A,ES15.8)', 'spacing(1.5)   = ', spacing(x_sgl)\n  x_sgl = 1.99_SGL\n  print '(A,ES15.8)', 'spacing(1.99)  = ', spacing(x_sgl)\n  x_sgl = 2.0_SGL\n  print '(A,ES15.8)', 'spacing(2.0)   = ', spacing(x_sgl)  ! Doubles!\n\n  ! Relationship with epsilon\n  print *\n  print '(A)', 'Spacing vs epsilon:'\n  print '(A,ES15.8)', 'spacing(1.0)   = ', spacing(1.0_SGL)\n  print '(A,ES15.8)', 'epsilon(1.0)   = ', epsilon(1.0_SGL)\n  print '(A)', 'Note: epsilon = spacing(1.0) for single precision'\n\n  ! Special case: spacing at zero\n  print *\n  print '(A,ES15.8)', 'spacing(0.0)   = ', spacing(0.0_SGL)\n  print '(A,ES15.8)', 'tiny(1.0)      = ', tiny(1.0_SGL)\n\n  ! Practical use: checking for \"essentially equal\"\n  print *\n  print '(A)', 'Robust comparison example:'\n  x_sgl = 1.0_SGL / 3.0_SGL\n  print '(A,L1)', 'x*3 == 1.0 (exact)?              ', (x_sgl * 3.0_SGL == 1.0_SGL)\n  print '(A,L1)', '|x*3 - 1.0| < 2*spacing(1.0)?    ', &\n        abs(x_sgl * 3.0_SGL - 1.0_SGL) < 2.0_SGL * spacing(1.0_SGL)\n\nend program demo_spacing\n```\n\n**Results:**\n```text\nSpacing at 1.0 for different precisions:\nSingle precision:   1.19209290E-07\nDouble precision:   2.22044605E-16\n\nspacing(1.0)              =   1.19209290E-07\nnearest(1.0, 1.0) - 1.0   =   1.19209290E-07\n\nSpacing at different magnitudes (single precision):\n    Value            Spacing\n      1.000E-06       5.605E-14\n      1.000E-04       5.960E-12\n      1.000E-02       7.451E-10\n      1.000E+00       1.192E-07\n      1.000E+02       7.629E-06\n      1.000E+04       9.766E-04\n      1.000E+06       6.250E-02\n\nSpacing between powers of 2:\nspacing(1.0)   =   1.19209290E-07\nspacing(1.5)   =   1.19209290E-07\nspacing(1.99)  =   1.19209290E-07\nspacing(2.0)   =   2.38418579E-07\n\nSpacing vs epsilon:\nspacing(1.0)   =   1.19209290E-07\nepsilon(1.0)   =   1.19209290E-07\nNote: epsilon = spacing(1.0) for single precision\n\nspacing(0.0)   =   1.17549435E-38\ntiny(1.0)      =   1.17549435E-38\n\nRobust comparison example:\nx*3 == 1.0 (exact)?              F\n|x*3 - 1.0| < 2*spacing(1.0)?    T\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n - [**nearest**](#nearest) - Nearest representable number\n - [**rrspacing**](#rrspacing) - Reciprocal of relative spacing\n - [**epsilon**](#epsilon) - Machine epsilon (relative precision)\n - [**tiny**](#tiny) - Smallest positive normalized number\n - [**digits**](#digits) - Number of significant digits\n - [**radix**](#radix) - Base of the numeric model"
}
