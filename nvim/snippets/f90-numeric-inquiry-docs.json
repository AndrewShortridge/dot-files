{
  "digits": "## digits\n\n### **Name**\n\n**digits** - \\[NUMERIC:INQUIRY\\] Returns the number of significant binary digits in the numeric model\n\n### **Synopsis**\n```fortran\n    result = digits(x)\n```\n```fortran\n     function digits(x) result(num_digits)\n\n      type(integer|real), intent(in) :: x\n      integer                        :: num_digits\n```\n\n### **Characteristics**\n\n - **X** must be of type INTEGER or REAL.\n - **X** may be a scalar or an array.\n - The result is a default INTEGER scalar.\n - The value of **X** is not used; only its type and kind determine the result.\n\n### **Description**\n\n **DIGITS(X)** returns the number of significant binary digits in the\n internal model representation of the type and kind of **X**. This is\n an inquiry function that characterizes the numeric model, not the\n actual value of the argument.\n\n For the Fortran numeric model:\n - For integers: the number of bits used to represent the magnitude\n   (excluding the sign bit)\n - For reals: the number of bits in the significand (mantissa),\n   including the implicit leading bit for IEEE 754 formats\n\n On IEEE 754 systems:\n - Single precision (REAL*4): typically returns 24\n - Double precision (REAL*8): typically returns 53\n - Default integer (INTEGER*4): typically returns 31\n\n### **Options**\n\n- **X**\n  : A variable or constant of INTEGER or REAL type. The actual value is\n  irrelevant; only the type and kind parameter matter. This argument is\n  required.\n\n### **Result**\n\n  The result is a scalar default integer equal to the number of significant\n  binary digits in the model representation for the type and kind of **X**.\n\n  For INTEGER types, this equals the number of bits used for the magnitude.\n\n  For REAL types, this equals the number of mantissa bits including the\n  implicit leading bit (for normalized numbers in IEEE 754 format).\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_digits\n  implicit none\n  integer          :: i = 12345\n  real             :: x = 3.143\n  real(kind=8)     :: y = 2.33d0\n  integer(kind=2)  :: short_int = 100\n  integer(kind=8)  :: long_int = 10000000000_8\n\n  print '(A)', 'Number of significant binary digits:'\n  print '(A,I3)', '  default integer:     ', digits(i)\n  print '(A,I3)', '  short integer (2):   ', digits(short_int)\n  print '(A,I3)', '  long integer (8):    ', digits(long_int)\n  print '(A,I3)', '  default real:        ', digits(x)\n  print '(A,I3)', '  double precision:    ', digits(y)\n\n  ! Demonstrate relationship with other model functions\n  print '(A)', ''\n  print '(A)', 'For default real:'\n  print '(A,I3)',  '  radix  = ', radix(x)\n  print '(A,I3)',  '  digits = ', digits(x)\n  print '(A,ES12.5)', '  epsilon = ', epsilon(x)\n\nend program demo_digits\n```\nResults (typical IEEE 754 system):\n```text\nNumber of significant binary digits:\n  default integer:      31\n  short integer (2):    15\n  long integer (8):     63\n  default real:         24\n  double precision:     53\n\nFor default real:\n  radix  =   2\n  digits =  24\n  epsilon =  1.19209E-07\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**radix**(3)](#radix),\n[**epsilon**(3)](#epsilon),\n[**precision**(3)](#precision),\n[**range**(3)](#range),\n[**huge**(3)](#huge),\n[**tiny**(3)](#tiny)",

  "epsilon": "## epsilon\n\n### **Name**\n\n**epsilon** - \\[NUMERIC:INQUIRY\\] Returns the smallest number that added to 1 produces a result greater than 1\n\n### **Synopsis**\n```fortran\n    result = epsilon(x)\n```\n```fortran\n     function epsilon(x) result(eps)\n\n      real(kind=k), intent(in) :: x\n      real(kind=k)             :: eps\n```\n\n### **Characteristics**\n\n - **X** must be of type REAL.\n - **X** may be a scalar or an array.\n - The result has the same type and kind as **X**.\n - The value of **X** is not used; only its type and kind determine the result.\n\n### **Description**\n\n **EPSILON(X)** returns the smallest positive number **E** of the same\n kind as **X** such that **1.0 + E > 1.0**. This value represents the\n relative spacing of representable numbers near 1.0, also known as\n machine epsilon or unit roundoff.\n\n For IEEE 754 floating-point arithmetic:\n - Single precision: epsilon is approximately 1.19209E-07 (2^-23)\n - Double precision: epsilon is approximately 2.22045E-16 (2^-52)\n\n This function is essential for:\n - Setting tolerances in iterative algorithms\n - Comparing floating-point numbers for approximate equality\n - Determining convergence criteria\n - Avoiding division by numbers too close to zero\n\n The mathematical relationship is:\n   epsilon(x) = radix(x)^(1-digits(x))\n\n### **Options**\n\n- **X**\n  : A variable or constant of REAL type. The actual value is irrelevant;\n  only the type and kind parameter matter. This argument is required.\n\n### **Result**\n\n  The result is a positive real value of the same kind as **X**,\n  representing the smallest distinguishable increment from 1.0 in that\n  floating-point representation.\n\n  This is the machine epsilon, useful for writing portable numerical\n  code that adapts to different precision levels.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_epsilon\n  implicit none\n  real             :: x = 1.0\n  real(kind=8)     :: y = 1.0d0\n  real             :: tolerance\n\n  print '(A)', 'Machine epsilon for different precisions:'\n  print '(A,ES15.8)', '  single precision: ', epsilon(x)\n  print '(A,ES23.16)', '  double precision: ', epsilon(y)\n\n  ! Demonstrate that 1 + epsilon > 1\n  print '(A)', ''\n  print '(A)', 'Verification that 1 + epsilon > 1:'\n  print '(A,L)', '  1.0 + epsilon(x) > 1.0: ', &\n                  (1.0 + epsilon(x)) > 1.0\n  print '(A,L)', '  1.0 + epsilon(x)/2 > 1.0: ', &\n                  (1.0 + epsilon(x)/2.0) > 1.0\n\n  ! Practical use: setting a tolerance for convergence\n  tolerance = 100.0 * epsilon(x)\n  print '(A)', ''\n  print '(A,ES12.5)', 'Practical tolerance (100*epsilon): ', tolerance\n\n  ! Comparing floating-point numbers\n  print '(A)', ''\n  print '(A)', 'Safe floating-point comparison example:'\n  call safe_compare(1.0/3.0, 0.333333343)\n\ncontains\n\n  subroutine safe_compare(a, b)\n    real, intent(in) :: a, b\n    real :: rel_diff\n    rel_diff = abs(a - b) / max(abs(a), abs(b), tiny(a))\n    if (rel_diff < 100.0 * epsilon(a)) then\n      print '(A)', '  Values are approximately equal'\n    else\n      print '(A)', '  Values differ significantly'\n    end if\n  end subroutine safe_compare\n\nend program demo_epsilon\n```\nResults (typical IEEE 754 system):\n```text\nMachine epsilon for different precisions:\n  single precision:  1.19209290E-07\n  double precision:  2.2204460492503131E-16\n\nVerification that 1 + epsilon > 1:\n  1.0 + epsilon(x) > 1.0: T\n  1.0 + epsilon(x)/2 > 1.0: F\n\nPractical tolerance (100*epsilon):  1.19209E-05\n\nSafe floating-point comparison example:\n  Values are approximately equal\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**tiny**(3)](#tiny),\n[**huge**(3)](#huge),\n[**digits**(3)](#digits),\n[**radix**(3)](#radix),\n[**precision**(3)](#precision),\n[**spacing**(3)](#spacing),\n[**nearest**(3)](#nearest)",

  "huge": "## huge\n\n### **Name**\n\n**huge** - \\[NUMERIC:INQUIRY\\] Returns the largest representable number in the numeric model\n\n### **Synopsis**\n```fortran\n    result = huge(x)\n```\n```fortran\n     function huge(x) result(largest)\n\n      type(integer|real), intent(in) :: x\n      type(same as x)                :: largest\n```\n\n### **Characteristics**\n\n - **X** must be of type INTEGER or REAL.\n - **X** may be a scalar or an array.\n - The result has the same type and kind as **X**.\n - The value of **X** is not used; only its type and kind determine the result.\n\n### **Description**\n\n **HUGE(X)** returns the largest number that is not an infinity in the\n model of the type of **X**. This represents the maximum finite value\n that can be stored in a variable of that type and kind.\n\n For the Fortran numeric model:\n - For integers: HUGE = radix^(digits) - 1\n - For reals: HUGE = (1 - radix^(-digits)) * radix^maxexponent\n\n Typical values on IEEE 754 systems:\n - INTEGER*4: 2147483647 (2^31 - 1)\n - INTEGER*8: 9223372036854775807 (2^63 - 1)\n - REAL*4: approximately 3.40282E+38\n - REAL*8: approximately 1.79769E+308\n\n This function is useful for:\n - Initializing variables to find minimum values\n - Checking for potential overflow conditions\n - Setting upper bounds in algorithms\n\n### **Options**\n\n- **X**\n  : A variable or constant of INTEGER or REAL type. The actual value is\n  irrelevant; only the type and kind parameter matter. This argument is\n  required.\n\n### **Result**\n\n  The result is a scalar value of the same type and kind as **X**,\n  containing the largest finite number representable in that type.\n\n  For INTEGER types, this is the largest positive integer.\n\n  For REAL types, this is the largest finite floating-point number\n  (operations producing values larger than this result in overflow\n  or infinity).\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_huge\n  implicit none\n  integer          :: i\n  integer(kind=2)  :: short_int\n  integer(kind=4)  :: default_int\n  integer(kind=8)  :: long_int\n  real             :: x\n  real(kind=8)     :: y\n\n  print '(A)', 'Largest representable values:'\n  print '(A)', ''\n  print '(A)', 'Integers:'\n  print '(A,I20)',   '  kind=2:  ', huge(short_int)\n  print '(A,I20)',   '  kind=4:  ', huge(default_int)\n  print '(A,I20)',   '  kind=8:  ', huge(long_int)\n\n  print '(A)', ''\n  print '(A)', 'Reals:'\n  print '(A,ES15.8)', '  single:  ', huge(x)\n  print '(A,ES24.16)', '  double:  ', huge(y)\n\n  ! Practical use: initialize minimum search\n  print '(A)', ''\n  print '(A)', 'Finding minimum value in array:'\n  call find_minimum([3.5, 1.2, 7.8, 0.5, 4.3])\n\n  ! Relationship with other model functions\n  print '(A)', ''\n  print '(A)', 'Model relationships for default real:'\n  print '(A,I5)',     '  maxexponent = ', maxexponent(x)\n  print '(A,ES15.8)', '  huge        = ', huge(x)\n  print '(A,ES15.8)', '  tiny        = ', tiny(x)\n\ncontains\n\n  subroutine find_minimum(arr)\n    real, intent(in) :: arr(:)\n    real :: min_val\n    integer :: i\n    min_val = huge(min_val)  ! Initialize to largest possible\n    do i = 1, size(arr)\n      if (arr(i) < min_val) min_val = arr(i)\n    end do\n    print '(A,F6.2)', '  Minimum found: ', min_val\n  end subroutine find_minimum\n\nend program demo_huge\n```\nResults (typical IEEE 754 system):\n```text\nLargest representable values:\n\nIntegers:\n  kind=2:                 32767\n  kind=4:            2147483647\n  kind=8:   9223372036854775807\n\nReals:\n  single:   3.40282347E+38\n  double:   1.7976931348623157E+308\n\nFinding minimum value in array:\n  Minimum found:   0.50\n\nModel relationships for default real:\n  maxexponent =   128\n  huge        =  3.40282347E+38\n  tiny        =  1.17549435E-38\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**tiny**(3)](#tiny),\n[**epsilon**(3)](#epsilon),\n[**maxexponent**(3)](#maxexponent),\n[**minexponent**(3)](#minexponent),\n[**range**(3)](#range),\n[**digits**(3)](#digits)",

  "maxexponent": "## maxexponent\n\n### **Name**\n\n**maxexponent** - \\[NUMERIC:INQUIRY\\] Returns the maximum exponent in the floating-point model\n\n### **Synopsis**\n```fortran\n    result = maxexponent(x)\n```\n```fortran\n     function maxexponent(x) result(max_exp)\n\n      real(kind=k), intent(in) :: x\n      integer                  :: max_exp\n```\n\n### **Characteristics**\n\n - **X** must be of type REAL.\n - **X** may be a scalar or an array.\n - The result is a default INTEGER scalar.\n - The value of **X** is not used; only its type and kind determine the result.\n\n### **Description**\n\n **MAXEXPONENT(X)** returns the maximum exponent in the model of the\n type of **X**. This is the largest exponent that can be used in the\n floating-point representation before overflow occurs.\n\n For IEEE 754 floating-point:\n - Single precision (REAL*4): maxexponent is typically 128\n - Double precision (REAL*8): maxexponent is typically 1024\n\n The relationship with HUGE is:\n   huge(x) is approximately radix(x)^maxexponent(x)\n\n Note that the actual IEEE 754 exponent value stored differs due to\n bias: the stored exponent equals the actual exponent plus a bias\n (127 for single, 1023 for double). MAXEXPONENT returns the unbiased\n (actual) maximum exponent.\n\n### **Options**\n\n- **X**\n  : A variable or constant of REAL type. The actual value is irrelevant;\n  only the type and kind parameter matter. This argument is required.\n\n### **Result**\n\n  The result is a scalar default integer equal to the maximum exponent\n  in the floating-point model for the kind of **X**.\n\n  This value represents the largest power of the radix (base) that can\n  be used in the floating-point representation.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_maxexponent\n  implicit none\n  real             :: x\n  real(kind=8)     :: y\n  real(kind=16)    :: z  ! Quad precision if available\n\n  print '(A)', 'Maximum exponents for different precisions:'\n  print '(A,I6)', '  single precision (real*4):  ', maxexponent(x)\n  print '(A,I6)', '  double precision (real*8):  ', maxexponent(y)\n\n  print '(A)', ''\n  print '(A)', 'Complete floating-point model for single precision:'\n  print '(A,I6)',     '  radix       = ', radix(x)\n  print '(A,I6)',     '  digits      = ', digits(x)\n  print '(A,I6)',     '  minexponent = ', minexponent(x)\n  print '(A,I6)',     '  maxexponent = ', maxexponent(x)\n  print '(A,ES15.8)', '  tiny        = ', tiny(x)\n  print '(A,ES15.8)', '  huge        = ', huge(x)\n\n  print '(A)', ''\n  print '(A)', 'Complete floating-point model for double precision:'\n  print '(A,I6)',      '  radix       = ', radix(y)\n  print '(A,I6)',      '  digits      = ', digits(y)\n  print '(A,I6)',      '  minexponent = ', minexponent(y)\n  print '(A,I6)',      '  maxexponent = ', maxexponent(y)\n  print '(A,ES24.16)', '  tiny        = ', tiny(y)\n  print '(A,ES24.16)', '  huge        = ', huge(y)\n\n  ! Demonstrate relationship: huge ~ radix^maxexponent\n  print '(A)', ''\n  print '(A)', 'Verification: 2^maxexponent approximates huge'\n  print '(A,ES15.8)', '  2^128          = ', 2.0**128\n  print '(A,ES15.8)', '  huge(real)     = ', huge(x)\n\nend program demo_maxexponent\n```\nResults (typical IEEE 754 system):\n```text\nMaximum exponents for different precisions:\n  single precision (real*4):     128\n  double precision (real*8):    1024\n\nComplete floating-point model for single precision:\n  radix       =      2\n  digits      =     24\n  minexponent =   -125\n  maxexponent =    128\n  tiny        =  1.17549435E-38\n  huge        =  3.40282347E+38\n\nComplete floating-point model for double precision:\n  radix       =      2\n  digits      =     53\n  minexponent =  -1021\n  maxexponent =   1024\n  tiny        =  2.2250738585072014E-308\n  huge        =  1.7976931348623157E+308\n\nVerification: 2^maxexponent approximates huge\n  2^128          =  3.40282367E+38\n  huge(real)     =  3.40282347E+38\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**minexponent**(3)](#minexponent),\n[**huge**(3)](#huge),\n[**tiny**(3)](#tiny),\n[**radix**(3)](#radix),\n[**digits**(3)](#digits),\n[**exponent**(3)](#exponent),\n[**range**(3)](#range)",

  "minexponent": "## minexponent\n\n### **Name**\n\n**minexponent** - \\[NUMERIC:INQUIRY\\] Returns the minimum exponent in the floating-point model\n\n### **Synopsis**\n```fortran\n    result = minexponent(x)\n```\n```fortran\n     function minexponent(x) result(min_exp)\n\n      real(kind=k), intent(in) :: x\n      integer                  :: min_exp\n```\n\n### **Characteristics**\n\n - **X** must be of type REAL.\n - **X** may be a scalar or an array.\n - The result is a default INTEGER scalar.\n - The value of **X** is not used; only its type and kind determine the result.\n\n### **Description**\n\n **MINEXPONENT(X)** returns the minimum exponent in the model of the\n type of **X**. This is the smallest (most negative) exponent that can\n be used in the normalized floating-point representation before\n underflow to zero occurs.\n\n For IEEE 754 floating-point:\n - Single precision (REAL*4): minexponent is typically -125\n - Double precision (REAL*8): minexponent is typically -1021\n\n The relationship with TINY is:\n   tiny(x) = radix(x)^(minexponent(x)-1)\n\n Note that IEEE 754 reserves the smallest exponent (all zeros) for\n denormalized numbers and zero. MINEXPONENT returns the smallest\n exponent for normalized numbers.\n\n### **Options**\n\n- **X**\n  : A variable or constant of REAL type. The actual value is irrelevant;\n  only the type and kind parameter matter. This argument is required.\n\n### **Result**\n\n  The result is a scalar default integer equal to the minimum exponent\n  in the floating-point model for the kind of **X**.\n\n  This value represents the smallest (most negative) power of the radix\n  that can be used for normalized floating-point numbers.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_minexponent\n  implicit none\n  real             :: x\n  real(kind=8)     :: y\n\n  print '(A)', 'Minimum exponents for different precisions:'\n  print '(A,I6)', '  single precision (real*4):  ', minexponent(x)\n  print '(A,I6)', '  double precision (real*8):  ', minexponent(y)\n\n  print '(A)', ''\n  print '(A)', 'Exponent range comparison:'\n  print '(A,I6,A,I6)', '  single: ', minexponent(x), ' to ', maxexponent(x)\n  print '(A,I6,A,I6)', '  double: ', minexponent(y), ' to ', maxexponent(y)\n\n  print '(A)', ''\n  print '(A)', 'Relationship between minexponent and tiny:'\n  print '(A,ES15.8)', '  tiny(real)       = ', tiny(x)\n  print '(A,ES15.8)', '  2^(minexp-1)     = ', 2.0**(minexponent(x)-1)\n  print '(A)', '  (These should be equal)'\n\n  print '(A)', ''\n  print '(A)', 'Underflow detection example:'\n  call check_underflow(x)\n\ncontains\n\n  subroutine check_underflow(template)\n    real, intent(in) :: template\n    real :: val, small_val\n    integer :: exp_val\n\n    ! Get a very small but valid number\n    small_val = tiny(template)\n    exp_val = exponent(small_val)\n\n    print '(A,ES12.5)', '  tiny value:      ', small_val\n    print '(A,I6)',     '  its exponent:    ', exp_val\n    print '(A,I6)',     '  minexponent:     ', minexponent(template)\n\n    ! Dividing tiny by radix would underflow\n    val = small_val / real(radix(template))\n    print '(A,ES12.5)', '  tiny/radix:      ', val\n    print '(A)',        '  (denormalized or zero)'\n  end subroutine check_underflow\n\nend program demo_minexponent\n```\nResults (typical IEEE 754 system):\n```text\nMinimum exponents for different precisions:\n  single precision (real*4):    -125\n  double precision (real*8):   -1021\n\nExponent range comparison:\n  single:   -125 to    128\n  double:  -1021 to   1024\n\nRelationship between minexponent and tiny:\n  tiny(real)       =  1.17549435E-38\n  2^(minexp-1)     =  1.17549435E-38\n  (These should be equal)\n\nUnderflow detection example:\n  tiny value:       1.17549E-38\n  its exponent:      -125\n  minexponent:       -125\n  tiny/radix:        5.87747E-39\n  (denormalized or zero)\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**maxexponent**(3)](#maxexponent),\n[**tiny**(3)](#tiny),\n[**huge**(3)](#huge),\n[**radix**(3)](#radix),\n[**digits**(3)](#digits),\n[**exponent**(3)](#exponent),\n[**range**(3)](#range)",

  "precision": "## precision\n\n### **Name**\n\n**precision** - \\[NUMERIC:INQUIRY\\] Returns the decimal precision of a real or complex kind\n\n### **Synopsis**\n```fortran\n    result = precision(x)\n```\n```fortran\n     function precision(x) result(dec_prec)\n\n      type(real|complex), intent(in) :: x\n      integer                        :: dec_prec\n```\n\n### **Characteristics**\n\n - **X** must be of type REAL or COMPLEX.\n - **X** may be a scalar or an array.\n - The result is a default INTEGER scalar.\n - The value of **X** is not used; only its type and kind determine the result.\n\n### **Description**\n\n **PRECISION(X)** returns the decimal precision in the model of the\n type of **X**. This is the number of significant decimal digits that\n can be reliably represented in the floating-point format.\n\n The decimal precision is calculated as:\n   precision = INT((digits(x) - 1) * LOG10(radix(x)))\n\n For IEEE 754 floating-point:\n - Single precision (REAL*4): precision is typically 6\n - Double precision (REAL*8): precision is typically 15\n - Quad precision (REAL*16): precision is typically 33\n\n Note: While IEEE 754 single precision has about 7.22 decimal digits\n of precision (24 bits * log10(2) = 7.22), PRECISION returns 6 because\n only 6 digits are guaranteed to round-trip correctly for all values.\n\n This function is useful with SELECTED_REAL_KIND to request a specific\n decimal precision level.\n\n### **Options**\n\n- **X**\n  : A variable or constant of REAL or COMPLEX type. The actual value is\n  irrelevant; only the type and kind parameter matter. This argument is\n  required.\n\n### **Result**\n\n  The result is a scalar default integer equal to the number of\n  significant decimal digits that can be represented in the\n  floating-point model for the kind of **X**.\n\n  For COMPLEX arguments, the precision of the real component is returned\n  (both components have the same precision).\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_precision\n  implicit none\n  real             :: x\n  real(kind=8)     :: y\n  complex          :: cx\n  complex(kind=8)  :: cy\n\n  print '(A)', 'Decimal precision for different kinds:'\n  print '(A,I3)', '  single precision real:     ', precision(x)\n  print '(A,I3)', '  double precision real:     ', precision(y)\n  print '(A,I3)', '  single precision complex:  ', precision(cx)\n  print '(A,I3)', '  double precision complex:  ', precision(cy)\n\n  print '(A)', ''\n  print '(A)', 'Relationship between precision and digits:'\n  print '(A,I3)', '  digits(single) = ', digits(x)\n  print '(A,I3)', '  precision(single) = ', precision(x)\n  print '(A)',    '  Formula: INT((24-1) * LOG10(2)) = INT(6.92) = 6'\n\n  print '(A)', ''\n  print '(A,I3)', '  digits(double) = ', digits(y)\n  print '(A,I3)', '  precision(double) = ', precision(y)\n  print '(A)',    '  Formula: INT((53-1) * LOG10(2)) = INT(15.65) = 15'\n\n  print '(A)', ''\n  print '(A)', 'Using precision with SELECTED_REAL_KIND:'\n  call show_kind_selection()\n\ncontains\n\n  subroutine show_kind_selection()\n    integer, parameter :: sp = selected_real_kind(6)   ! At least 6 digits\n    integer, parameter :: dp = selected_real_kind(15)  ! At least 15 digits\n    real(kind=sp) :: single_val\n    real(kind=dp) :: double_val\n\n    print '(A,I3)', '  selected_real_kind(6) gives precision:  ', &\n                    precision(single_val)\n    print '(A,I3)', '  selected_real_kind(15) gives precision: ', &\n                    precision(double_val)\n  end subroutine show_kind_selection\n\nend program demo_precision\n```\nResults (typical IEEE 754 system):\n```text\nDecimal precision for different kinds:\n  single precision real:       6\n  double precision real:      15\n  single precision complex:    6\n  double precision complex:   15\n\nRelationship between precision and digits:\n  digits(single) =  24\n  precision(single) =   6\n  Formula: INT((24-1) * LOG10(2)) = INT(6.92) = 6\n\n  digits(double) =  53\n  precision(double) =  15\n  Formula: INT((53-1) * LOG10(2)) = INT(15.65) = 15\n\nUsing precision with SELECTED_REAL_KIND:\n  selected_real_kind(6) gives precision:    6\n  selected_real_kind(15) gives precision:  15\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**digits**(3)](#digits),\n[**range**(3)](#range),\n[**radix**(3)](#radix),\n[**epsilon**(3)](#epsilon),\n[**selected_real_kind**(3)](#selected_real_kind),\n[**selected_int_kind**(3)](#selected_int_kind)",

  "radix": "## radix\n\n### **Name**\n\n**radix** - \\[NUMERIC:INQUIRY\\] Returns the base of the numeric model\n\n### **Synopsis**\n```fortran\n    result = radix(x)\n```\n```fortran\n     function radix(x) result(base)\n\n      type(integer|real), intent(in) :: x\n      integer                        :: base\n```\n\n### **Characteristics**\n\n - **X** must be of type INTEGER or REAL.\n - **X** may be a scalar or an array.\n - The result is a default INTEGER scalar.\n - The value of **X** is not used; only its type and kind determine the result.\n\n### **Description**\n\n **RADIX(X)** returns the base of the model representing numbers of the\n type and kind of **X**. This is the fundamental base used in the\n internal representation of numeric values.\n\n On virtually all modern computers, RADIX returns 2 for both integer\n and real types, indicating binary representation. Historical systems\n (such as some IBM mainframes) used other bases like 16 (hexadecimal\n floating-point).\n\n The radix is fundamental to the Fortran numeric model:\n - For integers: value = s * SUM(digit_k * radix^k) for k=0 to digits-1\n - For reals: value = s * (SUM(f_k * radix^(-k))) * radix^e\n\n where s is the sign, digits/f_k are the mantissa digits, and e is\n the exponent.\n\n### **Options**\n\n- **X**\n  : A variable or constant of INTEGER or REAL type. The actual value is\n  irrelevant; only the type and kind parameter matter. This argument is\n  required.\n\n### **Result**\n\n  The result is a scalar default integer equal to the base of the\n  numeric model for the type and kind of **X**.\n\n  On IEEE 754 compliant systems (essentially all modern platforms),\n  this returns 2.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_radix\n  implicit none\n  integer          :: i\n  integer(kind=8)  :: long_i\n  real             :: x\n  real(kind=8)     :: y\n\n  print '(A)', 'Radix (base) for different types:'\n  print '(A,I3)', '  default integer:    ', radix(i)\n  print '(A,I3)', '  long integer:       ', radix(long_i)\n  print '(A,I3)', '  single precision:   ', radix(x)\n  print '(A,I3)', '  double precision:   ', radix(y)\n\n  print '(A)', ''\n  print '(A)', 'The numeric model uses radix as the base.'\n  print '(A)', 'For binary (radix=2) floating-point:'\n  print '(A)', '  value = sign * mantissa * 2^exponent'\n\n  print '(A)', ''\n  print '(A)', 'Complete model parameters for single precision:'\n  print '(A,I6)',     '  radix       = ', radix(x)\n  print '(A,I6)',     '  digits      = ', digits(x)\n  print '(A,I6)',     '  minexponent = ', minexponent(x)\n  print '(A,I6)',     '  maxexponent = ', maxexponent(x)\n  print '(A,I6)',     '  precision   = ', precision(x)\n  print '(A,I6)',     '  range       = ', range(x)\n\n  print '(A)', ''\n  print '(A)', 'Derived quantities:'\n  print '(A,ES15.8)', '  epsilon = radix^(1-digits)    = ', &\n                       real(radix(x))**(1-digits(x))\n  print '(A,ES15.8)', '  actual epsilon               = ', epsilon(x)\n  print '(A,ES15.8)', '  tiny = radix^(minexponent-1) = ', &\n                       real(radix(x))**(minexponent(x)-1)\n  print '(A,ES15.8)', '  actual tiny                  = ', tiny(x)\n\nend program demo_radix\n```\nResults (typical IEEE 754 system):\n```text\nRadix (base) for different types:\n  default integer:      2\n  long integer:         2\n  single precision:     2\n  double precision:     2\n\nThe numeric model uses radix as the base.\nFor binary (radix=2) floating-point:\n  value = sign * mantissa * 2^exponent\n\nComplete model parameters for single precision:\n  radix       =      2\n  digits      =     24\n  minexponent =   -125\n  maxexponent =    128\n  precision   =      6\n  range       =     37\n\nDerived quantities:\n  epsilon = radix^(1-digits)    =  1.19209290E-07\n  actual epsilon               =  1.19209290E-07\n  tiny = radix^(minexponent-1) =  1.17549435E-38\n  actual tiny                  =  1.17549435E-38\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**digits**(3)](#digits),\n[**epsilon**(3)](#epsilon),\n[**huge**(3)](#huge),\n[**tiny**(3)](#tiny),\n[**maxexponent**(3)](#maxexponent),\n[**minexponent**(3)](#minexponent),\n[**precision**(3)](#precision),\n[**range**(3)](#range)",

  "range": "## range\n\n### **Name**\n\n**range** - \\[NUMERIC:INQUIRY\\] Returns the decimal exponent range of a numeric kind\n\n### **Synopsis**\n```fortran\n    result = range(x)\n```\n```fortran\n     function range(x) result(dec_range)\n\n      type(integer|real|complex), intent(in) :: x\n      integer                                :: dec_range\n```\n\n### **Characteristics**\n\n - **X** must be of type INTEGER, REAL, or COMPLEX.\n - **X** may be a scalar or an array.\n - The result is a default INTEGER scalar.\n - The value of **X** is not used; only its type and kind determine the result.\n\n### **Description**\n\n **RANGE(X)** returns the decimal exponent range in the model of the\n type of **X**. This indicates the range of powers of 10 that can be\n represented: from 10^(-range) to 10^(+range).\n\n The decimal exponent range is calculated as:\n - For integers: INT(LOG10(huge(x)))\n - For reals: INT(MIN(LOG10(huge(x)), -LOG10(tiny(x))))\n\n For IEEE 754 floating-point:\n - Single precision (REAL*4): range is typically 37\n - Double precision (REAL*8): range is typically 307\n - Default integer (INTEGER*4): range is typically 9\n - Long integer (INTEGER*8): range is typically 18\n\n This function is useful with SELECTED_REAL_KIND to request a specific\n exponent range.\n\n### **Options**\n\n- **X**\n  : A variable or constant of INTEGER, REAL, or COMPLEX type. The actual\n  value is irrelevant; only the type and kind parameter matter. This\n  argument is required.\n\n### **Result**\n\n  The result is a scalar default integer equal to the decimal exponent\n  range for the model of the type and kind of **X**.\n\n  For INTEGER, this is INT(LOG10(huge(x))).\n\n  For REAL and COMPLEX, this is the minimum of the positive and negative\n  ranges, ensuring symmetric representation around 1.0.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_range\n  implicit none\n  integer          :: i\n  integer(kind=2)  :: short_i\n  integer(kind=8)  :: long_i\n  real             :: x\n  real(kind=8)     :: y\n  complex          :: cx\n  complex(kind=8)  :: cy\n\n  print '(A)', 'Decimal exponent ranges:'\n  print '(A)', ''\n  print '(A)', 'Integers:'\n  print '(A,I4)', '  kind=2 (short):    ', range(short_i)\n  print '(A,I4)', '  kind=4 (default):  ', range(i)\n  print '(A,I4)', '  kind=8 (long):     ', range(long_i)\n\n  print '(A)', ''\n  print '(A)', 'Reals:'\n  print '(A,I4)', '  single precision:  ', range(x)\n  print '(A,I4)', '  double precision:  ', range(y)\n\n  print '(A)', ''\n  print '(A)', 'Complex:'\n  print '(A,I4)', '  single precision:  ', range(cx)\n  print '(A,I4)', '  double precision:  ', range(cy)\n\n  print '(A)', ''\n  print '(A)', 'What range means for single precision (range=37):'\n  print '(A,ES12.5)', '  Can represent up to:   ', 1.0e37\n  print '(A,ES12.5)', '  Can represent down to: ', 1.0e-37\n  print '(A,ES12.5)', '  Actual huge:           ', huge(x)\n  print '(A,ES12.5)', '  Actual tiny:           ', tiny(x)\n\n  print '(A)', ''\n  print '(A)', 'Relationship with huge and tiny:'\n  print '(A,I4)', '  INT(LOG10(huge(x)))      = ', int(log10(huge(x)))\n  print '(A,I4)', '  INT(-LOG10(tiny(x)))     = ', int(-log10(tiny(x)))\n  print '(A,I4)', '  range(x) (minimum of above) = ', range(x)\n\n  print '(A)', ''\n  print '(A)', 'Using range with SELECTED_REAL_KIND:'\n  call show_kind_selection()\n\ncontains\n\n  subroutine show_kind_selection()\n    integer, parameter :: k1 = selected_real_kind(p=6, r=37)\n    integer, parameter :: k2 = selected_real_kind(p=15, r=307)\n    real(kind=k1) :: r1\n    real(kind=k2) :: r2\n\n    print '(A,I4)', '  selected_real_kind(6,37) gives range:   ', range(r1)\n    print '(A,I4)', '  selected_real_kind(15,307) gives range: ', range(r2)\n  end subroutine show_kind_selection\n\nend program demo_range\n```\nResults (typical IEEE 754 system):\n```text\nDecimal exponent ranges:\n\nIntegers:\n  kind=2 (short):       4\n  kind=4 (default):     9\n  kind=8 (long):       18\n\nReals:\n  single precision:    37\n  double precision:   307\n\nComplex:\n  single precision:    37\n  double precision:   307\n\nWhat range means for single precision (range=37):\n  Can represent up to:    1.00000E+37\n  Can represent down to:  1.00000E-37\n  Actual huge:            3.40282E+38\n  Actual tiny:            1.17549E-38\n\nRelationship with huge and tiny:\n  INT(LOG10(huge(x)))      =   38\n  INT(-LOG10(tiny(x)))     =   37\n  range(x) (minimum of above) =   37\n\nUsing range with SELECTED_REAL_KIND:\n  selected_real_kind(6,37) gives range:     37\n  selected_real_kind(15,307) gives range:  307\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**precision**(3)](#precision),\n[**digits**(3)](#digits),\n[**radix**(3)](#radix),\n[**huge**(3)](#huge),\n[**tiny**(3)](#tiny),\n[**selected_real_kind**(3)](#selected_real_kind),\n[**selected_int_kind**(3)](#selected_int_kind)",

  "tiny": "## tiny\n\n### **Name**\n\n**tiny** - \\[NUMERIC:INQUIRY\\] Returns the smallest positive number in the floating-point model\n\n### **Synopsis**\n```fortran\n    result = tiny(x)\n```\n```fortran\n     function tiny(x) result(smallest)\n\n      real(kind=k), intent(in) :: x\n      real(kind=k)             :: smallest\n```\n\n### **Characteristics**\n\n - **X** must be of type REAL.\n - **X** may be a scalar or an array.\n - The result has the same type and kind as **X**.\n - The value of **X** is not used; only its type and kind determine the result.\n\n### **Description**\n\n **TINY(X)** returns the smallest positive normalized number in the\n model of the type of **X**. This is the smallest floating-point value\n that can be represented without losing precision due to denormalization.\n\n For IEEE 754 floating-point:\n - Single precision (REAL*4): tiny is approximately 1.17549E-38\n - Double precision (REAL*8): tiny is approximately 2.22507E-308\n\n The relationship with model parameters is:\n   tiny(x) = radix(x)^(minexponent(x)-1)\n\n Note: Numbers smaller than TINY can exist as denormalized (subnormal)\n numbers in IEEE 754, but they have reduced precision. TINY returns the\n smallest normal number with full precision.\n\n This function is useful for:\n - Avoiding division by zero or near-zero\n - Setting minimum thresholds in algorithms\n - Detecting potential underflow conditions\n\n### **Options**\n\n- **X**\n  : A variable or constant of REAL type. The actual value is irrelevant;\n  only the type and kind parameter matter. This argument is required.\n\n### **Result**\n\n  The result is a positive real value of the same kind as **X**,\n  representing the smallest positive normalized number in that\n  floating-point representation.\n\n  Values smaller than this are either denormalized (with reduced\n  precision) or underflow to zero.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_tiny\n  implicit none\n  real             :: x\n  real(kind=8)     :: y\n\n  print '(A)', 'Smallest positive normalized numbers:'\n  print '(A,ES15.8)', '  single precision: ', tiny(x)\n  print '(A,ES24.16)', '  double precision: ', tiny(y)\n\n  print '(A)', ''\n  print '(A)', 'Comparison with huge (full representable range):'\n  print '(A,ES15.8,A,ES15.8)', '  single: ', tiny(x), ' to ', huge(x)\n  print '(A,ES24.16,A,ES24.16)', '  double: ', tiny(y), ' to ', huge(y)\n\n  print '(A)', ''\n  print '(A)', 'Relationship with model parameters:'\n  print '(A,ES15.8)', '  tiny(real)             = ', tiny(x)\n  print '(A,ES15.8)', '  2^(minexponent-1)      = ', &\n                       2.0**(minexponent(x)-1)\n  print '(A,I6)',     '  minexponent(real)      = ', minexponent(x)\n\n  print '(A)', ''\n  print '(A)', 'Practical use: safe division'\n  call safe_divide(1.0, 1.0e-40)\n  call safe_divide(1.0, 0.0)\n\ncontains\n\n  subroutine safe_divide(a, b)\n    real, intent(in) :: a, b\n    real :: result\n\n    if (abs(b) < tiny(b)) then\n      print '(A,ES10.3,A)', '  Cannot divide by ', b, ' (too small)'\n      result = sign(huge(a), a) * sign(1.0, b)  ! Return +/- huge\n    else\n      result = a / b\n      print '(A,ES10.3,A,ES10.3,A,ES12.5)', &\n            '  ', a, ' / ', b, ' = ', result\n    end if\n  end subroutine safe_divide\n\nend program demo_tiny\n```\nResults (typical IEEE 754 system):\n```text\nSmallest positive normalized numbers:\n  single precision:  1.17549435E-38\n  double precision:  2.2250738585072014E-308\n\nComparison with huge (full representable range):\n  single:  1.17549435E-38 to  3.40282347E+38\n  double:  2.2250738585072014E-308 to  1.7976931348623157E+308\n\nRelationship with model parameters:\n  tiny(real)             =  1.17549435E-38\n  2^(minexponent-1)      =  1.17549435E-38\n  minexponent(real)      =   -125\n\nPractical use: safe division\n  Cannot divide by  1.000E-40 (too small)\n  Cannot divide by  0.000E+00 (too small)\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**huge**(3)](#huge),\n[**epsilon**(3)](#epsilon),\n[**minexponent**(3)](#minexponent),\n[**maxexponent**(3)](#maxexponent),\n[**radix**(3)](#radix),\n[**digits**(3)](#digits),\n[**range**(3)](#range)"
}
