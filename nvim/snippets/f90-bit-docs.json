{
  "bit_size": "## **bit_size** - \\[BIT:MANIPULATION\\] Returns the number of bits in the integer model\n\n### **Synopsis**\n```fortran\nresult = bit_size(i)\n```\n\n```fortran\ninteger function bit_size(i)\n  integer(kind=**), intent(in) :: i\nend function bit_size\n```\n\n### **Characteristics**\n- **i** is of type `integer` (any kind)\n- The result is a default `integer` scalar\n- This is an inquiry function - the result depends only on the type of **i**, not its value\n\n### **Description**\n**bit_size** returns the number of bits (including the sign bit) used to represent integers of the same kind as the argument **i**. This is the bit model size `s` such that integers of this kind can represent values in the range `-2^(s-1)` to `2^(s-1) - 1`.\n\nBit positions are numbered from `0` (least significant) to `bit_size(i) - 1` (most significant, sign bit).\n\n### **Options**\n- **i**\n  : An `integer` of any kind. The value is not used; only the kind type parameter matters.\n\n### **Result**\nThe result is a default `integer` containing the number of bits in the integer model for the kind of **i**. Common values are 8, 16, 32, or 64.\n\n### **Examples**\n```fortran\nprogram demo_bit_size\n  implicit none\n  integer :: i\n  integer(kind=1) :: i1\n  integer(kind=2) :: i2\n  integer(kind=4) :: i4\n  integer(kind=8) :: i8\n\n  print '(a,i0)', 'Default integer bit_size: ', bit_size(i)\n  print '(a,i0)', 'Integer(1) bit_size:      ', bit_size(i1)\n  print '(a,i0)', 'Integer(2) bit_size:      ', bit_size(i2)\n  print '(a,i0)', 'Integer(4) bit_size:      ', bit_size(i4)\n  print '(a,i0)', 'Integer(8) bit_size:      ', bit_size(i8)\nend program demo_bit_size\n```\nExpected output:\n```\nDefault integer bit_size: 32\nInteger(1) bit_size:      8\nInteger(2) bit_size:      16\nInteger(4) bit_size:      32\nInteger(8) bit_size:      64\n```\n\n### **Standard**\nFortran 90\n\n### **See Also**\n[btest](#), [ibclr](#), [ibits](#), [ibset](#), [iand](#), [ieor](#), [ior](#), [ishft](#), [ishftc](#), [not](#)",

  "btest": "## **btest** - \\[BIT:MANIPULATION\\] Tests a specific bit of an integer value\n\n### **Synopsis**\n```fortran\nresult = btest(i, pos)\n```\n\n```fortran\nelemental logical function btest(i, pos)\n  integer(kind=**), intent(in) :: i\n  integer(kind=**), intent(in) :: pos\nend function btest\n```\n\n### **Characteristics**\n- **i** is of type `integer` (any kind)\n- **pos** is of type `integer` (any kind)\n- The result is of type `logical` (default kind)\n- This is an elemental function\n\n### **Description**\n**btest** returns `.true.` if the bit at position **pos** in integer **i** is set to 1, and `.false.` if it is set to 0. Bit positions are numbered from right to left, starting at 0 for the least significant bit.\n\nThe bit position must satisfy `0 <= pos < bit_size(i)`.\n\n### **Options**\n- **i**\n  : The `integer` value whose bit is to be tested.\n\n- **pos**\n  : The bit position to test. Must be non-negative and less than `bit_size(i)`.\n\n### **Result**\nThe result is `.true.` if bit **pos** of **i** is 1, otherwise `.false.`.\n\n### **Examples**\n```fortran\nprogram demo_btest\n  implicit none\n  integer :: i, pos\n  \n  ! Test value 13 = binary 1101\n  i = 13\n  print '(a,i0,a,b8.8)', 'Value: ', i, ' Binary: ', i\n  \n  do pos = 0, 7\n    if (btest(i, pos)) then\n      print '(a,i0,a)', '  Bit ', pos, ' is SET'\n    else\n      print '(a,i0,a)', '  Bit ', pos, ' is CLEAR'\n    end if\n  end do\n  \n  ! Practical example: check if number is odd (bit 0 set)\n  print *\n  print '(a,l1)', 'Is 13 odd? ', btest(13, 0)\n  print '(a,l1)', 'Is 14 odd? ', btest(14, 0)\nend program demo_btest\n```\nExpected output:\n```\nValue: 13 Binary: 00001101\n  Bit 0 is SET\n  Bit 1 is CLEAR\n  Bit 2 is SET\n  Bit 3 is SET\n  Bit 4 is CLEAR\n  Bit 5 is CLEAR\n  Bit 6 is CLEAR\n  Bit 7 is CLEAR\n\nIs 13 odd? T\nIs 14 odd? F\n```\n\n### **Standard**\nFortran 90\n\n### **See Also**\n[bit_size](#), [ibclr](#), [ibits](#), [ibset](#), [iand](#), [ieor](#), [ior](#), [ishft](#), [ishftc](#), [not](#)",

  "iand": "## **iand** - \\[BIT:MANIPULATION\\] Performs bitwise logical AND on two integers\n\n### **Synopsis**\n```fortran\nresult = iand(i, j)\n```\n\n```fortran\nelemental integer(kind=**) function iand(i, j)\n  integer(kind=**), intent(in) :: i\n  integer(kind=**), intent(in) :: j\nend function iand\n```\n\n### **Characteristics**\n- **i** and **j** must be of type `integer` with the same kind\n- The result has the same type and kind as the arguments\n- This is an elemental function\n\n### **Description**\n**iand** returns the bitwise logical AND of **i** and **j**. For each bit position, the result bit is 1 only if both corresponding bits in **i** and **j** are 1; otherwise the result bit is 0.\n\nTruth table for AND:\n```\ni bit | j bit | result\n------+-------+--------\n  0   |   0   |   0\n  0   |   1   |   0\n  1   |   0   |   0\n  1   |   1   |   1\n```\n\n### **Options**\n- **i**\n  : First `integer` operand.\n\n- **j**\n  : Second `integer` operand. Must have the same kind as **i**.\n\n### **Result**\nThe result is an `integer` of the same kind as the arguments, containing the bitwise AND of **i** and **j**.\n\n### **Examples**\n```fortran\nprogram demo_iand\n  implicit none\n  integer :: a, b, result\n  \n  a = 13   ! binary: 1101\n  b = 11   ! binary: 1011\n  \n  result = iand(a, b)  ! binary: 1001 = 9\n  \n  print '(a,i0,a,b8.8)', 'a      = ', a, '  binary: ', a\n  print '(a,i0,a,b8.8)', 'b      = ', b, '  binary: ', b\n  print '(a,i0,a,b8.8)', 'iand   = ', result, '  binary: ', result\n  \n  ! Practical: masking to extract lower 4 bits\n  print *\n  print '(a,i0)', 'Lower 4 bits of 255: ', iand(255, 15)\n  \n  ! Check if bit 2 is set using mask\n  print '(a,l1)', 'Bit 2 of 13 set? ', iand(13, 4) /= 0\nend program demo_iand\n```\nExpected output:\n```\na      = 13  binary: 00001101\nb      = 11  binary: 00001011\niand   = 9  binary: 00001001\n\nLower 4 bits of 255: 15\nBit 2 of 13 set? T\n```\n\n### **Standard**\nFortran 90\n\n### **See Also**\n[ior](#), [ieor](#), [not](#), [btest](#), [ibclr](#), [ibits](#), [ibset](#), [ishft](#), [ishftc](#), [bit_size](#)",

  "ior": "## **ior** - \\[BIT:MANIPULATION\\] Performs bitwise logical inclusive OR on two integers\n\n### **Synopsis**\n```fortran\nresult = ior(i, j)\n```\n\n```fortran\nelemental integer(kind=**) function ior(i, j)\n  integer(kind=**), intent(in) :: i\n  integer(kind=**), intent(in) :: j\nend function ior\n```\n\n### **Characteristics**\n- **i** and **j** must be of type `integer` with the same kind\n- The result has the same type and kind as the arguments\n- This is an elemental function\n\n### **Description**\n**ior** returns the bitwise logical inclusive OR of **i** and **j**. For each bit position, the result bit is 1 if either or both corresponding bits in **i** and **j** are 1; the result bit is 0 only if both input bits are 0.\n\nTruth table for OR:\n```\ni bit | j bit | result\n------+-------+--------\n  0   |   0   |   0\n  0   |   1   |   1\n  1   |   0   |   1\n  1   |   1   |   1\n```\n\n### **Options**\n- **i**\n  : First `integer` operand.\n\n- **j**\n  : Second `integer` operand. Must have the same kind as **i**.\n\n### **Result**\nThe result is an `integer` of the same kind as the arguments, containing the bitwise inclusive OR of **i** and **j**.\n\n### **Examples**\n```fortran\nprogram demo_ior\n  implicit none\n  integer :: a, b, result\n  \n  a = 12   ! binary: 1100\n  b = 10   ! binary: 1010\n  \n  result = ior(a, b)  ! binary: 1110 = 14\n  \n  print '(a,i0,a,b8.8)', 'a     = ', a, '  binary: ', a\n  print '(a,i0,a,b8.8)', 'b     = ', b, '  binary: ', b\n  print '(a,i0,a,b8.8)', 'ior   = ', result, '  binary: ', result\n  \n  ! Practical: setting specific bits\n  print *\n  print '(a,i0)', 'Set bit 3 of 1: ', ior(1, 8)   ! 1 + 8 = 9\n  \n  ! Combining flags\n  integer :: read_flag, write_flag, permissions\n  read_flag = 4    ! binary: 100\n  write_flag = 2   ! binary: 010\n  permissions = ior(read_flag, write_flag)  ! binary: 110 = 6\n  print '(a,i0)', 'Combined permissions: ', permissions\nend program demo_ior\n```\nExpected output:\n```\na     = 12  binary: 00001100\nb     = 10  binary: 00001010\nior   = 14  binary: 00001110\n\nSet bit 3 of 1: 9\nCombined permissions: 6\n```\n\n### **Standard**\nFortran 90\n\n### **See Also**\n[iand](#), [ieor](#), [not](#), [btest](#), [ibclr](#), [ibits](#), [ibset](#), [ishft](#), [ishftc](#), [bit_size](#)",

  "ieor": "## **ieor** - \\[BIT:MANIPULATION\\] Performs bitwise logical exclusive OR on two integers\n\n### **Synopsis**\n```fortran\nresult = ieor(i, j)\n```\n\n```fortran\nelemental integer(kind=**) function ieor(i, j)\n  integer(kind=**), intent(in) :: i\n  integer(kind=**), intent(in) :: j\nend function ieor\n```\n\n### **Characteristics**\n- **i** and **j** must be of type `integer` with the same kind\n- The result has the same type and kind as the arguments\n- This is an elemental function\n\n### **Description**\n**ieor** returns the bitwise logical exclusive OR (XOR) of **i** and **j**. For each bit position, the result bit is 1 if exactly one of the corresponding bits in **i** and **j** is 1; the result bit is 0 if both bits are the same.\n\nTruth table for XOR:\n```\ni bit | j bit | result\n------+-------+--------\n  0   |   0   |   0\n  0   |   1   |   1\n  1   |   0   |   1\n  1   |   1   |   0\n```\n\n### **Options**\n- **i**\n  : First `integer` operand.\n\n- **j**\n  : Second `integer` operand. Must have the same kind as **i**.\n\n### **Result**\nThe result is an `integer` of the same kind as the arguments, containing the bitwise exclusive OR of **i** and **j**.\n\n### **Examples**\n```fortran\nprogram demo_ieor\n  implicit none\n  integer :: a, b, result\n  \n  a = 13   ! binary: 1101\n  b = 11   ! binary: 1011\n  \n  result = ieor(a, b)  ! binary: 0110 = 6\n  \n  print '(a,i0,a,b8.8)', 'a      = ', a, '  binary: ', a\n  print '(a,i0,a,b8.8)', 'b      = ', b, '  binary: ', b\n  print '(a,i0,a,b8.8)', 'ieor   = ', result, '  binary: ', result\n  \n  ! Practical: toggle specific bits\n  print *\n  print '(a,i0)', 'Toggle bit 0 of 14: ', ieor(14, 1)  ! 14 -> 15\n  print '(a,i0)', 'Toggle bit 0 of 15: ', ieor(15, 1)  ! 15 -> 14\n  \n  ! XOR swap (without temporary variable)\n  integer :: x, y\n  x = 5\n  y = 9\n  print '(a,i0,a,i0)', 'Before swap: x=', x, ' y=', y\n  x = ieor(x, y)\n  y = ieor(y, x)\n  x = ieor(x, y)\n  print '(a,i0,a,i0)', 'After swap:  x=', x, ' y=', y\nend program demo_ieor\n```\nExpected output:\n```\na      = 13  binary: 00001101\nb      = 11  binary: 00001011\nieor   = 6  binary: 00000110\n\nToggle bit 0 of 14: 15\nToggle bit 0 of 15: 14\nBefore swap: x=5 y=9\nAfter swap:  x=9 y=5\n```\n\n### **Standard**\nFortran 90\n\n### **See Also**\n[iand](#), [ior](#), [not](#), [btest](#), [ibclr](#), [ibits](#), [ibset](#), [ishft](#), [ishftc](#), [bit_size](#)",

  "ibclr": "## **ibclr** - \\[BIT:MANIPULATION\\] Clears a specific bit to zero\n\n### **Synopsis**\n```fortran\nresult = ibclr(i, pos)\n```\n\n```fortran\nelemental integer(kind=**) function ibclr(i, pos)\n  integer(kind=**), intent(in) :: i\n  integer(kind=**), intent(in) :: pos\nend function ibclr\n```\n\n### **Characteristics**\n- **i** is of type `integer` (any kind)\n- **pos** is of type `integer` (any kind)\n- The result has the same type and kind as **i**\n- This is an elemental function\n\n### **Description**\n**ibclr** returns the value of **i** with the bit at position **pos** set to zero. All other bits remain unchanged. Bit positions are numbered from 0 (least significant) to `bit_size(i) - 1` (most significant).\n\nThe constraint `0 <= pos < bit_size(i)` must be satisfied.\n\n### **Options**\n- **i**\n  : The `integer` value to be modified.\n\n- **pos**\n  : The bit position to clear. Must be non-negative and less than `bit_size(i)`.\n\n### **Result**\nThe result is the value of **i** with bit **pos** set to 0.\n\n### **Examples**\n```fortran\nprogram demo_ibclr\n  implicit none\n  integer :: val, pos, result\n  \n  val = 15   ! binary: 1111\n  \n  print '(a,i0,a,b8.8)', 'Original value: ', val, '  binary: ', val\n  print *\n  \n  do pos = 0, 3\n    result = ibclr(val, pos)\n    print '(a,i0,a,i0,a,b8.8)', 'ibclr(', val, ',', pos, ') = ', result\n  end do\n  \n  ! Practical: clear specific flag\n  print *\n  integer :: flags\n  flags = 255  ! All 8 bits set\n  print '(a,b8.8)', 'Before clearing bit 4: ', flags\n  flags = ibclr(flags, 4)\n  print '(a,b8.8)', 'After clearing bit 4:  ', flags\nend program demo_ibclr\n```\nExpected output:\n```\nOriginal value: 15  binary: 00001111\n\nibclr(15,0) =         14\nibclr(15,1) =         13\nibclr(15,2) =         11\nibclr(15,3) =          7\n\nBefore clearing bit 4: 11111111\nAfter clearing bit 4:  11101111\n```\n\n### **Standard**\nFortran 90\n\n### **See Also**\n[ibset](#), [ibits](#), [btest](#), [iand](#), [ieor](#), [ior](#), [ishft](#), [ishftc](#), [not](#), [bit_size](#)",

  "ibset": "## **ibset** - \\[BIT:MANIPULATION\\] Sets a specific bit to one\n\n### **Synopsis**\n```fortran\nresult = ibset(i, pos)\n```\n\n```fortran\nelemental integer(kind=**) function ibset(i, pos)\n  integer(kind=**), intent(in) :: i\n  integer(kind=**), intent(in) :: pos\nend function ibset\n```\n\n### **Characteristics**\n- **i** is of type `integer` (any kind)\n- **pos** is of type `integer` (any kind)\n- The result has the same type and kind as **i**\n- This is an elemental function\n\n### **Description**\n**ibset** returns the value of **i** with the bit at position **pos** set to one. All other bits remain unchanged. Bit positions are numbered from 0 (least significant) to `bit_size(i) - 1` (most significant).\n\nThe constraint `0 <= pos < bit_size(i)` must be satisfied.\n\n### **Options**\n- **i**\n  : The `integer` value to be modified.\n\n- **pos**\n  : The bit position to set. Must be non-negative and less than `bit_size(i)`.\n\n### **Result**\nThe result is the value of **i** with bit **pos** set to 1.\n\n### **Examples**\n```fortran\nprogram demo_ibset\n  implicit none\n  integer :: val, pos, result\n  \n  val = 0   ! binary: 0000\n  \n  print '(a,i0,a,b8.8)', 'Original value: ', val, '  binary: ', val\n  print *\n  \n  ! Set bits one at a time to build powers of 2\n  do pos = 0, 3\n    result = ibset(val, pos)\n    print '(a,i0,a,i0,a,i2,a,b8.8)', &\n      'ibset(', val, ',', pos, ') = ', result, '  binary: ', result\n  end do\n  \n  ! Build a value by setting multiple bits\n  print *\n  val = 0\n  val = ibset(val, 0)  ! Set bit 0: val = 1\n  val = ibset(val, 2)  ! Set bit 2: val = 5\n  val = ibset(val, 3)  ! Set bit 3: val = 13\n  print '(a,i0,a,b8.8)', 'After setting bits 0,2,3: ', val, '  binary: ', val\nend program demo_ibset\n```\nExpected output:\n```\nOriginal value: 0  binary: 00000000\n\nibset(0,0) =  1  binary: 00000001\nibset(0,1) =  2  binary: 00000010\nibset(0,2) =  4  binary: 00000100\nibset(0,3) =  8  binary: 00001000\n\nAfter setting bits 0,2,3: 13  binary: 00001101\n```\n\n### **Standard**\nFortran 90\n\n### **See Also**\n[ibclr](#), [ibits](#), [btest](#), [iand](#), [ieor](#), [ior](#), [ishft](#), [ishftc](#), [not](#), [bit_size](#)",

  "ibits": "## **ibits** - \\[BIT:MANIPULATION\\] Extracts a contiguous field of bits\n\n### **Synopsis**\n```fortran\nresult = ibits(i, pos, len)\n```\n\n```fortran\nelemental integer(kind=**) function ibits(i, pos, len)\n  integer(kind=**), intent(in) :: i\n  integer(kind=**), intent(in) :: pos\n  integer(kind=**), intent(in) :: len\nend function ibits\n```\n\n### **Characteristics**\n- **i** is of type `integer` (any kind)\n- **pos** is of type `integer` (any kind)\n- **len** is of type `integer` (any kind)\n- The result has the same type and kind as **i**\n- This is an elemental function\n\n### **Description**\n**ibits** extracts a field of **len** bits from **i**, starting at bit position **pos**, and returns them right-justified with all other bits set to zero. The extracted bits occupy positions 0 through **len**-1 in the result.\n\nThe constraints `pos >= 0`, `len >= 0`, and `pos + len <= bit_size(i)` must be satisfied.\n\n### **Options**\n- **i**\n  : The `integer` value from which to extract bits.\n\n- **pos**\n  : The starting bit position for extraction (0 = least significant).\n\n- **len**\n  : The number of bits to extract.\n\n### **Result**\nThe result contains the **len** bits from positions **pos** to **pos+len-1** of **i**, right-justified in the result with remaining bits set to zero.\n\n### **Examples**\n```fortran\nprogram demo_ibits\n  implicit none\n  integer :: val, extracted\n  \n  val = 255  ! binary: 11111111\n  \n  print '(a,i0,a,b8.8)', 'Original: ', val, '  binary: ', val\n  print *\n  \n  ! Extract different bit fields\n  extracted = ibits(val, 0, 4)  ! Lower 4 bits\n  print '(a,i0,a,b8.8)', 'ibits(255,0,4) = ', extracted, '  binary: ', extracted\n  \n  extracted = ibits(val, 4, 4)  ! Upper 4 bits\n  print '(a,i0,a,b8.8)', 'ibits(255,4,4) = ', extracted, '  binary: ', extracted\n  \n  ! Extract from a specific pattern\n  val = 182  ! binary: 10110110\n  print *\n  print '(a,i0,a,b8.8)', 'Value: ', val, '  binary: ', val\n  \n  ! Extract bits 2-4 (3 bits starting at position 2)\n  extracted = ibits(val, 2, 3)\n  print '(a,i0,a,b8.8)', 'ibits(182,2,3) = ', extracted, '  binary: ', extracted\n  \n  ! Practical: extract byte from 32-bit integer\n  integer :: word\n  word = 305419896  ! hex: 0x12345678\n  print *\n  print '(a,z8.8)', 'Word in hex: ', word\n  print '(a,z2.2)', 'Byte 0 (bits 0-7):   ', ibits(word, 0, 8)\n  print '(a,z2.2)', 'Byte 1 (bits 8-15):  ', ibits(word, 8, 8)\n  print '(a,z2.2)', 'Byte 2 (bits 16-23): ', ibits(word, 16, 8)\n  print '(a,z2.2)', 'Byte 3 (bits 24-31): ', ibits(word, 24, 8)\nend program demo_ibits\n```\nExpected output:\n```\nOriginal: 255  binary: 11111111\n\nibits(255,0,4) = 15  binary: 00001111\nibits(255,4,4) = 15  binary: 00001111\n\nValue: 182  binary: 10110110\nibits(182,2,3) = 5  binary: 00000101\n\nWord in hex: 12345678\nByte 0 (bits 0-7):   78\nByte 1 (bits 8-15):  56\nByte 2 (bits 16-23): 34\nByte 3 (bits 24-31): 12\n```\n\n### **Standard**\nFortran 90\n\n### **See Also**\n[ibclr](#), [ibset](#), [btest](#), [iand](#), [ieor](#), [ior](#), [ishft](#), [ishftc](#), [not](#), [bit_size](#), [mvbits](#)",

  "ishft": "## **ishft** - \\[BIT:MANIPULATION\\] Performs logical shift of bits\n\n### **Synopsis**\n```fortran\nresult = ishft(i, shift)\n```\n\n```fortran\nelemental integer(kind=**) function ishft(i, shift)\n  integer(kind=**), intent(in) :: i\n  integer(kind=**), intent(in) :: shift\nend function ishft\n```\n\n### **Characteristics**\n- **i** is of type `integer` (any kind)\n- **shift** is of type `integer` (any kind)\n- The result has the same type and kind as **i**\n- This is an elemental function\n\n### **Description**\n**ishft** returns the value of **i** with all bits shifted **shift** positions. Positive **shift** values shift bits left (toward higher bit positions), negative values shift bits right (toward lower bit positions), and zero means no shift.\n\nBits shifted out of either end are lost. Zeros are shifted in from the opposite end. The constraint `|shift| <= bit_size(i)` must be satisfied.\n\nThis is a *logical* shift, not an arithmetic shift - the sign bit receives the same treatment as other bits.\n\n### **Options**\n- **i**\n  : The `integer` value to be shifted.\n\n- **shift**\n  : The number of bit positions to shift. Positive shifts left, negative shifts right.\n\n### **Result**\nThe result is **i** with bits shifted **shift** positions, with zeros filling vacated positions.\n\n### **Examples**\n```fortran\nprogram demo_ishft\n  implicit none\n  integer :: val, result\n  \n  val = 1  ! binary: 00000001\n  \n  print '(a,i0,a,b8.8)', 'Original: ', val, '  binary: ', val\n  print *\n  \n  ! Left shifts (multiply by powers of 2)\n  print '(a)', 'Left shifts:'\n  result = ishft(val, 1)  ! 1 * 2 = 2\n  print '(a,i0,a,b8.8)', '  ishft(1,1)  = ', result, '  binary: ', result\n  result = ishft(val, 3)  ! 1 * 8 = 8\n  print '(a,i0,a,b8.8)', '  ishft(1,3)  = ', result, '  binary: ', result\n  result = ishft(val, 7)  ! 1 * 128 = 128\n  print '(a,i0,a,b8.8)', '  ishft(1,7)  = ', result, '  binary: ', result\n  \n  ! Right shifts (divide by powers of 2)\n  print *\n  val = 128  ! binary: 10000000\n  print '(a)', 'Right shifts:'\n  result = ishft(val, -1)  ! 128 / 2 = 64\n  print '(a,i0,a,b8.8)', '  ishft(128,-1) = ', result, '  binary: ', result\n  result = ishft(val, -3)  ! 128 / 8 = 16\n  print '(a,i0,a,b8.8)', '  ishft(128,-3) = ', result, '  binary: ', result\n  \n  ! Bits shifted out are lost\n  print *\n  val = 255  ! binary: 11111111\n  print '(a,i0,a,b8.8)', 'Original: ', val, '  binary: ', val\n  result = ishft(val, 4)\n  print '(a,i0,a,b16.16)', '  ishft(255,4) = ', result, '  binary: ', result\nend program demo_ishft\n```\nExpected output:\n```\nOriginal: 1  binary: 00000001\n\nLeft shifts:\n  ishft(1,1)  = 2  binary: 00000010\n  ishft(1,3)  = 8  binary: 00001000\n  ishft(1,7)  = 128  binary: 10000000\n\nRight shifts:\n  ishft(128,-1) = 64  binary: 01000000\n  ishft(128,-3) = 16  binary: 00010000\n\nOriginal: 255  binary: 11111111\n  ishft(255,4) = 4080  binary: 0000111111110000\n```\n\n### **Standard**\nFortran 90\n\n### **See Also**\n[ishftc](#), [ibits](#), [ibclr](#), [ibset](#), [btest](#), [iand](#), [ieor](#), [ior](#), [not](#), [bit_size](#)",

  "ishftc": "## **ishftc** - \\[BIT:MANIPULATION\\] Performs circular shift of bits\n\n### **Synopsis**\n```fortran\nresult = ishftc(i, shift [, size])\n```\n\n```fortran\nelemental integer(kind=**) function ishftc(i, shift, size)\n  integer(kind=**), intent(in) :: i\n  integer(kind=**), intent(in) :: shift\n  integer(kind=**), intent(in), optional :: size\nend function ishftc\n```\n\n### **Characteristics**\n- **i** is of type `integer` (any kind)\n- **shift** is of type `integer` (any kind)\n- **size** (optional) is of type `integer` (any kind)\n- The result has the same type and kind as **i**\n- This is an elemental function\n\n### **Description**\n**ishftc** returns the value of **i** with the rightmost **size** bits shifted circularly **shift** positions. Bits shifted out of one end are shifted into the other end. Positive **shift** rotates left, negative rotates right.\n\nIf **size** is omitted, it defaults to `bit_size(i)`, rotating all bits. The constraints `|shift| <= size` and `0 < size <= bit_size(i)` must be satisfied.\n\n### **Options**\n- **i**\n  : The `integer` value to be rotated.\n\n- **shift**\n  : The number of bit positions to rotate. Positive rotates left, negative rotates right.\n\n- **size**\n  : (Optional) The number of rightmost bits to include in the rotation. Defaults to `bit_size(i)`.\n\n### **Result**\nThe result is **i** with the rightmost **size** bits circularly shifted **shift** positions.\n\n### **Examples**\n```fortran\nprogram demo_ishftc\n  implicit none\n  integer :: val, result\n  \n  val = 1  ! binary: 00000001\n  \n  print '(a,i0,a,b8.8)', 'Original: ', val, '  binary: ', val\n  print *\n  \n  ! Circular left shift (within 8 bits for clarity)\n  print '(a)', 'Circular left shifts in 8 bits:'\n  result = ishftc(val, 1, 8)\n  print '(a,i0,a,b8.8)', '  ishftc(1,1,8)  = ', result, '  binary: ', result\n  result = ishftc(val, 7, 8)\n  print '(a,i0,a,b8.8)', '  ishftc(1,7,8)  = ', result, '  binary: ', result\n  result = ishftc(val, 8, 8)  ! Full rotation returns to original\n  print '(a,i0,a,b8.8)', '  ishftc(1,8,8)  = ', result, '  binary: ', result\n  \n  ! Circular right shift\n  print *\n  val = 128  ! binary: 10000000\n  print '(a)', 'Circular right shifts in 8 bits:'\n  result = ishftc(val, -1, 8)\n  print '(a,i0,a,b8.8)', '  ishftc(128,-1,8) = ', result, '  binary: ', result\n  result = ishftc(val, -7, 8)\n  print '(a,i0,a,b8.8)', '  ishftc(128,-7,8) = ', result, '  binary: ', result\n  \n  ! Partial rotation (only lower 4 bits)\n  print *\n  val = 15  ! binary: 00001111\n  print '(a,i0,a,b8.8)', 'Original: ', val, '  binary: ', val\n  result = ishftc(val, 2, 4)  ! Rotate lower 4 bits left by 2\n  print '(a,i0,a,b8.8)', '  ishftc(15,2,4)  = ', result, '  binary: ', result\n  ! Lower 4 bits: 1111 -> rotate left 2 -> 1111 (no change for all 1s)\n  \n  val = 9  ! binary: 00001001\n  print '(a,i0,a,b8.8)', 'Original: ', val, '  binary: ', val\n  result = ishftc(val, 2, 4)  ! Lower 4 bits: 1001 -> 0110 = 6\n  print '(a,i0,a,b8.8)', '  ishftc(9,2,4)   = ', result, '  binary: ', result\nend program demo_ishftc\n```\nExpected output:\n```\nOriginal: 1  binary: 00000001\n\nCircular left shifts in 8 bits:\n  ishftc(1,1,8)  = 2  binary: 00000010\n  ishftc(1,7,8)  = 128  binary: 10000000\n  ishftc(1,8,8)  = 1  binary: 00000001\n\nCircular right shifts in 8 bits:\n  ishftc(128,-1,8) = 64  binary: 01000000\n  ishftc(128,-7,8) = 1  binary: 00000001\n\nOriginal: 15  binary: 00001111\n  ishftc(15,2,4)  = 15  binary: 00001111\nOriginal: 9  binary: 00001001\n  ishftc(9,2,4)   = 6  binary: 00000110\n```\n\n### **Standard**\nFortran 90\n\n### **See Also**\n[ishft](#), [ibits](#), [ibclr](#), [ibset](#), [btest](#), [iand](#), [ieor](#), [ior](#), [not](#), [bit_size](#)",

  "not": "## **not** - \\[BIT:MANIPULATION\\] Returns the bitwise logical complement\n\n### **Synopsis**\n```fortran\nresult = not(i)\n```\n\n```fortran\nelemental integer(kind=**) function not(i)\n  integer(kind=**), intent(in) :: i\nend function not\n```\n\n### **Characteristics**\n- **i** is of type `integer` (any kind)\n- The result has the same type and kind as **i**\n- This is an elemental function\n\n### **Description**\n**not** returns the bitwise logical complement (one's complement) of **i**. Each bit of the result is the opposite of the corresponding bit in **i**: 0 becomes 1, and 1 becomes 0.\n\nTruth table for NOT:\n```\ni bit | result\n------+--------\n  0   |   1\n  1   |   0\n```\n\nFor signed integers, `not(i)` is equivalent to `-(i + 1)` in two's complement representation.\n\n### **Options**\n- **i**\n  : The `integer` value to complement.\n\n### **Result**\nThe result is an `integer` of the same kind as **i**, containing the bitwise complement of **i**.\n\n### **Examples**\n```fortran\nprogram demo_not\n  implicit none\n  integer :: val, result\n  integer(kind=1) :: byte\n  \n  ! Simple complement\n  val = 0\n  result = not(val)\n  print '(a,i0,a,i0)', 'not(0) = ', result, '  (all bits set to 1 = -1)'\n  \n  val = -1  ! All bits are 1\n  result = not(val)\n  print '(a,i0)', 'not(-1) = ', result\n  \n  ! Working with bytes for clearer visualization\n  print *\n  byte = 0_1\n  print '(a,b8.8,a,b8.8)', 'not(00000000) = ', byte, ' -> ', not(byte)\n  \n  byte = 15_1  ! binary: 00001111\n  print '(a,b8.8,a,b8.8)', 'not(00001111) = ', byte, ' -> ', not(byte)\n  \n  byte = -86_1  ! binary: 10101010\n  print '(a,b8.8,a,b8.8)', 'not(10101010) = ', byte, ' -> ', not(byte)\n  \n  ! Practical: create bitmask with all bits set except one\n  print *\n  integer :: mask\n  mask = not(ishft(1, 3))  ! All bits except bit 3\n  print '(a,b32.32)', 'Mask with bit 3 clear: ', mask\n  \n  ! Use with iand to clear a specific bit\n  val = 255\n  result = iand(val, not(ishft(1, 4)))  ! Clear bit 4\n  print '(a,i0,a,b8.8)', 'Clear bit 4 of 255: ', result, '  binary: ', result\nend program demo_not\n```\nExpected output:\n```\nnot(0) = -1  (all bits set to 1 = -1)\nnot(-1) = 0\n\nnot(00000000) = 00000000 -> 11111111\nnot(00001111) = 00001111 -> 11110000\nnot(10101010) = 10101010 -> 01010101\n\nMask with bit 3 clear: 11111111111111111111111111110111\nClear bit 4 of 255: 239  binary: 11101111\n```\n\n### **Standard**\nFortran 90\n\n### **See Also**\n[iand](#), [ior](#), [ieor](#), [btest](#), [ibclr](#), [ibits](#), [ibset](#), [ishft](#), [ishftc](#), [bit_size](#)"
}
