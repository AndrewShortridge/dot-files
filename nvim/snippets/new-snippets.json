{
  "Abstract Type": {
    "prefix": [
      "abstracttype",
      "ABSTRACTTYPE",
      "abstract",
      "ABSTRACT"
    ],
    "body": [
      "type, abstract :: ${1:type_name}",
      "\tprivate",
      "\t${2:integer} :: ${3:component}",
      "contains",
      "\tprocedure :: ${4:concrete_method} => ${1:type_name}_${4:concrete_method}",
      "\tprocedure(${5:interface_name}), deferred :: ${6:deferred_method}",
      "end type ${1:type_name}",
      "",
      "abstract interface",
      "\t${7:subroutine} ${5:interface_name}(${8:self})",
      "\t\timport :: ${1:type_name}",
      "\t\tclass(${1:type_name}), intent(${9:inout}) :: ${8:self}",
      "\tend ${7:subroutine} ${5:interface_name}",
      "end interface",
      "${0}"
    ],
    "description": "TYPE, ABSTRACT :: name defines an abstract derived type that cannot be instantiated directly but serves as a base for type extension with deferred procedures."
  },
  "_documentation": {
    "write_to_string": {
      "name": "**write** (internal) - \\[IO:OUTPUT\\] Write values to a character string (internal file)",
      "synopsis": {
        "usage": "```fortran\n    write(string, format_spec) value_list\n```",
        "interface": "```fortran\n     write(unit, fmt) output_list\n\n      character(len=*)         :: unit      ! Internal file (string)\n      character(len=*), intent(in) :: fmt   ! Format specification\n      type(*), intent(in)      :: output_list(..)  ! Values to write\n```"
      },
      "characteristics": [
        "**unit** is a character variable (scalar or array) that receives the formatted output.",
        "**fmt** is a format specification (character expression, label, or * for list-directed).",
        "**output_list** contains the values to be converted to character representation.",
        "The character variable must be long enough to hold the formatted output.",
        "This is an internal write - no actual file I/O occurs."
      ],
      "description": "**write** (internal) converts values from their internal representation to character form and stores the result in a character variable. This is Fortran's mechanism for converting numeric or other data types to strings, similar to sprintf in C or str() in Python. The format specification controls how each value is converted.",
      "options": {
        "unit": "A character variable (the internal file) that will receive the formatted output. For array units, each record is written to successive array elements.",
        "fmt": "Format specification controlling the output conversion. Can be:\n  - A character expression containing format edit descriptors: '(A,I0,F8.2)'\n  - An asterisk (*) for list-directed formatting\n  - A statement label referencing a FORMAT statement",
        "output_list": "One or more variables, constants, or expressions to be converted. Types include INTEGER, REAL, COMPLEX, LOGICAL, and CHARACTER."
      },
      "examples": {
        "code": "program demo_write_to_string\nimplicit none\n  character(len=50) :: str\n  character(len=20) :: num_str\n  integer :: i, error_code\n  real :: x\n  character(len=10) :: name\n\n  ! Basic integer to string conversion\n  i = 42\n  write(num_str, '(I0)') i\n  print *, 'Integer as string: [', trim(num_str), ']'\n\n  ! Real number with formatting\n  x = 3.14159\n  write(num_str, '(F8.3)') x\n  print *, 'Real as string: [', trim(num_str), ']'\n\n  ! Combining multiple values\n  name = 'Value'\n  i = 100\n  x = 2.5\n  write(str, '(A,A,I0,A,F6.2)') trim(name), ' = ', i, ' or ', x\n  print *, 'Combined: [', trim(str), ']'\n\n  ! Building formatted messages\n  error_code = 404\n  write(str, '(A,I0)') 'Error code: ', error_code\n  print *, trim(str)\n\n  ! List-directed (free format)\n  write(str, *) i, x\n  print *, 'List-directed: [', trim(str), ']'\n\nend program demo_write_to_string",
        "results": "```text\n Integer as string: [42]\n Real as string: [   3.142]\n Combined: [Value = 100 or   2.50]\n Error code: 404\n List-directed: [        100   2.500000]\n```"
      },
      "standard": "Fortran 77",
      "see_also": [
        "[**read**](#read) (internal) - Read from a character string",
        "[**write**](#write) (external) - Write to an external file",
        "[**print**](#print) - Write to standard output",
        "[**format**](#format) - Format edit descriptors"
      ]
    }
  },
  "Allocatable Array 1D": {
    "prefix": [
      "array1d",
      "ARRAY1D",
      "allocatable1d",
      "ALLOCATABLE1D"
    ],
    "body": "${1:real}(${2:dp}), allocatable :: ${3:arr}(:)",
    "description": "TYPE(KIND), ALLOCATABLE :: ARR(:) declares a one-dimensional allocatable array with deferred shape.",
    "documentation": {
      "name": "**allocatable_array_1d** - \\[MEMORY:ALLOCATION\\] Declare a one-dimensional allocatable array with deferred shape",
      "synopsis": {
        "usage": [
          "    type(kind), allocatable :: array_name(:)"
        ],
        "interface": [
          "     ! Declaration",
          "     real(dp), allocatable :: arr(:)",
          "",
          "     ! Allocation",
          "     allocate(arr(n), stat=istat)",
          "",
          "     ! Deallocation",
          "     deallocate(arr, stat=istat)"
        ]
      },
      "characteristics": [
        "**type** can be any intrinsic type (integer, real, complex, logical, character) or derived type",
        "**kind** specifies the kind type parameter (e.g., dp for double precision, sp for single precision)",
        "**array_name** is the identifier for the allocatable array variable",
        "The array has deferred shape indicated by the colon (:) in the dimension specification",
        "No storage is associated until the ALLOCATE statement is executed",
        "Memory is automatically deallocated when the variable goes out of scope"
      ],
      "description": "**allocatable_array_1d** declares a one-dimensional array with the ALLOCATABLE attribute. The array has deferred shape, meaning its bounds are not specified at declaration time but are determined dynamically at runtime through the ALLOCATE statement. This provides flexible memory management where array sizes can be computed during program execution. The ALLOCATABLE attribute provides safe memory handling with automatic deallocation when the variable goes out of scope, eliminating the possibility of memory leaks.",
      "options": [
        {
          "name": "type",
          "description": "The data type of the array elements. Can be any intrinsic type (INTEGER, REAL, COMPLEX, LOGICAL, CHARACTER) or a user-defined derived type. Examples: real, integer, complex, character(len=*)."
        },
        {
          "name": "kind",
          "description": "The kind type parameter specifying precision or storage size. Common values include: dp (double precision), sp (single precision), int32, int64, or numeric literals like 4, 8. If omitted, default kind is used."
        },
        {
          "name": "array_name",
          "description": "The identifier for the allocatable array variable. Must follow Fortran naming rules: start with a letter, contain only letters, digits, and underscores, maximum 63 characters in Fortran 90/95 or 63+ in later standards."
        }
      ],
      "examples": {
        "code": [
          "program demo_allocatable_array_1d",
          "  implicit none",
          "  integer, parameter :: dp = selected_real_kind(15, 307)",
          "  real(dp), allocatable :: values(:)",
          "  integer :: n, i, alloc_stat",
          "",
          "  ! Determine size at runtime",
          "  n = 5",
          "",
          "  ! Allocate with status checking",
          "  allocate(values(n), stat=alloc_stat)",
          "  if (alloc_stat /= 0) then",
          "    print *, 'Error: Memory allocation failed'",
          "    stop 1",
          "  end if",
          "",
          "  ! Initialize array elements",
          "  do i = 1, n",
          "    values(i) = real(i, dp) * 1.5_dp",
          "  end do",
          "",
          "  ! Use the array",
          "  print '(a)', 'Array values:'",
          "  print '(5f8.2)', values",
          "  print '(a,f8.2)', 'Sum: ', sum(values)",
          "",
          "  ! Check allocation status before operations",
          "  if (allocated(values)) then",
          "    print '(a,i0)', 'Array size: ', size(values)",
          "  end if",
          "",
          "  ! Deallocate when done (optional - automatic at end of scope)",
          "  deallocate(values, stat=alloc_stat)",
          "  if (alloc_stat /= 0) then",
          "    print *, 'Warning: Deallocation failed'",
          "  end if",
          "",
          "end program demo_allocatable_array_1d"
        ],
        "results": [
          "Array values:",
          "    1.50    3.00    4.50    6.00    7.50",
          "Sum:    22.50",
          "Array size: 5"
        ]
      },
      "standard": "Fortran 90",
      "see_also": [
        "[**allocate**(3)](#allocate) - Allocate storage for allocatable arrays",
        "[**deallocate**(3)](#deallocate) - Release storage for allocatable arrays",
        "[**allocated**(3)](#allocated) - Query allocation status of an allocatable array",
        "[**move_alloc**(3)](#move_alloc) - Transfer allocation between variables (Fortran 2003)",
        "[**size**(3)](#size) - Query the size of an array",
        "[**lbound**(3)](#lbound) - Query the lower bounds of an array",
        "[**ubound**(3)](#ubound) - Query the upper bounds of an array"
      ],
      "notes": [
        "Always check allocation status with STAT= to handle memory allocation failures gracefully",
        "Use ALLOCATED() intrinsic before DEALLOCATE to avoid deallocating unallocated arrays",
        "Prefer allocatable arrays over pointers for memory safety - they cannot create memory leaks",
        "In Fortran 2003+, allocatable arrays can be passed as procedure arguments with the ALLOCATABLE attribute",
        "In Fortran 2003+, allocatable arrays can be components of derived types",
        "When passing allocated arrays to procedures, assumed-shape dummy arguments (:) are typically preferred"
      ],
      "resources": [
        "[Fortran-lang Best Practices: Allocatable Arrays](https://fortran-lang.org/learn/best_practices/allocatable_arrays/)",
        "[Stanford Fortran 90 Tutorial: Arrays](https://web.stanford.edu/class/me200c/tutorial_90/07_arrays.html)"
      ]
    }
  },
  "Allocatable Array 2D": {
    "prefix": [
      "alloc2d",
      "ALLOC2D",
      "allocmat",
      "ALLOCMAT",
      "array2d",
      "ARRAY2D"
    ],
    "body": [
      "${1:real(dp)}, allocatable :: ${2:mat}(:,:)"
    ],
    "description": "TYPE, ALLOCATABLE :: NAME(:,:) declares a two-dimensional allocatable array.",
    "documentation": {
      "name": "**allocatable_array_2d** - \\[MEMORY:ALLOCATION\\] Declare a two-dimensional allocatable array",
      "synopsis": {
        "usage": [
          "```fortran",
          "    type, allocatable :: array_name(:,:)",
          "```"
        ],
        "interface": [
          "```fortran",
          "     ! Declaration syntax for 2D allocatable array",
          "",
          "      type(kind=**), allocatable :: array_name(:,:)",
          "",
          "     ! Allocation with explicit bounds",
          "",
          "      allocate(array_name(lower1:upper1, lower2:upper2), stat=ierr)",
          "",
          "     ! Deallocation",
          "",
          "      deallocate(array_name, stat=ierr)",
          "```"
        ]
      },
      "characteristics": [
        "**type** can be any intrinsic type (integer, real, complex, logical, character) or derived type.",
        "**kind** specifies the kind type parameter (e.g., dp for double precision real).",
        "**array_name** must be a valid Fortran identifier.",
        "The array has deferred shape indicated by (:,:) with two dimensions.",
        "The array is initially unallocated; it must be allocated before use.",
        "The ALLOCATED intrinsic can query allocation status.",
        "Allocatable arrays are automatically deallocated when they go out of scope (Fortran 95+)."
      ],
      "description": [
        "**allocatable_array_2d** declares a two-dimensional array with the ALLOCATABLE",
        "attribute. This allows dynamic memory allocation at runtime, where the array",
        "dimensions are not known until execution time. The deferred-shape specification",
        "(:,:) indicates two dimensions whose extents are determined when the array is",
        "allocated using the ALLOCATE statement.",
        "",
        "The ALLOCATABLE attribute provides safe memory management compared to pointers.",
        "Memory is automatically deallocated when the variable goes out of scope,",
        "eliminating the possibility of memory leaks. This makes allocatable arrays",
        "the preferred choice for dynamic arrays in modern Fortran."
      ],
      "options": [
        "- **type**",
        "  : The data type of the array elements. Valid types include:",
        "    - `integer` (with optional kind: integer(4), integer(8))",
        "    - `real` (with optional kind: real(sp), real(dp), real(qp))",
        "    - `complex` (with optional kind: complex(dp))",
        "    - `logical`",
        "    - `character(len=N)`",
        "    - Any user-defined derived type",
        "",
        "- **allocatable**",
        "  : The ALLOCATABLE attribute keyword indicating deferred allocation.",
        "",
        "- **array_name**",
        "  : A valid Fortran identifier for the array variable.",
        "",
        "- **(:,:)**",
        "  : Deferred-shape specification for a rank-2 (two-dimensional) array.",
        "    The colons indicate that bounds will be specified at allocation time."
      ],
      "examples": [
        "Sample program:",
        "```fortran",
        "program demo_allocatable_array_2d",
        "  implicit none",
        "  integer, parameter :: dp = selected_real_kind(15, 307)",
        "  real(dp), allocatable :: matrix(:,:)",
        "  real(dp), allocatable :: grid(:,:)",
        "  integer :: i, j, ierr",
        "  integer :: nrows, ncols",
        "",
        "  ! Set dimensions at runtime",
        "  nrows = 3",
        "  ncols = 4",
        "",
        "  ! Allocate the matrix with explicit bounds",
        "  allocate(matrix(nrows, ncols), stat=ierr)",
        "  if (ierr /= 0) then",
        "    print *, 'Allocation failed!'",
        "    stop 1",
        "  end if",
        "",
        "  ! Initialize the matrix",
        "  do j = 1, ncols",
        "    do i = 1, nrows",
        "      matrix(i, j) = real(i * 10 + j, dp)",
        "    end do",
        "  end do",
        "",
        "  ! Print the matrix",
        "  print *, 'Matrix contents:'",
        "  do i = 1, nrows",
        "    print '(4F8.1)', matrix(i, :)",
        "  end do",
        "",
        "  ! Check allocation status",
        "  print *, 'Matrix allocated:', allocated(matrix)",
        "",
        "  ! Allocate with non-default lower bounds (1-indexed by default)",
        "  allocate(grid(0:2, -1:1), stat=ierr)",
        "  if (ierr == 0) then",
        "    print *, 'Grid bounds: rows', lbound(grid,1), 'to', ubound(grid,1)",
        "    print *, '            cols', lbound(grid,2), 'to', ubound(grid,2)",
        "  end if",
        "",
        "  ! Explicit deallocation (optional - automatic on scope exit)",
        "  if (allocated(matrix)) deallocate(matrix)",
        "  if (allocated(grid)) deallocate(grid)",
        "",
        "  print *, 'Matrix allocated after deallocate:', allocated(matrix)",
        "",
        "end program demo_allocatable_array_2d",
        "```",
        "Results:",
        "```text",
        " Matrix contents:",
        "    11.0    12.0    13.0    14.0",
        "    21.0    22.0    23.0    24.0",
        "    31.0    32.0    33.0    34.0",
        " Matrix allocated: T",
        " Grid bounds: rows           0 to           2",
        "             cols          -1 to           1",
        " Matrix allocated after deallocate: F",
        "```"
      ],
      "standard": "Fortran 90 (ISO/IEC 1539:1991, sections 5.2.6, 6.3.1, 6.3.3)",
      "see_also": [
        "[**allocate**(3)](#allocate) - Allocate memory for allocatable arrays",
        "[**deallocate**(3)](#deallocate) - Free memory for allocatable arrays",
        "[**allocated**(3)](#allocated) - Query allocation status",
        "[**move_alloc**(3)](#move_alloc) - Move allocation between arrays (Fortran 2003)",
        "[**lbound**(3)](#lbound) - Query lower bounds of array",
        "[**ubound**(3)](#ubound) - Query upper bounds of array",
        "[**size**(3)](#size) - Query total size or extent of array",
        "[**shape**(3)](#shape) - Query shape of array"
      ]
    }
  },
  "Allocate 2D Array": {
    "prefix": [
      "allocarr2d",
      "ALLOCARR2D",
      "allocmat",
      "ALLOCMAT"
    ],
    "body": [
      "allocate(${1:mat}(${2:m}, ${3:n}), stat=${4:ierr})",
      "if (${4:ierr} /= 0) error stop 'Allocation of ${1:mat} failed'"
    ],
    "description": "allocate(mat(m,n),stat=ierr) dynamically allocates a rank-2 array with error handling.",
    "documentation": {
      "name": "**allocate 2D array** - \\[MEMORY:ALLOCATION\\] Dynamically allocate a rank-2 (matrix) array with error handling",
      "synopsis": {
        "usage": [
          "```fortran",
          "    allocate(array_name(rows, cols), stat=status_variable)",
          "    if (status_variable /= 0) error stop 'Allocation failed'",
          "```"
        ],
        "interface": [
          "```fortran",
          "    ! Declaration (must appear in specification part)",
          "    type, allocatable :: array_name(:,:)",
          "    integer           :: status_variable",
          "",
          "    ! Allocation (executable statement)",
          "    allocate(array_name(lower1:upper1, lower2:upper2), stat=status_variable)",
          "```"
        ]
      },
      "characteristics": [
        "- **array_name** must be declared with the ALLOCATABLE attribute and assumed-shape bounds (:,:)",
        "- **rows** and **cols** (or lower:upper bounds) must be scalar integer expressions",
        "- **status_variable** must be a scalar integer variable not allocated in the same statement",
        "- The array must not already be allocated (use ALLOCATED intrinsic to check)",
        "- Storage is uninitialized after successful allocation",
        "- Valid for any intrinsic or derived type (REAL, INTEGER, COMPLEX, TYPE, etc.)"
      ],
      "description": [
        "The **ALLOCATE** statement dynamically creates storage for allocatable arrays",
        "at runtime. This pattern allocates a rank-2 (matrix) array with specified",
        "dimensions and includes defensive error handling via the STAT= specifier.",
        "",
        "If STAT= is present, the status variable receives zero on success or a",
        "positive integer on failure. Without STAT=, allocation errors cause",
        "immediate program termination.",
        "",
        "Common failure conditions include:",
        "- Insufficient memory for the requested size",
        "- Array already allocated (must deallocate first or use ALLOCATED check)",
        "- Invalid bounds (e.g., negative extents where not permitted)"
      ],
      "options": {
        "array_name": {
          "description": "The allocatable array to be allocated. Must be declared with the ALLOCATABLE attribute and deferred-shape specification (:,:) for rank-2.",
          "example": "real, allocatable :: matrix(:,:)"
        },
        "rows": {
          "description": "First dimension extent (number of rows). Can be a simple upper bound or explicit lower:upper bounds. Must be a scalar integer expression.",
          "example": "100 or 0:99 or m"
        },
        "cols": {
          "description": "Second dimension extent (number of columns). Can be a simple upper bound or explicit lower:upper bounds. Must be a scalar integer expression.",
          "example": "50 or 1:n or size(other_array,2)"
        },
        "status_variable": {
          "description": "Scalar integer variable to receive allocation status. Set to 0 on success, positive value on error. Cannot be allocated in the same ALLOCATE statement.",
          "example": "ierr, alloc_stat, ios"
        }
      },
      "examples": {
        "sample_program": [
          "```fortran",
          "program demo_allocate_2d",
          "  implicit none",
          "  real, allocatable :: matrix(:,:)",
          "  real, allocatable :: work(:,:)",
          "  integer :: ierr, m, n",
          "",
          "  ! Get dimensions (could be from user input or computed)",
          "  m = 100",
          "  n = 50",
          "",
          "  ! Basic allocation with error handling",
          "  allocate(matrix(m, n), stat=ierr)",
          "  if (ierr /= 0) error stop 'Allocation of matrix failed'",
          "",
          "  ! Initialize the array",
          "  matrix = 0.0",
          "",
          "  ! Verify allocation and bounds",
          "  print '(a,l1)', 'Matrix allocated: ', allocated(matrix)",
          "  print '(a,2i5)', 'Shape: ', shape(matrix)",
          "  print '(a,2i5)', 'Lower bounds: ', lbound(matrix)",
          "  print '(a,2i5)', 'Upper bounds: ', ubound(matrix)",
          "",
          "  ! Allocation with explicit lower bounds (0-indexed)",
          "  allocate(work(0:m-1, 0:n-1), stat=ierr)",
          "  if (ierr /= 0) error stop 'Allocation of work failed'",
          "",
          "  print '(a,2i5)', 'Work lower bounds: ', lbound(work)",
          "  print '(a,2i5)', 'Work upper bounds: ', ubound(work)",
          "",
          "  ! Clean up",
          "  deallocate(matrix, work)",
          "",
          "end program demo_allocate_2d",
          "```"
        ],
        "expected_output": [
          "```text",
          "Matrix allocated: T",
          "Shape:   100   50",
          "Lower bounds:     1    1",
          "Upper bounds:   100   50",
          "Work lower bounds:     0    0",
          "Work upper bounds:    99   49",
          "```"
        ]
      },
      "standard": "Fortran 90 (ISO/IEC 1539:1991). The ALLOCATE statement and ALLOCATABLE attribute were introduced in Fortran 90. Enhanced in Fortran 2003 with ERRMSG= and SOURCE=, and in Fortran 2008 with MOLD=.",
      "see_also": [
        "[**DEALLOCATE**](#deallocate) - Release allocated memory",
        "[**ALLOCATED**](#allocated) - Inquiry function to check allocation status",
        "[**ALLOCATE with SOURCE=**](#allocate-source) - Allocate and initialize from existing array",
        "[**MOVE_ALLOC**](#move_alloc) - Transfer allocation between arrays"
      ],
      "notes": [
        "- Always pair ALLOCATE with DEALLOCATE to prevent memory leaks",
        "- Use ALLOCATED(array) before allocating to avoid 'already allocated' errors",
        "- Consider using automatic arrays for small, fixed-size local arrays",
        "- Fortran 2003 added ERRMSG= for descriptive error messages:",
        "  allocate(mat(m,n), stat=ierr, errmsg=msg)",
        "- Fortran 2003 added SOURCE= for initialization during allocation:",
        "  allocate(mat, source=other_mat)"
      ]
    }
  },
  "Allocate Array": {
    "prefix": [
      "allocarr",
      "ALLOCARR",
      "allocate_array"
    ],
    "body": [
      "allocate(${1:arr}(${2:n}), stat=${3:ierr})",
      "if (${3:ierr} /= 0) error stop 'Allocation of ${1:arr} failed'"
    ],
    "description": "ALLOCATE(object(shape), STAT=stat) dynamically allocates memory for an allocatable array with error checking.",
    "documentation": {
      "name": "**allocate** - \\[MEMORY:ALLOCATION\\] Dynamically allocate memory for allocatable arrays",
      "synopsis": {
        "usage": "allocate(object(lower:upper), stat=stat_var)",
        "interface": [
          "allocate(object(shape-spec), stat=stat_var)",
          "",
          "  type, allocatable :: object(:)",
          "  integer           :: stat_var"
        ]
      },
      "characteristics": [
        "**object** must be an allocatable array or pointer that has been declared with the ALLOCATABLE or POINTER attribute",
        "**shape-spec** is a list of dimension bounds in the form [lower:]upper for each dimension",
        "**stat_var** is a scalar integer variable that receives the allocation status",
        "The object must not already be allocated when ALLOCATE is executed (unless using STAT=)",
        "All dimension bounds must be scalar integer expressions"
      ],
      "description": "**allocate** dynamically creates storage for allocatable arrays or pointer targets at runtime. The shape of the array is determined by the shape specification provided. If the optional STAT= specifier is present and allocation succeeds, the stat variable is set to zero. If allocation fails and STAT= is present, the stat variable receives a positive integer error code. If allocation fails without STAT=, program execution terminates.",
      "options": {
        "object": "The allocatable array or pointer to allocate. Must have been declared with the ALLOCATABLE or POINTER attribute. Cannot already be allocated unless STAT= is specified.",
        "shape-spec": "Specifies the bounds for each dimension in the form [lower-bound:]upper-bound. The number of shape specifications must equal the rank of the object. If lower-bound is omitted, it defaults to 1.",
        "STAT=stat_var": "Optional. A scalar integer variable that receives the status of the allocation. Set to zero on success, or a positive processor-dependent error code on failure. If omitted and an error occurs, the program terminates."
      },
      "examples": {
        "code": [
          "program demo_allocate",
          "implicit none",
          "  integer :: ierr",
          "  integer :: n",
          "  real, allocatable :: arr(:)",
          "  real, allocatable :: matrix(:,:)",
          "",
          "  n = 100",
          "",
          "  ! Allocate a 1D array with error checking",
          "  allocate(arr(n), stat=ierr)",
          "  if (ierr /= 0) error stop 'Allocation of arr failed'",
          "",
          "  ! Allocate a 2D array with explicit bounds",
          "  allocate(matrix(0:9, -5:5), stat=ierr)",
          "  if (ierr /= 0) error stop 'Allocation of matrix failed'",
          "",
          "  print *, 'arr size:', size(arr)",
          "  print *, 'matrix shape:', shape(matrix)",
          "",
          "  ! Clean up",
          "  deallocate(arr, matrix)",
          "",
          "end program demo_allocate"
        ],
        "results": [
          " arr size:         100",
          " matrix shape:          10          11"
        ]
      },
      "standard": "Fortran 90",
      "see_also": [
        "**deallocate**(3)",
        "**allocated**(3)",
        "**move_alloc**(3)"
      ]
    }
  },
  "Allocate Mold": {
    "prefix": [
      "allocmold",
      "ALLOCMOLD",
      "allocate_mold"
    ],
    "body": "allocate(${1:new_arr}, mold=${2:template_arr})",
    "description": "ALLOCATE(alloc_list,MOLD=source_expr) allocates arrays with the shape and type of source_expr without copying values."
  },
  "_allocate_mold_documentation": {
    "name": "**allocate_mold** - \\[MEMORY:ALLOCATION\\] Allocate arrays using shape and type from a template without copying values",
    "synopsis": {
      "usage": [
        "allocate(alloc_object, mold=source_expr)",
        "allocate(alloc_object, mold=source_expr, stat=stat_var)",
        "allocate(alloc_object, mold=source_expr, stat=stat_var, errmsg=errmsg_var)"
      ],
      "interface": [
        "allocate(alloc_object [, alloc_object]... , mold=source_expr [, stat=stat_var] [, errmsg=errmsg_var])",
        "",
        "  type, allocatable :: alloc_object(..)  ! Allocatable array or scalar",
        "  type              :: source_expr(..)   ! Template for shape and type",
        "  integer           :: stat_var          ! Status variable (optional)",
        "  character(len=*)  :: errmsg_var        ! Error message (optional)"
      ]
    },
    "characteristics": [
      "**alloc_object** is an allocatable variable or an unallocated allocatable component",
      "**source_expr** provides the shape and type for the allocation; its value is not used",
      "**source_expr** may be an undefined variable since only its type and shape are referenced",
      "The allocated object has the same dynamic type and type parameters as source_expr",
      "For arrays, the allocated object has the same bounds as source_expr",
      "The allocated object is NOT initialized - its value is undefined after allocation",
      "Multiple objects can be allocated in a single statement with the same mold"
    ],
    "description": "The **ALLOCATE** statement with **MOLD=** allocates one or more objects with the same dynamic type, type parameters, and shape as the mold expression, but without copying any values. Unlike SOURCE=, the MOLD= specifier does not initialize the allocated object; its value remains undefined after allocation. This is particularly useful for polymorphic allocations where you need an object of the same type as another variable, or for allocating arrays with matching dimensions without the overhead of copying data. The mold expression can even be undefined since only its type information and array bounds are used.",
    "options": [
      {
        "name": "alloc_object",
        "description": "An allocatable variable or component to be allocated. Must not already be allocated unless preceded by a DEALLOCATE. For arrays, bounds can be explicitly specified or inherited from the mold."
      },
      {
        "name": "mold",
        "description": "An expression that provides the dynamic type, type parameters, and (for arrays) the shape of the object to be allocated. The value of the mold expression is not used and need not be defined. Cannot be used together with SOURCE= or a type-spec in the same ALLOCATE statement."
      },
      {
        "name": "stat",
        "description": "Optional integer variable that receives the allocation status. Zero indicates success; a positive value indicates an error occurred."
      },
      {
        "name": "errmsg",
        "description": "Optional character variable that receives a descriptive error message if an allocation error occurs."
      }
    ],
    "examples": {
      "code": [
        "program demo_allocate_mold",
        "implicit none",
        "  ! Example 1: Basic array allocation with mold",
        "  integer, allocatable :: arr(:)",
        "  integer :: template(5)",
        "  ",
        "  template = [1, 2, 3, 4, 5]",
        "  allocate(arr, mold=template)",
        "  ",
        "  print '(a,i0)', 'arr size: ', size(arr)",
        "  print '(a,i0,a,i0)', 'arr bounds: ', lbound(arr,1), ' to ', ubound(arr,1)",
        "  ! Note: arr values are undefined, not copied from template",
        "  ",
        "  ! Example 2: Multiple allocations with same mold",
        "  call multiple_allocations()",
        "  ",
        "  ! Example 3: Polymorphic allocation with mold",
        "  call polymorphic_example()",
        "  ",
        "contains",
        "",
        "  subroutine multiple_allocations()",
        "    real, allocatable :: a(:,:), b(:,:), c(:,:)",
        "    real :: source_array(3,4)",
        "    integer :: stat",
        "    character(len=100) :: errmsg",
        "    ",
        "    source_array = 1.0",
        "    ",
        "    ! Allocate multiple arrays with same shape",
        "    allocate(a, b, c, mold=source_array, stat=stat, errmsg=errmsg)",
        "    ",
        "    if (stat == 0) then",
        "      print '(a)', 'Multiple arrays allocated successfully'",
        "      print '(a,2i3)', 'Shape of a: ', shape(a)",
        "      print '(a,2i3)', 'Shape of b: ', shape(b)",
        "      print '(a,2i3)', 'Shape of c: ', shape(c)",
        "    else",
        "      print '(a,a)', 'Allocation error: ', trim(errmsg)",
        "    end if",
        "    ",
        "    deallocate(a, b, c)",
        "  end subroutine multiple_allocations",
        "",
        "  subroutine polymorphic_example()",
        "    type :: base_type",
        "      integer :: id",
        "    end type base_type",
        "    ",
        "    type, extends(base_type) :: extended_type",
        "      real :: value",
        "    end type extended_type",
        "    ",
        "    class(base_type), allocatable :: poly_obj",
        "    type(extended_type) :: template_obj",
        "    ",
        "    ! Allocate polymorphic object with dynamic type of template",
        "    allocate(poly_obj, mold=template_obj)",
        "    ",
        "    select type(poly_obj)",
        "      type is (extended_type)",
        "        print '(a)', 'poly_obj has dynamic type extended_type'",
        "      type is (base_type)",
        "        print '(a)', 'poly_obj has dynamic type base_type'",
        "    end select",
        "    ",
        "    deallocate(poly_obj)",
        "  end subroutine polymorphic_example",
        "",
        "end program demo_allocate_mold"
      ],
      "results": [
        "arr size: 5",
        "arr bounds: 1 to 5",
        "Multiple arrays allocated successfully",
        "Shape of a:   3  4",
        "Shape of b:   3  4",
        "Shape of c:   3  4",
        "poly_obj has dynamic type extended_type"
      ]
    },
    "standard": "Fortran 2008",
    "see_also": [
      "[**allocate_source**(3)](#allocate_source) - Allocate with value initialization from source",
      "[**deallocate**(3)](#deallocate) - Free allocated memory",
      "[**allocated**(3)](#allocated) - Query allocation status",
      "[**move_alloc**(3)](#move_alloc) - Transfer allocation between variables"
    ]
  },
  "Allocate Source": {
    "prefix": [
      "allocsource",
      "ALLOCSOURCE",
      "allocate_source"
    ],
    "body": [
      "allocate(${1:new_arr}${2:(${3:n})}, source=${4:source_expr}${5:, stat=${6:ierr}}${7:, errmsg=${8:errmsg}})"
    ],
    "description": "ALLOCATE(object,SOURCE=expr) allocates and initializes an object with the dynamic type and value of the source expression.",
    "documentation": {
      "name": "**allocate_source** - \\[MEMORY:ALLOCATION\\] Allocate with source initialization",
      "synopsis": {
        "usage": [
          "allocate(object, source=source_expr)",
          "allocate(object(bounds), source=source_expr, stat=stat_var, errmsg=errmsg_var)"
        ],
        "interface": [
          "allocate(allocation-list, source=source-expr [,stat=stat-var] [,errmsg=errmsg-var])",
          "",
          "  type(TYPE), allocatable :: object",
          "  type(TYPE)              :: source-expr",
          "  integer                 :: stat-var",
          "  character(len=*)        :: errmsg-var"
        ]
      },
      "characteristics": [
        "**object** must have the ALLOCATABLE or POINTER attribute",
        "**source_expr** must be type-compatible with **object**",
        "If **object** is an array and bounds are omitted, the shape is taken from **source_expr**",
        "If **source_expr** is scalar and **object** is an array, all elements are initialized to that scalar value",
        "**source_expr** cannot be an undefined variable (use MOLD= for that case)",
        "Cannot combine SOURCE= with type-spec (type::) in the same statement",
        "The dynamic type and value of **object** become those of **source_expr**"
      ],
      "description": "**allocate** with the **source=** specifier dynamically creates storage for an allocatable variable or pointer target and initializes it with the value and dynamic type of the source expression. This is particularly useful for polymorphic allocation where the exact type is determined at runtime, and for initializing arrays with a common value or copying the contents of another array during allocation.",
      "options": {
        "object": "The allocatable variable or pointer to be allocated. For arrays, shape bounds may be specified as [lower-bound:]upper-bound for each dimension, or omitted if SOURCE= provides an array of matching rank.",
        "source_expr": "A scalar or array expression whose dynamic type and value are used to initialize the allocated object. Must be type-compatible with **object**. If **object** is an array and **source_expr** is scalar, all elements receive the scalar value. If both are arrays, **source_expr** must have the same rank (not necessarily same shape if bounds are explicitly given).",
        "stat_var": "(Optional) A scalar integer variable that receives the allocation status. Set to zero on success, or a positive processor-dependent value on failure. If omitted and allocation fails, program execution terminates.",
        "errmsg_var": "(Optional) A scalar default character variable that receives a descriptive error message if allocation fails. Unchanged on success."
      },
      "examples": {
        "description": "Sample program demonstrating ALLOCATE with SOURCE=:",
        "code": [
          "program demo_allocate_source",
          "implicit none",
          "  integer, allocatable :: arr1(:), arr2(:)",
          "  real, allocatable :: matrix(:,:), copy_matrix(:,:)",
          "  integer :: ierr",
          "  character(len=100) :: errmsg",
          "",
          "  ! Example 1: Allocate array initialized to scalar value",
          "  allocate(arr1(10), source=0)",
          "  print *, 'arr1 initialized to zeros:', arr1",
          "",
          "  ! Example 2: Allocate array copying values from another array",
          "  arr2 = [1, 2, 3, 4, 5]",
          "  allocate(arr1, source=arr2)  ! arr1 takes shape and values from arr2",
          "  print *, 'arr1 copied from arr2:', arr1",
          "",
          "  ! Example 3: Allocate 2D array with error handling",
          "  allocate(matrix(100,100), source=1.0, stat=ierr, errmsg=errmsg)",
          "  if (ierr /= 0) then",
          "    print *, 'Allocation failed:', trim(errmsg)",
          "    stop 1",
          "  end if",
          "  print *, 'matrix(1,1) =', matrix(1,1)",
          "",
          "  ! Example 4: Copy array with automatic bounds",
          "  allocate(copy_matrix, source=matrix)",
          "  print *, 'copy_matrix shape:', shape(copy_matrix)",
          "",
          "  deallocate(arr1, arr2, matrix, copy_matrix)",
          "",
          "end program demo_allocate_source"
        ],
        "results": [
          " arr1 initialized to zeros:           0           0           0           0           0           0           0           0           0           0",
          " arr1 copied from arr2:           1           2           3           4           5",
          " matrix(1,1) =   1.00000000",
          " copy_matrix shape:         100         100"
        ]
      },
      "standard": "Fortran 2003 (SOURCE= specifier); Fortran 2008 added MOLD= as alternative",
      "see_also": [
        "[**allocate_mold**(3)](#allocate_mold) - Allocate with type/shape from mold without copying values",
        "[**deallocate**(3)](#deallocate) - Release dynamically allocated memory",
        "[**allocated**(3)](#allocated) - Check if an allocatable variable is allocated",
        "[**move_alloc**(3)](#move_alloc) - Transfer allocation between variables"
      ],
      "notes": [
        "SOURCE= copies both dynamic type and values; use MOLD= when only type/shape is needed",
        "For polymorphic (CLASS) variables, SOURCE= preserves the dynamic type at runtime",
        "Allocation failures can be caught with STAT= to prevent program termination",
        "ERRMSG= provides human-readable error descriptions but is unchanged on success"
      ]
    }
  },
  "Allocate String": {
    "prefix": [
      "allocstr",
      "ALLOCSTR",
      "allocate_string"
    ],
    "body": [
      "allocate(character(len=${1:n}) :: ${2:str})"
    ],
    "description": "ALLOCATE(CHARACTER(LEN=n) :: str) allocates a deferred-length character variable with the specified length."
  },
  "Array Constructor Implied Do": {
    "prefix": [
      "arraycon",
      "ARRAYCON",
      "implieddo",
      "IMPLIEDDO",
      "acimplied"
    ],
    "body": [
      "[(${1:expr}, ${2:i} = ${3:start}, ${4:end}${5:, ${6:step}})]"
    ],
    "description": "[(expr, var=start,end,step)] constructs a rank-one array using an implied-do loop to generate values.",
    "documentation": {
      "name": "**Array Constructor Implied-Do** - \\[ARRAY:CONSTRUCTION\\] Construct a rank-one array using an implied-do loop",
      "synopsis": {
        "usage": "```fortran\n    array = [(expr, var = start, end [, step])]\n```",
        "interface": "```fortran\n     ! Array constructor with implied-do loop\n     ! Fortran 90 syntax: (/ ... /)\n     ! Fortran 2003+ syntax: [ ... ]\n\n     type(TYPE(kind=**)), dimension(:) :: array\n     integer                           :: var    ! do-variable (loop-local scope)\n     integer                           :: start  ! initial value\n     integer                           :: end    ! final value\n     integer, optional                 :: step   ! stride (default: 1, must be nonzero)\n```"
      },
      "characteristics": [
        "**expr** is any scalar expression evaluated for each iteration; may reference the do-variable",
        "**var** is a scalar integer variable whose scope is limited to the implied-do loop",
        "**start** and **end** are scalar integer expressions defining the iteration range",
        "**step** is an optional scalar integer expression for the stride; must be nonzero, defaults to 1",
        "All values in the constructor must have the same type and kind parameters",
        "The result is always a rank-one array; use RESHAPE for higher dimensions",
        "Nested implied-do loops must use different do-variables"
      ],
      "description": "**Array constructor implied-do** creates a rank-one array by evaluating an expression for each iteration of an implied loop. The do-variable iterates from start to end with an optional step, and the expression is evaluated at each iteration to produce the corresponding array element. This provides a compact notation for initializing arrays with computed or patterned values without explicit loops.",
      "options": {
        "expr": "The expression to evaluate for each array element. May be any scalar expression of numeric, logical, or character type. Can reference the do-variable to create index-dependent values. All expressions must yield the same type and kind.",
        "var": "The implied-do loop variable (traditionally i, j, k, etc.). Must be a scalar integer. Its scope is confined to the implied-do loop, so it does not conflict with variables of the same name outside the constructor.",
        "start": "The initial value for the do-variable. Must be a scalar integer expression. The loop begins with var equal to this value.",
        "end": "The final value for the do-variable. Must be a scalar integer expression. The loop continues while var has not passed this value (considering the sign of step).",
        "step": "The increment added to var after each iteration. Must be a nonzero scalar integer expression. If omitted, defaults to 1. Use negative values to count downward."
      },
      "examples": {
        "code": "```fortran\nprogram demo_array_constructor_implied_do\n  implicit none\n  integer :: i\n  integer, dimension(5) :: arr1, arr2, arr3\n  real, dimension(10) :: reals\n  integer, dimension(3,4) :: matrix\n\n  ! Basic implied-do: create array [1, 2, 3, 4, 5]\n  arr1 = [(i, i = 1, 5)]\n  print '(a,5i3)', 'Sequential:    ', arr1\n\n  ! Expression with do-variable: squares [1, 4, 9, 16, 25]\n  arr2 = [(i**2, i = 1, 5)]\n  print '(a,5i3)', 'Squares:       ', arr2\n\n  ! Using step: even numbers [2, 4, 6, 8, 10]\n  arr3 = [(i, i = 2, 10, 2)]\n  print '(a,5i3)', 'Even numbers:  ', arr3\n\n  ! Countdown with negative step: [5, 4, 3, 2, 1]\n  arr1 = [(i, i = 5, 1, -1)]\n  print '(a,5i3)', 'Countdown:     ', arr1\n\n  ! Real values: [0.1, 0.2, ..., 1.0]\n  reals = [(real(i) * 0.1, i = 1, 10)]\n  print '(a,10f5.1)', 'Reals:         ', reals\n\n  ! Mixed: scalar + implied-do + scalar\n  arr1 = [0, (i, i = 1, 3), 99]\n  print '(a,5i3)', 'Mixed:         ', arr1\n\n  ! Nested implied-do for 2D array (requires RESHAPE)\n  matrix = reshape([((i + j*10, i = 1, 3), j = 1, 4)], shape(matrix))\n  print '(a)', 'Matrix (3x4):'\n  do i = 1, 3\n    print '(2x,4i4)', matrix(i,:)\n  end do\n\n  ! Fortran 90 syntax with (/ /) delimiters\n  arr1 = (/ (i*3, i = 1, 5) /)\n  print '(a,5i3)', 'F90 syntax:    ', arr1\n\nend program demo_array_constructor_implied_do\n```",
        "output": "```text\nSequential:      1  2  3  4  5\nSquares:         1  4  9 16 25\nEven numbers:    2  4  6  8 10\nCountdown:       5  4  3  2  1\nReals:           0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0\nMixed:           0  1  2  3 99\nMatrix (3x4):\n    11  21  31  41\n    12  22  32  42\n    13  23  33  43\nF90 syntax:      3  6  9 12 15\n```"
      },
      "standard": "Fortran 90 (original syntax with (/ /)); Fortran 2003 (square bracket syntax [ ])",
      "see_also": [
        "[**RESHAPE**(3)](#reshape) - Construct arrays of arbitrary shape from rank-one data",
        "[**SPREAD**(3)](#spread) - Replicate an array by adding a dimension",
        "[**PACK**(3)](#pack) - Pack array elements into a rank-one array under a mask",
        "[**MERGE**(3)](#merge) - Merge arrays under a mask condition"
      ],
      "notes": [
        "The do-variable has local scope within the implied-do and does not affect or conflict with variables of the same name outside the constructor.",
        "For character arrays in Fortran 90/95, all character expressions must have the same length (some compilers extend this).",
        "If all expressions are constant, the entire array constructor is a constant expression suitable for parameter initialization.",
        "The number of elements produced equals MAX(0, (end - start + step) / step) for positive step, or MAX(0, (start - end - step) / (-step)) for negative step."
      ]
    }
  },
  "Array Constructor Implied Do 2D": {
    "prefix": [
      "arraycon2d",
      "ARRAYCON2D"
    ],
    "body": [
      "reshape([((${1:expr}, ${2:i} = ${3:1}, ${4:m}), ${5:j} = ${6:1}, ${7:n})], [${4:m}, ${7:n}])"
    ],
    "description": "reshape([((expr, i = 1, m), j = 1, n)], [m, n]) constructs a 2D array using nested implied-do loops within an array constructor and RESHAPE.",
    "_documentation": {
      "name": "**reshape([((expr, i, j)], [m, n])** - \\[ARRAY:CONSTRUCTION\\] Construct a 2D array using nested implied-do loops with RESHAPE",
      "synopsis": {
        "usage": "```fortran\n    array_2d = reshape([((expr, i = start_i, end_i), j = start_j, end_j)], [end_i, end_j])\n```",
        "interface": "```fortran\n     result = reshape(source, shape)\n\n      type(NUMERIC/LOGICAL)           :: source(:)  ! 1D array from constructor\n      integer, dimension(2)           :: shape      ! [rows, cols]\n      type(NUMERIC/LOGICAL)           :: result(:,:)\n```"
      },
      "characteristics": [
        "**expr** is any scalar expression that may depend on the loop indices **i** and **j**",
        "**i** and **j** are scalar integer do-variables with scope limited to their implied-do loops",
        "Nested implied-do loops must use different do-variable names",
        "The array constructor produces a rank-one array; RESHAPE transforms it to rank-two",
        "The inner loop (**i**) varies fastest, filling columns before rows (Fortran column-major order)",
        "The result is a 2D array with shape [m, n] where m is rows and n is columns"
      ],
      "description": "This pattern combines an **array constructor** with **nested implied-do loops** and the **RESHAPE** intrinsic function to create a two-dimensional array. Array constructors in Fortran can only produce rank-one arrays, so RESHAPE is required to transform the linear sequence into a matrix. The nested implied-do loops generate values in column-major order (inner loop varies fastest), which matches Fortran's default array storage order.",
      "options": [
        {
          "name": "expr",
          "description": "A scalar expression evaluated for each combination of loop indices. May reference the do-variables i and j to compute position-dependent values. Must be of consistent type and kind for all iterations."
        },
        {
          "name": "i",
          "description": "The do-variable for the inner implied-do loop. Controls the row index. Its scope is limited to the inner loop. Must be a scalar integer variable name."
        },
        {
          "name": "start_i, end_i (1, m)",
          "description": "Integer expressions defining the range for the inner loop. Typically 1 to m where m is the number of rows. An optional stride can be added as a third parameter."
        },
        {
          "name": "j",
          "description": "The do-variable for the outer implied-do loop. Controls the column index. Its scope is limited to the outer loop. Must use a different name than the inner do-variable."
        },
        {
          "name": "start_j, end_j (1, n)",
          "description": "Integer expressions defining the range for the outer loop. Typically 1 to n where n is the number of columns. An optional stride can be added as a third parameter."
        },
        {
          "name": "[m, n]",
          "description": "The shape argument to RESHAPE specifying the dimensions of the result array. Must be a rank-one integer array with two elements: [rows, columns]. The product m*n must equal the total number of elements generated by the implied-do loops."
        }
      ],
      "result": "A two-dimensional array of shape [m, n] with type and kind matching the expression **expr**. Elements are filled in column-major order: the first m values fill column 1, the next m values fill column 2, and so on.",
      "examples": {
        "code": "```fortran\nprogram demo_array_constructor_2d\nimplicit none\n  integer :: i, j\n  integer :: matrix(3, 4)\n  real    :: coords(2, 3)\n  integer :: identity(3, 3)\n\n  ! Example 1: Create a 3x4 matrix where element(i,j) = i + 10*j\n  ! Values: column 1 = [11,12,13], column 2 = [21,22,23], etc.\n  matrix = reshape([((i + 10*j, i = 1, 3), j = 1, 4)], [3, 4])\n  \n  print '(a)', 'Matrix (i + 10*j):'\n  do i = 1, 3\n    print '(4i5)', matrix(i, :)\n  end do\n\n  ! Example 2: Create coordinate pairs as a 2x3 array\n  ! Each column is a point: (1,1), (2,2), (3,3)\n  coords = reshape([((real(i*j), i = 1, 2), j = 1, 3)], [2, 3])\n  \n  print '(a)', ''\n  print '(a)', 'Coordinates (i*j):'\n  do i = 1, 2\n    print '(3f8.2)', coords(i, :)\n  end do\n\n  ! Example 3: Identity matrix using conditional expression\n  identity = reshape([((merge(1, 0, i == j), i = 1, 3), j = 1, 3)], [3, 3])\n  \n  print '(a)', ''\n  print '(a)', 'Identity matrix:'\n  do i = 1, 3\n    print '(3i3)', identity(i, :)\n  end do\n\nend program demo_array_constructor_2d\n```",
        "output": "```text\nMatrix (i + 10*j):\n   11   21   31   41\n   12   22   32   42\n   13   23   33   43\n\nCoordinates (i*j):\n    1.00    2.00    3.00\n    2.00    4.00    6.00\n\nIdentity matrix:\n  1  0  0\n  0  1  0\n  0  0  1\n```"
      },
      "standard": "Fortran 90",
      "see_also": [
        "[**reshape**(3)](#reshape) - Transform array shape",
        "[**spread**(3)](#spread) - Replicate array along a dimension",
        "[**pack**(3)](#pack) - Pack array into rank-one array under mask",
        "[**unpack**(3)](#unpack) - Unpack rank-one array into array under mask",
        "[**merge**(3)](#merge) - Merge arrays under mask control"
      ],
      "resources": [
        "[Fortran Wiki: Array Constructors](https://fortranwiki.org/fortran/show/array+constructors)",
        "[Intel Fortran: Array Constructors](https://www.cita.utoronto.ca/~merz/intel_f10b/main_for/mergedProjects/lref_for/source_files/rfcarcon.htm)"
      ],
      "notes": [
        "The inner loop index (i) corresponds to rows and varies fastest due to Fortran's column-major storage order.",
        "For row-major initialization (values specified row by row), use the ORDER parameter: reshape([...], [m,n], order=[2,1]).",
        "Nested implied-do loops must use distinct do-variable names; using the same name causes a compilation error.",
        "The expression is evaluated once per iteration, so side-effect-free expressions are recommended.",
        "For large arrays, consider whether explicit loops might be more readable or efficient."
      ]
    }
  },
  "Assert Pattern": {
    "prefix": [
      "assert",
      "ASSERT"
    ],
    "body": [
      "if (.not. (${1:condition})) then",
      "\terror stop '${2:Assertion failed: ${1:condition}}'",
      "end if"
    ],
    "description": "ASSERT(CONDITION) terminates program execution with an error message if CONDITION is false.",
    "documentation": {
      "name": "**assert** - \\[ERROR:HANDLING\\] Assertion pattern for runtime condition verification",
      "synopsis": {
        "usage": [
          "```fortran",
          "    if (.not. (condition)) then",
          "        error stop 'Assertion failed: condition'",
          "    end if",
          "```"
        ],
        "interface": [
          "```fortran",
          "     ! Assert pattern (inline construct)",
          "",
          "      logical :: condition  ! Expression to verify",
          "      ! If condition is .false., program terminates with error",
          "```"
        ]
      },
      "characteristics": [
        "- **condition** is a scalar logical expression that evaluates to .true. or .false.",
        "- The pattern uses ERROR STOP for error termination (non-zero exit status).",
        "- The stop-code is a scalar default character constant expression.",
        "- Program execution terminates immediately if the condition is not satisfied.",
        "- All images terminate in coarray programs (error termination propagates)."
      ],
      "description": "**assert** implements a runtime assertion pattern that verifies a logical condition and terminates program execution with an error message if the condition evaluates to .false.. This pattern is essential for defensive programming, catching logic errors early, and validating preconditions, postconditions, and invariants during program execution. Unlike STOP which initiates normal termination, ERROR STOP initiates error termination, returning a non-zero exit status to the operating system and outputting the message to the standard error unit.",
      "options": {
        "condition": {
          "description": "A scalar logical expression to be verified at runtime. The expression is evaluated and if the result is .false., the program terminates with error status. Any valid Fortran logical expression is permitted, including comparisons, logical operators, and function results.",
          "examples": [
            "n > 0",
            "allocated(array)",
            "associated(ptr)",
            "size(a) == size(b)",
            "present(optional_arg)"
          ]
        },
        "message": {
          "description": "A scalar default character constant expression displayed on the standard error unit when the assertion fails. The message is prefixed with 'ERROR STOP: ' by the runtime system. It should describe what condition was expected to be true.",
          "examples": [
            "'Assertion failed: n > 0'",
            "'Array must be allocated'",
            "'Index out of bounds'"
          ]
        }
      },
      "examples": {
        "sample_program": [
          "```fortran",
          "program demo_assert",
          "implicit none",
          "  integer :: n",
          "  real, allocatable :: array(:)",
          "",
          "  ! Example 1: Validate input parameter",
          "  n = 5",
          "  if (.not. (n > 0)) then",
          "      error stop 'Assertion failed: n must be positive'",
          "  end if",
          "  print *, 'n is valid:', n",
          "",
          "  ! Example 2: Validate allocation status",
          "  allocate(array(n))",
          "  if (.not. (allocated(array))) then",
          "      error stop 'Assertion failed: array must be allocated'",
          "  end if",
          "  print *, 'array allocated with size:', size(array)",
          "",
          "  ! Example 3: Validate array bounds",
          "  if (.not. (n <= size(array))) then",
          "      error stop 'Assertion failed: index exceeds array bounds'",
          "  end if",
          "  print *, 'bounds check passed'",
          "",
          "  ! Example 4: Demonstrate assertion failure",
          "  ! Uncomment to see error termination:",
          "  ! n = -1",
          "  ! if (.not. (n > 0)) then",
          "  !     error stop 'Assertion failed: n > 0'",
          "  ! end if",
          "",
          "  deallocate(array)",
          "  print *, 'Program completed successfully'",
          "",
          "end program demo_assert",
          "```"
        ],
        "results": [
          "```text",
          " n is valid:           5",
          " array allocated with size:           5",
          " bounds check passed",
          " Program completed successfully",
          "```",
          "",
          "If assertion fails (with n = -1):",
          "```text",
          "ERROR STOP Assertion failed: n > 0",
          "```",
          "Exit status: non-zero (implementation-dependent)"
        ]
      },
      "standard": "Fortran 2008 (ERROR STOP statement); Fortran 2018 (variable stop-codes, QUIET= specifier, use in PURE procedures)",
      "see_also": [
        "[**error stop**(3)](#error_stop) - Error termination statement",
        "[**stop**(3)](#stop) - Normal termination statement",
        "[**if**(3)](#if) - Conditional execution construct",
        "[**iso_fortran_env**(3)](#iso_fortran_env) - error_unit for stderr output"
      ],
      "notes": [
        "- In Fortran 2008, stop-codes must be constant expressions. Variable stop-codes require Fortran 2018.",
        "- ERROR STOP outputs to the standard error unit (error_unit from iso_fortran_env).",
        "- The exit status returned to the OS is implementation-dependent but typically non-zero.",
        "- In coarray programs, ERROR STOP terminates all images, not just the executing image.",
        "- For production code, consider using a preprocessor macro to disable assertions.",
        "- Fortran 2018 allows ERROR STOP in PURE procedures, enabling assertions in pure code."
      ],
      "resources": [
        "- [Fortran 2008 Standard Features](https://fortranwiki.org/fortran/show/Fortran+2008)",
        "- [Error Handling in Fortran](https://gjbex.github.io/Defensive_programming_and_debugging/CodingBestPractices/ErrorHandling/error_handling_fortran/)",
        "- [Fortran stderr stop return codes](https://www.scivision.dev/fortran-stderr-stop-return-code/)"
      ]
    }
  },
  "Assert Simple": {
    "prefix": [
      "assertsimple",
      "ASSERTSIMPLE"
    ],
    "body": "if (.not. (${1:condition})) stop '${2:Assertion failed}'",
    "description": "ASSERT_SIMPLE(CONDITION,MESSAGE) halts program execution with an error message if a logical condition is false.",
    "documentation": {
      "name": "**assert_simple** - \\[ERROR:HANDLING\\] Simple assertion that halts execution if condition is false",
      "synopsis": {
        "usage": "if (.not. (condition)) stop 'message'",
        "interface": [
          "! Pattern: Simple assertion using IF and STOP",
          "!",
          "!   if (.not. (condition)) stop 'message'",
          "!",
          "!   logical, intent(in) :: condition  ! Expression to evaluate",
          "!   character(len=*), parameter :: message  ! Error message on failure"
        ]
      },
      "characteristics": [
        "**condition** is a logical expression that evaluates to .true. or .false.",
        "**message** is a character constant displayed when the assertion fails.",
        "When the condition is .false., program execution terminates immediately.",
        "The STOP statement returns a non-zero exit status to the operating system.",
        "This is a compile-time pattern, not a runtime function."
      ],
      "description": "**assert_simple** provides a basic assertion mechanism for Fortran programs. It evaluates a logical condition and, if the condition is false, immediately terminates program execution with a descriptive error message. This pattern is useful for validating preconditions, postconditions, and invariants during development and debugging. The .NOT. operator negates the condition so that the STOP statement executes only when the original condition fails.",
      "options": [
        {
          "name": "condition",
          "description": "A logical expression to be tested. Can be any valid Fortran logical expression including comparisons (==, /=, <, >, <=, >=), logical operations (.and., .or., .not., .eqv., .neqv.), or calls to logical functions. The assertion passes when this expression evaluates to .true."
        },
        {
          "name": "message",
          "description": "A character constant that describes the assertion failure. This message is displayed to the user when the assertion fails. Best practice is to include meaningful information about what condition was expected, such as 'Array size must be positive' or 'Input value out of range'."
        }
      ],
      "examples": {
        "code": [
          "program demo_assert_simple",
          "implicit none",
          "  integer :: n, array_size",
          "  real :: divisor",
          "  real, allocatable :: values(:)",
          "",
          "  ! Example 1: Validate input parameter",
          "  n = 10",
          "  if (.not. (n > 0)) stop 'Error: n must be positive'",
          "  print *, 'Passed: n is positive, n =', n",
          "",
          "  ! Example 2: Check array allocation size",
          "  array_size = 5",
          "  if (.not. (array_size >= 1)) stop 'Error: array_size must be at least 1'",
          "  allocate(values(array_size))",
          "  print *, 'Passed: array allocated with size', array_size",
          "",
          "  ! Example 3: Prevent division by zero",
          "  divisor = 2.5",
          "  if (.not. (divisor /= 0.0)) stop 'Error: divisor cannot be zero'",
          "  print *, 'Passed: safe to divide, divisor =', divisor",
          "",
          "  ! Example 4: Validate array bounds",
          "  values = [1.0, 2.0, 3.0, 4.0, 5.0]",
          "  if (.not. (size(values) == array_size)) stop 'Error: array size mismatch'",
          "  print *, 'Passed: array size matches expected value'",
          "",
          "  ! Example 5: Combined logical conditions",
          "  if (.not. (n > 0 .and. array_size > 0)) stop 'Error: both n and array_size must be positive'",
          "  print *, 'Passed: all conditions met'",
          "",
          "  print *, 'All assertions passed successfully!'",
          "",
          "  deallocate(values)",
          "end program demo_assert_simple"
        ],
        "results": [
          " Passed: n is positive, n =          10",
          " Passed: array allocated with size           5",
          " Passed: safe to divide, divisor =   2.50000000",
          " Passed: array size matches expected value",
          " Passed: all conditions met",
          " All assertions passed successfully!"
        ]
      },
      "standard": "Fortran 90",
      "see_also": [
        "**error_stop**(3) - Fortran 2008 ERROR STOP statement for error termination",
        "**stop**(3) - STOP statement for normal program termination",
        "**if_then_else**(3) - IF-THEN-ELSE construct for conditional execution"
      ],
      "notes": [
        "The STOP statement was introduced in Fortran 77 and enhanced in Fortran 90.",
        "For production code, consider using ERROR STOP (Fortran 2008) which guarantees a non-zero exit status.",
        "This pattern can be wrapped in a preprocessor macro for conditional compilation.",
        "Unlike some languages, Fortran does not have a built-in assert statement, making this pattern essential."
      ]
    }
  },
  "Associated Check": {
    "prefix": [
      "associated",
      "ASSOCIATED"
    ],
    "body": "associated(${1:pointer}${2:, ${3:target}})",
    "description": "ASSOCIATED(POINTER,TARGET=target) determines the association status of the pointer POINTER or its association with a specific TARGET."
  },
  "_associated_documentation": {
    "name": "**associated** - \\[TYPE:INQUIRY\\] Determine pointer association status",
    "synopsis": {
      "usage": "result = associated(pointer [, target])",
      "interface": [
        "function associated(pointer, target)",
        "",
        "  type(any_type), pointer       :: pointer",
        "  type(any_type), optional      :: target",
        "  logical                       :: associated"
      ]
    },
    "characteristics": [
      "**pointer** must have the POINTER attribute and may be of any type",
      "**target** (optional) must be a pointer or target with the same type, kind type parameter, and array rank as **pointer**",
      "The association status of both **pointer** and **target** must not be undefined",
      "The result is a default logical scalar value"
    ],
    "description": "**associated** determines the association status of the pointer **pointer**, or optionally tests whether **pointer** is associated with a specific **target**. This is an inquiry function that returns a logical value indicating the pointer's current association state.",
    "options": {
      "pointer": "A pointer of any type. Its association status must be defined (not undefined). The pointer may be a scalar or an array of any rank.",
      "target": "(Optional) A pointer or a target object with the same type, kind type parameter, and array rank as **pointer**. Its association status must not be undefined. If **target** is a pointer, the result indicates whether both pointers are associated with the same target."
    },
    "result": {
      "without_target": "When **target** is absent, **associated** returns .TRUE. if **pointer** is currently associated with any target, and .FALSE. if **pointer** has been disassociated (nullified).",
      "with_scalar_target": "When **target** is present and is a scalar, returns .TRUE. if **pointer** is associated with **target** (i.e., they reference the same storage location). Returns .FALSE. if **pointer** is disassociated.",
      "with_array_target": "When **target** is present and is an array, returns .TRUE. if **pointer** and **target** have the same shape, are not zero-sized, and occupy the same storage units in array element order.",
      "with_pointer_target": "When **target** is itself a pointer, returns .TRUE. only if both **pointer** and **target** are associated with the same target object."
    },
    "examples": {
      "code": [
        "program demo_associated",
        "implicit none",
        "  real, target  :: tgt(2) = [1.0, 2.0]",
        "  real, target  :: other(2) = [3.0, 4.0]",
        "  real, pointer :: ptr(:)",
        "  real, pointer :: ptr2(:)",
        "",
        "  ! Initially nullify pointers to ensure defined status",
        "  nullify(ptr)",
        "  nullify(ptr2)",
        "",
        "  ! Test 1: Check unassociated pointer",
        "  print *, 'ptr associated (should be F):', associated(ptr)",
        "",
        "  ! Test 2: Associate pointer with target",
        "  ptr => tgt",
        "  print *, 'ptr associated (should be T):', associated(ptr)",
        "",
        "  ! Test 3: Check association with specific target",
        "  print *, 'ptr => tgt (should be T):', associated(ptr, tgt)",
        "  print *, 'ptr => other (should be F):', associated(ptr, other)",
        "",
        "  ! Test 4: Two pointers to same target",
        "  ptr2 => tgt",
        "  print *, 'ptr => ptr2 target (should be T):', associated(ptr, ptr2)",
        "",
        "  ! Test 5: Two pointers to different targets",
        "  ptr2 => other",
        "  print *, 'ptr => ptr2 target (should be F):', associated(ptr, ptr2)",
        "",
        "  ! Test 6: Nullify and recheck",
        "  nullify(ptr)",
        "  print *, 'ptr after nullify (should be F):', associated(ptr)",
        "",
        "end program demo_associated"
      ],
      "results": [
        " ptr associated (should be F): F",
        " ptr associated (should be T): T",
        " ptr => tgt (should be T): T",
        " ptr => other (should be F): F",
        " ptr => ptr2 target (should be T): T",
        " ptr => ptr2 target (should be F): F",
        " ptr after nullify (should be F): F"
      ]
    },
    "standard": "Fortran 90 and later",
    "see_also": [
      "[**null**(3)](#null) - Function that returns a disassociated pointer",
      "[**allocated**(3)](#allocated) - Status of an allocatable entity"
    ],
    "notes": [
      "In Fortran 90, a pointer's association status is undefined when declared. You must explicitly nullify it or associate it with a target before calling **associated**. Fortran 95 and later allow initialization with => null() on declaration.",
      "Testing an undefined pointer with **associated** produces undefined behavior.",
      "The **associated** function is commonly used in conditional statements to safely dereference pointers."
    ]
  },
  "Assumed Rank": {
    "prefix": [
      "assumedrank",
      "ASSUMEDRANK",
      "assumed_rank",
      "ASSUMED_RANK"
    ],
    "body": "${1:type}(${2:kind}), dimension(..), intent(${3|in,out,inout|}) :: ${0:array}",
    "description": "ASSUMED_RANK(TYPE,KIND,INTENT,NAME) declares an assumed-rank dummy argument that accepts arrays of any rank."
  },
  "Assumed-Shape Array 1D": {
    "prefix": [
      "array1d",
      "ARRAY1D",
      "assumedshape1d",
      "ASSUMEDSHAPE1D"
    ],
    "body": [
      "${1:real}(${2:dp}), intent(${3|in,out,inout|}) :: ${4:arr}(:)"
    ],
    "description": "ARRAY(:) declares a one-dimensional assumed-shape array argument for procedures.",
    "documentation": {
      "name": "**assumed_shape_array_1d** - \\[ARRAY:DECLARATION\\] Declare a 1D assumed-shape dummy argument",
      "synopsis": {
        "usage": "type(kind), intent(in|out|inout) :: array_name(:)",
        "interface": [
          "subroutine example_sub(arr)",
          "",
          "  real(dp), intent(in) :: arr(:)",
          "",
          "end subroutine example_sub"
        ]
      },
      "characteristics": [
        "**type** can be any intrinsic type (integer, real, complex, logical, character) or derived type",
        "**kind** specifies the kind type parameter (e.g., dp, sp, int32, int64)",
        "**intent** must be one of: in (read-only), out (write-only), or inout (read-write)",
        "**array_name** is the dummy argument name; the colon (:) indicates assumed-shape",
        "The array assumes its shape from the actual argument passed at runtime",
        "The lower bound defaults to 1 unless explicitly specified"
      ],
      "description": "**assumed_shape_array_1d** declares a one-dimensional array dummy argument whose shape is determined by the actual argument at the time of procedure invocation. The array inherits the size and extent from the calling code, allowing procedures to operate on arrays of any size without requiring explicit size arguments. This is the preferred modern Fortran approach for passing arrays to procedures as it provides automatic bounds checking when enabled and allows use of array intrinsics like SIZE, LBOUND, and UBOUND.",
      "options": [
        {
          "name": "type",
          "description": "The data type of the array elements. Common choices include: real for floating-point numbers, integer for whole numbers, complex for complex numbers, logical for boolean values, character for strings, or any user-defined derived type."
        },
        {
          "name": "kind",
          "description": "The kind type parameter specifying precision or storage size. Common values: dp (double precision), sp (single precision), int32, int64. Should match the kind of the actual argument passed to the procedure."
        },
        {
          "name": "intent",
          "description": "Specifies how the argument is used: 'in' means the procedure only reads the array (cannot modify), 'out' means the procedure only writes to the array (initial values undefined), 'inout' means the procedure both reads and writes the array."
        },
        {
          "name": "array_name",
          "description": "The name of the dummy array argument. The (:) notation indicates this is an assumed-shape array that will receive its extent from the actual argument."
        }
      ],
      "examples": {
        "code": [
          "program demo_assumed_shape_1d",
          "  use, intrinsic :: iso_fortran_env, only: dp => real64",
          "  implicit none",
          "",
          "  real(dp) :: small_array(5)",
          "  real(dp) :: large_array(100)",
          "  real(dp) :: result_sum",
          "",
          "  ! Initialize arrays",
          "  small_array = [1.0_dp, 2.0_dp, 3.0_dp, 4.0_dp, 5.0_dp]",
          "  large_array = 1.0_dp  ! All elements set to 1.0",
          "",
          "  ! Pass different sized arrays to the same procedure",
          "  call compute_sum(small_array, result_sum)",
          "  print '(A,F10.2)', 'Sum of small_array: ', result_sum",
          "",
          "  call compute_sum(large_array, result_sum)",
          "  print '(A,F10.2)', 'Sum of large_array: ', result_sum",
          "",
          "  ! Demonstrate array section passing",
          "  call compute_sum(large_array(1:10), result_sum)",
          "  print '(A,F10.2)', 'Sum of first 10 elements: ', result_sum",
          "",
          "contains",
          "",
          "  subroutine compute_sum(arr, total)",
          "    ! Assumed-shape array - size determined at runtime",
          "    real(dp), intent(in)  :: arr(:)",
          "    real(dp), intent(out) :: total",
          "",
          "    ! Can use intrinsics to query array properties",
          "    print '(A,I0)', '  Array size: ', size(arr)",
          "    print '(A,I0,A,I0)', '  Bounds: ', lbound(arr,1), ' to ', ubound(arr,1)",
          "",
          "    total = sum(arr)",
          "  end subroutine compute_sum",
          "",
          "end program demo_assumed_shape_1d"
        ],
        "results": [
          "  Array size: 5",
          "  Bounds: 1 to 5",
          "Sum of small_array:      15.00",
          "  Array size: 100",
          "  Bounds: 1 to 100",
          "Sum of large_array:     100.00",
          "  Array size: 10",
          "  Bounds: 1 to 10",
          "Sum of first 10 elements:      10.00"
        ]
      },
      "standard": "Fortran 90",
      "see_also": [
        "[**assumed_shape_array_2d**(3)](#assumed_shape_array_2d) - Two-dimensional assumed-shape arrays",
        "[**explicit_shape_array**(3)](#explicit_shape_array) - Arrays with explicit dimensions",
        "[**allocatable_array**(3)](#allocatable_array) - Dynamically allocated arrays",
        "[**size**(3)](#size) - Query array size intrinsic",
        "[**lbound**(3)](#lbound) - Query lower bound intrinsic",
        "[**ubound**(3)](#ubound) - Query upper bound intrinsic"
      ]
    }
  },
  "Assumed-Shape Array 2D": {
    "prefix": [
      "assumed2d",
      "ASSUMED2D",
      "arr2d",
      "mat"
    ],
    "body": [
      "${1:real(dp)}, intent(${2|in,out,inout|}) :: ${3:mat}(:,:)$0"
    ],
    "description": "ASSUMED_SHAPE_2D(TYPE,INTENT,NAME) declares a 2D assumed-shape array dummy argument.",
    "documentation": {
      "name": "**assumed_shape_2d** - \\[ARRAY:DECLARATION\\] Declare a two-dimensional assumed-shape array dummy argument",
      "synopsis": {
        "usage": "type, intent(in|out|inout) :: array_name(:,:)",
        "interface": [
          "subroutine example_sub(matrix)",
          "",
          "  real(dp), intent(in) :: matrix(:,:)",
          ""
        ]
      },
      "characteristics": [
        "**type** is any intrinsic or derived type (integer, real, complex, logical, character, or user-defined type)",
        "**intent** specifies the data flow direction: in (read-only), out (write-only), or inout (read-write)",
        "**name** is the dummy argument name that will reference the passed array",
        "The array rank must match the actual argument (both must be rank-2)",
        "The array kind must match the actual argument",
        "Lower bounds default to 1 unless explicitly specified",
        "The procedure must have an explicit interface (module procedure or interface block)"
      ],
      "description": "**Assumed-shape arrays** allow dummy arguments to accept arrays of any extent without requiring explicit size parameters. The bounds are automatically determined from the actual argument at runtime. This is the recommended method for passing arrays in modern Fortran as it provides type safety, bounds checking capability, and simplifies procedure interfaces. The shape information is passed automatically through the array descriptor, and intrinsic functions like SIZE, SHAPE, LBOUND, and UBOUND can query the dimensions.",
      "options": [
        {
          "name": "type",
          "description": "The data type declaration including kind specification. Common examples: real(dp), integer, complex(dp), character(len=*), or derived types. The type must match the actual argument exactly."
        },
        {
          "name": "intent",
          "description": "Specifies how the argument is used: 'in' for read-only input (value cannot be modified), 'out' for output-only (value is undefined on entry, must be defined before return), 'inout' for both input and output (value can be read and modified)."
        },
        {
          "name": "name",
          "description": "The identifier for the dummy argument. By convention, use descriptive names like 'matrix', 'grid', 'coefficients', etc. The name is local to the procedure."
        }
      ],
      "examples": {
        "code": [
          "program demo_assumed_shape_2d",
          "  use, intrinsic :: iso_fortran_env, only: dp => real64",
          "  implicit none",
          "",
          "  real(dp) :: small_matrix(2, 3)",
          "  real(dp) :: large_matrix(100, 200)",
          "  real(dp), allocatable :: dynamic_matrix(:,:)",
          "",
          "  ! Initialize test matrices",
          "  small_matrix = reshape([1, 2, 3, 4, 5, 6], [2, 3])",
          "  large_matrix = 0.0_dp",
          "  ",
          "  allocate(dynamic_matrix(50, 75))",
          "  dynamic_matrix = 1.0_dp",
          "",
          "  ! Same subroutine works with any 2D array size",
          "  call print_matrix_info(small_matrix)",
          "  call print_matrix_info(large_matrix)",
          "  call print_matrix_info(dynamic_matrix)",
          "",
          "  ! Demonstrate intent(inout) - modify in place",
          "  call scale_matrix(small_matrix, 2.0_dp)",
          "  print *, 'Scaled matrix(1,1):', small_matrix(1,1)",
          "",
          "  deallocate(dynamic_matrix)",
          "",
          "contains",
          "",
          "  subroutine print_matrix_info(mat)",
          "    ! Assumed-shape 2D array with intent(in)",
          "    real(dp), intent(in) :: mat(:,:)",
          "    ",
          "    print *, 'Matrix shape:', size(mat, 1), 'x', size(mat, 2)",
          "    print *, 'Total elements:', size(mat)",
          "    print *, 'Bounds: [', lbound(mat, 1), ':', ubound(mat, 1), ', ', &",
          "                         lbound(mat, 2), ':', ubound(mat, 2), ']'",
          "  end subroutine print_matrix_info",
          "",
          "  subroutine scale_matrix(mat, factor)",
          "    ! Assumed-shape 2D array with intent(inout)",
          "    real(dp), intent(inout) :: mat(:,:)",
          "    real(dp), intent(in) :: factor",
          "    ",
          "    mat = mat * factor",
          "  end subroutine scale_matrix",
          "",
          "end program demo_assumed_shape_2d"
        ],
        "results": [
          " Matrix shape:           2 x           3",
          " Total elements:           6",
          " Bounds: [           1 :           2 ,            1 :           3 ]",
          " Matrix shape:         100 x         200",
          " Total elements:       20000",
          " Bounds: [           1 :         100 ,            1 :         200 ]",
          " Matrix shape:          50 x          75",
          " Total elements:        3750",
          " Bounds: [           1 :          50 ,            1 :          75 ]",
          " Scaled matrix(1,1):   2.0000000000000000"
        ]
      },
      "standard": "Fortran 90 (ISO/IEC 1539:1991)",
      "see_also": [
        "**assumed_shape_1d** - One-dimensional assumed-shape array",
        "**assumed_shape_3d** - Three-dimensional assumed-shape array",
        "**assumed_rank** - Assumed-rank array (Fortran 2018)",
        "**allocatable_array** - Allocatable array declaration",
        "**SIZE**(3) - Returns array extent",
        "**SHAPE**(3) - Returns array shape",
        "**LBOUND**(3) - Returns lower bounds",
        "**UBOUND**(3) - Returns upper bounds"
      ],
      "notes": [
        "Assumed-shape arrays require an explicit interface. Place procedures in modules or provide interface blocks.",
        "The lower bound defaults to 1 regardless of the actual argument's lower bound. To preserve bounds, pass them explicitly.",
        "Unlike assumed-size arrays (with *), assumed-shape arrays allow bounds checking and intrinsic inquiry functions.",
        "For maximum performance in tight loops, consider explicit-shape arrays if the compiler cannot optimize descriptor access."
      ]
    }
  },
  "Assumed-Shape Array 3D": {
    "prefix": [
      "assumed3d",
      "ASSUMED3D",
      "arr3d"
    ],
    "body": [
      "${1:real(dp)}, intent(${2|in,out,inout|}) :: ${3:arr}(:,:,:)$0"
    ],
    "description": "ASSUMED_SHAPE_3D(TYPE,INTENT,NAME) declares a 3D assumed-shape array argument for procedures."
  },
  "BLAS DGEMM": {
    "prefix": [
      "dgemm",
      "DGEMM"
    ],
    "body": [
      "call dgemm('${1:N}', '${2:N}', ${3:m}, ${4:n}, ${5:k}, ${6:alpha}, ${7:A}, ${8:lda}, ${9:B}, ${10:ldb}, ${11:beta}, ${12:C}, ${13:ldc})"
    ],
    "description": "DGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC) performs double precision matrix-matrix multiplication C = alpha*op(A)*op(B) + beta*C.",
    "documentation": {
      "name": "**dgemm** - \\[NUMERIC:BLAS\\] Double precision general matrix-matrix multiply",
      "synopsis": {
        "usage": "call dgemm(transa, transb, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc)",
        "interface": [
          "subroutine dgemm(transa, transb, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc)",
          "",
          "  character(len=1), intent(in)    :: transa",
          "  character(len=1), intent(in)    :: transb",
          "  integer,          intent(in)    :: m",
          "  integer,          intent(in)    :: n",
          "  integer,          intent(in)    :: k",
          "  double precision, intent(in)    :: alpha",
          "  double precision, intent(in)    :: A(lda,*)",
          "  integer,          intent(in)    :: lda",
          "  double precision, intent(in)    :: B(ldb,*)",
          "  integer,          intent(in)    :: ldb",
          "  double precision, intent(in)    :: beta",
          "  double precision, intent(inout) :: C(ldc,*)",
          "  integer,          intent(in)    :: ldc"
        ]
      },
      "characteristics": [
        "**transa** is a single character specifying the operation on matrix A",
        "**transb** is a single character specifying the operation on matrix B",
        "**m** is an integer specifying the number of rows of op(A) and C",
        "**n** is an integer specifying the number of columns of op(B) and C",
        "**k** is an integer specifying the number of columns of op(A) and rows of op(B)",
        "**alpha** is a double precision scalar multiplier for op(A)*op(B)",
        "**A** is a double precision array of dimension (lda, ka) where ka is k when transa='N' or m otherwise",
        "**lda** is an integer specifying the leading dimension of A",
        "**B** is a double precision array of dimension (ldb, kb) where kb is n when transb='N' or k otherwise",
        "**ldb** is an integer specifying the leading dimension of B",
        "**beta** is a double precision scalar multiplier for C",
        "**C** is a double precision array of dimension (ldc, n), the result matrix",
        "**ldc** is an integer specifying the leading dimension of C, must be >= max(1, m)"
      ],
      "description": [
        "**dgemm** performs one of the matrix-matrix operations:",
        "",
        "  C := alpha*op(A)*op(B) + beta*C",
        "",
        "where op(X) is one of op(X) = X or op(X) = X**T (transpose),",
        "alpha and beta are scalars, and A, B, and C are matrices.",
        "op(A) is an m by k matrix, op(B) is a k by n matrix, and C is an m by n matrix.",
        "",
        "This is a Level 3 BLAS routine optimized for matrix-matrix operations",
        "with O(n^3) floating point operations and O(n^2) data movement,",
        "achieving high performance through cache optimization."
      ],
      "options": [
        {
          "name": "transa",
          "description": "Specifies the form of op(A) used in the multiplication. 'N' or 'n': op(A) = A (no transpose). 'T' or 't': op(A) = A**T (transpose). 'C' or 'c': op(A) = A**T (conjugate transpose, same as transpose for real)."
        },
        {
          "name": "transb",
          "description": "Specifies the form of op(B) used in the multiplication. 'N' or 'n': op(B) = B (no transpose). 'T' or 't': op(B) = B**T (transpose). 'C' or 'c': op(B) = B**T (conjugate transpose, same as transpose for real)."
        },
        {
          "name": "m",
          "description": "The number of rows of the matrix op(A) and of the matrix C. m >= 0."
        },
        {
          "name": "n",
          "description": "The number of columns of the matrix op(B) and of the matrix C. n >= 0."
        },
        {
          "name": "k",
          "description": "The number of columns of the matrix op(A) and the number of rows of the matrix op(B). k >= 0."
        },
        {
          "name": "alpha",
          "description": "Double precision scalar. When alpha is zero, A and B are not referenced."
        },
        {
          "name": "A",
          "description": "Double precision array. When transa='N', A has dimensions (lda, k). When transa='T' or 'C', A has dimensions (lda, m). The leading m by k (or k by m) part contains the matrix A."
        },
        {
          "name": "lda",
          "description": "Leading dimension of A. When transa='N', lda >= max(1, m). When transa='T' or 'C', lda >= max(1, k)."
        },
        {
          "name": "B",
          "description": "Double precision array. When transb='N', B has dimensions (ldb, n). When transb='T' or 'C', B has dimensions (ldb, k). The leading k by n (or n by k) part contains the matrix B."
        },
        {
          "name": "ldb",
          "description": "Leading dimension of B. When transb='N', ldb >= max(1, k). When transb='T' or 'C', ldb >= max(1, n)."
        },
        {
          "name": "beta",
          "description": "Double precision scalar. When beta is zero, C need not be set on input."
        },
        {
          "name": "C",
          "description": "Double precision array of dimension (ldc, n). On entry, the leading m by n part contains the matrix C. On exit, C is overwritten by the m by n result matrix."
        },
        {
          "name": "ldc",
          "description": "Leading dimension of C. ldc >= max(1, m)."
        }
      ],
      "examples": {
        "code": [
          "program demo_dgemm",
          "! Demonstrates BLAS DGEMM: C = alpha*A*B + beta*C",
          "implicit none",
          "  integer, parameter :: m = 2, n = 3, k = 2",
          "  double precision :: alpha, beta",
          "  double precision :: A(m, k), B(k, n), C(m, n)",
          "  integer :: i, j",
          "",
          "  ! Initialize matrices",
          "  ! A is 2x2:",
          "  !   | 1.0  2.0 |",
          "  !   | 3.0  4.0 |",
          "  A(1,1) = 1.0d0; A(1,2) = 2.0d0",
          "  A(2,1) = 3.0d0; A(2,2) = 4.0d0",
          "",
          "  ! B is 2x3:",
          "  !   | 1.0  2.0  3.0 |",
          "  !   | 4.0  5.0  6.0 |",
          "  B(1,1) = 1.0d0; B(1,2) = 2.0d0; B(1,3) = 3.0d0",
          "  B(2,1) = 4.0d0; B(2,2) = 5.0d0; B(2,3) = 6.0d0",
          "",
          "  ! Initialize C to zero",
          "  C = 0.0d0",
          "",
          "  ! Set scalars: C = 1.0*A*B + 0.0*C",
          "  alpha = 1.0d0",
          "  beta = 0.0d0",
          "",
          "  ! Perform matrix multiplication: C = A * B",
          "  ! 'N','N' means no transpose for A or B",
          "  call dgemm('N', 'N', m, n, k, alpha, A, m, B, k, beta, C, m)",
          "",
          "  ! Print result",
          "  print '(a)', 'Matrix C = A * B:'",
          "  do i = 1, m",
          "    print '(3f8.2)', (C(i,j), j=1,n)",
          "  end do",
          "",
          "  ! Expected result:",
          "  ! C(1,1) = 1*1 + 2*4 = 9",
          "  ! C(1,2) = 1*2 + 2*5 = 12",
          "  ! C(1,3) = 1*3 + 2*6 = 15",
          "  ! C(2,1) = 3*1 + 4*4 = 19",
          "  ! C(2,2) = 3*2 + 4*5 = 26",
          "  ! C(2,3) = 3*3 + 4*6 = 33",
          "",
          "  ! Example with transpose: C = A^T * A (produces symmetric matrix)",
          "  ! A^T is 2x2, A is 2x2, result is 2x2",
          "  call dgemm('T', 'N', k, k, m, 1.0d0, A, m, A, m, 0.0d0, C, m)",
          "  print '(a)', 'Matrix C = A^T * A:'",
          "  do i = 1, k",
          "    print '(2f8.2)', (C(i,j), j=1,k)",
          "  end do",
          "",
          "end program demo_dgemm"
        ],
        "results": [
          "Matrix C = A * B:",
          "    9.00   12.00   15.00",
          "   19.00   26.00   33.00",
          "Matrix C = A^T * A:",
          "   10.00   14.00",
          "   14.00   20.00"
        ]
      },
      "standard": "BLAS Level 3 (Basic Linear Algebra Subprograms)",
      "see_also": [
        "**sgemm**(3) - Single precision general matrix-matrix multiply",
        "**zgemm**(3) - Double complex general matrix-matrix multiply",
        "**cgemm**(3) - Single complex general matrix-matrix multiply",
        "**matmul**(3) - Fortran intrinsic matrix multiplication"
      ]
    }
  },
  "C Function Binding": {
    "prefix": [
      "cbind",
      "CBIND",
      "bindc",
      "BINDC",
      "c_function",
      "C_FUNCTION"
    ],
    "body": [
      "function ${1:func_name}(${2:arg}) result(${3:res}) bind(c, name='${4:c_func_name}')",
      "\tuse, intrinsic :: iso_c_binding, only: ${5:c_int, c_double}",
      "\t${6:integer(c_int)}, intent(in), value :: ${2:arg}",
      "\t${7:real(c_double)} :: ${3:res}",
      "",
      "\t$0",
      "end function ${1:func_name}"
    ],
    "description": "BIND(C,NAME=c_name) declares a Fortran function interoperable with C, using ISO_C_BINDING types for portable data exchange."
  },
  "C Interoperable Type": {
    "prefix": [
      "ctype",
      "CTYPE",
      "bindctype",
      "BINDCTYPE",
      "bind_c_type"
    ],
    "body": [
      "type, bind(c) :: ${1:type_name}",
      "\t${2:integer(c_int)} :: ${3:member1}",
      "\t${4:real(c_double)} :: ${5:member2}",
      "\t${0}",
      "end type ${1:type_name}"
    ],
    "description": "type, bind(c) :: name ... end type name defines a derived type interoperable with C structs."
  },
  "_c_interoperable_type_documentation": {
    "name": "**bind(c) type** - \\[INTEROP:C_BINDING\\] Define a derived type interoperable with C structs",
    "synopsis": {
      "usage": [
        "type, bind(c) :: type_name",
        "    component_type :: component_name",
        "end type type_name"
      ],
      "interface": [
        "type, bind(c) :: type_name",
        "",
        "    integer(c_int)     :: int_member",
        "    real(c_float)      :: float_member",
        "    real(c_double)     :: double_member",
        "    character(c_char)  :: char_member",
        "    type(c_ptr)        :: ptr_member",
        "",
        "end type type_name"
      ]
    },
    "characteristics": [
      "**bind(c)** attribute makes the type interoperable with C struct types.",
      "All components must be of interoperable types from ISO_C_BINDING module.",
      "Components must not be pointers or allocatable.",
      "The type must not have type parameters.",
      "The type must not extend another type (no inheritance).",
      "The type must not have the SEQUENCE attribute.",
      "Component names do not need to match C struct member names.",
      "Memory layout matches C struct layout (implementation-dependent padding may occur)."
    ],
    "description": "**bind(c) type** declares a Fortran derived type that is interoperable with a C struct. This enables passing structured data between Fortran and C routines. The BIND(C) attribute ensures the Fortran type has a storage layout compatible with the corresponding C struct. All component types must be interoperable kinds provided by the ISO_C_BINDING intrinsic module, such as C_INT, C_FLOAT, C_DOUBLE, C_CHAR, C_PTR, and C_FUNPTR.",
    "options": [
      {
        "name": "type_name",
        "description": "The name of the derived type. This name is used in Fortran code and does not need to match the C struct name. The C name can be specified via BIND(C, NAME='c_struct_name')."
      },
      {
        "name": "bind(c)",
        "description": "Required attribute that marks the type as C-interoperable. Optionally accepts NAME='string' to specify the C struct tag name for linkage purposes."
      },
      {
        "name": "components",
        "description": "Each component must be declared with an interoperable type. Common interoperable types from ISO_C_BINDING include: integer(c_int), integer(c_long), integer(c_size_t), real(c_float), real(c_double), character(c_char), type(c_ptr), type(c_funptr), and logical(c_bool)."
      }
    ],
    "examples": {
      "code": [
        "program demo_c_interoperable_type",
        "  use, intrinsic :: iso_c_binding",
        "  implicit none",
        "",
        "  ! Define a Fortran type interoperable with C struct",
        "  type, bind(c) :: point_2d",
        "    real(c_double) :: x",
        "    real(c_double) :: y",
        "  end type point_2d",
        "",
        "  ! More complex type with various C-interoperable members",
        "  type, bind(c) :: particle",
        "    integer(c_int)    :: id",
        "    real(c_double)    :: mass",
        "    real(c_float)     :: charge",
        "    type(point_2d)    :: position    ! Nested interoperable type",
        "    type(point_2d)    :: velocity",
        "    logical(c_bool)   :: active",
        "  end type particle",
        "",
        "  ! Interface to C function that uses the type",
        "  interface",
        "    subroutine process_particle(p) bind(c, name='process_particle')",
        "      import :: particle",
        "      type(particle), intent(inout) :: p",
        "    end subroutine process_particle",
        "  end interface",
        "",
        "  type(point_2d)  :: pt",
        "  type(particle)  :: p1",
        "",
        "  ! Initialize point",
        "  pt%x = 3.0_c_double",
        "  pt%y = 4.0_c_double",
        "  print '(A,F6.2,A,F6.2)', 'Point: (', pt%x, ', ', pt%y, ')'",
        "",
        "  ! Initialize particle",
        "  p1%id       = 1",
        "  p1%mass     = 1.67e-27_c_double   ! Proton mass in kg",
        "  p1%charge   = 1.6e-19_c_float     ! Elementary charge in C",
        "  p1%position = point_2d(0.0_c_double, 0.0_c_double)",
        "  p1%velocity = point_2d(1.0e5_c_double, 2.0e5_c_double)",
        "  p1%active   = .true._c_bool",
        "",
        "  print '(A,I0)',       'Particle ID: ', p1%id",
        "  print '(A,ES12.4)',   'Mass: ', p1%mass",
        "  print '(A,L1)',       'Active: ', p1%active",
        "",
        "end program demo_c_interoperable_type"
      ],
      "corresponding_c_code": [
        "/* Corresponding C struct definitions */",
        "#include <stdbool.h>",
        "",
        "typedef struct {",
        "    double x;",
        "    double y;",
        "} point_2d;",
        "",
        "typedef struct {",
        "    int       id;",
        "    double    mass;",
        "    float     charge;",
        "    point_2d  position;",
        "    point_2d  velocity;",
        "    _Bool     active;",
        "} particle;",
        "",
        "void process_particle(particle* p) {",
        "    /* Process the particle */",
        "    p->id++;",
        "}"
      ],
      "results": [
        "Point: (  3.00,   4.00)",
        "Particle ID: 1",
        "Mass:   1.6700E-27",
        "Active: T"
      ]
    },
    "standard": "Fortran 2003",
    "see_also": [
      "[**iso_c_binding**(3)](#iso_c_binding) - Intrinsic module providing C interoperability constants and types",
      "[**c_ptr**(3)](#c_ptr) - Derived type for C pointer interoperability",
      "[**c_f_pointer**(3)](#c_f_pointer) - Convert C pointer to Fortran pointer",
      "[**c_loc**(3)](#c_loc) - Get C address of Fortran variable",
      "[**c_funptr**(3)](#c_funptr) - Derived type for C function pointer interoperability",
      "[**bind(c)**(3)](#bind_c) - Attribute for C-interoperable procedures"
    ],
    "notes": [
      "The BIND(C) attribute was introduced in Fortran 2003 as part of the C interoperability features.",
      "Character components should be declared as character(c_char) for single characters or character(c_char, len=N) for fixed-length strings (interoperates with char[N] in C).",
      "Arrays of interoperable types are allowed as components and interoperate with C arrays.",
      "The optional NAME= specifier in BIND(C, NAME='name') allows specifying a different name for C linkage.",
      "Sequence association rules differ between Fortran and C; use explicit interfaces for safety.",
      "Compiler-specific padding may affect interoperability; use -fpack-derived or equivalent flags if needed."
    ]
  },
  "C Pointer Conversion": {
    "prefix": [
      "cfptr",
      "CFPTR",
      "c_f_pointer",
      "C_F_POINTER"
    ],
    "body": [
      "use, intrinsic :: iso_c_binding, only: c_ptr, c_f_pointer, ${1:c_double}",
      "type(c_ptr) :: ${2:cptr}",
      "${3:real($1)}, pointer :: ${4:fptr}${5:(:)}",
      "call c_f_pointer(${2:cptr}, ${4:fptr}${6:, [${7:n}]})"
    ],
    "description": "C_F_POINTER(CPTR,FPTR,SHAPE=shape) converts a C pointer to a Fortran pointer with optional shape specification."
  },
  "C_F_POINTER": {
    "args": "CPTR,FPTR,SHAPE=shape",
    "doc": "C_F_POINTER(CPTR,FPTR,SHAPE=shape) assigns the target of a C pointer to a Fortran pointer.",
    "type": 2
  },
  "C_F_POINTER_MARKDOWN": {
    "documentation": [
      "## c_f_pointer",
      "",
      "### **Name**",
      "",
      "**c_f_pointer** - \\[INTEROP:C_BINDING\\] Convert a C pointer to a Fortran pointer",
      "",
      "### **Synopsis**",
      "",
      "```fortran",
      "    call c_f_pointer(cptr, fptr [, shape])",
      "```",
      "",
      "```fortran",
      "     subroutine c_f_pointer(cptr, fptr, shape)",
      "",
      "      type(c_ptr), intent(in)              :: cptr",
      "      type(*), pointer, intent(out)        :: fptr",
      "      integer, intent(in), optional        :: shape(:)",
      "```",
      "",
      "### **Characteristics**",
      "",
      " - **cptr** is a scalar of type `c_ptr` from `iso_c_binding`.",
      " - **fptr** is a Fortran pointer of any type that is interoperable with the target of **cptr**.",
      " - **shape** is a rank-one integer array specifying the shape of an array pointer.",
      " - **shape** shall be present if and only if **fptr** is an array pointer.",
      " - The size of **shape** must equal the rank of **fptr**.",
      "",
      "### **Description**",
      "",
      " **c_f_pointer** assigns the target of the C pointer **cptr** to the Fortran",
      " pointer **fptr** and optionally specifies its shape. This subroutine provides",
      " the mechanism to convert C memory addresses into Fortran pointers, enabling",
      " seamless interoperability between Fortran and C code.",
      "",
      " The C pointer type `c_ptr` is an opaque derived type with private components",
      " that represents C pointers in Fortran. Since C pointers are fundamentally",
      " different from Fortran pointers with the POINTER attribute, this conversion",
      " subroutine is essential for interoperability.",
      "",
      "### **Options**",
      "",
      "- **cptr**",
      "  : A scalar of type `c_ptr` containing the C address to be associated with",
      "  the Fortran pointer. This is typically obtained from a C function via",
      "  `bind(c)` interface or from `c_loc()` applied to a Fortran target.",
      "",
      "- **fptr**",
      "  : A Fortran pointer that will be associated with the target of **cptr**.",
      "  The type of **fptr** must be interoperable with the C type that **cptr**",
      "  points to. For scalars, **fptr** should be a scalar pointer. For arrays,",
      "  **fptr** should be an array pointer with the appropriate rank.",
      "",
      "- **shape**",
      "  : (Optional) A rank-one integer array specifying the extents of each",
      "  dimension when **fptr** is an array pointer. The size of **shape** must",
      "  equal the rank of **fptr**. This argument is required for array pointers",
      "  and must be absent for scalar pointers.",
      "",
      "### **Examples**",
      "",
      "Sample program:",
      "",
      "```fortran",
      "program demo_c_f_pointer",
      "  use, intrinsic :: iso_c_binding, only: c_ptr, c_f_pointer, c_double, c_loc",
      "  implicit none",
      "",
      "  ! Declarations",
      "  real(c_double), target  :: scalar_data",
      "  real(c_double), target  :: array_data(3, 4)",
      "  type(c_ptr)             :: cptr",
      "  real(c_double), pointer :: fptr_scalar",
      "  real(c_double), pointer :: fptr_array(:,:)",
      "",
      "  ! Example 1: Scalar pointer conversion",
      "  scalar_data = 3.14159d0",
      "  cptr = c_loc(scalar_data)              ! Get C pointer to scalar",
      "  call c_f_pointer(cptr, fptr_scalar)    ! Convert to Fortran pointer",
      "  print '(A,F10.5)', 'Scalar value: ', fptr_scalar",
      "",
      "  ! Example 2: Array pointer conversion with shape",
      "  array_data = reshape([(dble(i), i=1,12)], [3, 4])",
      "  cptr = c_loc(array_data)               ! Get C pointer to array",
      "  call c_f_pointer(cptr, fptr_array, [3, 4])  ! Convert with shape",
      "  print '(A)', 'Array values (first column):'",
      "  print '(3F8.1)', fptr_array(:, 1)",
      "",
      "  ! Example 3: Treating 1D array as 2D via reshaping",
      "  block",
      "    real(c_double), target  :: linear(12)",
      "    real(c_double), pointer :: matrix(:,:)",
      "    linear = [(dble(i)*10, i=1,12)]",
      "    cptr = c_loc(linear)",
      "    call c_f_pointer(cptr, matrix, [3, 4])",
      "    print '(A)', 'Reshaped matrix (row 1):'",
      "    print '(4F8.1)', matrix(1, :)",
      "  end block",
      "",
      "contains",
      "  integer function i()",
      "    i = 0  ! Placeholder for implicit loop variable",
      "  end function",
      "",
      "end program demo_c_f_pointer",
      "```",
      "",
      "Results:",
      "",
      "```text",
      "Scalar value:    3.14159",
      "Array values (first column):",
      "     1.0     2.0     3.0",
      "Reshaped matrix (row 1):",
      "    10.0    40.0    70.0   100.0",
      "```",
      "",
      "### **Standard**",
      "",
      "Fortran 2003",
      "",
      "### **See Also**",
      "",
      "[**c_loc**(3)](#c_loc),",
      "[**c_funloc**(3)](#c_funloc),",
      "[**c_f_procpointer**(3)](#c_f_procpointer),",
      "[**c_associated**(3)](#c_associated),",
      "[**c_sizeof**(3)](#c_sizeof)",
      "",
      "### **Resources**",
      "",
      "- [GNU Fortran C_F_POINTER Documentation](https://gcc.gnu.org/onlinedocs/gfortran/C_005fF_005fPOINTER.html)",
      "- [Fortran Wiki: c_f_pointer](https://fortranwiki.org/fortran/show/c_f_pointer)",
      "- [IBM XL Fortran C_F_POINTER](https://www.ibm.com/docs/en/xl-fortran-linux/16.1.1?topic=procedures-c-f-pointercptr-fptr-shape)"
    ]
  },
  "C String to Fortran": {
    "prefix": [
      "cstring",
      "CSTRING",
      "c2fstring",
      "C2FSTRING",
      "c_to_f_string"
    ],
    "body": [
      "function c_to_f_string(c_str) result(f_str)",
      "  use, intrinsic :: iso_c_binding, only: c_char, c_null_char",
      "  character(kind=c_char), dimension(*), intent(in) :: c_str",
      "  character(len=:), allocatable :: f_str",
      "  integer :: i, n",
      "",
      "  ! Find the null terminator",
      "  n = 1",
      "  do while (c_str(n) /= c_null_char)",
      "    n = n + 1",
      "  end do",
      "  n = n - 1",
      "",
      "  ! Allocate and copy",
      "  allocate(character(len=n) :: f_str)",
      "  do i = 1, n",
      "    f_str(i:i) = c_str(i)",
      "  end do",
      "end function c_to_f_string"
    ],
    "description": "C_TO_F_STRING(C_STR) converts a C null-terminated string to a Fortran allocatable string.",
    "_documentation": {
      "name": "**c_to_f_string** - \\[INTEROP:C_BINDING\\] Convert C null-terminated string to Fortran string",
      "synopsis": {
        "usage": "    f_str = c_to_f_string(c_str)",
        "interface": [
          "     function c_to_f_string(c_str) result(f_str)",
          "",
          "      character(kind=c_char), dimension(*), intent(in) :: c_str",
          "      character(len=:), allocatable                    :: f_str"
        ]
      },
      "characteristics": [
        "**c_str** is a character array of kind `c_char` with assumed size, representing a C null-terminated string.",
        "**f_str** is an allocatable deferred-length character string.",
        "The function requires `iso_c_binding` module for `c_char` and `c_null_char`.",
        "The result is allocated to the exact length of the C string (excluding the null terminator)."
      ],
      "description": "**c_to_f_string** converts a C-style null-terminated character array into a native Fortran allocatable string. It scans the input array for the null terminator (`c_null_char`), allocates the result string to the appropriate length, and copies the characters. This is essential for interoperability when receiving string data from C functions.",
      "options": {
        "c_str": "A C null-terminated string represented as a character array of kind `c_char`. Must be null-terminated with `c_null_char` (ASCII 0). The array is assumed-size `dimension(*)` to accept any length."
      },
      "result": "An allocatable character string containing the contents of the C string without the null terminator. The length is automatically determined from the position of `c_null_char`. If the C string is empty (null terminator at position 1), returns a zero-length string.",
      "examples": {
        "code": [
          "program demo_c_to_f_string",
          "  use, intrinsic :: iso_c_binding",
          "  implicit none",
          "",
          "  interface",
          "    ! Example C function that returns a string",
          "    function get_message() bind(C, name='get_message')",
          "      import :: c_ptr",
          "      type(c_ptr) :: get_message",
          "    end function get_message",
          "  end interface",
          "",
          "  character(kind=c_char), dimension(256), target :: c_buffer",
          "  character(len=:), allocatable :: fortran_string",
          "",
          "  ! Simulate a C string (null-terminated)",
          "  c_buffer(1) = 'H'",
          "  c_buffer(2) = 'e'",
          "  c_buffer(3) = 'l'",
          "  c_buffer(4) = 'l'",
          "  c_buffer(5) = 'o'",
          "  c_buffer(6) = c_null_char",
          "",
          "  ! Convert to Fortran string",
          "  fortran_string = c_to_f_string(c_buffer)",
          "",
          "  print '(A,I0)', 'Length: ', len(fortran_string)",
          "  print '(A,A)',  'String: ', fortran_string",
          "",
          "contains",
          "",
          "  function c_to_f_string(c_str) result(f_str)",
          "    character(kind=c_char), dimension(*), intent(in) :: c_str",
          "    character(len=:), allocatable :: f_str",
          "    integer :: i, n",
          "",
          "    n = 1",
          "    do while (c_str(n) /= c_null_char)",
          "      n = n + 1",
          "    end do",
          "    n = n - 1",
          "",
          "    allocate(character(len=n) :: f_str)",
          "    do i = 1, n",
          "      f_str(i:i) = c_str(i)",
          "    end do",
          "  end function c_to_f_string",
          "",
          "end program demo_c_to_f_string"
        ],
        "results": [
          "Length: 5",
          "String: Hello"
        ]
      },
      "standard": "Fortran 2003",
      "see_also": [
        "[**c_f_pointer**(3)](#c_f_pointer)",
        "[**c_loc**(3)](#c_loc)",
        "[**c_associated**(3)](#c_associated)",
        "[**iso_c_binding**(3)](#iso_c_binding)"
      ]
    }
  },
  "C Subroutine Binding": {
    "prefix": [
      "cbindsub",
      "CBINDSUB",
      "bindcsub"
    ],
    "body": [
      "subroutine ${1:fortran_sub}(${2:arg}) bind(c, name='${3:c_sub_name}')",
      "\tuse, intrinsic :: iso_c_binding, only: ${4:c_int, c_ptr}",
      "\t${5:type(c_ptr)}, value :: ${2:arg}",
      "",
      "\t${0}",
      "end subroutine ${1:fortran_sub}"
    ],
    "description": "BIND_C_SUB(FORTRAN_SUB,ARG,C_SUB_NAME,C_TYPES,ARG_TYPE) creates a Fortran subroutine callable from C with iso_c_binding interoperability."
  },
  "Check Optional Present": {
    "prefix": [
      "present",
      "PRESENT"
    ],
    "body": [
      "if (present(${1:arg})) then",
      "\t${0}",
      "end if"
    ],
    "description": "PRESENT(A) determines whether an optional dummy argument is present.",
    "documentation": {
      "name": "**present** - \\[TYPE:INQUIRY\\] Determine whether an optional dummy argument is present",
      "synopsis": {
        "usage": "result = present(a)",
        "interface": [
          "function present(a)",
          "",
          "  type(*), optional, intent(in) :: a(..)",
          "  logical                       :: present"
        ]
      },
      "characteristics": [
        "**a** is a dummy argument with the OPTIONAL attribute",
        "**a** can be of any type (scalar, array, pointer, or dummy procedure)",
        "**a** must be accessible in the current scope (subroutine or function)",
        "The result is a default logical scalar"
      ],
      "description": "**present** determines whether an optional dummy argument was provided in the actual argument list of the procedure invocation. It returns .TRUE. if the optional argument A is present, otherwise .FALSE. This intrinsic is essential for writing procedures that handle optional arguments safely, as accessing an absent optional argument is prohibited by the Fortran standard.",
      "options": {
        "a": "The name of an optional dummy argument accessible in the current procedure. It must have the OPTIONAL attribute in its declaration. The argument can be of any data type, including derived types, and can be a scalar, array, pointer, or even a dummy procedure."
      },
      "result": "Returns a default logical value: .TRUE. if the optional argument A was provided by the caller, .FALSE. if the argument was omitted. The result can be used in conditional expressions to safely access or provide default values for optional arguments.",
      "examples": {
        "program": [
          "program demo_present",
          "implicit none",
          "  ! Demonstrate PRESENT intrinsic with optional arguments",
          "  ",
          "  ! Test with and without optional argument",
          "  call greet('Alice')",
          "  call greet('Bob', 'Dr.')",
          "  ",
          "  ! Test logical return value",
          "  print *, 'f() returns:', f()",
          "  print *, 'f(42) returns:', f(42)",
          "",
          "contains",
          "",
          "  subroutine greet(name, title)",
          "    character(len=*), intent(in) :: name",
          "    character(len=*), intent(in), optional :: title",
          "    ",
          "    if (present(title)) then",
          "      print *, 'Hello, ', trim(title), ' ', trim(name), '!'",
          "    else",
          "      print *, 'Hello, ', trim(name), '!'",
          "    end if",
          "  end subroutine greet",
          "",
          "  logical function f(x)",
          "    integer, intent(in), optional :: x",
          "    f = present(x)",
          "  end function f",
          "",
          "end program demo_present"
        ],
        "results": [
          " Hello, Alice!",
          " Hello, Dr. Bob!",
          " f() returns: F",
          " f(42) returns: T"
        ]
      },
      "standard": "Fortran 90",
      "see_also": [
        "[**optional**(attribute)](#optional)"
      ],
      "notes": [
        "IMPORTANT: Fortran does not guarantee short-circuit evaluation of logical expressions. When checking PRESENT and then using the argument, use nested IF statements rather than compound logical expressions.",
        "WRONG: if (present(arg) .and. arg > 0) then",
        "RIGHT: if (present(arg)) then; if (arg > 0) then ...",
        "An absent optional argument can be passed to another procedure that also declares it as OPTIONAL without first checking PRESENT - the 'absent-ness' propagates correctly."
      ]
    }
  },
  "Class Polymorphic": {
    "prefix": [
      "class",
      "CLASS",
      "polymorphic"
    ],
    "body": "class(${1:type_name}), intent(${2|in,out,inout|}) :: ${0:self}",
    "description": "CLASS(type_name) declares a polymorphic dummy argument that can accept any type extension."
  },
  "Coarray Declaration": {
    "prefix": [
      "coarray",
      "COARRAY",
      "codimension"
    ],
    "body": [
      "${1:real(dp)}, codimension[${2:*}] :: ${0:var}"
    ],
    "description": "## coarray_declaration\n\n### **Name**\n\n**coarray_declaration** - \\[PARALLEL:COARRAY\\] Declare a coarray variable with codimension\n\n### **Synopsis**\n```fortran\n    type, codimension[cosubscript] :: variable_name\n```\n```fortran\n     type(TYPE(kind=**)), codimension[lower:upper, ...] :: var\n\n     ! Equivalent explicit declaration:\n     type(TYPE(kind=**)) :: var[lower:upper, ...]\n```\n\n### **Characteristics**\n\n - **type** can be any intrinsic or derived type (integer, real, complex, logical, character, or user-defined type).\n - **codimension** specifies the coarray bounds in square brackets.\n - The final upper cobound must be an asterisk (*) indicating deferred upper cobound.\n - Coarrays can be scalars or arrays with any valid array bounds.\n - All images in the program have their own instance of the coarray.\n\n### **Description**\n\n **coarray_declaration** declares a variable as a coarray, enabling parallel data access across multiple images in a SPMD (Single Program, Multiple Data) parallel execution model. Each image has its own local copy of the coarray, and images can access data on other images using coarray syntax with square bracket notation.\n\n### **Options**\n\n- **type**\n  : The data type of the coarray variable. Can be any intrinsic type (integer, real, complex, logical, character) or a derived type. Kind parameters may be specified.\n\n- **codimension[cosubscripts]**\n  : Specifies the coarray cobounds. The cosubscripts define the mapping of images to coarray indices. The final upper cobound must be * (asterisk). For a single codimension, use [*]. For multiple codimensions, use [lower:upper, ..., *].\n\n- **variable_name**\n  : The name of the coarray variable being declared.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_coarray_declaration\n  use iso_fortran_env, only: dp => real64\n  implicit none\n\n  ! Simple coarray scalar\n  real(dp), codimension[*] :: scalar_value\n\n  ! Coarray with explicit lower cobound\n  integer, codimension[0:*] :: indexed_from_zero\n\n  ! Coarray array (local array, distributed across images)\n  real(dp), dimension(100), codimension[*] :: local_array\n\n  ! 2D coarray grid layout\n  real(dp), codimension[2, *] :: grid_value\n\n  ! Alternative syntax (equivalent to codimension)\n  real(dp) :: alternate_syntax[*]\n\n  ! Initialize local value\n  scalar_value = real(this_image(), dp)\n\n  ! Synchronize all images\n  sync all\n\n  ! Access value from image 1 on all images\n  if (this_image() /= 1) then\n    print '(A,I0,A,F6.2)', 'Image ', this_image(), &\n          ' reads from image 1: ', scalar_value[1]\n  else\n    print '(A,F6.2)', 'Image 1 has value: ', scalar_value\n  end if\n\nend program demo_coarray_declaration\n```\nResults (with 4 images):\n```text\n    Image 1 has value:   1.00\n    Image 2 reads from image 1:   1.00\n    Image 3 reads from image 1:   1.00\n    Image 4 reads from image 1:   1.00\n```\n\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\n[**sync_all**(3)](#sync_all),\n[**sync_images**(3)](#sync_images),\n[**this_image**(3)](#this_image),\n[**num_images**(3)](#num_images),\n[**co_sum**(3)](#co_sum),\n[**co_broadcast**(3)](#co_broadcast)"
  },
  "Coarray Image Query": {
    "prefix": [
      "thisimage",
      "THISIMAGE",
      "numimages",
      "NUMIMAGES",
      "this_image",
      "num_images",
      "coarrayquery"
    ],
    "body": [
      "integer :: ${1:me}, ${2:nimages}",
      "${1:me} = this_image()",
      "${2:nimages} = num_images()"
    ],
    "description": "THIS_IMAGE() and NUM_IMAGES() query the image index of the invoking image and total number of images in a coarray program.\n\n## this_image / num_images\n\n### **Name**\n\n**this_image / num_images** - \\[PARALLEL:COARRAY\\] Query coarray image index and total image count\n\n### **Synopsis**\n```fortran\n    me = this_image()\n    nimages = num_images()\n```\n```fortran\n     function this_image() result(image_index)\n       integer :: image_index\n\n     function this_image(coarray) result(cosubscripts)\n       type(*), dimension[..] :: coarray\n       integer                :: cosubscripts(:)\n\n     function this_image(coarray, dim) result(cosubscript)\n       type(*), dimension[..] :: coarray\n       integer, intent(in)    :: dim\n       integer                :: cosubscript\n\n     function num_images() result(nimages)\n       integer :: nimages\n\n     function num_images(team) result(nimages)\n       type(team_type), intent(in) :: team\n       integer                     :: nimages\n\n     function num_images(team_number) result(nimages)\n       integer, intent(in) :: team_number\n       integer             :: nimages\n```\n\n### **Characteristics**\n\n - **this_image()** with no arguments returns the image index of the invoking image as a default integer.\n - **this_image(coarray)** returns an integer array of cosubscripts for the invoking image.\n - **this_image(coarray, dim)** returns the cosubscript for dimension **dim** as a scalar integer.\n - **num_images()** with no arguments returns the total number of images in the current team.\n - **num_images(team)** returns the number of images in the specified team.\n - **num_images(team_number)** returns the number of images in the team with the specified team number.\n - Image indices range from 1 to num_images().\n\n### **Description**\n\n **this_image** returns the image index of the invoking image within the current team, or the cosubscripts corresponding to the invoking image for a given coarray. **num_images** returns the total number of images in execution, either in the current team or a specified team. These functions are fundamental for coarray parallel programming, enabling each image to identify itself and coordinate with other images.\n\n### **Options**\n\n- **coarray**\n  : A coarray of any type. Used with this_image to determine the cosubscripts that would be used to access the invoking image's portion of the coarray.\n\n- **dim**\n  : An integer scalar indicating which dimension's cosubscript to return. Must be between 1 and the corank of the coarray.\n\n- **team**\n  : A scalar of type TEAM_TYPE from ISO_FORTRAN_ENV, specifying the team to query.\n\n- **team_number**\n  : An integer scalar specifying the team number to query.\n\n### **Result**\n\n  For **this_image()** with no arguments, the result is a default integer representing the image index (1 to num_images()).\n\n  For **this_image(coarray)**, the result is an integer array with size equal to the corank of the coarray, containing the cosubscripts for the invoking image.\n\n  For **this_image(coarray, dim)**, the result is a scalar integer representing the cosubscript for the specified dimension.\n\n  For **num_images()**, the result is a default integer representing the total number of images currently executing.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_coarray_image_query\n  use iso_fortran_env, only: team_type\n  implicit none\n  integer :: me, nimages\n  integer :: data[*]  ! Simple coarray\n  integer :: matrix[2, *]  ! 2D cobounds coarray\n  integer :: cosubs(1)\n\n  ! Get image index and total images\n  me = this_image()\n  nimages = num_images()\n\n  print '(A,I0,A,I0)', 'Image ', me, ' of ', nimages\n\n  ! Initialize local data\n  data = me * 10\n\n  ! Synchronize all images before accessing remote data\n  sync all\n\n  ! Image 1 collects data from all images\n  if (me == 1) then\n    print *, 'Image 1 collecting data:'\n    block\n      integer :: i\n      do i = 1, nimages\n        print '(A,I0,A,I0)', '  data[', i, '] = ', data[i]\n      end do\n    end block\n  end if\n\n  ! Get cosubscripts for a coarray\n  cosubs = this_image(data)\n  print '(A,I0,A,I0)', 'Image ', me, ' has cosubscript: ', cosubs(1)\n\n  sync all\n\nend program demo_coarray_image_query\n```\nResults (with 4 images):\n```text\nImage 1 of 4\nImage 2 of 4\nImage 3 of 4\nImage 4 of 4\n Image 1 collecting data:\n  data[1] = 10\n  data[2] = 20\n  data[3] = 30\n  data[4] = 40\nImage 1 has cosubscript: 1\nImage 2 has cosubscript: 2\nImage 3 has cosubscript: 3\nImage 4 has cosubscript: 4\n```\n\n### **Standard**\n\nFortran 2008 (basic forms), Fortran 2018 (team arguments)\n\n### **See Also**\n\n[**sync_all**(3)](#sync_all),\n[**sync_images**(3)](#sync_images),\n[**co_sum**(3)](#co_sum),\n[**co_broadcast**(3)](#co_broadcast),\n[**team_type**(3)](#team_type)"
  },
  "Command Line Arguments": {
    "prefix": [
      "cmdargs",
      "CMDARGS",
      "getcommandargument",
      "GETCOMMANDARGUMENT",
      "command_argument_count",
      "COMMAND_ARGUMENT_COUNT"
    ],
    "body": [
      "integer :: i, argc, istat",
      "character(len=${1:256}) :: arg",
      "",
      "argc = command_argument_count()",
      "do i = 1, argc",
      "    call get_command_argument(i, arg, status=istat)",
      "    if (istat == 0) then",
      "        ${2:! Process argument}",
      "        print *, 'Argument ', i, ': ', trim(arg)",
      "    end if",
      "end do$0"
    ],
    "description": "GET_COMMAND_ARGUMENT(NUMBER,VALUE=value,LENGTH=length,STATUS=status) retrieves command line arguments passed to the program.",
    "documentation": {
      "name": "**get_command_argument** - [SYSTEM:SUBROUTINE] Retrieve command line arguments passed to the program",
      "synopsis": {
        "usage": [
          "    argc = command_argument_count()",
          "    call get_command_argument(number [,value] [,length] [,status])"
        ],
        "interface": [
          "     function command_argument_count() result(argc)",
          "",
          "      integer :: argc",
          "",
          "     subroutine get_command_argument(number, value, length, status)",
          "",
          "      integer, intent(in)            :: number",
          "      character(len=*), intent(out)  :: value",
          "      integer, intent(out), optional :: length",
          "      integer, intent(out), optional :: status"
        ]
      },
      "characteristics": [
        " - **command_argument_count** is an inquiry function that returns a default integer.",
        " - **number** is a scalar integer with intent(in); must be non-negative.",
        " - **value** is a scalar character variable of default kind.",
        " - **length** is an optional scalar integer that receives the argument length.",
        " - **status** is an optional scalar integer: 0 = success, -1 = truncated, positive = error.",
        " - The command name (argument 0) is not included in the argument count."
      ],
      "description": [
        " **command_argument_count** returns the number of command line arguments",
        " passed to the program, excluding the command name itself.",
        "",
        " **get_command_argument** retrieves the NUMBER-th command line argument.",
        " When NUMBER is 0, the command name is returned (if supported by the system).",
        " When NUMBER is greater than the argument count, VALUE is filled with blanks.",
        " If VALUE cannot hold the entire argument, it is truncated and STATUS is set to -1."
      ],
      "options": [
        "- **number**",
        "  : A non-negative integer specifying which argument to retrieve.",
        "  NUMBER=0 returns the program name. NUMBER=1 through command_argument_count()",
        "  retrieves the corresponding argument.",
        "",
        "- **value**",
        "  : A character variable that receives the argument string. If the argument",
        "  is longer than the variable, it is truncated. If the argument does not exist,",
        "  the variable is filled with blanks.",
        "",
        "- **length**",
        "  : Optional. Returns the actual length of the argument before any truncation.",
        "  Useful for allocating appropriately sized strings.",
        "",
        "- **status**",
        "  : Optional. Returns 0 on success, -1 if the value was truncated, or a",
        "  positive value if the argument retrieval failed."
      ],
      "examples": {
        "program": [
          "program demo_command_line_arguments",
          "implicit none",
          "  integer :: i, argc, arg_length, istat",
          "  character(len=256) :: arg",
          "  character(len=:), allocatable :: prog_name",
          "",
          "  ! Get the program name (argument 0)",
          "  call get_command_argument(0, arg, length=arg_length)",
          "  allocate(character(len=arg_length) :: prog_name)",
          "  call get_command_argument(0, prog_name)",
          "  print '(a,a)', 'Program: ', prog_name",
          "",
          "  ! Get the number of command line arguments",
          "  argc = command_argument_count()",
          "  print '(a,i0)', 'Number of arguments: ', argc",
          "",
          "  ! Process each argument",
          "  do i = 1, argc",
          "      call get_command_argument(i, arg, length=arg_length, status=istat)",
          "      if (istat == 0) then",
          "          print '(a,i0,a,a)', 'Argument ', i, ': ', trim(arg)",
          "      else if (istat == -1) then",
          "          print '(a,i0,a)', 'Argument ', i, ' was truncated'",
          "      else",
          "          print '(a,i0,a)', 'Error retrieving argument ', i, ''",
          "      end if",
          "  end do",
          "",
          "end program demo_command_line_arguments"
        ],
        "results": [
          "    $ ./demo_command_line_arguments foo bar baz",
          "    Program: ./demo_command_line_arguments",
          "    Number of arguments: 3",
          "    Argument 1: foo",
          "    Argument 2: bar",
          "    Argument 3: baz"
        ]
      },
      "standard": "Fortran 2003",
      "see_also": [
        "[**get_command**(3)](#get_command)",
        "[**get_environment_variable**(3)](#get_environment_variable)",
        "[**execute_command_line**(3)](#execute_command_line)"
      ]
    }
  },
  "Compiler Directive": {
    "prefix": [
      "directive",
      "DIRECTIVE",
      "!dir$"
    ],
    "body": [
      "!dir$ ${1|NOVECTOR,VECTOR,IVDEP,PARALLEL,NOINLINE,INLINE,UNROLL,NOUNROLL,OPTIMIZE,NOOPTIMIZE|}${0}"
    ],
    "description": "!DIR$ DIRECTIVE inserts a compiler directive to control optimization and code generation behavior."
  },
  "Complex with Precision": {
    "prefix": [
      "complexdp",
      "COMPLEXDP",
      "complex_kind",
      "COMPLEX_KIND"
    ],
    "body": [
      "complex(${1:dp}) :: ${0:var}"
    ],
    "description": "complex(KIND) :: var declares a complex variable with specified precision kind parameter."
  },
  "_Complex with Precision_documentation": {
    "name": "## complex_with_precision\n\n### **Name**\n\n**complex_with_precision** - \\[NUMERIC:DECLARATION\\] Declare a complex variable with explicit kind precision\n\n### **Synopsis**\n```fortran\n    complex(KIND) :: variable_name\n```\n```fortran\n     ! Declaration with kind parameter\n\n      integer, parameter   :: dp = selected_real_kind(15, 307)\n      complex(kind=dp)     :: z\n```\n\n### **Characteristics**\n\n - **KIND** is an integer constant expression specifying the kind type parameter.\n - **variable_name** is a valid Fortran identifier for the complex variable.\n - The kind parameter determines both the precision and range of the real and imaginary parts.\n - Common kind values: `kind(0.0)` for default real, `kind(0.0d0)` for double precision.\n - The `selected_real_kind(p, r)` intrinsic is the portable way to specify precision.\n\n### **Description**\n\n **complex(KIND)** declares a complex variable with a specific precision determined by the kind type parameter. A complex number consists of two real components (real and imaginary parts), each having the precision specified by KIND. Using explicit kind parameters ensures portable precision across different compilers and platforms, rather than relying on non-standard extensions like `COMPLEX*16` or `DOUBLE COMPLEX`.\n\n### **Options**\n\n- **KIND**\n  : An integer constant expression that specifies the kind type parameter for the complex variable. This determines the precision and range of both the real and imaginary components. Common approaches:\n    - `dp` where `integer, parameter :: dp = selected_real_kind(15, 307)` for double precision (~15 decimal digits)\n    - `sp` where `integer, parameter :: sp = selected_real_kind(6, 37)` for single precision (~6 decimal digits)\n    - `kind(0.0d0)` for double precision (less portable)\n    - `kind(0.0)` for default real precision\n\n- **variable_name**\n  : The identifier for the complex variable being declared. Must follow Fortran naming rules (start with letter, contain only alphanumeric characters and underscores, max 63 characters in Fortran 90).\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_complex_with_precision\n  implicit none\n\n  ! Define kind parameters for portability\n  integer, parameter :: sp = selected_real_kind(6, 37)    ! Single precision\n  integer, parameter :: dp = selected_real_kind(15, 307)  ! Double precision\n\n  ! Declare complex variables with different precisions\n  complex(sp) :: z_single\n  complex(dp) :: z_double\n  complex(dp) :: z1, z2, z_result\n\n  ! Initialize complex numbers\n  z_single = (1.0_sp, 2.0_sp)\n  z_double = (1.0_dp, 2.0_dp)\n\n  ! Demonstrate precision difference\n  print '(a)', 'Single precision complex:'\n  print '(a, 2es15.7)', '  z_single = ', real(z_single), aimag(z_single)\n\n  print '(a)', 'Double precision complex:'\n  print '(a, 2es24.16)', '  z_double = ', real(z_double), aimag(z_double)\n\n  ! Complex arithmetic with double precision\n  z1 = (3.0_dp, 4.0_dp)\n  z2 = (1.0_dp, -1.0_dp)\n  z_result = z1 * z2\n\n  print '(a)', 'Complex multiplication (3+4i) * (1-i):'\n  print '(a, 2f10.4)', '  Result = ', real(z_result), aimag(z_result)\n\n  ! Magnitude of complex number\n  print '(a, f10.4)', 'Magnitude of z1 = ', abs(z1)\n\nend program demo_complex_with_precision\n```\nResults:\n```text\nSingle precision complex:\n  z_single =   1.0000000E+00  2.0000000E+00\nDouble precision complex:\n  z_double =  1.0000000000000000E+00 2.0000000000000000E+00\nComplex multiplication (3+4i) * (1-i):\n  Result =     7.0000    1.0000\nMagnitude of z1 =     5.0000\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**cmplx**(3)](#cmplx),\n[**real**(3)](#real),\n[**aimag**(3)](#aimag),\n[**conjg**(3)](#conjg),\n[**abs**(3)](#abs),\n[**selected_real_kind**(3)](#selected_real_kind),\n[**kind**(3)](#kind)"
  },
  "Contiguous Array": {
    "prefix": [
      "contiguous",
      "CONTIGUOUS"
    ],
    "body": [
      "${1:real(dp)}, contiguous, intent(${2|in,out,inout|}) :: ${0:arr}(:)"
    ],
    "description": "CONTIGUOUS(TYPE,INTENT,NAME) declares an assumed-shape array argument with the contiguous attribute for optimized memory access."
  },
  "_contiguous_array_documentation": {
    "markdown": "## contiguous\n\n### **Name**\n\n**contiguous** - \\[ARRAY:DECLARATION\\] Declare an assumed-shape array with contiguous memory attribute\n\n### **Synopsis**\n```fortran\n    type, contiguous, intent(in|out|inout) :: array_name(:)\n```\n```fortran\n     subroutine example_sub(arr)\n\n      real(dp), contiguous, intent(in) :: arr(:)\n```\n\n### **Characteristics**\n\n - **type** is any intrinsic or derived type with optional kind specifier.\n - **intent** must be one of `in`, `out`, or `inout` for dummy arguments.\n - **array_name** is an assumed-shape array of any rank.\n - The **contiguous** attribute guarantees the array occupies contiguous memory locations.\n - Only valid for assumed-shape or assumed-rank dummy arguments and pointer arrays.\n\n### **Description**\n\n The **contiguous** attribute specifies that an assumed-shape or pointer\n array occupies a contiguous block of memory. This enables compiler\n optimizations that assume sequential memory access and allows the array\n to be passed to procedures expecting explicit-shape or assumed-size\n arrays without creating a temporary copy.\n\n### **Options**\n\n- **type**\n  : The data type of the array elements. Can be any intrinsic type\n  (integer, real, complex, logical, character) or derived type, with\n  optional kind specifier (e.g., `real(dp)`, `integer(int64)`).\n\n- **intent**\n  : Specifies the intended use of the argument:\n    - `in`: The argument is read-only and must not be modified.\n    - `out`: The argument is write-only and must be defined before use.\n    - `inout`: The argument may be both read and modified.\n\n- **array_name**\n  : The name of the dummy argument array. The `(:)` notation indicates\n  an assumed-shape array that inherits its bounds from the actual argument.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_contiguous\n  use, intrinsic :: iso_fortran_env, only: dp => real64\n  implicit none\n\n  real(dp), allocatable :: data(:)\n  real(dp) :: result\n\n  ! Allocate contiguous array\n  allocate(data(100))\n  call random_number(data)\n\n  ! Pass to procedure with contiguous attribute\n  call compute_sum(data, result)\n  print '(a,g0.6)', 'Sum of contiguous array: ', result\n\n  ! Non-contiguous slice would require copy\n  call compute_sum(data(1:50:1), result)\n  print '(a,g0.6)', 'Sum of slice: ', result\n\ncontains\n\n  subroutine compute_sum(arr, total)\n    real(dp), contiguous, intent(in) :: arr(:)\n    real(dp), intent(out) :: total\n\n    total = sum(arr)\n  end subroutine compute_sum\n\nend program demo_contiguous\n```\nResults:\n```text\nSum of contiguous array: 49.8234\nSum of slice: 24.9117\n```\n\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\n[**dimension**(3)](#dimension),\n[**allocatable**(3)](#allocatable),\n[**pointer**(3)](#pointer),\n[**assumed_shape**(3)](#assumed_shape)"
  },
  "Correct Initialization": {
    "prefix": [
      "initvar",
      "INITVAR",
      "nosavedecl",
      "NOSAVEDECL"
    ],
    "body": [
      "${1:integer} :: ${2:var}",
      "${2:var} = ${0:initial_value}"
    ],
    "description": "INITVAR(TYPE,VAR,VALUE) declares a variable and initializes it in a separate statement to avoid implicit SAVE.",
    "documentation": {
      "name": "**initvar** - \\[STRUCTURE:DECLARATION\\] Declare and initialize a variable without implicit SAVE attribute",
      "synopsis": {
        "usage": "```fortran\n    type :: variable\n    variable = value\n```",
        "interface": "```fortran\n     ! Declaration (no initialization)\n     type(kind=**) :: variable_name\n\n     ! Separate initialization statement\n     variable_name = initial_value\n```"
      },
      "characteristics": [
        "**type** is any valid Fortran data type (integer, real, complex, logical, character, or derived type)",
        "**variable** is a valid identifier following Fortran naming conventions",
        "**value** is a literal or expression compatible with the declared type",
        "The variable does NOT receive the implicit SAVE attribute",
        "Variable is re-initialized on each procedure invocation"
      ],
      "description": "**initvar** provides a two-statement pattern for declaring and initializing local variables in procedures. In Fortran, when you initialize a variable in its declaration statement (e.g., `integer :: x = 0`), the variable implicitly receives the SAVE attribute. This means the variable retains its value between procedure calls, which is often unintended and can lead to subtle bugs, especially in recursive procedures or when procedures are called multiple times with expected fresh state. By separating the declaration from the initialization, the variable behaves as a normal local variable that is re-initialized each time the procedure is called.",
      "options": [
        {
          "name": "type",
          "description": "The Fortran data type for the variable. Can be any intrinsic type (integer, real, double precision, complex, logical, character) with optional kind specifier, or a derived type."
        },
        {
          "name": "variable",
          "description": "The name of the variable being declared. Must be a valid Fortran identifier (starts with a letter, contains only letters, digits, and underscores)."
        },
        {
          "name": "value",
          "description": "The initial value to assign. Must be type-compatible with the declared variable. Can be a literal constant, a named constant, or an expression."
        }
      ],
      "examples": {
        "code": "program demo_initvar\nimplicit none\n  call counter_wrong()\n  call counter_wrong()\n  call counter_wrong()\n  print *, '---'\n  call counter_correct()\n  call counter_correct()\n  call counter_correct()\ncontains\n\n  subroutine counter_wrong()\n    ! BAD: Initialization in declaration gives implicit SAVE\n    integer :: count = 0\n    count = count + 1\n    print *, 'Wrong counter:', count\n  end subroutine counter_wrong\n\n  subroutine counter_correct()\n    ! GOOD: Separate declaration and initialization\n    integer :: count\n    count = 0  ! Re-initialized every call\n    count = count + 1\n    print *, 'Correct counter:', count\n  end subroutine counter_correct\n\nend program demo_initvar",
        "results": "```text\n Wrong counter:           1\n Wrong counter:           2\n Wrong counter:           3\n ---\n Correct counter:           1\n Correct counter:           1\n Correct counter:           1\n```"
      },
      "standard": "Fortran 90",
      "see_also": [
        "**save**(3) - Explicitly preserve variable values between calls",
        "**block**(3) - Local scoping construct (Fortran 2008)",
        "**associate**(3) - Create named associations with expressions"
      ],
      "notes": "The implicit SAVE behavior for initialized declarations dates back to Fortran 77 compatibility. While this behavior is well-defined by the standard, it frequently surprises programmers coming from other languages where local variable initialization does not imply persistence. Modern best practice recommends always separating declaration from initialization for local variables in procedures, or explicitly using the SAVE attribute when persistence is actually desired."
    }
  },
  "CPU Time": {
    "prefix": [
      "cputime",
      "CPUTIME",
      "cpu_time",
      "CPU_TIME"
    ],
    "body": [
      "real :: ${1:start_time}, ${2:end_time}",
      "",
      "call cpu_time(${1:start_time})",
      "${0:! code to time}",
      "call cpu_time(${2:end_time})",
      "",
      "print '(A,F10.6,A)', 'CPU time: ', ${2:end_time} - ${1:start_time}, ' seconds'"
    ],
    "description": "## cpu_time\n\n### **Name**\n\n**cpu_time** - \\[SYSTEM:SUBROUTINE\\] Returns the processor time\n\n### **Synopsis**\n```fortran\n    call cpu_time(time)\n```\n```fortran\n     subroutine cpu_time(time)\n\n      real, intent(out) :: time\n```\n\n### **Characteristics**\n\n - **time** is a scalar real of default kind with intent(out).\n - The returned value is processor-dependent.\n - If processor time is not available, a processor-dependent negative value is returned.\n\n### **Description**\n\n **cpu_time** returns a processor-dependent approximation of the processor\n time in seconds. If the processor cannot return a meaningful time, a\n processor-dependent negative value is returned.\n\n The absolute value of the time returned is processor-dependent and has\n no particular meaning. Only the difference between two calls to cpu_time\n is meaningful, representing the processor time used between the calls.\n\n### **Options**\n\n- **time**\n  : A real scalar variable with intent(out) that receives the processor\n  time in seconds. If processor time is not available, a negative value\n  is returned.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_cpu_time\nimplicit none\n  real :: start_time, end_time\n  real :: elapsed\n  integer :: i, j\n  real :: a(1000, 1000)\n\n  ! Get starting time\n  call cpu_time(start_time)\n\n  ! Perform some computation\n  do i = 1, 1000\n    do j = 1, 1000\n      a(i, j) = real(i * j)\n    end do\n  end do\n\n  ! Get ending time\n  call cpu_time(end_time)\n\n  ! Calculate elapsed time\n  elapsed = end_time - start_time\n\n  print '(A)', 'Matrix initialization complete.'\n  print '(A,F10.6,A)', 'CPU time: ', elapsed, ' seconds'\n\n  ! Verify negative value indicates unavailable time\n  if (start_time < 0.0) then\n    print '(A)', 'Warning: CPU time not available on this processor.'\n  end if\n\nend program demo_cpu_time\n```\nResults:\n```text\n    Matrix initialization complete.\n    CPU time:   0.012345 seconds\n```\n\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**system_clock**(3)](#system_clock),\n[**date_and_time**(3)](#date_and_time)"
  },
  "Custom Index Bounds": {
    "prefix": [
      "custombounds",
      "CUSTOMBOUNDS",
      "arraybounds",
      "ARRAYBOUNDS"
    ],
    "body": [
      "${1:real(dp)} :: ${2:arr}(${3:0}:${4:n-1})"
    ],
    "description": "TYPE :: ARRAY(LOWER:UPPER) declares an array with custom index bounds.\n\n## custom_index_bounds\n\n### **Name**\n\n**custom_index_bounds** - \\[ARRAY:DECLARATION\\] Declare an array with user-specified lower and upper index bounds\n\n### **Synopsis**\n```fortran\n    type :: array_name(lower_bound:upper_bound)\n```\n```fortran\n     type(kind)           :: array_name(lower:upper)\n\n      type                 :: Any valid Fortran type (integer, real, complex, logical, character, derived type)\n      lower                :: Integer constant or variable specifying the lower bound\n      upper                :: Integer constant or variable specifying the upper bound\n```\n\n### **Characteristics**\n\n - **type** is any valid Fortran data type including intrinsic types and derived types.\n - **lower_bound** is an integer expression specifying the starting index.\n - **upper_bound** is an integer expression specifying the ending index.\n - The array size is (upper_bound - lower_bound + 1) elements.\n - Bounds can be negative, zero, or positive integers.\n - Both bounds must be specified when using custom index bounds.\n\n### **Description**\n\n **custom_index_bounds** declares an array with explicit lower and upper index bounds\n rather than using Fortran's default 1-based indexing. This is useful when array\n indices have natural meanings outside the 1:n range, such as 0-based indexing\n for C interoperability, negative indices for stencil operations, or year-based\n indices for time series data.\n\n### **Options**\n\n- **type**\n  : The data type for array elements. Can be any intrinsic type (integer, real,\n  complex, logical, character) with optional kind specification, or a derived type.\n\n- **array_name**\n  : A valid Fortran identifier for the array variable.\n\n- **lower_bound**\n  : An integer constant expression defining the smallest valid index. Common values\n  include 0 (for C-style indexing), negative values (for centered stencils), or\n  domain-specific starting values (like years).\n\n- **upper_bound**\n  : An integer constant expression defining the largest valid index. Often expressed\n  as n-1 (for 0-based arrays of size n) or a meaningful domain value.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_custom_index_bounds\n  implicit none\n  integer, parameter :: dp = kind(1.0d0)\n\n  ! 0-based array (C-style indexing)\n  real(dp) :: zero_based(0:9)\n\n  ! Negative to positive bounds (centered stencil)\n  integer :: stencil(-2:2)\n\n  ! Year-based indexing for time series\n  real(dp) :: annual_data(1990:2025)\n\n  ! Character array with custom bounds\n  character(len=20) :: months(1:12)\n\n  integer :: i\n\n  ! Initialize 0-based array\n  do i = 0, 9\n    zero_based(i) = real(i, dp) * 1.5_dp\n  end do\n  print *, '0-based array bounds:', lbound(zero_based, 1), ':', ubound(zero_based, 1)\n  print *, 'zero_based(0) =', zero_based(0)\n  print *, 'zero_based(9) =', zero_based(9)\n\n  ! Initialize stencil coefficients\n  stencil = [-1, -2, 0, 2, 1]\n  print *, 'Stencil bounds:', lbound(stencil, 1), ':', ubound(stencil, 1)\n  print *, 'stencil(-2) =', stencil(-2)\n  print *, 'stencil(0)  =', stencil(0)\n  print *, 'stencil(2)  =', stencil(2)\n\n  ! Initialize year-based data\n  annual_data(2020) = 100.5_dp\n  annual_data(2021) = 105.2_dp\n  print *, 'Year 2020 data:', annual_data(2020)\n  print *, 'Year 2021 data:', annual_data(2021)\n\nend program demo_custom_index_bounds\n```\nResults:\n```text\n 0-based array bounds:           0 :           9\n zero_based(0) =   0.0000000000000000\n zero_based(9) =   13.500000000000000\n Stencil bounds:          -2 :           2\n stencil(-2) =          -1\n stencil(0)  =           0\n stencil(2)  =           1\n Year 2020 data:   100.50000000000000\n Year 2021 data:   105.19999999999999\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**allocatable_array**(3)](#allocatable_array),\n[**assumed_shape**(3)](#assumed_shape),\n[**lbound**(3)](#lbound),\n[**ubound**(3)](#ubound),\n[**size**(3)](#size)"
  },
  "Cycle Named Loop": {
    "prefix": [
      "cycleloop",
      "CYCLELOOP"
    ],
    "body": "cycle ${1:loop_name}",
    "description": "CYCLE loop_name - [CONTROL:LOOP] Skip to the next iteration of a named loop construct.\n\n### **Synopsis**\n```fortran\n    cycle loop_name\n```\n```fortran\n     loop_name: do i = 1, n\n       if (condition) cycle loop_name\n     end do loop_name\n```\n\n### **Characteristics**\n\n - **loop_name** must be the name of an enclosing DO construct.\n - The CYCLE statement transfers control to the end of the named loop.\n - Execution continues with the next iteration of the loop if the loop control permits.\n - Without a loop name, CYCLE applies to the innermost DO construct.\n\n### **Description**\n\n **cycle** causes the current iteration of the named DO loop to terminate early. Control transfers to the END DO statement of the named construct, and the loop continues with its next iteration (if any remain). This is particularly useful in nested loops where you need to skip to the next iteration of an outer loop rather than the innermost one.\n\n### **Options**\n\n- **loop_name**\n  : The construct name of the DO loop to cycle. Must match the name label of an enclosing DO construct. When omitted, CYCLE applies to the innermost DO loop.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_cycle_named\nimplicit none\n  integer :: i, j\n  integer :: matrix(3,3)\n\n  ! Initialize matrix with values\n  matrix = reshape([1,2,3, 4,0,6, 7,8,9], [3,3])\n\n  ! Process matrix, skipping entire rows that contain zero\n  row_loop: do i = 1, 3\n    col_loop: do j = 1, 3\n      ! If we find a zero, skip to the next row\n      if (matrix(i,j) == 0) then\n        print *, 'Skipping row', i, 'due to zero at column', j\n        cycle row_loop  ! Skip remaining columns, go to next row\n      end if\n      print *, 'Processing element (', i, ',', j, ') =', matrix(i,j)\n    end do col_loop\n  end do row_loop\n\n  print *, 'Done processing matrix'\nend program demo_cycle_named\n```\nResults:\n```text\n Processing element ( 1 , 1 ) = 1\n Processing element ( 1 , 2 ) = 4\n Processing element ( 1 , 3 ) = 7\n Processing element ( 2 , 1 ) = 2\n Skipping row 2 due to zero at column 2\n Processing element ( 3 , 1 ) = 3\n Processing element ( 3 , 2 ) = 6\n Processing element ( 3 , 3 ) = 9\n Done processing matrix\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**exit**(3)](#exit), [**do**(3)](#do), [**do_concurrent**(3)](#do_concurrent)"
  },
  "Deferred Length String": {
    "prefix": [
      "deferredstr",
      "DEFERREDSTR"
    ],
    "body": "character(len=:), allocatable :: ${1:str}",
    "description": "character(len=:), allocatable :: name declares a deferred-length allocatable character variable."
  },
  "Deferred Procedure": {
    "prefix": [
      "deferred",
      "DEFERRED"
    ],
    "body": [
      "procedure(${1:interface}), deferred :: ${0:method}"
    ],
    "description": "PROCEDURE(interface), DEFERRED :: method declares an abstract method in an abstract type that must be implemented by extending types."
  },
  "Do Concurrent with Locality": {
    "prefix": [
      "doconcurrentlocal",
      "DOCONCURRENTLOCAL",
      "doconclocal"
    ],
    "body": [
      "do concurrent (${1:i} = ${2:1}:${3:n}) local(${4:temp}) shared(${5:arr})",
      "\t${0}",
      "end do"
    ],
    "description": "DO CONCURRENT (var=start:end) LOCAL(vars) SHARED(vars) executes loop iterations in any order with explicit locality specifications.\n\n## do_concurrent_local\n\n### **Name**\n\n**do_concurrent_local** - \\[CONTROL:LOOP\\] Parallel loop with explicit locality clauses\n\n### **Synopsis**\n\n```fortran\n    do concurrent (index = start:end) local(vars) shared(vars)\n      ! loop body\n    end do\n```\n\n```fortran\n     do concurrent (integer :: i = lower:upper:stride) &\n         local(temp_var) local_init(initialized_var) &\n         shared(array) reduce(+:sum_var)\n\n       ! loop body with concurrent execution\n     end do\n```\n\n### **Characteristics**\n\n - **index** is an integer scalar loop control variable\n - **start**, **end**, and optional **stride** are integer expressions\n - **local** variables are private to each iteration with undefined initial values\n - **local_init** variables are private but initialized from the outer scope value\n - **shared** variables are accessible by all iterations (read-only recommended)\n - **reduce** variables accumulate values across iterations using a specified operator\n - Loop iterations may execute in any order, including concurrently\n\n### **Description**\n\n **do concurrent** with locality specifications provides explicit control over\n variable scoping in parallel loop constructs. The locality clauses inform the\n compiler about data dependencies and enable safe parallel execution.\n\n The **local** clause declares variables that are private to each iteration,\n similar to OpenMP private. The **shared** clause indicates variables that\n are accessible by all iterations. The **local_init** clause provides private\n variables initialized from outer scope values. The **reduce** clause enables\n safe reductions across iterations.\n\n### **Options**\n\n- **local(variable-list)**\n  : Declares variables that are local to each iteration. Each iteration has\n  its own instance with an undefined initial value. Variables in this list\n  must not depend on values from other iterations.\n\n- **local_init(variable-list)**\n  : Declares variables that are local to each iteration but initialized to\n  the value from the enclosing scope at the start of each iteration.\n\n- **shared(variable-list)**\n  : Declares variables that are shared across all iterations. These should\n  generally be read-only to avoid race conditions. Arrays being indexed by\n  the loop variable are typically shared.\n\n- **reduce(operator:variable-list)**\n  : Declares reduction variables that accumulate values across iterations.\n  Supported operators include +, *, .and., .or., min, max, iand, ior, ieor.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_do_concurrent_locality\nimplicit none\n  integer, parameter :: n = 1000\n  real :: a(n), b(n), c(n)\n  real :: temp, total\n  integer :: i\n\n  ! Initialize arrays\n  a = [(real(i), i = 1, n)]\n  b = [(real(i) * 2.0, i = 1, n)]\n  total = 0.0\n\n  ! Basic do concurrent with local and shared\n  do concurrent (i = 1:n) local(temp) shared(a, b, c)\n    temp = a(i) * b(i)\n    c(i) = temp + 1.0\n  end do\n\n  print *, 'c(1) =', c(1), 'c(n) =', c(n)\n\n  ! Do concurrent with reduction\n  do concurrent (i = 1:n) shared(a) reduce(+:total)\n    total = total + a(i)\n  end do\n\n  print *, 'Sum of a:', total\n\nend program demo_do_concurrent_locality\n```\n\nResults:\n\n```text\n c(1) =   3.00000000      c(n) =   2000001.00\n Sum of a:   500500.000\n```\n\n### **Standard**\n\nFortran 2008 (do concurrent), Fortran 2018 (locality clauses: local, local_init, shared, reduce)\n\n### **See Also**\n\n[**do_concurrent**(3)](#do_concurrent),\n[**do**(3)](#do),\n[**forall**(3)](#forall)"
  },
  "Double Precision Literal": {
    "prefix": [
      "_dp",
      "_DP"
    ],
    "body": "${1:1.0}_dp",
    "description": "_dp(VALUE) appends the double precision kind suffix to a numeric literal.",
    "documentation": {
      "name": "**_dp** - \\[NUMERIC:LITERAL\\] Double precision kind suffix for numeric literals",
      "synopsis": {
        "usage": "```fortran\n    value_dp = 1.0_dp\n```",
        "interface": "```fortran\n     real(kind=dp) :: value_dp\n\n      ! Where dp is defined as:\n      integer, parameter :: dp = selected_real_kind(15, 307)\n      ! or\n      use, intrinsic :: iso_fortran_env, only: dp => real64\n```"
      },
      "characteristics": [
        "**_dp** is a kind suffix applied to real literal constants",
        "The literal must be a valid real constant (with decimal point)",
        "Provides approximately 15-17 significant decimal digits of precision",
        "Exponent range is typically 10^-307 to 10^308",
        "Requires a named constant `dp` to be defined in scope"
      ],
      "description": "**_dp** is a kind type parameter suffix that specifies double precision (64-bit) floating-point representation for a real literal constant. Using explicit kind suffixes ensures portable, consistent precision across different compilers and platforms, avoiding the ambiguous `double precision` type and compiler-dependent default real kinds.",
      "options": {
        "VALUE": "A real literal constant to which the kind suffix is appended. Must include a decimal point (e.g., `1.0`, `3.14159`, `2.998e8`). Integer literals without a decimal point should be written as `1.0_dp` not `1_dp`."
      },
      "examples": {
        "code": "```fortran\nprogram demo_dp_literal\n  use, intrinsic :: iso_fortran_env, only: dp => real64\n  implicit none\n\n  ! Declare double precision variables\n  real(dp) :: pi, avogadro, speed_of_light\n  real(dp) :: result\n\n  ! Use _dp suffix for literal constants\n  pi = 3.14159265358979323846_dp\n  avogadro = 6.02214076e23_dp\n  speed_of_light = 2.99792458e8_dp\n\n  ! Arithmetic with double precision literals\n  result = 2.0_dp * pi * 1.0_dp\n\n  print '(A,ES23.16)', 'Pi:              ', pi\n  print '(A,ES23.16)', 'Avogadro:        ', avogadro\n  print '(A,ES23.16)', 'Speed of light:  ', speed_of_light\n  print '(A,ES23.16)', '2*pi:            ', result\n\n  ! Demonstrate precision difference\n  print '(A)', ''\n  print '(A)', 'Precision comparison:'\n  print '(A,F20.17)', 'Default real 1.1:     ', 1.1\n  print '(A,F20.17)', 'Double prec 1.1_dp:   ', 1.1_dp\n\nend program demo_dp_literal\n```",
        "results": "```text\nPi:               3.1415926535897931E+00\nAvogadro:         6.0221407600000000E+23\nSpeed of light:   2.9979245800000000E+08\n2*pi:             6.2831853071795862E+00\n\nPrecision comparison:\nDefault real 1.1:      1.10000002384185791\nDouble prec 1.1_dp:    1.10000000000000009\n```"
      },
      "standard": "Fortran 90",
      "see_also": [
        "[**selected_real_kind**(3)](#selected_real_kind)",
        "[**real64**(3)](#real64)",
        "[**kind**(3)](#kind)",
        "[**real**(3)](#real)"
      ],
      "notes": "The `_dp` suffix requires that `dp` be defined as a named constant representing the desired kind value. Common approaches include:\n\n1. Using `iso_fortran_env`: `use, intrinsic :: iso_fortran_env, only: dp => real64`\n2. Using `selected_real_kind`: `integer, parameter :: dp = selected_real_kind(15, 307)`\n\nAlways use kind suffixes on literal constants in expressions to avoid precision loss from implicit type conversion. For example, `x = x + 0.1_dp` maintains precision, while `x = x + 0.1` may lose precision if the default real is single precision."
    }
  },
  "Double Precision Parameter": {
    "prefix": [
      "paramdp",
      "PARAMDP"
    ],
    "body": [
      "${1:real(dp)}, parameter :: ${2:name} = ${3:value}_dp$0"
    ],
    "description": "PARAMDP(TYPE,NAME,VALUE) declares a named constant with double precision kind suffix.",
    "documentation": {
      "name": "**paramdp** - \\[NUMERIC:DECLARATION\\] Declare a named constant with double precision kind",
      "synopsis": {
        "usage": "real(dp), parameter :: name = value_dp",
        "interface": "     type(real(kind=dp)), parameter :: constant_name = literal_value_dp\n\n      ! Requires kind parameter definition:\n      integer, parameter :: dp = kind(1.0d0)\n      ! or\n      use, intrinsic :: iso_fortran_env, only: dp => real64"
      },
      "characteristics": [
        "**type** is typically real(dp) but can be any numeric type with dp kind",
        "**name** is a valid Fortran identifier for the constant",
        "**value** is a numeric literal that must be followed by the _dp kind suffix",
        "The constant is immutable after declaration",
        "The dp kind parameter must be defined prior to use"
      ],
      "description": "**paramdp** declares a named constant (parameter) with double precision floating-point kind. Named constants improve code readability, enable compiler optimizations, and prevent accidental modification of important values like physical constants or algorithm parameters.",
      "options": {
        "type": "The type declaration for the constant. Typically real(dp) for double precision real numbers. Can also be complex(dp) for double precision complex numbers.",
        "name": "A valid Fortran identifier that will hold the constant value. Use descriptive names following naming conventions (e.g., PI, BOLTZMANN_CONST, MAX_ITERATIONS).",
        "value": "The numeric literal value. Must include the _dp suffix to ensure the literal is stored with double precision. Without the suffix, precision may be lost during assignment."
      },
      "examples": {
        "code": "program demo_paramdp\n  use, intrinsic :: iso_fortran_env, only: dp => real64\n  implicit none\n\n  ! Mathematical constants with double precision\n  real(dp), parameter :: PI = 3.141592653589793238_dp\n  real(dp), parameter :: E  = 2.718281828459045235_dp\n\n  ! Physical constants (SI units)\n  real(dp), parameter :: SPEED_OF_LIGHT = 299792458.0_dp        ! m/s\n  real(dp), parameter :: BOLTZMANN_CONST = 1.380649e-23_dp      ! J/K\n  real(dp), parameter :: PLANCK_CONST = 6.62607015e-34_dp       ! J*s\n\n  ! Algorithm parameters\n  real(dp), parameter :: TOLERANCE = 1.0e-12_dp\n  real(dp), parameter :: RELAXATION_FACTOR = 0.8_dp\n\n  ! Variables for demonstration\n  real(dp) :: circle_area, radius\n\n  radius = 2.5_dp\n  circle_area = PI * radius**2\n\n  print '(A)',          'Double Precision Parameter Demo'\n  print '(A)',          '================================'\n  print '(A,ES23.16)',  'PI                = ', PI\n  print '(A,ES23.16)',  'E                 = ', E\n  print '(A,ES23.16)',  'Speed of Light    = ', SPEED_OF_LIGHT\n  print '(A,ES23.16)',  'Boltzmann Const   = ', BOLTZMANN_CONST\n  print '(A,ES23.16)',  'Planck Const      = ', PLANCK_CONST\n  print '(A,ES23.16)',  'Tolerance         = ', TOLERANCE\n  print '(A)',          ''\n  print '(A,F6.2)',     'Circle radius     = ', radius\n  print '(A,ES23.16)',  'Circle area       = ', circle_area\n\nend program demo_paramdp",
        "results": "Double Precision Parameter Demo\n================================\nPI                =  3.1415926535897931E+00\nE                 =  2.7182818284590451E+00\nSpeed of Light    =  2.9979245800000000E+08\nBoltzmann Const   =  1.3806490000000000E-23\nPlanck Const      =  6.6260701500000001E-34\nTolerance         =  1.0000000000000000E-12\n\nCircle radius     =   2.50\nCircle area       =  1.9634954084936209E+01"
      },
      "standard": "Fortran 90",
      "see_also": [
        "**real(3)**",
        "**kind(3)**",
        "**selected_real_kind(3)**",
        "**iso_fortran_env** module",
        "**precision(3)**"
      ]
    }
  },
  "Double Precision Real": {
    "prefix": [
      "realdp",
      "REALDP"
    ],
    "body": [
      "real(${1:dp}) :: ${0:var}"
    ],
    "description": "## real_dp\n\n### **Name**\n\n**real_dp** - \\[NUMERIC:DECLARATION\\] Declare a double precision real variable\n\n### **Synopsis**\n```fortran\n    real(dp) :: variable_name\n```\n```fortran\n     ! Declaration with kind parameter\n\n      integer, parameter :: dp = selected_real_kind(15, 307)\n      real(dp)           :: variable_name\n```\n\n### **Characteristics**\n\n - **dp** is a kind parameter specifying double precision (typically 64-bit).\n - **variable_name** is the identifier for the declared variable.\n - The kind parameter should be defined using `selected_real_kind` for portability.\n - Default double precision provides approximately 15-17 significant decimal digits.\n\n### **Description**\n\n **real_dp** declares a real variable with double precision. Using kind parameters\n instead of the non-standard `double precision` type ensures portability across\n different compilers and platforms. The dp parameter should be defined as\n `selected_real_kind(15, 307)` to guarantee at least 15 decimal digits of\n precision and an exponent range of at least 10^307.\n\n### **Options**\n\n- **dp**\n  : The kind parameter specifying double precision. Should be defined as\n  `integer, parameter :: dp = selected_real_kind(15, 307)` for portable code.\n  Common alternatives include `kind(1.0d0)` or compiler-specific constants.\n\n- **var**\n  : The name of the variable being declared. Must be a valid Fortran identifier\n  (starts with letter, contains only letters, digits, and underscores).\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_real_dp\nimplicit none\n  ! Define double precision kind parameter\n  integer, parameter :: dp = selected_real_kind(15, 307)\n\n  ! Declare double precision variables\n  real(dp) :: x\n  real(dp) :: pi\n  real(dp) :: result\n\n  ! Initialize with double precision literal\n  pi = 3.141592653589793_dp\n  x = 1.0_dp\n\n  ! Perform calculation\n  result = sin(pi * x)\n\n  print '(A,ES23.16)', 'pi     = ', pi\n  print '(A,ES23.16)', 'sin(pi)= ', result\n  print '(A,I0)',      'kind   = ', kind(x)\n  print '(A,I0)',      'digits = ', precision(x)\n\nend program demo_real_dp\n```\nResults:\n```text\npi     =  3.1415926535897931E+00\nsin(pi)=  1.2246467991473532E-16\nkind   = 8\ndigits = 15\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**selected_real_kind**(3)](#selected_real_kind),\n[**precision**(3)](#precision),\n[**kind**(3)](#kind),\n[**real**(3)](#real)"
  },
  "Elemental Subroutine": {
    "prefix": [
      "elementalsub",
      "ELEMENTALSUB",
      "elementalsubroutine",
      "ELEMENTALSUBROUTINE"
    ],
    "body": [
      "elemental subroutine ${1:name}(${2:input}, ${3:output})",
      "\t${4:real}, intent(in) :: ${2:input}",
      "\t${5:real}, intent(out) :: ${3:output}",
      "",
      "\t${0}",
      "end subroutine ${1:name}"
    ],
    "description": "## elemental_subroutine\n\n### **Name**\n\n**elemental_subroutine** - \\[STRUCTURE:PROCEDURE\\] Define an elemental subroutine that operates element-wise on arrays\n\n### **Synopsis**\n```fortran\n    call elemental_subroutine(input, output)\n```\n```fortran\n     elemental subroutine name(input, output)\n\n      type(TYPE(kind=**)), intent(in)  :: input\n      type(TYPE(kind=**)), intent(out) :: output\n```\n\n### **Characteristics**\n\n - **input** is a scalar or array of any intrinsic type or derived type with elemental components.\n - **output** is a scalar or array of any intrinsic type or derived type with elemental components.\n - All dummy arguments must be scalar and have specified intent (in, out, or inout).\n - The subroutine is automatically applied element-wise when called with array arguments.\n - No side effects are permitted (no I/O, no STOP, no modifying global data).\n\n### **Description**\n\n **elemental subroutine** defines a subroutine with the ELEMENTAL attribute that operates on scalar arguments but can be called with arrays of any shape. The compiler automatically applies the subroutine to each element of the array arguments in parallel. All dummy arguments must have explicit intent, be scalar, and the subroutine must be pure (no side effects).\n\n### **Options**\n\n- **name**\n  : The name of the elemental subroutine. Must be a valid Fortran identifier.\n\n- **input**\n  : An input dummy argument with intent(in). Must be scalar. When the subroutine is called with an array, the operation is applied element-wise.\n\n- **output**\n  : An output dummy argument with intent(out). Must be scalar. Receives the result of the elemental operation.\n\n- **type**\n  : The data type of the dummy arguments. Common types include real, integer, complex, logical, or character.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_elemental_subroutine\nimplicit none\n  real :: x(5), y(5)\n  real :: a, b\n  integer :: i\n\n  ! Initialize array\n  x = [(real(i), i = 1, 5)]\n\n  ! Call elemental subroutine with arrays - applies element-wise\n  call square_it(x, y)\n  print '(a,5f8.2)', 'x:        ', x\n  print '(a,5f8.2)', 'x squared:', y\n\n  ! Also works with scalars\n  a = 3.0\n  call square_it(a, b)\n  print '(a,f8.2)', 'Scalar result: ', b\n\ncontains\n\n  elemental subroutine square_it(input, output)\n    real, intent(in)  :: input\n    real, intent(out) :: output\n\n    output = input * input\n  end subroutine square_it\n\nend program demo_elemental_subroutine\n```\nResults:\n```text\nx:            1.00    2.00    3.00    4.00    5.00\nx squared:    1.00    4.00    9.00   16.00   25.00\nScalar result:     9.00\n```\n\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**elemental_function**(3)](#elemental_function),\n[**pure_subroutine**(3)](#pure_subroutine),\n[**impure_elemental**(3)](#impure_elemental)"
  },
  "Enum Definition": {
    "prefix": [
      "enum",
      "ENUM"
    ],
    "body": [
      "enum, bind(c)",
      "\tenumerator :: ${1:name1} = ${2:0}",
      "\tenumerator :: ${3:name2}",
      "\tenumerator :: ${0:name3}",
      "end enum"
    ],
    "description": "## enum\n\n### **Name**\n\n**enum** - \\[STRUCTURE:TYPE\\] Define a C-interoperable enumeration type\n\n### **Synopsis**\n```fortran\n    enum, bind(c)\n      enumerator :: name1 = value\n      enumerator :: name2\n    end enum\n```\n```fortran\n     enum, bind(c)\n\n      enumerator :: name1 = value    ! Explicit value assignment\n      enumerator :: name2            ! Auto-incremented value\n      enumerator :: name3, name4     ! Multiple enumerators\n     end enum\n```\n\n### **Characteristics**\n\n - **enum, bind(c)** declares a C-interoperable enumeration block.\n - **enumerator** declares named integer constants within the enum.\n - Each enumerator has type integer with a kind that is interoperable with a C enumeration type.\n - Values auto-increment from the previous enumerator if not explicitly assigned.\n - The first enumerator defaults to 0 if no value is specified.\n\n### **Description**\n\n **enum** defines an enumeration type that is interoperable with C enum types. The `bind(c)` attribute is required and ensures the enumerators have compatible integer kinds with C. Enumerators are named constants whose values can be explicitly set or automatically assigned by incrementing from the previous value.\n\n### **Options**\n\n- **bind(c)**\n  : Required attribute that specifies C interoperability. Ensures the enumeration uses an integer kind compatible with C enum types.\n\n- **enumerator**\n  : Keyword used to declare each named constant in the enumeration. Multiple enumerators can be declared on a single line separated by commas.\n\n- **name = value**\n  : Assigns an explicit integer value to the enumerator. If omitted, the value is one greater than the previous enumerator (or 0 for the first).\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_enum\nimplicit none\n\n  ! Define color enumeration\n  enum, bind(c)\n    enumerator :: RED = 1\n    enumerator :: GREEN = 2\n    enumerator :: BLUE = 4\n  end enum\n\n  ! Define status codes with auto-increment\n  enum, bind(c)\n    enumerator :: STATUS_OK = 0\n    enumerator :: STATUS_WARNING      ! = 1 (auto)\n    enumerator :: STATUS_ERROR        ! = 2 (auto)\n    enumerator :: STATUS_CRITICAL     ! = 3 (auto)\n  end enum\n\n  ! Define multiple enumerators on one line\n  enum, bind(c)\n    enumerator :: NORTH = 0, EAST = 90, SOUTH = 180, WEST = 270\n  end enum\n\n  integer :: current_color\n  integer :: status\n  integer :: direction\n\n  current_color = GREEN\n  status = STATUS_WARNING\n  direction = EAST\n\n  print '(A,I0)', 'Color value: ', current_color\n  print '(A,I0)', 'Status value: ', status\n  print '(A,I0)', 'Direction value: ', direction\n\n  ! Use in conditional\n  if (status > STATUS_OK) then\n    print '(A)', 'Non-OK status detected'\n  end if\n\nend program demo_enum\n```\nResults:\n```text\nColor value: 2\nStatus value: 1\nDirection value: 90\nNon-OK status detected\n```\n\n### **Standard**\n\nFortran 2003\n\n### **See Also**\n\n[**integer**(3)](#integer),\n[**parameter**(3)](#parameter),\n[**iso_c_binding**(3)](#iso_c_binding)"
  },
  "Environment Variable": {
    "prefix": [
      "get_environment_variable",
      "GET_ENVIRONMENT_VARIABLE",
      "getenv",
      "GETENV"
    ],
    "body": [
      "call get_environment_variable(${1:name}, ${2:value}${3:, length=${4:length}}${5:, status=${6:status}}${7:, trim_name=${8:.true.}})"
    ],
    "description": "GET_ENVIRONMENT_VARIABLE(NAME,VALUE,LENGTH=length,STATUS=status,TRIM_NAME=trim_name,ERRMSG=errmsg) retrieves the value of an environment variable.\n\n### **Name**\n\n**get_environment_variable** - \\[SYSTEM:SUBROUTINE\\] Retrieve the value of an environment variable\n\n### **Synopsis**\n```fortran\n    call get_environment_variable(name, value, length, status, trim_name, errmsg)\n```\n```fortran\n     subroutine get_environment_variable(name, value, length, status, trim_name, errmsg)\n\n      character(len=*), intent(in)            :: name\n      character(len=*), intent(out), optional :: value\n      integer, intent(out), optional          :: length\n      integer, intent(out), optional          :: status\n      logical, intent(in), optional           :: trim_name\n      character(len=*), intent(inout), optional :: errmsg\n```\n\n### **Characteristics**\n\n - **name** is a scalar character string containing the environment variable name.\n - **value** is a scalar character string to receive the environment variable value.\n - **length** is a scalar default integer to receive the length of the environment variable value.\n - **status** is a scalar default integer indicating success or failure.\n - **trim_name** is a scalar logical controlling whether trailing blanks in name are significant.\n - **errmsg** is a scalar character string to receive an error message if an error occurs.\n - All arguments except **name** are optional.\n\n### **Description**\n\n **get_environment_variable** retrieves the value of the environment variable specified by **name**. If the environment variable exists, its value is assigned to **value** (if present), and its length to **length** (if present). The **status** argument indicates whether the operation succeeded.\n\n### **Options**\n\n- **name**\n  : The name of the environment variable to retrieve. This is the only required argument.\n\n- **value**\n  : Receives the value of the environment variable. If the variable exists but value is too short, the value is truncated. If the variable does not exist, value is filled with blanks.\n\n- **length**\n  : Receives the length of the environment variable value. If the variable does not exist, length is set to 0. This can be used to determine the required size before allocating value.\n\n- **status**\n  : Returns 0 if the variable exists and was successfully retrieved, 1 if the variable does not exist, 2 if the processor does not support environment variables, or -1 if value is present but too short.\n\n- **trim_name**\n  : If .true. (the default), trailing blanks in name are ignored. If .false., trailing blanks are significant and included in the environment variable name.\n\n- **errmsg**\n  : If present and an error occurs, receives an explanatory message. If no error occurs, errmsg is unchanged.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_get_environment_variable\nimplicit none\n  character(len=256) :: homedir\n  character(len=256) :: path_value\n  character(len=256) :: errmsg\n  integer :: length, status\n\n  ! Get HOME environment variable\n  call get_environment_variable('HOME', homedir, status=status)\n  if (status == 0) then\n    print *, 'HOME = ', trim(homedir)\n  else\n    print *, 'HOME environment variable not found'\n  end if\n\n  ! First get the length of PATH\n  call get_environment_variable('PATH', length=length, status=status)\n  if (status == 0) then\n    print *, 'PATH length = ', length\n  end if\n\n  ! Get PATH with full status checking\n  call get_environment_variable('PATH', path_value, length, status, &\n                                 trim_name=.true., errmsg=errmsg)\n  select case (status)\n    case (0)\n      print *, 'PATH = ', trim(path_value)\n    case (1)\n      print *, 'PATH does not exist'\n    case (2)\n      print *, 'Environment variables not supported'\n    case (-1)\n      print *, 'PATH value truncated, actual length: ', length\n  end select\n\n  ! Try to get a non-existent variable\n  call get_environment_variable('NONEXISTENT_VAR_12345', status=status)\n  if (status == 1) then\n    print *, 'Variable does not exist (as expected)'\n  end if\n\nend program demo_get_environment_variable\n```\nResults:\n```text\n HOME = /home/user\n PATH length =          142\n PATH = /usr/local/bin:/usr/bin:/bin\n Variable does not exist (as expected)\n```\n\n### **Standard**\n\nFortran 2003\n\n### **See Also**\n\n[**get_command**(3)](#get_command),\n[**get_command_argument**(3)](#get_command_argument),\n[**command_argument_count**(3)](#command_argument_count)"
  },
  "Error Unit": {
    "prefix": [
      "errorunit",
      "ERRORUNIT",
      "stderr",
      "STDERR",
      "error_unit",
      "ERROR_UNIT"
    ],
    "body": "write(error_unit, '(${1:A})') ${0:message}",
    "description": "WRITE(ERROR_UNIT,FMT) outputs diagnostic messages to standard error stream."
  },
  "Exit Named Loop": {
    "prefix": [
      "exitloop",
      "EXITLOOP",
      "exit_loop"
    ],
    "body": "exit ${1:loop_name}",
    "description": "EXIT loop_name terminates execution of a named loop construct and transfers control to the statement following the loop."
  },
  "Extended Type": {
    "prefix": [
      "extends",
      "EXTENDS",
      "extendedtype",
      "EXTENDEDTYPE",
      "inheritance"
    ],
    "body": [
      "type, extends(${1:parent_type}) :: ${2:child_type}",
      "\t${3:integer} :: ${4:new_member}",
      "\t${0}",
      "end type ${2:child_type}"
    ],
    "description": "## extended_type\n\n### **Name**\n\n**extended_type** - \\[STRUCTURE:TYPE\\] Define a derived type that inherits from a parent type\n\n### **Synopsis**\n\n```fortran\n    type, extends(parent_type) :: child_type\n```\n\n```fortran\n     type, extends(parent_type) :: child_type\n\n      ! Inherited components from parent_type are implicitly available\n      type(component_type) :: new_component  ! Additional components\n     contains\n      procedure :: new_method  ! Additional type-bound procedures\n     end type child_type\n```\n\n### **Characteristics**\n\n - **parent_type** is an existing extensible derived type (non-SEQUENCE, non-BIND(C)).\n - **child_type** inherits all components and type-bound procedures from **parent_type**.\n - The child type can add new components and procedures, or override inherited procedures.\n - A child type object can be used anywhere a parent type is expected (polymorphism).\n - Only single inheritance is supported; a type can extend exactly one parent.\n\n### **Description**\n\n **extended_type** uses the EXTENDS attribute to create a derived type that inherits\n from a parent type. The child type automatically contains all components and\n type-bound procedures of the parent type, and can add new components, add new\n procedures, or override inherited procedures with its own implementations.\n This enables object-oriented programming patterns including inheritance and\n polymorphism in Fortran.\n\n### **Options**\n\n- **parent_type**\n  : The name of the base type to inherit from. Must be an extensible derived\n  type (cannot be SEQUENCE or BIND(C) type). The parent type must be accessible\n  in the current scope.\n\n- **child_type**\n  : The name of the new derived type being defined. This type will contain all\n  components of parent_type plus any additional components declared in the\n  type definition body.\n\n- **new_component**\n  : Optional additional component declarations. These extend the parent type's\n  component list. Access the parent's components directly by name.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_extended_type\nimplicit none\n\n  ! Base type for geometric shapes\n  type :: shape\n    real :: x = 0.0  ! x-coordinate of center\n    real :: y = 0.0  ! y-coordinate of center\n  contains\n    procedure :: move => shape_move\n    procedure :: describe => shape_describe\n  end type shape\n\n  ! Extended type: circle inherits from shape\n  type, extends(shape) :: circle\n    real :: radius = 1.0\n  contains\n    procedure :: area => circle_area\n    procedure :: describe => circle_describe  ! Override parent method\n  end type circle\n\n  ! Extended type: rectangle inherits from shape\n  type, extends(shape) :: rectangle\n    real :: width = 1.0\n    real :: height = 1.0\n  contains\n    procedure :: area => rectangle_area\n    procedure :: describe => rectangle_describe  ! Override parent method\n  end type rectangle\n\n  type(circle) :: c\n  type(rectangle) :: r\n  class(shape), pointer :: s\n\n  ! Initialize objects\n  c = circle(x=0.0, y=0.0, radius=5.0)\n  r = rectangle(x=2.0, y=3.0, width=4.0, height=6.0)\n\n  ! Call inherited method\n  call c%move(1.0, 1.0)\n  print *, 'Circle center after move:', c%x, c%y\n\n  ! Call overridden method\n  call c%describe()\n  call r%describe()\n\n  ! Demonstrate polymorphism\n  s => c\n  call s%describe()  ! Calls circle_describe\n\n  s => r\n  call s%describe()  ! Calls rectangle_describe\n\n  print *, 'Circle area:', c%area()\n  print *, 'Rectangle area:', r%area()\n\ncontains\n\n  subroutine shape_move(self, dx, dy)\n    class(shape), intent(inout) :: self\n    real, intent(in) :: dx, dy\n    self%x = self%x + dx\n    self%y = self%y + dy\n  end subroutine shape_move\n\n  subroutine shape_describe(self)\n    class(shape), intent(in) :: self\n    print *, 'Shape at (', self%x, ',', self%y, ')'\n  end subroutine shape_describe\n\n  subroutine circle_describe(self)\n    class(circle), intent(in) :: self\n    print *, 'Circle at (', self%x, ',', self%y, ') with radius', self%radius\n  end subroutine circle_describe\n\n  function circle_area(self) result(a)\n    class(circle), intent(in) :: self\n    real :: a\n    real, parameter :: pi = 3.14159265359\n    a = pi * self%radius**2\n  end function circle_area\n\n  subroutine rectangle_describe(self)\n    class(rectangle), intent(in) :: self\n    print *, 'Rectangle at (', self%x, ',', self%y, ') size', self%width, 'x', self%height\n  end subroutine rectangle_describe\n\n  function rectangle_area(self) result(a)\n    class(rectangle), intent(in) :: self\n    real :: a\n    a = self%width * self%height\n  end function rectangle_area\n\nend program demo_extended_type\n```\n\nResults:\n\n```text\n Circle center after move:   1.00000000       1.00000000\n Circle at (   1.00000000     ,   1.00000000     ) with radius   5.00000000\n Rectangle at (   2.00000000     ,   3.00000000     ) size   4.00000000     x   6.00000000\n Circle at (   1.00000000     ,   1.00000000     ) with radius   5.00000000\n Rectangle at (   2.00000000     ,   3.00000000     ) size   4.00000000     x   6.00000000\n Circle area:   78.5398178\n Rectangle area:   24.0000000\n```\n\n### **Standard**\n\nFortran 2003\n\n### **See Also**\n\n[**type**](#type),\n[**class**](#class),\n[**select_type**](#select_type),\n[**abstract_type**](#abstract_type),\n[**procedure**](#procedure)"
  },
  "Final Procedure": {
    "prefix": [
      "final",
      "FINAL",
      "finalizer"
    ],
    "body": [
      "final :: ${1:finalize_name}"
    ],
    "description": "FINAL :: procedure_name declares a finalizer procedure for a derived type."
  },
  "Flush Output": {
    "prefix": [
      "flush",
      "FLUSH"
    ],
    "body": [
      "flush(${1:unit})"
    ],
    "description": "## flush\n\n### **Name**\n\n**flush** - \\[IO:SUBROUTINE\\] Flush pending output to a file unit\n\n### **Synopsis**\n```fortran\n    call flush(unit)\n```\n```fortran\n     subroutine flush(unit)\n\n      integer, intent(in) :: unit\n```\n\n### **Characteristics**\n\n - **unit** is a scalar integer representing a connected file unit number.\n - The unit must be open for output.\n - This is a subroutine, not a function.\n\n### **Description**\n\n **flush** causes any data written to the specified file unit to be\n immediately transferred to the external file. This ensures that buffered\n output is written to disk before the program continues, which is useful\n for debugging, ensuring data integrity before a potential crash, or\n when coordinating with other processes reading the same file.\n\n### **Options**\n\n- **unit**\n  : A scalar integer expression specifying the unit number of an external\n  file that is connected for output. The unit must be open. If unit is\n  omitted, all open units are flushed.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_flush\nimplicit none\n  integer :: io_unit\n  integer :: i\n\n  ! Open a file for writing\n  open(newunit=io_unit, file='output.txt', status='replace')\n\n  ! Write some data\n  do i = 1, 5\n    write(io_unit, '(A,I0)') 'Line ', i\n  end do\n\n  ! Flush to ensure data is written to disk\n  flush(io_unit)\n\n  print *, 'Data flushed to output.txt'\n\n  ! Continue with more operations...\n  write(io_unit, '(A)') 'Final line after flush'\n\n  close(io_unit)\n\nend program demo_flush\n```\nResults:\n```text\n Data flushed to output.txt\n```\nContents of output.txt:\n```text\nLine 1\nLine 2\nLine 3\nLine 4\nLine 5\nFinal line after flush\n```\n\n### **Standard**\n\nFortran 2003\n\n### **See Also**\n\n[**open**(3)](#open),\n[**close**(3)](#close),\n[**write**(3)](#write)"
  },
  "Format String": {
    "prefix": [
      "format",
      "FORMAT"
    ],
    "body": [
      "character(len=*), parameter :: ${1:fmt} = '(${0:A})'"
    ],
    "description": "FORMAT(FMT) declares a named format string parameter for formatted I/O operations.",
    "documentation": {
      "name": "**format** - \\[IO:FORMAT\\] Declare a named format string parameter",
      "synopsis": {
        "usage": "character(len=*), parameter :: fmt = '(format_descriptors)'",
        "interface": [
          "character(len=*), parameter :: fmt_name = '(descriptors)'",
          "",
          "! Where:",
          "!   fmt_name    - Name of the format parameter",
          "!   descriptors - Format edit descriptors"
        ]
      },
      "characteristics": [
        "**fmt** is a character constant with assumed length (len=*)",
        "The **parameter** attribute makes it a named constant",
        "Format strings must be enclosed in parentheses within the string",
        "Can be used with READ, WRITE, and PRINT statements"
      ],
      "description": "**format** declares a named character parameter containing format edit descriptors for use in formatted input/output operations. Using named format parameters improves code readability and maintainability by allowing format strings to be defined once and reused throughout a program.",
      "options": [
        {
          "name": "A",
          "description": "Character data descriptor. A alone uses actual length; A<w> uses width w."
        },
        {
          "name": "I<w>",
          "description": "Integer descriptor with width w. I<w>.<m> specifies minimum digits m."
        },
        {
          "name": "F<w>.<d>",
          "description": "Fixed-point real with width w and d decimal places."
        },
        {
          "name": "E<w>.<d>",
          "description": "Exponential notation real with width w and d decimal places."
        },
        {
          "name": "ES<w>.<d>",
          "description": "Scientific notation (1.0 <= mantissa < 10.0)."
        },
        {
          "name": "EN<w>.<d>",
          "description": "Engineering notation (exponent multiple of 3)."
        },
        {
          "name": "G<w>.<d>",
          "description": "General descriptor; switches between F and E based on magnitude."
        },
        {
          "name": "L<w>",
          "description": "Logical descriptor with width w (outputs T or F)."
        },
        {
          "name": "X",
          "description": "Skip one position. <n>X skips n positions."
        },
        {
          "name": "/",
          "description": "End current record and start new line."
        },
        {
          "name": "'text'",
          "description": "Literal character string in output."
        },
        {
          "name": "<r>(...)",
          "description": "Repeat group r times. Parentheses group descriptors."
        }
      ],
      "examples": {
        "code": [
          "program demo_format_string",
          "implicit none",
          "  ! Declare format parameters for different output types",
          "  character(len=*), parameter :: fmt_header = '(A, T20, A, T40, A)'",
          "  character(len=*), parameter :: fmt_data   = '(A, T20, I8, T40, F10.3)'",
          "  character(len=*), parameter :: fmt_sci    = '(A, ES12.4)'",
          "  character(len=*), parameter :: fmt_multi  = '(3(I5, 2X))'",
          "",
          "  integer :: count",
          "  real    :: value, temperature",
          "  character(len=20) :: name",
          "",
          "  ! Initialize variables",
          "  name = 'Sample'",
          "  count = 42",
          "  value = 123.456",
          "  temperature = 6.022e23",
          "",
          "  ! Use named format parameters",
          "  print fmt_header, 'Name', 'Count', 'Value'",
          "  print fmt_header, '----', '-----', '-----'",
          "  print fmt_data, name, count, value",
          "",
          "  ! Scientific notation format",
          "  print fmt_sci, 'Avogadro: ', temperature",
          "",
          "  ! Repeated format group",
          "  print fmt_multi, 10, 20, 30",
          "",
          "end program demo_format_string"
        ],
        "results": [
          "Name               Count               Value",
          "----               -----               -----",
          "Sample                 42          123.456",
          "Avogadro:   6.0220E+23",
          "   10     20     30"
        ]
      },
      "standard": "Fortran 90",
      "see_also": [
        "**write**(3)",
        "**read**(3)",
        "**print**(3)",
        "**open**(3)"
      ]
    }
  },
  "Fortran String to C": {
    "prefix": [
      "f2cstring",
      "F2CSTRING",
      "fstring",
      "FSTRING"
    ],
    "body": [
      "pure function f_to_c_string(f_string) result(c_string)",
      "  use iso_c_binding, only: c_char, c_null_char",
      "  character(len=*), intent(in) :: f_string",
      "  character(kind=c_char, len=1) :: c_string(len_trim(f_string) + 1)",
      "  integer :: i, n",
      "",
      "  n = len_trim(f_string)",
      "  do i = 1, n",
      "    c_string(i) = f_string(i:i)",
      "  end do",
      "  c_string(n + 1) = c_null_char",
      "end function f_to_c_string"
    ],
    "description": "## f_to_c_string\n\n### **Name**\n\n**f_to_c_string** - \\[INTEROP:C_BINDING\\] Convert Fortran string to null-terminated C string array\n\n### **Synopsis**\n```fortran\n    c_string = f_to_c_string(f_string)\n```\n```fortran\n     pure function f_to_c_string(f_string) result(c_string)\n\n      use iso_c_binding, only: c_char, c_null_char\n      character(len=*), intent(in)  :: f_string\n      character(kind=c_char, len=1) :: c_string(len_trim(f_string) + 1)\n```\n\n### **Characteristics**\n\n - **f_string** is a character scalar of any length.\n - The result is a rank-1 array of c_char characters with length len_trim(f_string) + 1.\n - The result array is null-terminated for C interoperability.\n - This is a pure function suitable for use in concurrent contexts.\n\n### **Description**\n\n **f_to_c_string** converts a Fortran character string to a null-terminated\n C-compatible character array. It trims trailing blanks from the input string\n and appends a C_NULL_CHAR to create a proper C string representation.\n\n### **Options**\n\n- **f_string**\n  : The Fortran character string to convert. May be of any length.\n  Trailing blanks are automatically trimmed before conversion.\n\n### **Result**\n\n  Returns a rank-1 array of single characters with kind c_char. The array\n  size is len_trim(f_string) + 1, where the final element is c_null_char.\n  Each character from the trimmed input string is copied to the corresponding\n  array element.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_f_to_c_string\n  use iso_c_binding, only: c_char, c_null_char, c_ptr, c_loc\n  implicit none\n\n  character(len=32) :: fortran_str\n  character(kind=c_char, len=1), allocatable :: c_str(:)\n  integer :: i\n\n  ! Define interface for the conversion function\n  interface\n    pure function f_to_c_string(f_string) result(c_string)\n      use iso_c_binding, only: c_char, c_null_char\n      character(len=*), intent(in) :: f_string\n      character(kind=c_char, len=1) :: c_string(len_trim(f_string) + 1)\n    end function f_to_c_string\n  end interface\n\n  ! Test with a simple string\n  fortran_str = 'Hello, C World!'\n  c_str = f_to_c_string(fortran_str)\n\n  print '(A)', 'Original Fortran string: \"' // trim(fortran_str) // '\"'\n  print '(A,I0)', 'C string array size: ', size(c_str)\n  print '(A)', 'C string contents (character by character):'\n\n  do i = 1, size(c_str)\n    if (c_str(i) == c_null_char) then\n      print '(A,I0,A)', '  c_str(', i, ') = NULL_CHAR (terminator)'\n    else\n      print '(A,I0,A,A,A)', '  c_str(', i, ') = \"', c_str(i), '\"'\n    end if\n  end do\n\n  deallocate(c_str)\n\nend program demo_f_to_c_string\n```\nResults:\n```text\nOriginal Fortran string: \"Hello, C World!\"\nC string array size: 16\nC string contents (character by character):\n  c_str(1) = \"H\"\n  c_str(2) = \"e\"\n  c_str(3) = \"l\"\n  c_str(4) = \"l\"\n  c_str(5) = \"o\"\n  c_str(6) = \",\"\n  c_str(7) = \" \"\n  c_str(8) = \"C\"\n  c_str(9) = \" \"\n  c_str(10) = \"W\"\n  c_str(11) = \"o\"\n  c_str(12) = \"r\"\n  c_str(13) = \"l\"\n  c_str(14) = \"d\"\n  c_str(15) = \"!\"\n  c_str(16) = NULL_CHAR (terminator)\n```\n\n### **Standard**\n\nFortran 2003 (iso_c_binding module)\n\n### **See Also**\n\n[**c_f_pointer**(3)](#c_f_pointer),\n[**c_loc**(3)](#c_loc),\n[**c_null_char**(3)](#c_null_char),\n[**iso_c_binding**(3)](#iso_c_binding)"
  },
  "Fortran to C Pointer": {
    "prefix": [
      "fcptr",
      "FCPTR",
      "c_loc"
    ],
    "body": [
      "use, intrinsic :: iso_c_binding, only: c_ptr, c_loc",
      "${1:real(c_double)}, target :: ${2:data}${3:(${4:n})}",
      "type(c_ptr) :: ${5:cptr}",
      "",
      "${5:cptr} = c_loc(${2:data})"
    ],
    "description": "C_LOC(X) returns the C address of the Fortran variable X with the TARGET attribute."
  },
  "GCC Attributes": {
    "prefix": [
      "gccattr",
      "GCCATTR",
      "gccattributes",
      "GCCATTRIBUTES"
    ],
    "body": [
      "!gcc$ attributes ${1|target,aligned,alias,cdecl,dllexport,dllimport,fastcall,hot,cold,noinline,stdcall,used,unused,visibility|} :: ${0:name}"
    ],
    "description": "!GCC$ ATTRIBUTES attr :: name applies GCC-specific attributes to variables, procedures, or types.\n\n## gcc_attributes\n\n### **Name**\n\n**!GCC$ ATTRIBUTES** - \\[STRUCTURE:DIRECTIVE\\] Apply GCC-specific attributes to Fortran entities\n\n### **Synopsis**\n\n```fortran\n    !gcc$ attributes attribute_list :: entity_name\n```\n\n```fortran\n     !gcc$ attributes attribute :: name\n\n      ! Where:\n      ! attribute - GCC attribute specifier\n      ! name      - Variable, procedure, or type name\n```\n\n### **Characteristics**\n\n - **attribute** is a GCC attribute keyword or list of keywords.\n - **name** is a variable, procedure, or derived type identifier.\n - The directive must appear on a comment line starting with `!gcc$`.\n - Multiple attributes can be specified separated by commas.\n - Attributes affect code generation and linking behavior.\n\n### **Description**\n\n **!GCC$ ATTRIBUTES** is a GCC extension directive that allows applying\n compiler-specific attributes to Fortran entities. These attributes control\n various aspects of code generation, calling conventions, symbol visibility,\n and optimization hints.\n\n### **Options**\n\n- **target**\n  : Indicates the variable may be the target of a pointer. Required for\n  variables that will be pointed to by C pointers.\n\n- **aligned**\n  : Specifies memory alignment requirements. Use `aligned(n)` for specific\n  byte alignment.\n\n- **alias**\n  : Creates an alias name for a symbol. Use `alias('name')` to specify\n  the alias string.\n\n- **cdecl**\n  : Uses the C calling convention. Default for most platforms.\n\n- **dllexport**\n  : Exports the symbol from a Windows DLL. Required for shared library\n  public interfaces on Windows.\n\n- **dllimport**\n  : Imports the symbol from a Windows DLL. Used when calling functions\n  from external DLLs.\n\n- **fastcall**\n  : Uses the fastcall calling convention (registers for first arguments).\n  x86-specific optimization.\n\n- **hot**\n  : Hints that the function is called frequently. Enables aggressive\n  optimization for this code path.\n\n- **cold**\n  : Hints that the function is rarely called. Optimizer may deprioritize\n  this code path.\n\n- **noinline**\n  : Prevents the compiler from inlining this function, even if it would\n  normally be a candidate.\n\n- **stdcall**\n  : Uses the stdcall calling convention. Common for Windows API functions.\n\n- **used**\n  : Prevents the symbol from being removed by dead code elimination,\n  even if it appears unused.\n\n- **unused**\n  : Suppresses warnings about unused variables or functions.\n\n- **visibility**\n  : Controls symbol visibility in shared libraries. Use `visibility('hidden')`\n  or `visibility('default')`.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_gcc_attributes\n  implicit none\n\n  ! Variable with target attribute for C interoperability\n  real, target :: buffer(1000)\n  !gcc$ attributes target :: buffer\n\n  ! Function that should not be inlined\n  !gcc$ attributes noinline :: compute_expensive\n\n  ! Hot path optimization hint\n  !gcc$ attributes hot :: inner_loop_kernel\n\n  ! Cold path for error handling\n  !gcc$ attributes cold :: handle_error\n\n  call test_attributes()\n\ncontains\n\n  subroutine compute_expensive(x, y, result)\n    !gcc$ attributes noinline :: compute_expensive\n    real, intent(in) :: x, y\n    real, intent(out) :: result\n    result = x * y + sqrt(x**2 + y**2)\n  end subroutine\n\n  subroutine inner_loop_kernel(arr, n)\n    !gcc$ attributes hot :: inner_loop_kernel\n    integer, intent(in) :: n\n    real, intent(inout) :: arr(n)\n    integer :: i\n    do i = 1, n\n      arr(i) = arr(i) * 2.0\n    end do\n  end subroutine\n\n  subroutine handle_error(code)\n    !gcc$ attributes cold :: handle_error\n    integer, intent(in) :: code\n    print *, 'Error occurred:', code\n    stop 1\n  end subroutine\n\n  subroutine test_attributes()\n    real :: data(100)\n    real :: res\n    data = 1.0\n    call compute_expensive(3.0, 4.0, res)\n    print *, 'Compute result:', res\n    call inner_loop_kernel(data, 100)\n    print *, 'First element after kernel:', data(1)\n  end subroutine\n\nend program demo_gcc_attributes\n```\n\nResults:\n\n```text\n Compute result:   17.0000000\n First element after kernel:   2.00000000\n```\n\nWindows DLL example:\n\n```fortran\nmodule my_dll_exports\n  implicit none\n\n  !gcc$ attributes dllexport :: public_function\n  !gcc$ attributes dllexport :: public_variable\n\n  real :: public_variable = 42.0\n\ncontains\n\n  function public_function(x) result(y)\n    !gcc$ attributes dllexport :: public_function\n    real, intent(in) :: x\n    real :: y\n    y = x * public_variable\n  end function\n\nend module my_dll_exports\n```\n\n### **Standard**\n\nGCC Extension (gfortran-specific, not part of any Fortran standard)\n\n### **See Also**\n\n[**BIND(C)**](#bind_c),\n[**ISO_C_BINDING**](#iso_c_binding),\n[**!DEC$ ATTRIBUTES**](#dec_attributes)"
  },
  "Generic Interface Block": {
    "prefix": [
      "genericinterface",
      "GENERICINTERFACE"
    ],
    "body": [
      "interface ${1:generic_name}",
      "\tmodule procedure ${2:proc1}",
      "\tmodule procedure ${3:proc2}",
      "\t${0}",
      "end interface ${1:generic_name}"
    ],
    "description": "## generic_interface\n\n### **Name**\n\n**generic_interface** - \\[STRUCTURE:PROCEDURE\\] Define a generic interface that maps a single name to multiple specific procedures\n\n### **Synopsis**\n```fortran\n    interface generic_name\n       module procedure specific_proc1\n       module procedure specific_proc2\n    end interface generic_name\n```\n```fortran\n     interface generic_name\n\n      ! Declares a generic name that can resolve to\n      ! different procedures based on argument types\n      module procedure :: specific_proc1  ! handles type1 arguments\n      module procedure :: specific_proc2  ! handles type2 arguments\n\n     end interface generic_name\n```\n\n### **Characteristics**\n\n - **generic_name** is the common name used to invoke any of the specific procedures.\n - **specific procedures** must have distinguishable argument signatures (type, kind, or rank).\n - All procedures in the interface must be module procedures or external procedures with explicit interfaces.\n - The compiler selects the appropriate procedure based on the actual arguments at the call site.\n\n### **Description**\n\n **generic_interface** allows multiple procedures to be called using a single generic name. The compiler determines which specific procedure to invoke based on the types, kinds, and ranks of the actual arguments. This enables polymorphic behavior and cleaner APIs where the same operation can apply to different data types.\n\n### **Options**\n\n- **generic_name**\n  : The identifier used to call any of the grouped procedures. Must be a valid Fortran identifier.\n\n- **module procedure**\n  : Specifies a procedure defined in the same module that should be accessible through the generic name. Each listed procedure must have a unique signature distinguishable by argument characteristics.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_generic_interface\nimplicit none\n\n  interface swap\n     module procedure swap_int, swap_real\n  end interface swap\n\n  integer :: i1 = 10, i2 = 20\n  real    :: r1 = 1.5, r2 = 3.5\n\n  print *, 'Before swap:'\n  print *, 'Integers: i1 =', i1, ', i2 =', i2\n  print *, 'Reals:    r1 =', r1, ', r2 =', r2\n\n  call swap(i1, i2)  ! Calls swap_int\n  call swap(r1, r2)  ! Calls swap_real\n\n  print *, 'After swap:'\n  print *, 'Integers: i1 =', i1, ', i2 =', i2\n  print *, 'Reals:    r1 =', r1, ', r2 =', r2\n\ncontains\n\n  subroutine swap_int(a, b)\n    integer, intent(inout) :: a, b\n    integer :: temp\n    temp = a\n    a = b\n    b = temp\n  end subroutine swap_int\n\n  subroutine swap_real(a, b)\n    real, intent(inout) :: a, b\n    real :: temp\n    temp = a\n    a = b\n    b = temp\n  end subroutine swap_real\n\nend program demo_generic_interface\n```\nResults:\n```text\n Before swap:\n Integers: i1 =          10 , i2 =          20\n Reals:    r1 =   1.500000     , r2 =   3.500000\n After swap:\n Integers: i1 =          20 , i2 =          10\n Reals:    r1 =   3.500000     , r2 =   1.500000\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**abstract_interface**(3)](#abstract_interface),\n[**module**(3)](#module),\n[**procedure**(3)](#procedure)"
  },
  "Inquire File Exists": {
    "prefix": [
      "inquireexists",
      "INQUIREEXISTS",
      "fileexists",
      "FILEEXISTS"
    ],
    "body": [
      "logical :: ${1:file_exists}",
      "inquire(file='${2:filename}', exist=${1:file_exists})",
      "if (${1:file_exists}) then",
      "\t${0}",
      "end if"
    ],
    "description": "INQUIRE(FILE,EXIST) checks whether a file exists in the filesystem and stores the result in a logical variable.",
    "documentation": "## inquire_file_exists\n\n### **Name**\n\n**inquire_file_exists** - \\[IO:FILE\\] Check if a file exists in the filesystem\n\n### **Synopsis**\n\n```fortran\n    inquire(file='filename', exist=file_exists)\n```\n\n```fortran\n     ! File existence inquiry pattern\n\n      character(len=*) :: filename\n      logical          :: file_exists\n\n      inquire(file=filename, exist=file_exists)\n```\n\n### **Characteristics**\n\n - **filename** is a character expression specifying the file path to check.\n - **file_exists** is a logical variable that receives the result.\n - The INQUIRE statement is non-destructive and does not modify or open the file.\n - The file path can be absolute or relative to the current working directory.\n\n### **Description**\n\n **inquire_file_exists** uses the INQUIRE statement with the EXIST specifier\n to determine whether a named file exists in the filesystem. The logical\n variable is set to .TRUE. if the file exists and .FALSE. otherwise. This\n pattern is commonly used before attempting to OPEN a file for reading to\n avoid runtime errors, or to check if an output file already exists before\n overwriting it.\n\n### **Options**\n\n- **file**\n  : A character expression containing the name of the file to check.\n  The filename can include a path (absolute or relative). The interpretation\n  of the filename is processor-dependent but typically follows the\n  conventions of the underlying operating system.\n\n- **exist**\n  : A logical variable that is assigned .TRUE. if a file with the\n  specified name exists, and .FALSE. otherwise. The variable must be\n  declared as LOGICAL before use.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_inquire_file_exists\nimplicit none\n  character(len=256) :: filename\n  logical :: file_exists\n  integer :: unit_num, ios\n\n  ! Check if a configuration file exists\n  filename = 'config.dat'\n  inquire(file=filename, exist=file_exists)\n\n  if (file_exists) then\n    print *, 'File exists: ', trim(filename)\n    open(newunit=unit_num, file=filename, status='old', &\n         action='read', iostat=ios)\n    if (ios == 0) then\n      print *, 'File opened successfully'\n      close(unit_num)\n    end if\n  else\n    print *, 'File does not exist: ', trim(filename)\n    print *, 'Creating new file...'\n    open(newunit=unit_num, file=filename, status='new', &\n         action='write', iostat=ios)\n    if (ios == 0) then\n      write(unit_num, *) 'Default configuration'\n      close(unit_num)\n      print *, 'New file created'\n    end if\n  end if\n\n  ! Check for a file that likely does not exist\n  inquire(file='nonexistent_file_12345.txt', exist=file_exists)\n  print *, 'Nonexistent file check:', file_exists\n\nend program demo_inquire_file_exists\n```\n\nResults:\n\n```text\n File does not exist: config.dat\n Creating new file...\n New file created\n Nonexistent file check: F\n```\n\n### **Standard**\n\nFortran 77\n\n### **See Also**\n\n[**open**(3)](#open),\n[**close**(3)](#close),\n[**inquire**(3)](#inquire),\n[**read**(3)](#read),\n[**write**(3)](#write)"
  },
  "Integer Kind int32": {
    "prefix": [
      "int32",
      "INT32"
    ],
    "body": [
      "integer(int32) :: ${0:var}"
    ],
    "description": "integer(int32) :: var declares a 32-bit integer variable using the ISO_FORTRAN_ENV intrinsic kind constant.\n\n### **Name**\n\n**int32** - \\[NUMERIC:DECLARATION\\] Declare a 32-bit integer variable\n\n### **Synopsis**\n```fortran\n    integer(int32) :: variable_name\n```\n```fortran\n     use, intrinsic :: iso_fortran_env, only: int32\n\n     integer(int32) :: variable_name\n```\n\n### **Characteristics**\n\n - **int32** is a named constant from the ISO_FORTRAN_ENV intrinsic module.\n - The value of int32 represents a kind type parameter for integer types with a storage size of 32 bits.\n - If the processor does not support 32-bit integers, int32 will have the value -1.\n - Variables declared with this kind can represent values in the range -2,147,483,648 to 2,147,483,647.\n\n### **Description**\n\n **int32** provides a portable way to declare 32-bit integer variables across different Fortran compilers and platforms. Using ISO_FORTRAN_ENV kind constants ensures consistent integer sizes regardless of the underlying hardware architecture, which is essential for numerical reproducibility and interoperability.\n\n### **Options**\n\n- **variable_name**\n  : The name of the integer variable being declared. Must follow Fortran naming conventions (start with a letter, contain only letters, digits, and underscores).\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_int32\n  use, intrinsic :: iso_fortran_env, only: int32\n  implicit none\n\n  integer(int32) :: count\n  integer(int32) :: max_value\n  integer(int32) :: min_value\n\n  ! Assign values\n  count = 42\n  max_value = huge(count)\n  min_value = -huge(count) - 1\n\n  print '(A,I0)', 'Count: ', count\n  print '(A,I0)', 'Maximum int32 value: ', max_value\n  print '(A,I0)', 'Minimum int32 value: ', min_value\n  print '(A,I0)', 'Storage size (bits): ', storage_size(count)\n\nend program demo_int32\n```\nResults:\n```text\nCount: 42\nMaximum int32 value: 2147483647\nMinimum int32 value: -2147483648\nStorage size (bits): 32\n```\n\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\n[**int8**(3)](#int8),\n[**int16**(3)](#int16),\n[**int64**(3)](#int64),\n[**selected_int_kind**(3)](#selected_int_kind),\n[**iso_fortran_env**(3)](#iso_fortran_env)"
  },
  "Integer Kind int64": {
    "prefix": [
      "int64",
      "INT64"
    ],
    "body": [
      "integer(int64) :: ${0:var}"
    ],
    "description": "integer(int64) :: var declares a 64-bit integer variable using ISO_FORTRAN_ENV kind parameter.",
    "documentation": {
      "name": "**int64** - \\[NUMERIC:DECLARATION\\] Declare a 64-bit integer variable",
      "synopsis": {
        "usage": "```fortran\n    integer(int64) :: variable_name\n```",
        "interface": "```fortran\n     integer(int64) :: variable_name\n\n      ! Where int64 is a kind parameter from ISO_FORTRAN_ENV\n      ! Guarantees exactly 64 bits of storage\n```"
      },
      "characteristics": [
        "**int64** is a named constant from the ISO_FORTRAN_ENV intrinsic module.",
        "Provides a portable way to declare 64-bit integers across compilers.",
        "The value of int64 is processor-dependent but guarantees 64-bit storage.",
        "Range: approximately -9.2 x 10^18 to 9.2 x 10^18."
      ],
      "description": "**int64** is a kind parameter constant provided by the ISO_FORTRAN_ENV intrinsic module that specifies a 64-bit integer type. Using int64 ensures portable code that will work across different Fortran compilers while guaranteeing exactly 64 bits of storage for integer values. This is essential for applications requiring large integer ranges or interfacing with C code using int64_t.",
      "options": [
        {
          "name": "var",
          "description": "The name of the integer variable being declared. Must follow Fortran naming rules: start with a letter, contain only letters, digits, and underscores, and be at most 63 characters long."
        }
      ],
      "examples": {
        "code": "```fortran\nprogram demo_int64\n  use, intrinsic :: iso_fortran_env, only: int64\n  implicit none\n\n  integer(int64) :: large_number\n  integer(int64) :: factorial_result\n  integer(int64) :: i\n\n  ! Demonstrate the range of int64\n  large_number = 9223372036854775807_int64  ! Maximum int64 value\n  print '(A,I0)', 'Maximum int64 value: ', large_number\n\n  ! Calculate factorial of 20 (requires 64-bit integer)\n  factorial_result = 1_int64\n  do i = 1_int64, 20_int64\n    factorial_result = factorial_result * i\n  end do\n  print '(A,I0)', 'Factorial of 20: ', factorial_result\n\n  ! Show the kind value\n  print '(A,I0)', 'Kind value for int64: ', int64\n  print '(A,I0)', 'Bit size: ', bit_size(large_number)\n\nend program demo_int64\n```",
        "results": "```text\nMaximum int64 value: 9223372036854775807\nFactorial of 20: 2432902008176640000\nKind value for int64: 8\nBit size: 64\n```"
      },
      "standard": "Fortran 2008",
      "see_also": [
        "[**int32**(3)](#int32) - 32-bit integer kind parameter",
        "[**int16**(3)](#int16) - 16-bit integer kind parameter",
        "[**int8**(3)](#int8) - 8-bit integer kind parameter",
        "[**selected_int_kind**(3)](#selected_int_kind) - Select integer kind by range",
        "[**huge**(3)](#huge) - Largest value of same kind"
      ]
    }
  },
  "Internal Procedure": {
    "prefix": [
      "internal",
      "INTERNAL",
      "contained",
      "CONTAINED"
    ],
    "body": [
      "subroutine ${1:outer_procedure}(${2:args})",
      "  implicit none",
      "  ${3:! Declarations}",
      "  ${4:! Host procedure body}",
      "",
      "  call ${5:internal_sub}(${6:local_args})",
      "",
      "contains",
      "",
      "  subroutine ${5:internal_sub}(${7:internal_args})",
      "    ! Host association: can access ${1:outer_procedure}'s variables",
      "    ${8:! Internal procedure body}",
      "  end subroutine ${5:internal_sub}",
      "",
      "end subroutine ${1:outer_procedure}",
      "$0"
    ],
    "description": "INTERNAL_PROCEDURE(HOST,CONTAINED) creates a procedure with internal (contained) subprograms using host association."
  },
  "IO Error Handling": {
    "prefix": [
      "iocheck",
      "IOCHECK",
      "iostatcheck",
      "IOSTATCHECK"
    ],
    "body": [
      "if (${1:iostat_var} > 0) then",
      "\twrite(*, '(A,I0)') 'I/O error code: ', ${1:iostat_var}",
      "\terror stop 'I/O operation failed'",
      "else if (${1:iostat_var} < 0) then",
      "\t${2:! End-of-file or end-of-record reached}",
      "\t${0}",
      "end if"
    ],
    "description": "IOCHECK(IOSTAT_VAR) checks IOSTAT return value and handles I/O errors appropriately."
  },
  "Kind Parameter Definition": {
    "prefix": [
      "kindparam",
      "KINDPARAM",
      "dp",
      "DP"
    ],
    "body": [
      "integer, parameter :: ${1:dp} = kind(0.d0)"
    ],
    "description": "integer, parameter :: dp = kind(0.d0) defines a kind parameter for double precision reals.\n\n## kind_parameter\n\n### **Name**\n\n**kind_parameter** - \\[NUMERIC:DECLARATION\\] Define a named kind parameter for double precision reals\n\n### **Synopsis**\n```fortran\n    integer, parameter :: dp = kind(0.d0)\n```\n```fortran\n     integer, parameter :: dp = kind(0.d0)\n\n      integer, parameter :: dp\n      real(kind=dp)      :: variable\n```\n\n### **Characteristics**\n\n - **dp** is an integer named constant (parameter)\n - The value is determined at compile-time by the KIND intrinsic function\n - The literal **0.d0** is a double precision real constant\n - This pattern provides portable precision specification across compilers\n\n### **Description**\n\n **kind_parameter** defines a named integer constant that captures the kind\n type parameter for double precision real numbers. Using kind(0.d0) returns\n the kind value that the compiler uses for double precision literals (those\n with the 'd' exponent). This is the recommended portable way to specify\n double precision in modern Fortran, as it avoids magic numbers and\n non-portable kind values like 8.\n\n### **Options**\n\n- **dp**\n  : The name of the kind parameter constant. Common conventions include\n  dp (double precision), wp (working precision), rk (real kind), or\n  r8 (real 8-byte). The name should reflect its intended use.\n\n- **kind(0.d0)**\n  : The KIND intrinsic returns the kind type parameter of its argument.\n  The literal 0.d0 is a double precision constant (using the 'd' exponent),\n  so kind(0.d0) returns the compiler's kind value for double precision.\n  Alternative forms include selected_real_kind(15, 307) for explicit\n  precision/range requirements.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_kind_parameter\nimplicit none\n  ! Define kind parameter for double precision\n  integer, parameter :: dp = kind(0.d0)\n\n  ! Declare variables using the kind parameter\n  real(dp) :: x, y, result\n  real(dp), parameter :: pi = 3.141592653589793238_dp\n\n  ! Use double precision arithmetic\n  x = 1.0_dp\n  y = 3.0_dp\n  result = x / y\n\n  print '(a,i0)', 'Kind parameter dp = ', dp\n  print '(a,i0)', 'Precision digits = ', precision(result)\n  print '(a,i0)', 'Exponent range   = ', range(result)\n  print '(a,es23.15)', 'Value of 1/3     = ', result\n  print '(a,es23.15)', 'Value of pi      = ', pi\n\nend program demo_kind_parameter\n```\nResults:\n```text\n    Kind parameter dp = 8\n    Precision digits = 15\n    Exponent range   = 307\n    Value of 1/3     =  3.333333333333333E-01\n    Value of pi      =  3.141592653589793E+00\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**kind**(3)](#kind),\n[**selected_real_kind**(3)](#selected_real_kind),\n[**precision**(3)](#precision),\n[**range**(3)](#range)"
  },
  "LAPACK DGESV": {
    "prefix": [
      "dgesv",
      "DGESV"
    ],
    "body": [
      "call dgesv(${1:n}, ${2:nrhs}, ${3:A}, ${4:lda}, ${5:ipiv}, ${6:B}, ${7:ldb}, ${0:info})"
    ],
    "description": "DGESV(N,NRHS,A,LDA,IPIV,B,LDB,INFO) solves a system of linear equations A*X=B using LU factorization with partial pivoting."
  },
  "Module Procedure": {
    "prefix": [
      "moduleprocedure",
      "MODULEPROCEDURE",
      "modproc",
      "MODPROC"
    ],
    "body": "module procedure ${1:proc_name}",
    "description": "MODULE PROCEDURE proc_name declares a module procedure in an interface block or submodule.\n\n### **Name**\n\n**module procedure** - \\[STRUCTURE:PROCEDURE\\] Declare a module procedure within an interface or submodule\n\n### **Synopsis**\n```fortran\n    module procedure proc_name\n```\n```fortran\n     module procedure proc_name [, proc_name2, ...]\n\n     ! Within an interface block:\n     interface generic_name\n       module procedure specific_proc1\n       module procedure specific_proc2\n     end interface\n\n     ! Within a submodule:\n     submodule (parent_module) child_submodule\n     contains\n       module procedure deferred_proc\n         ! Implementation\n       end procedure\n     end submodule\n```\n\n### **Characteristics**\n\n - **proc_name** is the name of a procedure defined in the current module or its parent module.\n - Used within INTERFACE blocks to add module procedures to a generic interface.\n - Used within SUBMODULE to provide implementation of a deferred (separate) module procedure.\n - Multiple procedure names can be listed, separated by commas.\n - The referenced procedure must be accessible in the current scope.\n\n### **Description**\n\n **module procedure** serves two primary purposes in Fortran:\n\n 1. **Generic Interfaces**: Within an INTERFACE block, it declares that a module\n    procedure is a specific implementation of a generic interface. This allows\n    procedure overloading based on argument types.\n\n 2. **Submodule Implementation**: Within a SUBMODULE, it provides the actual\n    implementation of a procedure whose interface was declared with the SEPARATE\n    attribute in the parent module.\n\n### **Options**\n\n- **proc_name**\n  : The name of the module procedure to be included in the generic interface\n  or implemented in a submodule. Must be a valid Fortran identifier referencing\n  an accessible module procedure. Multiple names can be provided as a\n  comma-separated list.\n\n### **Examples**\n\nSample program demonstrating generic interface:\n```fortran\nprogram demo_module_procedure\n  use math_operations\n  implicit none\n  integer :: int_result\n  real :: real_result\n\n  ! Generic 'add' resolves to appropriate specific procedure\n  int_result = add(2, 3)\n  real_result = add(2.5, 3.7)\n\n  print *, 'Integer addition: ', int_result\n  print *, 'Real addition: ', real_result\n\nend program demo_module_procedure\n\nmodule math_operations\n  implicit none\n\n  interface add\n    module procedure add_integers\n    module procedure add_reals\n  end interface add\n\ncontains\n\n  function add_integers(a, b) result(c)\n    integer, intent(in) :: a, b\n    integer :: c\n    c = a + b\n  end function add_integers\n\n  function add_reals(a, b) result(c)\n    real, intent(in) :: a, b\n    real :: c\n    c = a + b\n  end function add_reals\n\nend module math_operations\n```\nResults:\n```text\n Integer addition:            5\n Real addition:    6.20000029\n```\n\nSample program demonstrating submodule implementation:\n```fortran\nmodule base_module\n  implicit none\n\n  interface\n    module subroutine greet(name)\n      character(len=*), intent(in) :: name\n    end subroutine greet\n  end interface\n\nend module base_module\n\nsubmodule (base_module) greetings_impl\n  implicit none\ncontains\n\n  module procedure greet\n    print *, 'Hello, ', trim(name), '!'\n  end procedure greet\n\nend submodule greetings_impl\n\nprogram demo_submodule_procedure\n  use base_module\n  implicit none\n\n  call greet('World')\n\nend program demo_submodule_procedure\n```\nResults:\n```text\n Hello, World!\n```\n\n### **Standard**\n\nFortran 90 (generic interfaces), Fortran 2008 (submodules)\n\n### **See Also**\n\n[**interface**(3)](#interface),\n[**submodule**(3)](#submodule),\n[**procedure**(3)](#procedure),\n[**contains**(3)](#contains)"
  },
  "Module with Explicit Visibility": {
    "prefix": [
      "module_private",
      "MODULE_PRIVATE",
      "modprivate",
      "MODPRIVATE"
    ],
    "body": [
      "module ${1:module_name}",
      "\timplicit none",
      "\tprivate",
      "\tpublic :: ${2:public_entity}",
      "",
      "\t${3:! Module variables and types}",
      "",
      "contains",
      "",
      "\t${0:! Module procedures}",
      "",
      "end module ${1:module_name}"
    ],
    "description": "## module_private\n\n### **Name**\n\n**module_private** - \\[STRUCTURE:MODULE\\] Module with private default and explicit public exports\n\n### **Synopsis**\n```fortran\n    module module_name\n      implicit none\n      private\n      public :: public_entity\n      ! declarations\n    contains\n      ! procedures\n    end module module_name\n```\n```fortran\n     module module_name\n\n      implicit none\n      private                    ! Default visibility is private\n      public :: exported_var     ! Explicitly export public entities\n      public :: exported_type\n      public :: exported_proc\n\n      integer :: internal_var    ! Private by default\n      integer :: exported_var    ! Public via explicit declaration\n\n     contains\n\n      subroutine exported_proc() ! Public via explicit declaration\n      end subroutine\n\n      subroutine internal_proc() ! Private by default\n      end subroutine\n\n     end module module_name\n```\n\n### **Characteristics**\n\n - **module_name** is a valid Fortran identifier for the module.\n - **private** statement sets default visibility to private for all entities.\n - **public** statement explicitly exports selected entities.\n - All module entities are private unless explicitly declared public.\n - Provides encapsulation by hiding implementation details.\n\n### **Description**\n\n **module_private** creates a module with private default visibility where\n all module entities (variables, types, procedures) are private unless\n explicitly exported via the `public` statement. This pattern follows the\n principle of information hiding and encapsulation, exposing only the\n intended public interface while keeping implementation details hidden\n from module users.\n\n### **Options**\n\n- **module_name**\n  : The identifier for the module. Must be a valid Fortran name starting\n  with a letter and containing only letters, digits, and underscores.\n\n- **public_entity**\n  : One or more entities to export from the module. Can be variables,\n  parameters, derived types, or procedure names. Multiple entities can\n  be listed comma-separated or in multiple public statements.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_module_private\n  use vector_math, only: vector_t, vector_add, vector_magnitude\n  implicit none\n\n  type(vector_t) :: v1, v2, v3\n\n  ! Initialize vectors using public constructor\n  v1 = vector_t(1.0, 2.0, 3.0)\n  v2 = vector_t(4.0, 5.0, 6.0)\n\n  ! Use public procedures\n  v3 = vector_add(v1, v2)\n  print '(A,3F8.3)', 'Sum vector: ', v3%x, v3%y, v3%z\n  print '(A,F8.3)', 'Magnitude:  ', vector_magnitude(v3)\n\nend program demo_module_private\n\nmodule vector_math\n  implicit none\n  private\n  public :: vector_t, vector_add, vector_magnitude\n\n  type :: vector_t\n    real :: x = 0.0\n    real :: y = 0.0\n    real :: z = 0.0\n  end type vector_t\n\n  ! Internal constant - not exported\n  real, parameter :: tolerance = 1.0e-10\n\ncontains\n\n  pure function vector_add(a, b) result(c)\n    type(vector_t), intent(in) :: a, b\n    type(vector_t) :: c\n    c%x = a%x + b%x\n    c%y = a%y + b%y\n    c%z = a%z + b%z\n  end function vector_add\n\n  pure function vector_magnitude(v) result(mag)\n    type(vector_t), intent(in) :: v\n    real :: mag\n    mag = sqrt(v%x**2 + v%y**2 + v%z**2)\n  end function vector_magnitude\n\n  ! Internal helper - not exported\n  pure function is_zero_vector(v) result(is_zero)\n    type(vector_t), intent(in) :: v\n    logical :: is_zero\n    is_zero = vector_magnitude(v) < tolerance\n  end function is_zero_vector\n\nend module vector_math\n```\nResults:\n```text\n    Sum vector:    5.000   7.000   9.000\n    Magnitude:    12.449\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**module**(3)](#module),\n[**use**(3)](#use),\n[**private**(3)](#private),\n[**public**(3)](#public),\n[**protected**(3)](#protected)"
  },
  "Module with Precision Parameter": {
    "prefix": [
      "moduledp",
      "MODULEDP",
      "modprecision",
      "MODPRECISION"
    ],
    "body": [
      "module ${1:module_name}",
      "  !! ${1:module_name} - Module with configurable floating-point precision",
      "  !!",
      "  !! NAME",
      "  !!   ${1:module_name} - [STRUCTURE:MODULE] Module defining precision parameter using selected_real_kind",
      "  !!",
      "  !! SYNOPSIS",
      "  !!   use ${1:module_name}, only: dp",
      "  !!   real(dp) :: x",
      "  !!",
      "  !! CHARACTERISTICS",
      "  !!   - dp is a kind parameter for double precision reals",
      "  !!   - Provides 15 significant decimal digits",
      "  !!   - Exponent range of at least 10^307",
      "  !!   - Portable across compilers",
      "  !!",
      "  !! DESCRIPTION",
      "  !!   This module provides a portable way to declare double-precision",
      "  !!   real variables using selected_real_kind. Using a named constant",
      "  !!   for precision ensures portability and makes it easy to change",
      "  !!   precision requirements across an entire codebase.",
      "  !!",
      "  !! OPTIONS",
      "  !!   - p=15 : Request at least 15 decimal digits of precision",
      "  !!   - r=307 : Request exponent range of at least 10^307",
      "  !!",
      "  !! EXAMPLES",
      "  !!   program demo_precision_module",
      "  !!   use ${1:module_name}, only: dp",
      "  !!   implicit none",
      "  !!     real(dp) :: x, y, z",
      "  !!     x = 1.0_dp",
      "  !!     y = 2.0_dp",
      "  !!     z = x + y",
      "  !!     print '(a,i0)', 'Kind parameter dp = ', dp",
      "  !!     print '(a,g0)', 'Result z = ', z",
      "  !!   end program demo_precision_module",
      "  !!",
      "  !!   Results:",
      "  !!     Kind parameter dp = 8",
      "  !!     Result z = 3.0000000000000000",
      "  !!",
      "  !! STANDARD",
      "  !!   Fortran 90 (selected_real_kind intrinsic)",
      "  !!",
      "  !! SEE ALSO",
      "  !!   selected_real_kind(3), selected_int_kind(3), kind(3),",
      "  !!   precision(3), range(3), iso_fortran_env module",
      "  !!",
      "  implicit none",
      "  private",
      "",
      "  !> Double precision kind parameter",
      "  !> p=15 digits of precision, r=307 exponent range",
      "  integer, parameter, public :: dp = selected_real_kind(p=${2:15}, r=${3:307})",
      "",
      "  $0",
      "",
      "end module ${1:module_name}"
    ],
    "description": "MODULE(MODULE_NAME,P,R) creates a module with precision parameter dp using selected_real_kind for portable floating-point precision."
  },
  "Move Alloc": {
    "prefix": [
      "move_alloc",
      "MOVE_ALLOC",
      "movealloc",
      "MOVEALLOC"
    ],
    "body": "call move_alloc(from=${1:source}, to=${2:dest})",
    "description": "MOVE_ALLOC(FROM,TO) moves an allocation from one allocatable object to another.\n\n## move_alloc\n\n### **Name**\n\n**move_alloc** - \\[MEMORY:ALLOCATION\\] Move an allocation from one allocatable object to another\n\n### **Synopsis**\n```fortran\n    call move_alloc(from, to)\n```\n```fortran\n     subroutine move_alloc(from, to)\n\n      type(TYPE(kind=**)), allocatable, intent(inout) :: from(..)\n      type(TYPE(kind=**)), allocatable, intent(out)   :: to(..)\n```\n\n### **Characteristics**\n\n - **from** is an allocatable object of any type, kind, and rank.\n - **to** is an allocatable object of the same type, kind, and rank as **from**.\n - After the call, **from** becomes deallocated and **to** obtains the allocation status, bounds, and value of **from**.\n - Both arguments must have the same declared type and rank.\n\n### **Description**\n\n **move_alloc** moves an allocation from the allocatable object **from** to the allocatable object **to**. This is an intrinsic subroutine that transfers the allocation status, array bounds, dynamic type, type parameters, and value from **from** to **to** without physically copying the data. After the call completes, **from** becomes deallocated while **to** receives the allocation that previously belonged to **from**. If **to** was already allocated before the call, it is first deallocated.\n\n### **Options**\n\n- **from**\n  : The source allocatable object. It must be allocatable and may be of any type (intrinsic or derived), kind, and rank. After the call, **from** becomes deallocated regardless of its initial allocation status.\n\n- **to**\n  : The target allocatable object. It must be allocatable with the same declared type, kind, and rank as **from**. If **to** is currently allocated, it is deallocated before the move occurs. After the call, **to** has the allocation status, bounds, and value that **from** had before the call.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_move_alloc\nimplicit none\n  integer, allocatable :: arr1(:), arr2(:)\n  integer, allocatable :: matrix1(:,:), matrix2(:,:)\n\n  ! Example 1: Move a 1D array allocation\n  allocate(arr1(5))\n  arr1 = [1, 2, 3, 4, 5]\n\n  print *, 'Before move_alloc:'\n  print *, '  arr1 allocated:', allocated(arr1)\n  print *, '  arr2 allocated:', allocated(arr2)\n  print *, '  arr1 =', arr1\n\n  ! Move allocation from arr1 to arr2\n  call move_alloc(from=arr1, to=arr2)\n\n  print *, 'After move_alloc:'\n  print *, '  arr1 allocated:', allocated(arr1)\n  print *, '  arr2 allocated:', allocated(arr2)\n  print *, '  arr2 =', arr2\n\n  ! Example 2: Dynamic array growth using move_alloc\n  allocate(matrix1(2,3))\n  matrix1 = reshape([1,2,3,4,5,6], [2,3])\n\n  print *, ''\n  print *, 'Matrix before expansion:'\n  print *, '  shape =', shape(matrix1)\n\n  ! Grow the array by moving to temporary and reallocating\n  call move_alloc(from=matrix1, to=matrix2)\n  allocate(matrix1(4,6))\n  matrix1 = 0\n  matrix1(1:2, 1:3) = matrix2\n\n  print *, 'Matrix after expansion:'\n  print *, '  shape =', shape(matrix1)\n  print *, '  matrix2 deallocated:', .not. allocated(matrix2)\n\nend program demo_move_alloc\n```\nResults:\n```text\n Before move_alloc:\n   arr1 allocated: T\n   arr2 allocated: F\n   arr1 =           1           2           3           4           5\n After move_alloc:\n   arr1 allocated: F\n   arr2 allocated: T\n   arr2 =           1           2           3           4           5\n\n Matrix before expansion:\n   shape =           2           3\n Matrix after expansion:\n   shape =           4           6\n   matrix2 deallocated: T\n```\n\n### **Standard**\n\nFortran 2003\n\n### **See Also**\n\n[**allocate**(3)](#allocate),\n[**deallocate**(3)](#deallocate),\n[**allocated**(3)](#allocated)"
  },
  "MPI Allreduce": {
    "prefix": [
      "mpiallreduce",
      "MPIALLREDUCE",
      "mpi_allreduce",
      "MPI_ALLREDUCE"
    ],
    "body": [
      "call MPI_Allreduce(${1:sendbuf}, ${2:recvbuf}, ${3:count}, ${4|MPI_DOUBLE_PRECISION,MPI_REAL,MPI_INTEGER,MPI_COMPLEX,MPI_LOGICAL,MPI_CHARACTER|}, ${5|MPI_SUM,MPI_MAX,MPI_MIN,MPI_PROD,MPI_LAND,MPI_LOR,MPI_LXOR,MPI_BAND,MPI_BOR,MPI_BXOR|}, ${6:MPI_COMM_WORLD}, ${0:ierr})"
    ],
    "description": "MPI_ALLREDUCE(SENDBUF,RECVBUF,COUNT,DATATYPE,OP,COMM,IERR) combines values from all processes and distributes the result back to all processes.\n\n## MPI_Allreduce\n\n### **Name**\n\n**MPI_Allreduce** - \\[PARALLEL:MPI\\] Combines values from all processes and distributes the result back to all processes\n\n### **Synopsis**\n\n```fortran\n    call MPI_Allreduce(sendbuf, recvbuf, count, datatype, op, comm, ierr)\n```\n\n```fortran\n    USE mpi_f08\n    MPI_Allreduce(sendbuf, recvbuf, count, datatype, op, comm, ierror)\n\n        TYPE(*), DIMENSION(..), INTENT(IN)  :: sendbuf\n        TYPE(*), DIMENSION(..)              :: recvbuf\n        INTEGER, INTENT(IN)                 :: count\n        TYPE(MPI_Datatype), INTENT(IN)      :: datatype\n        TYPE(MPI_Op), INTENT(IN)            :: op\n        TYPE(MPI_Comm), INTENT(IN)          :: comm\n        INTEGER, OPTIONAL, INTENT(OUT)      :: ierror\n```\n\n### **Characteristics**\n\n- **sendbuf** is a buffer of any type with `count` elements to be reduced\n- **recvbuf** is a buffer of the same type as `sendbuf` to receive the result\n- **count** is a non-negative integer specifying the number of elements\n- **datatype** must match the type of data in `sendbuf` and `recvbuf`\n- **op** must be a valid reduction operation compatible with `datatype`\n- **comm** is a valid MPI communicator (intracommunicator or intercommunicator)\n- **ierr** returns the error status (0 for success)\n- All processes in the communicator must call this routine\n- The result is distributed to all processes (unlike MPI_Reduce)\n\n### **Description**\n\n**MPI_Allreduce** performs a global reduction operation (sum, max, min, etc.) on data from all processes in a communicator and distributes the result to all processes. This is equivalent to an MPI_Reduce followed by an MPI_Bcast, but is typically more efficient. All processes contribute data and all processes receive the final result.\n\n### **Options**\n\n- **sendbuf**\n  : Starting address of the send buffer containing `count` elements of type `datatype`. Use MPI_IN_PLACE for in-place operations on intracommunicators.\n\n- **recvbuf**\n  : Starting address of the receive buffer where the reduction result will be stored. Must be distinct from `sendbuf` unless using MPI_IN_PLACE.\n\n- **count**\n  : Number of elements in `sendbuf` and `recvbuf`. Must be non-negative and identical on all processes.\n\n- **datatype**\n  : MPI datatype of elements. Common Fortran types:\n  - MPI_INTEGER, MPI_REAL, MPI_DOUBLE_PRECISION\n  - MPI_COMPLEX, MPI_DOUBLE_COMPLEX\n  - MPI_LOGICAL, MPI_CHARACTER\n\n- **op**\n  : Reduction operation to perform. Predefined operations:\n  - Arithmetic: MPI_SUM, MPI_PROD\n  - Comparison: MPI_MAX, MPI_MIN\n  - Logical: MPI_LAND, MPI_LOR, MPI_LXOR\n  - Bitwise: MPI_BAND, MPI_BOR, MPI_BXOR\n  - Location: MPI_MAXLOC, MPI_MINLOC\n\n- **comm**\n  : MPI communicator defining the group of processes participating. Typically MPI_COMM_WORLD for all processes.\n\n- **ierr**\n  : Integer error code. Returns MPI_SUCCESS (0) on successful completion.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_mpi_allreduce\n  use mpi\n  implicit none\n  integer :: ierr, rank, nprocs\n  real(8) :: local_sum, global_sum\n  real(8) :: local_max, global_max\n  real(8) :: local_array(3), global_array(3)\n\n  ! Initialize MPI\n  call MPI_Init(ierr)\n  call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierr)\n  call MPI_Comm_size(MPI_COMM_WORLD, nprocs, ierr)\n\n  ! Example 1: Sum of scalar values across all processes\n  local_sum = real(rank + 1, 8)  ! Each process has value rank+1\n  call MPI_Allreduce(local_sum, global_sum, 1, MPI_DOUBLE_PRECISION, &\n                     MPI_SUM, MPI_COMM_WORLD, ierr)\n  if (rank == 0) then\n    print '(A,F8.2)', 'Global sum: ', global_sum\n  end if\n\n  ! Example 2: Maximum value across all processes\n  local_max = real(rank * 10, 8)\n  call MPI_Allreduce(local_max, global_max, 1, MPI_DOUBLE_PRECISION, &\n                     MPI_MAX, MPI_COMM_WORLD, ierr)\n  if (rank == 0) then\n    print '(A,F8.2)', 'Global max: ', global_max\n  end if\n\n  ! Example 3: Element-wise reduction of arrays\n  local_array = [real(rank, 8), real(rank*2, 8), real(rank*3, 8)]\n  call MPI_Allreduce(local_array, global_array, 3, MPI_DOUBLE_PRECISION, &\n                     MPI_SUM, MPI_COMM_WORLD, ierr)\n  if (rank == 0) then\n    print '(A,3F8.2)', 'Global array sum: ', global_array\n  end if\n\n  ! Example 4: In-place reduction (result overwrites sendbuf)\n  local_sum = real(rank + 1, 8)\n  call MPI_Allreduce(MPI_IN_PLACE, local_sum, 1, MPI_DOUBLE_PRECISION, &\n                     MPI_SUM, MPI_COMM_WORLD, ierr)\n  if (rank == 0) then\n    print '(A,F8.2)', 'In-place sum: ', local_sum\n  end if\n\n  call MPI_Finalize(ierr)\nend program demo_mpi_allreduce\n```\n\nResults (with 4 processes):\n\n```text\n    Global sum:    10.00\n    Global max:    30.00\n    Global array sum:     6.00   12.00   18.00\n    In-place sum:    10.00\n```\n\n### **Standard**\n\nMPI-1.0 (introduced in the original MPI standard, 1994)\n\n### **See Also**\n\n[**MPI_Reduce**(3)](#mpi_reduce),\n[**MPI_Bcast**(3)](#mpi_bcast),\n[**MPI_Scatter**(3)](#mpi_scatter),\n[**MPI_Gather**(3)](#mpi_gather),\n[**MPI_Allgather**(3)](#mpi_allgather),\n[**MPI_Reduce_scatter**(3)](#mpi_reduce_scatter),\n[**MPI_Iallreduce**(3)](#mpi_iallreduce)\n\n### **Resources**\n\n- [Open MPI 5.0.x MPI_Allreduce Documentation](https://docs.open-mpi.org/en/v5.0.x/man-openmpi/man3/MPI_Allreduce.3.html)\n- [MPI Tutorial: MPI Reduce and Allreduce](https://mpitutorial.com/tutorials/mpi-reduce-and-allreduce/)\n- [MPI Forum Predefined Reduce Operations](https://www.mpi-forum.org/docs/mpi-1.1/mpi-11-html/node78.html)"
  },
  "MPI Broadcast": {
    "prefix": [
      "mpibcast",
      "MPIBCAST",
      "mpi_bcast",
      "MPI_BCAST"
    ],
    "body": [
      "call MPI_Bcast(${1:buffer}, ${2:count}, ${3:MPI_DOUBLE_PRECISION}, ${4:root}, ${5:MPI_COMM_WORLD}, ${0:ierr})"
    ],
    "description": "## MPI_Bcast\n\n### **Name**\n\n**MPI_Bcast** - \\[PARALLEL:MPI\\] Broadcast a message from root to all processes in a communicator\n\n### **Synopsis**\n\n```fortran\n    call MPI_Bcast(buffer, count, datatype, root, comm, ierror)\n```\n\n```fortran\n     subroutine MPI_Bcast(buffer, count, datatype, root, comm, ierror)\n\n      type(*), dimension(..)    :: buffer\n      integer, intent(in)       :: count\n      type(MPI_Datatype), intent(in) :: datatype\n      integer, intent(in)       :: root\n      type(MPI_Comm), intent(in)     :: comm\n      integer, intent(out)      :: ierror\n```\n\n### **Characteristics**\n\n - **buffer** is a data buffer of any type and rank\n - **count** is an integer specifying the number of elements\n - **datatype** is an MPI datatype handle (e.g., MPI_DOUBLE_PRECISION, MPI_INTEGER)\n - **root** is an integer rank of the broadcasting process\n - **comm** is an MPI communicator handle\n - **ierror** returns the error status (0 for success)\n - All processes in the communicator must call this routine with identical arguments\n\n### **Description**\n\n **MPI_Bcast** broadcasts a message from the process with rank **root** to all\n other processes in the group, including itself. After the call, all processes\n in the communicator have identical copies of the buffer data. This is a\n collective operation that must be called by all processes in the communicator.\n\n### **Options**\n\n- **buffer**\n  : Starting address of the data buffer. On the root process, this contains\n  the data to be broadcast. On all other processes, this is where the\n  received data will be stored.\n\n- **count**\n  : Number of elements in the buffer. Must be non-negative and identical\n  on all processes.\n\n- **datatype**\n  : MPI datatype of each buffer element. Common values include:\n  MPI_INTEGER, MPI_REAL, MPI_DOUBLE_PRECISION, MPI_COMPLEX,\n  MPI_LOGICAL, MPI_CHARACTER. Must match on all processes.\n\n- **root**\n  : Rank of the process sending the broadcast (0 to comm_size-1).\n  Must be identical on all processes in the communicator.\n\n- **comm**\n  : MPI communicator defining the process group. Typically MPI_COMM_WORLD\n  for all processes, or a custom communicator for subgroups.\n\n- **ierror**\n  : Error status. Returns MPI_SUCCESS (0) on successful completion,\n  or an MPI error code on failure.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_mpi_bcast\n  use mpi\n  implicit none\n\n  integer :: ierr, rank, nprocs\n  integer :: root\n  real(8) :: value\n  real(8), dimension(4) :: array\n\n  ! Initialize MPI\n  call MPI_Init(ierr)\n  call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierr)\n  call MPI_Comm_size(MPI_COMM_WORLD, nprocs, ierr)\n\n  root = 0\n\n  ! Example 1: Broadcast a scalar\n  if (rank == root) then\n    value = 3.14159265358979d0\n    print '(A,I2,A,F12.8)', 'Process ', rank, ' (root) sending value: ', value\n  else\n    value = 0.0d0\n  end if\n\n  call MPI_Bcast(value, 1, MPI_DOUBLE_PRECISION, root, MPI_COMM_WORLD, ierr)\n\n  print '(A,I2,A,F12.8)', 'Process ', rank, ' received value: ', value\n\n  ! Example 2: Broadcast an array\n  if (rank == root) then\n    array = [1.0d0, 2.0d0, 3.0d0, 4.0d0]\n    print '(A,I2,A)', 'Process ', rank, ' (root) broadcasting array'\n  else\n    array = 0.0d0\n  end if\n\n  call MPI_Bcast(array, 4, MPI_DOUBLE_PRECISION, root, MPI_COMM_WORLD, ierr)\n\n  print '(A,I2,A,4F8.2)', 'Process ', rank, ' array: ', array\n\n  call MPI_Finalize(ierr)\nend program demo_mpi_bcast\n```\n\nResults (with 4 processes):\n\n```text\nProcess  0 (root) sending value:   3.14159265\nProcess  0 received value:   3.14159265\nProcess  1 received value:   3.14159265\nProcess  2 received value:   3.14159265\nProcess  3 received value:   3.14159265\nProcess  0 (root) broadcasting array\nProcess  0 array:     1.00    2.00    3.00    4.00\nProcess  1 array:     1.00    2.00    3.00    4.00\nProcess  2 array:     1.00    2.00    3.00    4.00\nProcess  3 array:     1.00    2.00    3.00    4.00\n```\n\nCompile with: `mpif90 demo_mpi_bcast.f90 -o demo_mpi_bcast`\n\nRun with: `mpirun -np 4 ./demo_mpi_bcast`\n\n### **Standard**\n\nMPI-1.0\n\n### **See Also**\n\n[**MPI_Ibcast**(3)](#mpi_ibcast),\n[**MPI_Scatter**(3)](#mpi_scatter),\n[**MPI_Gather**(3)](#mpi_gather),\n[**MPI_Allgather**(3)](#mpi_allgather),\n[**MPI_Reduce**(3)](#mpi_reduce),\n[**MPI_Allreduce**(3)](#mpi_allreduce),\n[**MPI_Comm_rank**(3)](#mpi_comm_rank),\n[**MPI_Comm_size**(3)](#mpi_comm_size)"
  },
  "MPI_INIT": {
    "args": "IERROR=ierror",
    "doc": "MPI_INIT(IERROR) initializes the MPI execution environment for the world model.",
    "type": 2
  },
  "MPI_FINALIZE": {
    "args": "IERROR=ierror",
    "doc": "MPI_FINALIZE(IERROR) terminates the MPI execution environment.",
    "type": 2
  },
  "MPI Init Finalize": {
    "prefix": [
      "mpiinit",
      "MPIINIT",
      "mpi_init"
    ],
    "body": [
      "use mpi_f08",
      "implicit none",
      "",
      "integer :: ${1:rank}, ${2:nprocs}",
      "",
      "call MPI_Init()",
      "call MPI_Comm_rank(MPI_COMM_WORLD, ${1:rank})",
      "call MPI_Comm_size(MPI_COMM_WORLD, ${2:nprocs})",
      "",
      "$0",
      "",
      "call MPI_Finalize()"
    ],
    "description": "MPI_INIT/MPI_FINALIZE initializes and terminates the MPI world model execution environment."
  },
  "MPI Module Import": {
    "prefix": [
      "usempi",
      "USEMPI",
      "mpi_f08",
      "MPI_F08",
      "usempif08"
    ],
    "body": "use mpi_f08",
    "description": "USE MPI_F08 imports the modern MPI Fortran bindings module with type-safe derived type handles."
  },
  "MPI Recv": {
    "prefix": [
      "mpirecv",
      "MPIRECV",
      "mpi_recv",
      "MPI_RECV"
    ],
    "body": "call MPI_Recv(${1:buf}, ${2:count}, ${3:MPI_DOUBLE_PRECISION}, ${4:source}, ${5:tag}, ${6:MPI_COMM_WORLD}, ${7:status}, ${8:ierr})",
    "description": "MPI_RECV(BUF,COUNT,DATATYPE,SOURCE,TAG,COMM,STATUS,IERROR) performs a standard-mode blocking receive operation.",
    "documentation": {
      "name": "**MPI_Recv** - \\[PARALLEL:MPI\\] Blocking receive for a message",
      "synopsis": {
        "usage": "call MPI_Recv(buf, count, datatype, source, tag, comm, status, ierror)",
        "interface_legacy": [
          "subroutine MPI_Recv(buf, count, datatype, source, tag, comm, status, ierror)",
          "",
          "  <type>    :: buf(*)",
          "  integer, intent(in)  :: count",
          "  integer, intent(in)  :: datatype",
          "  integer, intent(in)  :: source",
          "  integer, intent(in)  :: tag",
          "  integer, intent(in)  :: comm",
          "  integer, intent(out) :: status(MPI_STATUS_SIZE)",
          "  integer, intent(out) :: ierror"
        ],
        "interface_f08": [
          "subroutine MPI_Recv(buf, count, datatype, source, tag, comm, status, ierror)",
          "",
          "  type(*), dimension(..)          :: buf",
          "  integer, intent(in)             :: count",
          "  type(MPI_Datatype), intent(in)  :: datatype",
          "  integer, intent(in)             :: source",
          "  integer, intent(in)             :: tag",
          "  type(MPI_Comm), intent(in)      :: comm",
          "  type(MPI_Status), intent(out)   :: status",
          "  integer, optional, intent(out)  :: ierror"
        ]
      },
      "characteristics": [
        "**buf** is the receive buffer where incoming data will be stored; can be any Fortran data type.",
        "**count** is a non-negative integer specifying the maximum number of elements to receive.",
        "**datatype** must be a valid MPI datatype handle (e.g., MPI_INTEGER, MPI_REAL, MPI_DOUBLE_PRECISION).",
        "**source** is an integer rank of the sending process, or MPI_ANY_SOURCE to accept from any sender.",
        "**tag** is a non-negative integer message tag, or MPI_ANY_TAG to accept any tag.",
        "**comm** is a valid MPI communicator handle.",
        "**status** returns message metadata; use MPI_STATUS_IGNORE if not needed.",
        "This is a blocking operation that returns only after the message has been received into the buffer."
      ],
      "description": "**MPI_Recv** performs a standard-mode blocking receive operation. It blocks until the receive buffer contains the newly received message from the specified source. The actual length of the received message can be determined using MPI_Get_count on the returned status. The received message length must be less than or equal to the buffer length specified by count; otherwise, an MPI_ERR_TRUNCATE error occurs.",
      "options": {
        "buf": "Initial address of the receive buffer (output). This is where the incoming message data will be stored. The buffer must be large enough to hold count elements of the specified datatype.",
        "count": "Maximum number of elements to receive (integer, input). Must be non-negative. The actual number of elements received may be less; use MPI_Get_count to determine the exact count.",
        "datatype": "MPI datatype handle specifying the type of each buffer element (input). Common values: MPI_INTEGER, MPI_REAL, MPI_DOUBLE_PRECISION, MPI_COMPLEX, MPI_LOGICAL, MPI_CHARACTER.",
        "source": "Rank of the source process within the communicator (integer, input). Use MPI_ANY_SOURCE as a wildcard to receive from any sending process.",
        "tag": "Message tag for matching (integer, input). Must be non-negative (0 to MPI_TAG_UB). Use MPI_ANY_TAG as a wildcard to match any tag value.",
        "comm": "MPI communicator handle (input). Specifies the communication context. Common value: MPI_COMM_WORLD for global communicator.",
        "status": "Status object containing information about the received message (output). Declared as integer status(MPI_STATUS_SIZE) in legacy Fortran or type(MPI_Status) with mpi_f08 module. Contains source rank (status(MPI_SOURCE)), tag (status(MPI_TAG)), and error code (status(MPI_ERROR)). Use MPI_STATUS_IGNORE if status information is not needed.",
        "ierror": "Error code (integer, output). Returns MPI_SUCCESS on successful completion. Optional in mpi_f08 interface."
      },
      "errors": {
        "MPI_SUCCESS": "No error; routine completed successfully.",
        "MPI_ERR_COMM": "Invalid communicator.",
        "MPI_ERR_TYPE": "Invalid datatype argument or uncommitted MPI_Datatype.",
        "MPI_ERR_COUNT": "Invalid count argument (negative value).",
        "MPI_ERR_TAG": "Invalid tag; must be non-negative or MPI_ANY_TAG.",
        "MPI_ERR_RANK": "Invalid source rank; must be 0 to communicator_size-1 or MPI_ANY_SOURCE.",
        "MPI_ERR_TRUNCATE": "Message was truncated because it exceeded the receive buffer size."
      },
      "examples": {
        "program": [
          "program demo_mpi_recv",
          "  ! Demonstrates blocking point-to-point communication with MPI_Send/MPI_Recv",
          "  use mpi_f08",
          "  implicit none",
          "",
          "  integer :: rank, num_procs, ierr",
          "  integer, parameter :: MSG_TAG = 100",
          "  real(8) :: send_data(10), recv_data(10)",
          "  type(MPI_Status) :: status",
          "  integer :: recv_count, i",
          "",
          "  ! Initialize MPI",
          "  call MPI_Init(ierr)",
          "  call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierr)",
          "  call MPI_Comm_size(MPI_COMM_WORLD, num_procs, ierr)",
          "",
          "  if (num_procs < 2) then",
          "    print *, 'Error: This program requires at least 2 processes'",
          "    call MPI_Abort(MPI_COMM_WORLD, 1, ierr)",
          "  end if",
          "",
          "  if (rank == 0) then",
          "    ! Process 0: Initialize and send data",
          "    do i = 1, 10",
          "      send_data(i) = real(i, 8) * 1.5d0",
          "    end do",
          "    print '(A)', 'Process 0: Sending data to process 1'",
          "    call MPI_Send(send_data, 10, MPI_DOUBLE_PRECISION, 1, MSG_TAG, &",
          "                  MPI_COMM_WORLD, ierr)",
          "",
          "  else if (rank == 1) then",
          "    ! Process 1: Receive data from process 0",
          "    print '(A)', 'Process 1: Waiting to receive data from process 0'",
          "    call MPI_Recv(recv_data, 10, MPI_DOUBLE_PRECISION, 0, MSG_TAG, &",
          "                  MPI_COMM_WORLD, status, ierr)",
          "",
          "    ! Query status for actual count received",
          "    call MPI_Get_count(status, MPI_DOUBLE_PRECISION, recv_count, ierr)",
          "",
          "    print '(A,I0)', 'Process 1: Received ', recv_count, ' elements'",
          "    print '(A,I0)', 'Process 1: Source rank = ', status%MPI_SOURCE",
          "    print '(A,I0)', 'Process 1: Message tag = ', status%MPI_TAG",
          "    print '(A,10F6.1)', 'Process 1: Data = ', recv_data",
          "  end if",
          "",
          "  call MPI_Finalize(ierr)",
          "",
          "end program demo_mpi_recv"
        ],
        "compile": "mpif90 -o demo_mpi_recv demo_mpi_recv.f90",
        "run": "mpirun -np 2 ./demo_mpi_recv",
        "output": [
          "Process 0: Sending data to process 1",
          "Process 1: Waiting to receive data from process 0",
          "Process 1: Received 10 elements",
          "Process 1: Source rank = 0",
          "Process 1: Message tag = 100",
          "Process 1: Data =    1.5   3.0   4.5   6.0   7.5   9.0  10.5  12.0  13.5  15.0"
        ]
      },
      "example_with_wildcards": {
        "description": "Using MPI_ANY_SOURCE and MPI_ANY_TAG wildcards",
        "program": [
          "program demo_mpi_recv_wildcards",
          "  ! Demonstrates receiving from any source with any tag",
          "  use mpi_f08",
          "  implicit none",
          "",
          "  integer :: rank, num_procs, ierr, i",
          "  integer :: message",
          "  type(MPI_Status) :: status",
          "",
          "  call MPI_Init(ierr)",
          "  call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierr)",
          "  call MPI_Comm_size(MPI_COMM_WORLD, num_procs, ierr)",
          "",
          "  if (rank == 0) then",
          "    ! Rank 0 receives from any source with any tag",
          "    do i = 1, num_procs - 1",
          "      call MPI_Recv(message, 1, MPI_INTEGER, MPI_ANY_SOURCE, MPI_ANY_TAG, &",
          "                    MPI_COMM_WORLD, status, ierr)",
          "      print '(A,I0,A,I0,A,I0)', 'Received value ', message, &",
          "            ' from rank ', status%MPI_SOURCE, ' with tag ', status%MPI_TAG",
          "    end do",
          "  else",
          "    ! Other ranks send their rank as data and tag",
          "    message = rank * 100",
          "    call MPI_Send(message, 1, MPI_INTEGER, 0, rank, MPI_COMM_WORLD, ierr)",
          "  end if",
          "",
          "  call MPI_Finalize(ierr)",
          "",
          "end program demo_mpi_recv_wildcards"
        ]
      },
      "example_status_ignore": {
        "description": "Using MPI_STATUS_IGNORE when status information is not needed",
        "snippet": [
          "! When you don't need status information, use MPI_STATUS_IGNORE",
          "call MPI_Recv(data, count, MPI_DOUBLE_PRECISION, source, tag, &",
          "              MPI_COMM_WORLD, MPI_STATUS_IGNORE, ierr)"
        ]
      },
      "standard": "MPI-1.0 (1994), with mpi_f08 module interface added in MPI-3.0 (2012)",
      "see_also": [
        "**MPI_Send**(3) - Standard-mode blocking send",
        "**MPI_Irecv**(3) - Non-blocking receive",
        "**MPI_Sendrecv**(3) - Combined send and receive",
        "**MPI_Probe**(3) - Blocking test for a message without receiving",
        "**MPI_Get_count**(3) - Get the number of elements in a message",
        "**MPI_Wait**(3) - Wait for non-blocking operation to complete"
      ],
      "resources": [
        "Open MPI Documentation: https://docs.open-mpi.org/en/v5.0.x/man-openmpi/man3/MPI_Recv.3.html",
        "MPI Forum Standard: https://www.mpi-forum.org/docs/",
        "MPICH Documentation: https://www.mpich.org/static/docs/latest/www3/MPI_Recv.html"
      ]
    }
  },
  "MPI Reduce": {
    "prefix": [
      "mpireduce",
      "MPIREDUCE",
      "mpi_reduce",
      "MPI_REDUCE"
    ],
    "body": [
      "call MPI_Reduce(${1:sendbuf}, ${2:recvbuf}, ${3:count}, ${4:datatype}, ${5:op}, ${6:root}, ${7:comm}, ${0:ierr})"
    ],
    "description": "MPI_REDUCE(SENDBUF,RECVBUF,COUNT,DATATYPE,OP,ROOT,COMM,IERR) performs a global reduction operation across all processes in a communicator.\n\n## MPI_Reduce\n\n### **Name**\n\n**MPI_Reduce** - \\[PARALLEL:MPI\\] Perform a global reduction operation across all processes in a communicator\n\n### **Synopsis**\n\n```fortran\n    call MPI_Reduce(sendbuf, recvbuf, count, datatype, op, root, comm, ierr)\n```\n\n```fortran\n     subroutine MPI_Reduce(sendbuf, recvbuf, count, datatype, op, root, comm, ierr)\n\n      <type>            :: sendbuf(*)\n      <type>            :: recvbuf(*)\n      integer           :: count\n      integer           :: datatype\n      integer           :: op\n      integer           :: root\n      integer           :: comm\n      integer           :: ierr\n```\n\n### **Characteristics**\n\n - **sendbuf** is an array of any numeric or logical type containing the local contribution to the reduction.\n - **recvbuf** is an array of the same type as sendbuf; only significant at the root process.\n - **count** is an integer specifying the number of elements in the send buffer.\n - **datatype** is an integer MPI datatype handle (e.g., MPI_DOUBLE_PRECISION, MPI_INTEGER).\n - **op** is an integer MPI operation handle specifying the reduction operation.\n - **root** is an integer specifying the rank of the process that receives the result.\n - **comm** is an integer MPI communicator handle.\n - **ierr** is an integer error code (0 indicates success).\n - All processes in the communicator must call with identical count, datatype, op, root, and comm.\n\n### **Description**\n\n **MPI_Reduce** combines the elements provided in the input buffer of each\n process in the group, using the specified reduction operation **op**, and\n returns the combined value in the output buffer of the process with rank\n **root**. The operation is performed element-wise when count > 1.\n\n### **Options**\n\n- **sendbuf**\n  : Address of the send buffer containing count elements of the specified\n  datatype. Each process contributes its local data to the reduction.\n  The root process may use MPI_IN_PLACE to use recvbuf as both input and output.\n\n- **recvbuf**\n  : Address of the receive buffer where the reduction result is stored.\n  Only significant at the root process; ignored on other processes.\n\n- **count**\n  : Number of elements in the send buffer. Must be non-negative and identical\n  across all processes in the communicator.\n\n- **datatype**\n  : MPI datatype handle describing each element. Common values:\n  MPI_INTEGER, MPI_REAL, MPI_DOUBLE_PRECISION, MPI_COMPLEX, MPI_LOGICAL.\n\n- **op**\n  : MPI reduction operation handle. Predefined operations:\n  - MPI_MAX     - Maximum value\n  - MPI_MIN     - Minimum value\n  - MPI_SUM     - Sum\n  - MPI_PROD    - Product\n  - MPI_LAND    - Logical AND\n  - MPI_BAND    - Bitwise AND\n  - MPI_LOR     - Logical OR\n  - MPI_BOR     - Bitwise OR\n  - MPI_LXOR    - Logical XOR\n  - MPI_BXOR    - Bitwise XOR\n  - MPI_MAXLOC  - Maximum value and location\n  - MPI_MINLOC  - Minimum value and location\n\n- **root**\n  : Rank of the root process (0 to size-1) within the communicator.\n  Only this process receives the reduction result in recvbuf.\n\n- **comm**\n  : MPI communicator handle defining the process group. Typically\n  MPI_COMM_WORLD for all processes or a user-defined communicator.\n\n- **ierr**\n  : Integer error code. Returns MPI_SUCCESS (0) on success, or an\n  MPI error code on failure.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_mpi_reduce\n  use mpi\n  implicit none\n\n  integer :: ierr, rank, nprocs\n  real(8) :: local_value, global_sum, global_max, global_min\n  real(8), dimension(3) :: local_array, sum_array\n  integer :: i\n\n  ! Initialize MPI\n  call MPI_Init(ierr)\n  call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierr)\n  call MPI_Comm_size(MPI_COMM_WORLD, nprocs, ierr)\n\n  ! Each process has a different value based on its rank\n  local_value = real(rank + 1, 8) * 10.0d0\n\n  ! Reduce with SUM operation - result goes to root (rank 0)\n  call MPI_Reduce(local_value, global_sum, 1, MPI_DOUBLE_PRECISION, &\n                  MPI_SUM, 0, MPI_COMM_WORLD, ierr)\n\n  ! Reduce with MAX operation\n  call MPI_Reduce(local_value, global_max, 1, MPI_DOUBLE_PRECISION, &\n                  MPI_MAX, 0, MPI_COMM_WORLD, ierr)\n\n  ! Reduce with MIN operation\n  call MPI_Reduce(local_value, global_min, 1, MPI_DOUBLE_PRECISION, &\n                  MPI_MIN, 0, MPI_COMM_WORLD, ierr)\n\n  ! Only root process has valid results\n  if (rank == 0) then\n    print '(A,I0,A)', 'Running with ', nprocs, ' processes'\n    print '(A,F10.2)', 'Global sum: ', global_sum\n    print '(A,F10.2)', 'Global max: ', global_max\n    print '(A,F10.2)', 'Global min: ', global_min\n  end if\n\n  ! Example with arrays: reduce multiple elements at once\n  do i = 1, 3\n    local_array(i) = real(rank * 3 + i, 8)\n  end do\n\n  call MPI_Reduce(local_array, sum_array, 3, MPI_DOUBLE_PRECISION, &\n                  MPI_SUM, 0, MPI_COMM_WORLD, ierr)\n\n  if (rank == 0) then\n    print '(A)', 'Array reduction (SUM):'\n    print '(A,3F8.2)', '  Result: ', sum_array\n  end if\n\n  call MPI_Finalize(ierr)\n\nend program demo_mpi_reduce\n```\n\nResults (with 4 processes):\n\n```text\nRunning with 4 processes\nGlobal sum:     100.00\nGlobal max:      40.00\nGlobal min:      10.00\nArray reduction (SUM):\n  Result:    22.00   26.00   30.00\n```\n\n### **Standard**\n\nMPI-1.0\n\n### **See Also**\n\n[**MPI_Allreduce**(3)](#mpi_allreduce),\n[**MPI_Reduce_scatter**(3)](#mpi_reduce_scatter),\n[**MPI_Op_create**(3)](#mpi_op_create),\n[**MPI_Comm_rank**(3)](#mpi_comm_rank),\n[**MPI_Comm_size**(3)](#mpi_comm_size),\n[**MPI_Init**(3)](#mpi_init),\n[**MPI_Finalize**(3)](#mpi_finalize)\n\n### **Resources**\n\n- [Open MPI Documentation](https://docs.open-mpi.org/en/v5.0.x/man-openmpi/man3/MPI_Reduce.3.html)\n- [MPI Forum Standards](https://www.mpi-forum.org/docs/)\n- [MPI Tutorial - Reduce and Allreduce](https://mpitutorial.com/tutorials/mpi-reduce-and-allreduce/)"
  },
  "MPI Send": {
    "prefix": [
      "mpisend",
      "MPISEND",
      "mpi_send",
      "MPI_Send"
    ],
    "body": "call MPI_Send(${1:buf}, ${2:count}, ${3:MPI_DOUBLE_PRECISION}, ${4:dest}, ${5:tag}, ${6:MPI_COMM_WORLD}, ${0:ierr})",
    "description": "MPI_SEND(BUF,COUNT,DATATYPE,DEST,TAG,COMM,IERROR) performs a standard-mode blocking send to a destination process.",
    "documentation": {
      "name": "**MPI_Send** - \\[PARALLEL:MPI\\] Standard-mode blocking send",
      "synopsis": [
        "```fortran",
        "    call MPI_Send(buf, count, datatype, dest, tag, comm, ierror)",
        "```",
        "",
        "```fortran",
        "! Traditional Fortran interface",
        "USE MPI",
        "MPI_SEND(BUF, COUNT, DATATYPE, DEST, TAG, COMM, IERROR)",
        "     <type>  BUF(*)",
        "     INTEGER COUNT, DATATYPE, DEST, TAG, COMM, IERROR",
        "",
        "! Fortran 2008 interface (mpi_f08 module)",
        "USE mpi_f08",
        "MPI_Send(buf, count, datatype, dest, tag, comm, ierror)",
        "     TYPE(*), DIMENSION(..), INTENT(IN) :: buf",
        "     INTEGER, INTENT(IN) :: count, dest, tag",
        "     TYPE(MPI_Datatype), INTENT(IN) :: datatype",
        "     TYPE(MPI_Comm), INTENT(IN) :: comm",
        "     INTEGER, OPTIONAL, INTENT(OUT) :: ierror",
        "```"
      ],
      "characteristics": [
        " - **buf** is the starting address of the send buffer; can be any data type.",
        " - **count** is a non-negative integer specifying the number of elements to send.",
        " - **datatype** is an MPI datatype handle (e.g., MPI_INTEGER, MPI_DOUBLE_PRECISION, MPI_REAL).",
        " - **dest** is an integer rank of the destination process within the communicator.",
        " - **tag** is a non-negative integer message tag for matching send/receive pairs.",
        " - **comm** is an MPI communicator handle (e.g., MPI_COMM_WORLD).",
        " - **ierror** is the output error status (Fortran only); returns MPI_SUCCESS on success.",
        " - This is a **blocking** operation: the call does not return until the send buffer can be safely reused."
      ],
      "description": [
        " **MPI_Send** performs a standard-mode blocking send operation. The routine",
        " blocks until the message data has been safely copied out of the send buffer,",
        " either to a system buffer or directly to the matching receive buffer. After",
        " MPI_Send returns, the application may freely modify the send buffer without",
        " affecting the transmitted message. The blocking behavior ensures data integrity",
        " but may introduce synchronization delays if the receiver is not ready."
      ],
      "options": [
        "- **buf**",
        "  : Initial address of the send buffer. This is the location in memory where",
        "  the data to be sent begins. The buffer must contain at least `count` elements",
        "  of the specified `datatype`.",
        "",
        "- **count**",
        "  : Number of elements to send. Must be a non-negative integer. If count is zero,",
        "  an empty message is sent (useful for synchronization). The actual byte size is",
        "  `count * sizeof(datatype)`.",
        "",
        "- **datatype**",
        "  : MPI datatype handle describing each element in the buffer. Common Fortran",
        "  datatypes include:",
        "    - MPI_INTEGER, MPI_INTEGER1, MPI_INTEGER2, MPI_INTEGER4, MPI_INTEGER8",
        "    - MPI_REAL, MPI_REAL4, MPI_REAL8, MPI_DOUBLE_PRECISION",
        "    - MPI_COMPLEX, MPI_DOUBLE_COMPLEX",
        "    - MPI_LOGICAL",
        "    - MPI_CHARACTER",
        "    - MPI_BYTE (for raw binary data)",
        "",
        "- **dest**",
        "  : Rank of the destination process within the communicator. Must be a valid",
        "  rank in the range [0, size-1] where size is the number of processes in comm.",
        "  Cannot be MPI_PROC_NULL for MPI_Send (use MPI_Ssend or check rank first).",
        "",
        "- **tag**",
        "  : Message tag for identification. Must be a non-negative integer in the range",
        "  [0, MPI_TAG_UB]. Tags allow the receiver to select specific messages using",
        "  MPI_Recv with a matching tag or MPI_ANY_TAG.",
        "",
        "- **comm**",
        "  : MPI communicator handle defining the process group. Common communicators:",
        "    - MPI_COMM_WORLD: All processes in the MPI job",
        "    - User-defined communicators from MPI_Comm_split, MPI_Comm_create, etc.",
        "",
        "- **ierror**",
        "  : (Fortran only) Output parameter for error status. Returns MPI_SUCCESS (0)",
        "  on successful completion. Error codes include MPI_ERR_COMM, MPI_ERR_COUNT,",
        "  MPI_ERR_TYPE, MPI_ERR_TAG, MPI_ERR_RANK."
      ],
      "examples": [
        "Sample program:",
        "",
        "```fortran",
        "program demo_mpi_send",
        "  use mpi",
        "  implicit none",
        "",
        "  integer :: ierr, rank, size",
        "  integer :: send_buf(10), recv_buf(10)",
        "  integer :: dest, source, tag",
        "  integer :: status(MPI_STATUS_SIZE)",
        "  integer :: i",
        "",
        "  ! Initialize MPI",
        "  call MPI_Init(ierr)",
        "  call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierr)",
        "  call MPI_Comm_size(MPI_COMM_WORLD, size, ierr)",
        "",
        "  if (size < 2) then",
        "    print *, 'This example requires at least 2 processes'",
        "    call MPI_Abort(MPI_COMM_WORLD, 1, ierr)",
        "  end if",
        "",
        "  tag = 100",
        "",
        "  if (rank == 0) then",
        "    ! Process 0 sends data to process 1",
        "    do i = 1, 10",
        "      send_buf(i) = i * 10",
        "    end do",
        "    dest = 1",
        "    print *, 'Process 0 sending:', send_buf",
        "    call MPI_Send(send_buf, 10, MPI_INTEGER, dest, tag, MPI_COMM_WORLD, ierr)",
        "    print *, 'Process 0: Send completed'",
        "",
        "  else if (rank == 1) then",
        "    ! Process 1 receives data from process 0",
        "    source = 0",
        "    call MPI_Recv(recv_buf, 10, MPI_INTEGER, source, tag, MPI_COMM_WORLD, status, ierr)",
        "    print *, 'Process 1 received:', recv_buf",
        "  end if",
        "",
        "  call MPI_Finalize(ierr)",
        "",
        "end program demo_mpi_send",
        "```",
        "",
        "Compile and run:",
        "```bash",
        "mpif90 -o demo_mpi_send demo_mpi_send.f90",
        "mpirun -np 2 ./demo_mpi_send",
        "```",
        "",
        "Results:",
        "```text",
        " Process 0 sending:          10          20          30          40          50          60          70          80          90         100",
        " Process 0: Send completed",
        " Process 1 received:          10          20          30          40          50          60          70          80          90         100",
        "```"
      ],
      "standard": "MPI-1.0 (Message Passing Interface Standard, Version 1.0, 1994)",
      "see_also": [
        "[**MPI_Recv**(3)](#mpi_recv) - Standard-mode blocking receive,",
        "[**MPI_Isend**(3)](#mpi_isend) - Non-blocking send,",
        "[**MPI_Irecv**(3)](#mpi_irecv) - Non-blocking receive,",
        "[**MPI_Sendrecv**(3)](#mpi_sendrecv) - Combined send and receive,",
        "[**MPI_Bsend**(3)](#mpi_bsend) - Buffered-mode blocking send,",
        "[**MPI_Ssend**(3)](#mpi_ssend) - Synchronous-mode blocking send,",
        "[**MPI_Rsend**(3)](#mpi_rsend) - Ready-mode blocking send,",
        "[**MPI_Wait**(3)](#mpi_wait) - Wait for non-blocking operation to complete"
      ],
      "resources": [
        "- [Open MPI 5.0.x MPI_Send Documentation](https://docs.open-mpi.org/en/v5.0.x/man-openmpi/man3/MPI_Send.3.html)",
        "- [MPI Forum - MPI 5.0 Specification](https://www.mpi-forum.org/docs/mpi-5.0/mpi50-report.pdf)",
        "- [MPICH MPI_Send Reference](https://www.mpich.org/static/docs/v3.3/www3/MPI_Send.html)"
      ]
    }
  },
  "MPI Sendrecv": {
    "prefix": [
      "mpisendrecv",
      "MPISENDRECV",
      "mpi_sendrecv",
      "MPI_SENDRECV"
    ],
    "body": [
      "call MPI_Sendrecv(${1:sendbuf}, ${2:sendcount}, ${3:MPI_DOUBLE_PRECISION}, ${4:dest}, ${5:sendtag}, &",
      "                  ${6:recvbuf}, ${7:recvcount}, ${8:MPI_DOUBLE_PRECISION}, ${9:source}, ${10:recvtag}, &",
      "                  ${11:MPI_COMM_WORLD}, ${12:status}, ${0:ierr})"
    ],
    "description": "MPI_SENDRECV(SENDBUF,SENDCOUNT,SENDTYPE,DEST,SENDTAG,RECVBUF,RECVCOUNT,RECVTYPE,SOURCE,RECVTAG,COMM,STATUS,IERROR) executes a blocking send and receive operation."
  },
  "_MPI_SENDRECV_DOCUMENTATION": {
    "name": "**MPI_SENDRECV** - \\[PARALLEL:MPI\\] Execute a blocking send and receive operation",
    "synopsis": {
      "usage": "call MPI_Sendrecv(sendbuf, sendcount, sendtype, dest, sendtag, recvbuf, recvcount, recvtype, source, recvtag, comm, status, ierr)",
      "interface": [
        "subroutine MPI_Sendrecv(sendbuf, sendcount, sendtype, dest, sendtag, &",
        "                        recvbuf, recvcount, recvtype, source, recvtag, &",
        "                        comm, status, ierror)",
        "",
        "  type(*), dimension(..), intent(in)  :: sendbuf",
        "  integer, intent(in)                 :: sendcount",
        "  integer, intent(in)                 :: sendtype",
        "  integer, intent(in)                 :: dest",
        "  integer, intent(in)                 :: sendtag",
        "  type(*), dimension(..)              :: recvbuf",
        "  integer, intent(in)                 :: recvcount",
        "  integer, intent(in)                 :: recvtype",
        "  integer, intent(in)                 :: source",
        "  integer, intent(in)                 :: recvtag",
        "  integer, intent(in)                 :: comm",
        "  integer, dimension(MPI_STATUS_SIZE) :: status",
        "  integer, intent(out)                :: ierror"
      ]
    },
    "characteristics": [
      "**sendbuf** is the send buffer containing data of any type",
      "**sendcount** is a non-negative integer specifying the number of elements to send",
      "**sendtype** is an MPI datatype handle (e.g., MPI_INTEGER, MPI_DOUBLE_PRECISION)",
      "**dest** is the rank of the destination process in the communicator",
      "**sendtag** is a non-negative integer message tag for the send operation",
      "**recvbuf** is the receive buffer (must be disjoint from sendbuf)",
      "**recvcount** is the maximum number of elements to receive",
      "**recvtype** is an MPI datatype handle for the receive buffer elements",
      "**source** is the rank of the source process (or MPI_ANY_SOURCE)",
      "**recvtag** is the expected message tag (or MPI_ANY_TAG)",
      "**comm** is an MPI communicator handle",
      "**status** is an integer array of size MPI_STATUS_SIZE containing receive status",
      "**ierror** is the error code returned by the operation",
      "This is a blocking operation that completes when the send buffer may be reused and the receive buffer contains the received data",
      "The send and receive buffers must be disjoint (non-overlapping)",
      "Send and receive may have different lengths and datatypes"
    ],
    "description": "**MPI_Sendrecv** combines a send and a receive operation into a single call. It sends a message from the send buffer to the destination process while simultaneously receiving a message from the source process into the receive buffer. This operation is useful for executing shift operations across a chain of processes and is guaranteed not to deadlock for an exchange between source and destination, even when both operations involve the same pair of processes.",
    "options": {
      "sendbuf": "Initial address of the send buffer containing the data to be transmitted. The buffer must remain valid until the operation completes.",
      "sendcount": "Number of elements to send from the send buffer. Must be a non-negative integer.",
      "sendtype": "MPI datatype of each element in the send buffer. Common types include MPI_INTEGER, MPI_REAL, MPI_DOUBLE_PRECISION, MPI_COMPLEX, MPI_CHARACTER, and MPI_LOGICAL.",
      "dest": "Rank of the destination process within the communicator. Must be a valid rank (0 to comm_size-1) or MPI_PROC_NULL for a no-op send.",
      "sendtag": "Message tag for the send operation. Must be a non-negative integer not exceeding MPI_TAG_UB.",
      "recvbuf": "Initial address of the receive buffer where incoming data will be stored. Must be disjoint from sendbuf.",
      "recvcount": "Maximum number of elements that can be received. The actual number received may be smaller.",
      "recvtype": "MPI datatype of each element in the receive buffer. May differ from sendtype.",
      "source": "Rank of the source process from which to receive. Use MPI_ANY_SOURCE to receive from any process.",
      "recvtag": "Expected message tag. Use MPI_ANY_TAG to match any tag.",
      "comm": "MPI communicator over which the communication takes place (e.g., MPI_COMM_WORLD).",
      "status": "Integer array of size MPI_STATUS_SIZE that returns information about the received message. Use MPI_STATUS_IGNORE if status information is not needed.",
      "ierror": "Error code returned by the subroutine. MPI_SUCCESS indicates successful completion."
    },
    "examples": {
      "code": [
        "program demo_mpi_sendrecv",
        "  use mpi",
        "  implicit none",
        "  ",
        "  integer :: ierr, rank, nprocs",
        "  integer :: left_neighbor, right_neighbor",
        "  integer :: send_data, recv_data",
        "  integer :: status(MPI_STATUS_SIZE)",
        "  integer, parameter :: TAG = 100",
        "  ",
        "  ! Initialize MPI",
        "  call MPI_Init(ierr)",
        "  call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierr)",
        "  call MPI_Comm_size(MPI_COMM_WORLD, nprocs, ierr)",
        "  ",
        "  ! Calculate neighbors in a ring topology",
        "  left_neighbor = mod(rank - 1 + nprocs, nprocs)",
        "  right_neighbor = mod(rank + 1, nprocs)",
        "  ",
        "  ! Each process sends its rank to the right and receives from the left",
        "  send_data = rank",
        "  ",
        "  call MPI_Sendrecv(send_data, 1, MPI_INTEGER, right_neighbor, TAG, &",
        "                    recv_data, 1, MPI_INTEGER, left_neighbor, TAG, &",
        "                    MPI_COMM_WORLD, status, ierr)",
        "  ",
        "  print '(A,I2,A,I2,A,I2)', 'Rank ', rank, ' sent to ', right_neighbor, &",
        "                           ', received ', recv_data, ' from ', left_neighbor",
        "  ",
        "  ! Example with arrays: shift real data to the right",
        "  block",
        "    real(8) :: send_array(5), recv_array(5)",
        "    integer :: i",
        "    ",
        "    ! Initialize send array with rank-specific values",
        "    do i = 1, 5",
        "      send_array(i) = real(rank * 10 + i, 8)",
        "    end do",
        "    ",
        "    call MPI_Sendrecv(send_array, 5, MPI_DOUBLE_PRECISION, right_neighbor, TAG+1, &",
        "                      recv_array, 5, MPI_DOUBLE_PRECISION, left_neighbor, TAG+1, &",
        "                      MPI_COMM_WORLD, MPI_STATUS_IGNORE, ierr)",
        "    ",
        "    print '(A,I2,A,5F6.1)', 'Rank ', rank, ' received array: ', recv_array",
        "  end block",
        "  ",
        "  call MPI_Finalize(ierr)",
        "end program demo_mpi_sendrecv"
      ],
      "results": [
        "! Running with 4 processes (mpirun -np 4 ./demo_mpi_sendrecv):",
        "Rank  0 sent to  1, received  3 from  3",
        "Rank  1 sent to  2, received  0 from  0",
        "Rank  2 sent to  3, received  1 from  1",
        "Rank  3 sent to  0, received  2 from  2",
        "Rank  0 received array:   31.0  32.0  33.0  34.0  35.0",
        "Rank  1 received array:    1.0   2.0   3.0   4.0   5.0",
        "Rank  2 received array:   11.0  12.0  13.0  14.0  15.0",
        "Rank  3 received array:   21.0  22.0  23.0  24.0  25.0"
      ]
    },
    "standard": "MPI-1.0",
    "see_also": [
      "[**MPI_Send**(3)](#mpi_send)",
      "[**MPI_Recv**(3)](#mpi_recv)",
      "[**MPI_Sendrecv_replace**(3)](#mpi_sendrecv_replace)",
      "[**MPI_Isend**(3)](#mpi_isend)",
      "[**MPI_Irecv**(3)](#mpi_irecv)"
    ],
    "errors": {
      "MPI_SUCCESS": "No error; MPI routine completed successfully",
      "MPI_ERR_COMM": "Invalid communicator",
      "MPI_ERR_COUNT": "Invalid count argument (must be non-negative)",
      "MPI_ERR_TYPE": "Invalid datatype argument or uncommitted datatype",
      "MPI_ERR_TAG": "Invalid tag argument (must be non-negative and not exceed MPI_TAG_UB)",
      "MPI_ERR_RANK": "Invalid source or destination rank"
    },
    "notes": [
      "This routine is thread-safe and may be used by multiple threads without user-provided locks",
      "A send-receive operation can be used with process topologies (Chapter 6 of MPI-1) for shifts on logical topologies",
      "The message sent by MPI_Sendrecv can be received by a regular MPI_Recv or probed by MPI_Probe",
      "MPI_Sendrecv can receive messages sent by regular MPI_Send operations",
      "For in-place operations where send and receive buffers overlap, use MPI_Sendrecv_replace instead"
    ]
  },
  "Named Do Loop": {
    "prefix": [
      "donamed",
      "DONAMED",
      "namedloop"
    ],
    "body": [
      "${1:loop_name}: do ${2:i} = ${3:1}, ${4:n}",
      "\t${0}",
      "end do ${1:loop_name}"
    ],
    "description": "named_do_loop(LOOP_NAME,VARIABLE,START,END) creates a labeled do loop construct for controlled iteration with explicit loop identification.\n\n## named_do_loop\n\n### **Name**\n\n**named_do_loop** - \\[CONTROL:LOOP\\] Named iterative loop construct with explicit label\n\n### **Synopsis**\n```fortran\n    loop_name: do variable = start, end\n      ! loop body\n    end do loop_name\n```\n```fortran\n     construct named_do_loop(loop_name, variable, start, end)\n\n      character(len=*)      :: loop_name  ! construct name/label\n      integer, intent(in)   :: variable   ! loop counter\n      integer, intent(in)   :: start      ! initial value\n      integer, intent(in)   :: end        ! final value\n```\n\n### **Characteristics**\n\n - **loop_name** is a valid Fortran identifier used to label the construct.\n - **variable** is a scalar integer variable serving as the loop counter.\n - **start** is a scalar integer expression for the initial counter value.\n - **end** is a scalar integer expression for the final counter value.\n - The loop name must appear on both the DO statement and the END DO statement.\n - Named loops enable targeted EXIT and CYCLE statements for nested loop control.\n\n### **Description**\n\n **named_do_loop** creates a labeled iterative construct that executes a block\n of statements repeatedly while incrementing a counter variable from a starting\n value to an ending value. The explicit name provides self-documenting code and\n enables precise control flow in nested loop structures using EXIT loop_name\n and CYCLE loop_name statements.\n\n### **Options**\n\n- **loop_name**\n  : A valid Fortran identifier that labels the construct. Must be unique within\n  the scoping unit. The same name must appear after END DO. Enables targeted\n  EXIT and CYCLE statements when loops are nested.\n\n- **variable**\n  : A scalar integer variable that serves as the loop counter. It is incremented\n  automatically at the end of each iteration. Should not be modified within the\n  loop body.\n\n- **start**\n  : A scalar integer expression specifying the initial value of the loop counter.\n  Evaluated once before the first iteration.\n\n- **end**\n  : A scalar integer expression specifying the final value of the loop counter.\n  The loop executes while variable <= end (for positive increment).\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_named_do_loop\nimplicit none\n  integer :: i, j, k\n  integer :: matrix(3,3)\n  integer :: sum_total\n\n  ! Basic named loop - useful for documentation\n  row_loop: do i = 1, 3\n    print *, 'Processing row:', i\n  end do row_loop\n\n  ! Nested named loops with targeted EXIT\n  sum_total = 0\n  outer: do i = 1, 10\n    inner: do j = 1, 10\n      sum_total = sum_total + 1\n      if (sum_total > 50) exit outer  ! Exit outer loop directly\n    end do inner\n  end do outer\n  print *, 'Sum stopped at:', sum_total\n\n  ! Named loops with targeted CYCLE\n  matrix = 0\n  fill_rows: do i = 1, 3\n    fill_cols: do j = 1, 3\n      if (i == j) cycle fill_cols  ! Skip diagonal elements\n      matrix(i,j) = i * j\n    end do fill_cols\n  end do fill_rows\n  print *, 'Matrix (diagonal skipped):'\n  do i = 1, 3\n    print '(3I4)', matrix(i,:)\n  end do\n\n  ! Triple nested loop demonstrating precise control\n  search: do i = 1, 5\n    level2: do j = 1, 5\n      level3: do k = 1, 5\n        if (i*j*k == 30) then\n          print *, 'Found product 30 at:', i, j, k\n          exit search  ! Exit all three loops at once\n        end if\n      end do level3\n    end do level2\n  end do search\n\nend program demo_named_do_loop\n```\nResults:\n```text\n Processing row:           1\n Processing row:           2\n Processing row:           3\n Sum stopped at:          51\n Matrix (diagonal skipped):\n   0   2   3\n   2   0   6\n   3   6   0\n Found product 30 at:           2           3           5\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**do**(3)](#do),\n[**do_while**(3)](#do_while),\n[**do_concurrent**(3)](#do_concurrent),\n[**exit**(3)](#exit),\n[**cycle**(3)](#cycle)"
  },
  "Named Do Loop with Step": {
    "prefix": [
      "donamedstep",
      "DONAMEDSTEP"
    ],
    "body": [
      "${1:loop_name}: do ${2:i} = ${3:1}, ${4:n}, ${5:step}",
      "\t${0}",
      "end do ${1:loop_name}"
    ],
    "description": "## named_do_loop_with_step\n\n### **Name**\n\n**named_do_loop_with_step** - \\[CONTROL:LOOP\\] Named do loop with explicit step increment\n\n### **Synopsis**\n```fortran\n    loop_name: do variable = start, end, step\n      ! loop body\n    end do loop_name\n```\n```fortran\n     loop_name: do variable = start, end, step\n\n      integer :: variable  ! loop control variable\n      integer :: start     ! initial value\n      integer :: end       ! terminal value\n      integer :: step      ! increment (positive or negative)\n```\n\n### **Characteristics**\n\n - **loop_name** is a user-defined identifier that labels the loop construct.\n - **variable** is a scalar integer variable (the loop control variable).\n - **start**, **end**, and **step** are scalar integer expressions.\n - **step** must be non-zero; positive for ascending loops, negative for descending.\n - The loop name must match between the do statement and end do statement.\n - Named loops can be referenced by EXIT and CYCLE statements for precise control.\n\n### **Description**\n\n **named_do_loop_with_step** creates a counted do loop with an explicit step value and a user-defined name. The loop variable is initialized to the start value and incremented by step after each iteration until it exceeds the end value (for positive step) or falls below it (for negative step). The loop name allows EXIT and CYCLE statements to target this specific loop when nested within other loops.\n\n### **Options**\n\n- **loop_name**\n  : A valid Fortran identifier that labels the loop. Must appear on both the do statement (followed by a colon) and the end do statement. Enables targeted EXIT and CYCLE statements.\n\n- **variable**\n  : The loop control variable. Must be a scalar integer variable. Its value is automatically managed by the loop construct and should not be modified within the loop body.\n\n- **start**\n  : An integer expression specifying the initial value of the loop variable.\n\n- **end**\n  : An integer expression specifying the terminal value. The loop continues while the variable has not passed this value (considering the sign of step).\n\n- **step**\n  : An integer expression specifying the increment added to the loop variable after each iteration. Must be non-zero. Use positive values for ascending sequences, negative values for descending sequences.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_named_do_loop_with_step\nimplicit none\n  integer :: i, j, sum\n\n  ! Example 1: Count by 2s (ascending with step)\n  print *, 'Even numbers from 2 to 10:'\n  evens: do i = 2, 10, 2\n    print *, i\n  end do evens\n\n  ! Example 2: Countdown (descending with negative step)\n  print *, 'Countdown from 5:'\n  countdown: do i = 5, 1, -1\n    print *, i\n  end do countdown\n\n  ! Example 3: Nested loops with targeted EXIT\n  print *, 'Nested loop example with targeted EXIT:'\n  sum = 0\n  outer: do i = 1, 100, 10\n    inner: do j = 1, 5, 1\n      sum = sum + i + j\n      if (sum > 50) exit outer  ! Exit outer loop by name\n    end do inner\n  end do outer\n  print *, 'Sum when exceeding 50:', sum\n\n  ! Example 4: Skip iterations with targeted CYCLE\n  print *, 'CYCLE example - skip j=2:'\n  row_loop: do i = 1, 2, 1\n    col_loop: do j = 1, 3, 1\n      if (j == 2) cycle col_loop  ! Skip to next j\n      print *, 'i=', i, ' j=', j\n    end do col_loop\n  end do row_loop\n\nend program demo_named_do_loop_with_step\n```\nResults:\n```text\n Even numbers from 2 to 10:\n           2\n           4\n           6\n           8\n          10\n Countdown from 5:\n           5\n           4\n           3\n           2\n           1\n Nested loop example with targeted EXIT:\n Sum when exceeding 50:          56\n CYCLE example - skip j=2:\n i=           1  j=           1\n i=           1  j=           3\n i=           2  j=           1\n i=           2  j=           3\n```\n\n### **Standard**\n\nFortran 77 (named constructs added in Fortran 90)\n\n### **See Also**\n\n[**do_loop**(3)](#do_loop),\n[**do_loop_with_step**(3)](#do_loop_with_step),\n[**named_do_loop**(3)](#named_do_loop),\n[**do_while**(3)](#do_while),\n[**do_concurrent**(3)](#do_concurrent),\n[**exit**(3)](#exit),\n[**cycle**(3)](#cycle)"
  },
  "Namelist Definition": {
    "prefix": [
      "namelist",
      "NAMELIST"
    ],
    "body": [
      "namelist /${1:group_name}/ ${2:var1}, ${3:var2}${0}"
    ],
    "description": "NAMELIST(/group_name/var1,var2) defines a named group of variables for namelist-directed I/O.",
    "documentation": {
      "name": "**namelist** - \\[IO:NAMELIST\\] Define a named group of variables for namelist-directed input/output",
      "synopsis": {
        "usage": "namelist /group_name/ var1, var2, ...",
        "interface": [
          "namelist /group_name/ variable_list",
          "",
          "character(len=*) :: group_name  ! Name identifying the namelist group",
          "type(*)          :: var1, var2  ! Variables to include in the group"
        ]
      },
      "characteristics": [
        "**group_name** is a valid Fortran identifier used to reference the namelist group",
        "**variable_list** contains one or more variables separated by commas",
        "Variables must be declared before appearing in the NAMELIST statement",
        "Variables cannot be assumed-size arrays, dummy procedures, or pointers (F90/F95)",
        "Multiple NAMELIST statements can reference the same group name to extend it",
        "A variable can belong to multiple namelist groups"
      ],
      "description": "**namelist** declares a named group of variables that can be read or written together using namelist-directed I/O. This provides a convenient, self-documenting format where input data is specified by variable name rather than position, making input files more readable and less error-prone.",
      "options": [
        {
          "name": "group_name",
          "description": "A valid Fortran identifier that names the namelist group. This name is used in READ and WRITE statements with NML= specifier to perform namelist I/O operations. The name must be unique among namelist groups in the scoping unit."
        },
        {
          "name": "variable_list",
          "description": "A comma-separated list of variable names to include in the namelist group. Variables can be of any intrinsic or derived type. Array variables include all elements. Derived types must have components that are accessible. Variables must be accessible in the scope where the NAMELIST statement appears."
        }
      ],
      "examples": {
        "code": [
          "program demo_namelist",
          "implicit none",
          "  ! Declare variables for simulation parameters",
          "  integer :: num_iterations",
          "  real    :: time_step, tolerance",
          "  logical :: verbose",
          "  character(len=80) :: output_file",
          "",
          "  ! Define namelist group for simulation settings",
          "  namelist /sim_params/ num_iterations, time_step, tolerance, verbose, output_file",
          "",
          "  ! Set default values",
          "  num_iterations = 100",
          "  time_step = 0.01",
          "  tolerance = 1.0e-6",
          "  verbose = .false.",
          "  output_file = 'results.dat'",
          "",
          "  ! Read namelist from input file (if it exists)",
          "  open(unit=10, file='input.nml', status='old', action='read', err=100)",
          "  read(10, nml=sim_params)",
          "  close(10)",
          "",
          "100 continue",
          "",
          "  ! Display current settings",
          "  print '(a)', 'Current simulation parameters:'",
          "  write(*, nml=sim_params)",
          "",
          "  ! Write namelist to a new file",
          "  open(unit=20, file='output.nml', status='replace', action='write')",
          "  write(20, nml=sim_params)",
          "  close(20)",
          "",
          "end program demo_namelist"
        ],
        "input_file": [
          "&sim_params",
          "  num_iterations = 500,",
          "  time_step = 0.001,",
          "  tolerance = 1.0e-8,",
          "  verbose = .true.,",
          "  output_file = 'simulation_output.dat'",
          "/"
        ],
        "results": [
          "Current simulation parameters:",
          "&SIM_PARAMS",
          " NUM_ITERATIONS=500,",
          " TIME_STEP=0.100000001E-02,",
          " TOLERANCE=0.100000000E-07,",
          " VERBOSE=T,",
          " OUTPUT_FILE=simulation_output.dat",
          "/"
        ]
      },
      "standard": "Fortran 90",
      "see_also": [
        "**read**(3) - Read data from file or standard input",
        "**write**(3) - Write data to file or standard output",
        "**open**(3) - Connect an external file to a unit",
        "**inquire**(3) - Inquire about file or unit properties"
      ]
    }
  },
  "Namelist Read": {
    "prefix": [
      "nmlread",
      "NMLREAD"
    ],
    "body": [
      "read(${1:unit}, nml=${2:nml_name}, iostat=${3:ierr})",
      "if (${3:ierr} /= 0) error stop 'Failed to read namelist ${2:nml_name}'"
    ],
    "description": "## namelist_read\n\n### **Name**\n\n**namelist_read** - \\[IO:NAMELIST\\] Read a namelist from a file unit with error handling\n\n### **Synopsis**\n```fortran\n    read(unit, nml=nml_name, iostat=ierr)\n    if (ierr /= 0) error stop 'Failed to read namelist nml_name'\n```\n```fortran\n     ! Namelist read statement with error handling\n\n      integer, intent(in)    :: unit      ! Connected file unit number\n      namelist /nml_name/    :: variables ! Namelist group definition\n      integer, intent(out)   :: ierr      ! I/O status (0 = success)\n```\n\n### **Characteristics**\n\n - **unit** is a scalar integer representing an open file unit connected for formatted input.\n - **nml_name** is the name of a previously declared namelist group.\n - **ierr** is an integer variable that receives the I/O status code.\n - The file must be connected for formatted sequential access.\n - All variables in the namelist group are read from the input.\n\n### **Description**\n\n **namelist_read** reads values from a formatted file into variables belonging\n to a namelist group. The input file must contain the namelist data in the\n standard namelist format beginning with `&nml_name` and ending with `/`.\n If the read fails, the iostat variable receives a non-zero value, and\n the error stop statement terminates the program with a diagnostic message.\n\n### **Options**\n\n- **unit**\n  : The logical unit number of a file that has been opened for formatted\n  sequential reading. The unit must be connected before the read statement.\n\n- **nml_name**\n  : The name of a namelist group previously defined with the NAMELIST\n  statement. All variables in the group will be assigned values from the\n  input file if present in the namelist input.\n\n- **ierr**\n  : An integer variable that receives the I/O status. Zero indicates\n  successful completion. A positive value indicates an error occurred.\n  A negative value indicates an end-of-file or end-of-record condition.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_namelist_read\nimplicit none\n  ! Declare variables for namelist\n  integer :: max_iterations = 100\n  real    :: tolerance = 1.0e-6\n  logical :: verbose = .false.\n  character(len=64) :: output_file = 'output.dat'\n\n  ! Define namelist group\n  namelist /settings/ max_iterations, tolerance, verbose, output_file\n\n  integer :: unit_num, ierr\n\n  ! Create a sample input file\n  open(newunit=unit_num, file='settings.nml', status='replace', action='write')\n  write(unit_num, '(a)') '&settings'\n  write(unit_num, '(a)') '  max_iterations = 500'\n  write(unit_num, '(a)') '  tolerance = 1.0e-8'\n  write(unit_num, '(a)') '  verbose = .true.'\n  write(unit_num, '(a)') '  output_file = \"results.dat\"'\n  write(unit_num, '(a)') '/'\n  close(unit_num)\n\n  ! Read namelist from file\n  open(newunit=unit_num, file='settings.nml', status='old', action='read')\n  read(unit_num, nml=settings, iostat=ierr)\n  if (ierr /= 0) error stop 'Failed to read namelist settings'\n  close(unit_num)\n\n  ! Display read values\n  print '(a)',       'Namelist values read:'\n  print '(a,i0)',    '  max_iterations = ', max_iterations\n  print '(a,es10.3)','  tolerance      = ', tolerance\n  print '(a,l1)',    '  verbose        = ', verbose\n  print '(a,a)',     '  output_file    = ', trim(output_file)\n\n  ! Clean up\n  open(newunit=unit_num, file='settings.nml', status='old')\n  close(unit_num, status='delete')\n\nend program demo_namelist_read\n```\nResults:\n```text\nNamelist values read:\n  max_iterations = 500\n  tolerance      = 1.000E-08\n  verbose        = T\n  output_file    = results.dat\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**namelist_write**(3)](#namelist_write),\n[**open**(3)](#open),\n[**read**(3)](#read),\n[**inquire**(3)](#inquire)"
  },
  "Namelist Write": {
    "prefix": [
      "nmlwrite",
      "NMLWRITE"
    ],
    "body": [
      "write(${1:unit}, nml=${2:nml_name})"
    ],
    "description": "WRITE(UNIT,NML=nml_name) writes all variables in a namelist group to a file or output unit."
  },
  "Null Intrinsic": {
    "prefix": [
      "null",
      "NULL",
      "nullptr",
      "NULLPTR"
    ],
    "body": [
      "${1:ptr} => null(${2:mold})"
    ],
    "description": "NULL(MOLD=mold) returns a disassociated pointer or unallocated allocatable entity.",
    "documentation": {
      "name": "**null** - \\[TYPE:INQUIRY\\] Returns a disassociated pointer or unallocated allocatable entity",
      "synopsis": {
        "usage": "```fortran\n    pointer => null()\n    pointer => null(mold)\n```",
        "interface": "```fortran\n     function null(mold) result(ptr)\n\n      type(TYPE(kind=**)), pointer, optional, intent(in) :: mold\n      type(TYPE(kind=**)), pointer                       :: ptr\n```"
      },
      "characteristics": [
        "**mold** is an optional pointer of any type.",
        "The result is a disassociated pointer of the same type, kind, and rank as **mold** if present.",
        "If **mold** is absent, the result type is determined by context (e.g., the pointer being assigned to).",
        "Can be used with any pointer type: intrinsic types, derived types, or procedure pointers."
      ],
      "description": "**null** returns a disassociated pointer. If **mold** is present, the result is the same type, kind, and rank as **mold**. If **mold** is absent, the context determines the type (such as in a pointer assignment or as a default initializer).",
      "options": {
        "mold": "An optional pointer of any type. If present, the result is a disassociated pointer with the same type, kind, and rank as **mold**. If absent, the type is determined from context."
      },
      "result": "A disassociated pointer. The type, kind, and rank match **mold** if present; otherwise, they are determined by context. The pointer status is always disassociated (not undefined).",
      "examples": {
        "code": "program demo_null\nimplicit none\n  integer, pointer :: iptr => null()\n  real, pointer    :: rptr => null()\n  integer, pointer :: arr_ptr(:) => null()\n  type :: node\n    integer :: value\n    type(node), pointer :: next => null()\n  end type node\n  type(node), pointer :: head => null()\n\n  ! Check initial status\n  print *, 'iptr associated:', associated(iptr)\n  print *, 'rptr associated:', associated(rptr)\n  print *, 'arr_ptr associated:', associated(arr_ptr)\n  print *, 'head associated:', associated(head)\n\n  ! Allocate and use\n  allocate(iptr)\n  iptr = 42\n  print *, 'iptr value:', iptr\n  print *, 'iptr now associated:', associated(iptr)\n\n  ! Nullify (reset to disassociated)\n  iptr => null()\n  print *, 'After null(), iptr associated:', associated(iptr)\n\n  ! Using mold argument\n  allocate(arr_ptr(5))\n  arr_ptr = [1, 2, 3, 4, 5]\n  arr_ptr => null(arr_ptr)  ! Same type and rank\n  print *, 'arr_ptr after null(mold):', associated(arr_ptr)\n\n  ! Linked list example\n  allocate(head)\n  head%value = 100\n  head%next => null()  ! Explicitly null\n  print *, 'head%next associated:', associated(head%next)\n\n  deallocate(head)\n\nend program demo_null",
        "results": "```text\n iptr associated: F\n rptr associated: F\n arr_ptr associated: F\n head associated: F\n iptr value:          42\n iptr now associated: T\n After null(), iptr associated: F\n arr_ptr after null(mold): F\n head%next associated: F\n```"
      },
      "standard": "Fortran 95",
      "see_also": [
        "[**associated**(3)](#associated)",
        "[**nullify**(3)](#nullify)",
        "[**pointer**(3)](#pointer)",
        "[**allocate**(3)](#allocate)"
      ]
    }
  },
  "Nullify Pointer": {
    "prefix": [
      "nullify",
      "NULLIFY"
    ],
    "body": "nullify(${1:pointer})",
    "description": "NULLIFY(POINTER) disassociates a pointer from its target, setting it to a null pointer state.\n\n## nullify\n\n### **Name**\n\n**nullify** - \\[MEMORY:POINTER\\] Disassociate a pointer from its target\n\n### **Synopsis**\n```fortran\n    call nullify(pointer)\n```\n```fortran\n     subroutine nullify(pointer)\n\n      type(*), pointer :: pointer\n```\n\n### **Characteristics**\n\n - **pointer** is a pointer of any type, kind, and rank.\n - The pointer becomes disassociated (null) after the call.\n - Multiple pointers can be nullified in a single statement.\n\n### **Description**\n\n **nullify** disassociates a pointer from its target, placing the pointer\n in a null (disassociated) state. After nullification, the pointer does\n not point to any target and ASSOCIATED(pointer) returns .FALSE.\n\n Nullification does NOT deallocate memory if the pointer was the only\n reference to an allocated target - this can cause a memory leak.\n Always DEALLOCATE before NULLIFY if the pointer owns allocated memory.\n\n### **Options**\n\n- **pointer**\n  : A pointer variable of any intrinsic or derived type. The pointer\n  becomes disassociated after the statement executes. Multiple pointers\n  can be specified, separated by commas.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_nullify\nimplicit none\n  integer, pointer :: ptr => null()\n  integer, target  :: val = 42\n  integer, pointer :: arr_ptr(:) => null()\n  integer, target  :: arr(5) = [1, 2, 3, 4, 5]\n\n  ! Associate pointer with target\n  ptr => val\n  print *, 'Associated:', associated(ptr)  ! T\n  print *, 'Value:', ptr                    ! 42\n\n  ! Disassociate using nullify\n  nullify(ptr)\n  print *, 'After nullify:', associated(ptr)  ! F\n\n  ! Array pointer example\n  arr_ptr => arr\n  print *, 'Array associated:', associated(arr_ptr)  ! T\n  print *, 'Array values:', arr_ptr                  ! 1 2 3 4 5\n\n  nullify(arr_ptr)\n  print *, 'Array after nullify:', associated(arr_ptr)  ! F\n\n  ! Multiple pointers in one statement\n  ptr => val\n  arr_ptr => arr\n  nullify(ptr, arr_ptr)  ! Both now disassociated\n  print *, 'Both null:', .not.associated(ptr), .not.associated(arr_ptr)\n\nend program demo_nullify\n```\nResults:\n```text\n Associated: T\n Value:          42\n After nullify: F\n Array associated: T\n Array values:           1           2           3           4           5\n Array after nullify: F\n Both null: T T\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**associated**(3)](#associated),\n[**allocate**(3)](#allocate),\n[**deallocate**(3)](#deallocate),\n[**null**(3)](#null)"
  },
  "OpenMP Atomic": {
    "prefix": [
      "ompatomic",
      "OMPATOMIC",
      "!$omp atomic"
    ],
    "body": [
      "!$omp atomic${1| ,update ,read ,write ,capture |}${2|,seq_cst,acq_rel,release,acquire,relaxed|}",
      "${3:x} = ${3:x} ${4|+,-,*,/,.and.,.or.,.eqv.,.neqv.|} ${0:expr}"
    ],
    "description": "!$OMP ATOMIC [clause] ensures atomic update of a shared variable using supported operators or intrinsics.",
    "documentation": {
      "name": "**!$OMP ATOMIC** - \\[PARALLEL:OPENMP\\] Atomic memory operation directive for thread-safe updates",
      "synopsis": {
        "usage": [
          "!$omp atomic [atomic-clause] [memory-order-clause]",
          "   statement",
          "[!$omp end atomic]"
        ],
        "forms": [
          "!$omp atomic",
          "   x = x operator expr",
          "",
          "!$omp atomic update",
          "   x = intrinsic_procedure_name(x, expr_list)",
          "",
          "!$omp atomic read",
          "   v = x",
          "",
          "!$omp atomic write",
          "   x = expr",
          "",
          "!$omp atomic capture",
          "   v = x",
          "   x = x operator expr",
          "!$omp end atomic"
        ]
      },
      "characteristics": [
        "**x** is a scalar variable of intrinsic type (integer, real, complex, or logical)",
        "**x** must not have the ALLOCATABLE attribute",
        "**v** is a scalar variable used to capture the original or final value of x",
        "**expr** is an expression that does not reference the storage location of x",
        "**operator** is one of: +, -, *, /, .AND., .OR., .EQV., .NEQV.",
        "**intrinsic_procedure_name** is one of: MAX, MIN, IAND, IOR, IEOR",
        "Multiple references to x must designate the same storage location",
        "The directive ensures atomic read-modify-write operations across threads"
      ],
      "description": "**!$OMP ATOMIC** ensures that a specific storage location is accessed atomically, preventing data races when multiple threads update shared variables. Without an atomic-clause, the behavior defaults to UPDATE. The atomic construct provides a lightweight synchronization mechanism compared to critical sections, with hardware support on most modern processors. Only the read and write of the designated location are performed atomically; evaluation of expressions is not atomic.",
      "options": {
        "atomic-clause": {
          "update": "Default. Performs atomic read-modify-write using the specified operator or intrinsic. Statement form: x = x op expr, x = expr op x, x = intrinsic(x, expr), or x = intrinsic(expr, x).",
          "read": "Performs an atomic read of x into v. Statement form: v = x. Memory-order-clause must not be acq_rel or release.",
          "write": "Performs an atomic write of expr to x. Statement form: x = expr. Memory-order-clause must not be acq_rel or acquire.",
          "capture": "Atomically updates x while capturing its original or final value in v. Requires !$OMP END ATOMIC. If atomic-clause is also present, it must be update."
        },
        "memory-order-clause": {
          "seq_cst": "Sequentially consistent ordering. Strongest memory ordering guarantee.",
          "acq_rel": "Acquire-release semantics. Not valid with read (use acquire) or write (use release).",
          "release": "Release semantics. Ensures prior writes are visible before the atomic operation.",
          "acquire": "Acquire semantics. Ensures subsequent reads see the atomic operation.",
          "relaxed": "No memory ordering constraints beyond atomicity itself."
        },
        "additional-clauses": {
          "compare": "(OpenMP 5.1+) Enables conditional atomic updates: if (x == e) x = d. Must be combined with update.",
          "fail(memory-order)": "(OpenMP 5.1+) Specifies memory ordering when compare fails.",
          "weak": "(OpenMP 5.1+) Allows spurious failures for compare-and-swap equality tests.",
          "hint(hint-expression)": "Implementation hint for optimization. Does not affect semantics."
        },
        "supported-operators": [
          "+ (addition)",
          "- (subtraction)",
          "* (multiplication)",
          "/ (division)",
          ".AND. (logical AND)",
          ".OR. (logical OR)",
          ".EQV. (logical equivalence)",
          ".NEQV. (logical non-equivalence)"
        ],
        "supported-intrinsics": [
          "MAX (maximum value)",
          "MIN (minimum value)",
          "IAND (bitwise AND)",
          "IOR (bitwise OR)",
          "IEOR (bitwise exclusive OR)"
        ]
      },
      "examples": {
        "sample_program": [
          "program demo_omp_atomic",
          "  use omp_lib",
          "  implicit none",
          "  integer :: counter, i, old_val, new_val",
          "  real    :: sum_val, arr(1000)",
          "  integer :: max_val, thread_max",
          "",
          "  ! Initialize test data",
          "  counter = 0",
          "  sum_val = 0.0",
          "  max_val = 0",
          "  do i = 1, 1000",
          "    arr(i) = real(i)",
          "  end do",
          "",
          "  !-----------------------------------------------------------------",
          "  ! Example 1: Basic atomic update (default) - increment counter",
          "  !-----------------------------------------------------------------",
          "  !$omp parallel do",
          "  do i = 1, 1000",
          "    !$omp atomic",
          "    counter = counter + 1",
          "  end do",
          "  !$omp end parallel do",
          "  print '(A,I0)', 'Counter after 1000 increments: ', counter",
          "",
          "  !-----------------------------------------------------------------",
          "  ! Example 2: Atomic update with explicit clause and memory order",
          "  !-----------------------------------------------------------------",
          "  !$omp parallel do reduction(+:sum_val)",
          "  do i = 1, 1000",
          "    sum_val = sum_val + arr(i)",
          "  end do",
          "  !$omp end parallel do",
          "  print '(A,F12.1)', 'Sum of array: ', sum_val",
          "",
          "  !-----------------------------------------------------------------",
          "  ! Example 3: Atomic with intrinsic (finding maximum)",
          "  !-----------------------------------------------------------------",
          "  !$omp parallel private(thread_max)",
          "  thread_max = 0",
          "  !$omp do",
          "  do i = 1, 1000",
          "    if (mod(i, 7) == 0) thread_max = max(thread_max, i)",
          "  end do",
          "  !$omp end do",
          "  !$omp atomic update",
          "  max_val = max(max_val, thread_max)",
          "  !$omp end parallel",
          "  print '(A,I0)', 'Maximum value divisible by 7: ', max_val",
          "",
          "  !-----------------------------------------------------------------",
          "  ! Example 4: Atomic read and write",
          "  !-----------------------------------------------------------------",
          "  counter = 42",
          "  !$omp parallel sections",
          "  !$omp section",
          "    !$omp atomic write",
          "    counter = 100",
          "  !$omp section",
          "    !$omp atomic read",
          "    old_val = counter",
          "    print '(A,I0)', 'Read value (42 or 100): ', old_val",
          "  !$omp end parallel sections",
          "",
          "  !-----------------------------------------------------------------",
          "  ! Example 5: Atomic capture - get old value while updating",
          "  !-----------------------------------------------------------------",
          "  counter = 0",
          "  !$omp parallel do",
          "  do i = 1, 10",
          "    !$omp atomic capture",
          "    old_val = counter",
          "    counter = counter + 1",
          "    !$omp end atomic",
          "    print '(A,I0,A,I0)', 'Thread got ticket: ', old_val, ' new counter: ', old_val + 1",
          "  end do",
          "  !$omp end parallel do",
          "",
          "  print '(A)', 'All atomic operations completed successfully.'",
          "",
          "end program demo_omp_atomic"
        ],
        "expected_output": [
          "Counter after 1000 increments: 1000",
          "Sum of array:     500500.0",
          "Maximum value divisible by 7: 994",
          "Read value (42 or 100): 42",
          "Thread got ticket: 0 new counter: 1",
          "Thread got ticket: 1 new counter: 2",
          "Thread got ticket: 2 new counter: 3",
          "...",
          "All atomic operations completed successfully."
        ],
        "compilation": "gfortran -fopenmp demo_omp_atomic.f90 -o demo_omp_atomic"
      },
      "standard": "OpenMP 1.0 (basic atomic), OpenMP 3.1 (read/write/capture clauses), OpenMP 4.5 (seq_cst), OpenMP 5.0 (memory order clauses), OpenMP 5.1 (compare, fail, weak clauses), OpenMP 6.0 (current specification)",
      "see_also": [
        "**!$OMP CRITICAL** - Mutual exclusion for code blocks",
        "**!$OMP PARALLEL** - Parallel region directive",
        "**!$OMP REDUCTION** - Reduction clause for parallel loops",
        "**!$OMP FLUSH** - Memory synchronization directive",
        "**!$OMP BARRIER** - Thread synchronization point"
      ],
      "notes": [
        "Atomic operations are generally faster than critical sections for simple updates.",
        "Hardware atomic instructions are used when available (most modern x86, ARM, POWER processors).",
        "For complex multi-statement critical regions, use !$OMP CRITICAL instead.",
        "The capture clause requires !$OMP END ATOMIC to delimit the structured block.",
        "Memory ordering defaults to relaxed unless specified; use seq_cst for strictest ordering.",
        "All atomic accesses to a variable throughout the program must use compatible types."
      ],
      "resources": [
        "OpenMP 6.0 Specification: https://www.openmp.org/specifications/",
        "OpenMP 5.1 Atomic Construct: https://www.openmp.org/spec-html/5.1/openmpsu105.html",
        "Intel Fortran OpenMP Directives: https://www.intel.com/content/www/us/en/docs/fortran-compiler/developer-guide-reference/2025-1/openmp-fortran-compiler-directives.html"
      ]
    }
  },
  "OpenMP Barrier": {
    "prefix": [
      "omp barrier",
      "OMP BARRIER",
      "ompbarrier",
      "OMPBARRIER"
    ],
    "body": "!$omp barrier$0",
    "description": "!$OMP BARRIER synchronizes all threads in the current team at an explicit barrier point.\n\n## barrier\n\n### **Name**\n\n**barrier** - \\[PARALLEL:OPENMP\\] Explicit thread synchronization barrier\n\n### **Synopsis**\n```fortran\n    !$omp barrier\n```\n```fortran\n     ! Stand-alone directive (no clauses)\n     !$omp barrier\n```\n\n### **Characteristics**\n\n - **Stand-alone directive** that takes no clauses or arguments.\n - **Binding** is to the innermost enclosing parallel region.\n - **All threads** in the current team must encounter the barrier.\n - **Implicit tasks** and explicit tasks bound to the parallel region must complete before any thread continues.\n\n### **Description**\n\n **barrier** specifies an explicit synchronization point at which all threads in the current team must wait. When a thread reaches the barrier directive, it halts execution until all other threads in the team have also reached the barrier. Once all threads arrive and complete any pending explicit tasks bound to the parallel region, they resume parallel execution of subsequent code.\n\n The barrier construct ensures that all work performed by threads before the barrier is visible to all threads after the barrier. This is essential for maintaining data consistency when threads need to share results from parallel computations.\n\n### **Options**\n\n - The **barrier** directive accepts no clauses or options.\n   : It is a stand-alone synchronization construct.\n\n### **Restrictions**\n\n - Each barrier region must be encountered by **all threads** in a team or by **none at all**, unless cancellation has been requested for the innermost enclosing parallel region.\n - The **sequence** of worksharing regions and barrier regions encountered must be the **same for every thread** in a team.\n - A **barrier** directive may not appear within a worksharing construct, critical, ordered, atomic, master, or single construct.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_omp_barrier\n  use omp_lib\n  implicit none\n  integer :: thread_id\n  integer, parameter :: n = 4\n  integer :: partial_sums(n)\n  integer :: total_sum\n  integer :: i\n\n  total_sum = 0\n\n  !$omp parallel num_threads(n) private(thread_id) shared(partial_sums, total_sum)\n    thread_id = omp_get_thread_num()\n\n    ! Each thread computes its partial sum\n    partial_sums(thread_id + 1) = (thread_id + 1) * 10\n    print '(A,I0,A,I0)', 'Thread ', thread_id, ' computed partial sum: ', partial_sums(thread_id + 1)\n\n    ! Wait for all threads to finish computing\n    !$omp barrier\n\n    ! Only thread 0 computes the total after all partial sums are ready\n    !$omp single\n      do i = 1, n\n        total_sum = total_sum + partial_sums(i)\n      end do\n      print '(A,I0)', 'Total sum after barrier: ', total_sum\n    !$omp end single\n  !$omp end parallel\n\nend program demo_omp_barrier\n```\nResults:\n```text\n    Thread 0 computed partial sum: 10\n    Thread 1 computed partial sum: 20\n    Thread 2 computed partial sum: 30\n    Thread 3 computed partial sum: 40\n    Total sum after barrier: 100\n```\n\n### **Standard**\n\nOpenMP 1.0 (1997 for Fortran)\n\n### **See Also**\n\n[**!$omp parallel**(3)](#omp_parallel),\n[**!$omp critical**(3)](#omp_critical),\n[**!$omp single**(3)](#omp_single),\n[**!$omp atomic**(3)](#omp_atomic),\n[**omp_get_thread_num**(3)](#omp_get_thread_num)\n\n### **Resources**\n\n- [OpenMP 5.0 Barrier Construct Specification](https://www.openmp.org/spec-html/5.0/openmpsu90.html)\n- [LLNL OpenMP Tutorial - Barrier Directive](https://hpc-tutorials.llnl.gov/openmp/barrier_directive/)\n- [OpenMP Official Site](https://www.openmp.org/)"
  },
  "OpenMP Critical Section": {
    "prefix": [
      "ompcritical",
      "OMPCRITICAL",
      "critical"
    ],
    "body": [
      "!$omp critical${1: (${2:name})${3:, hint(${4:omp_sync_hint_none})}}",
      "\t${0}",
      "!$omp end critical${1: (${2:name})}"
    ],
    "description": "!$OMP CRITICAL [(name) [, hint(hint-expression)]] restricts execution of the structured block to a single thread at a time.\n\n## critical\n\n### **Name**\n\n**critical** - \\[PARALLEL:OPENMP\\] Mutual exclusion synchronization construct\n\n### **Synopsis**\n\n```fortran\n    !$omp critical [(name) [, hint(hint-expression)]]\n        structured-block\n    !$omp end critical [(name)]\n```\n\n```fortran\n    ! Directive structure\n    !$omp critical [(name) [, hint(hint-expr)]]\n\n      ! name           - Optional global identifier for the critical region\n      ! hint-expr      - Scalar expression of kind omp_sync_hint_kind\n\n    !$omp end critical [(name)]\n```\n\n### **Characteristics**\n\n - **name** is an optional global identifier that labels the critical region.\n - **hint-expression** is a constant expression evaluating to a scalar value with kind `omp_sync_hint_kind`.\n - All critical constructs with the same name are treated as the same region.\n - Unnamed critical sections are all treated as the same section.\n - The binding thread set encompasses all threads in the contention group.\n\n### **Description**\n\n **critical** restricts execution of the associated structured block to a single thread at a time. When a thread encounters a critical region, it waits until no other thread in the contention group is executing that named critical region. This provides mutual exclusion synchronization for the enclosed code block.\n\n The optional name acts as a global identifier. Different critical regions with the same name enforce mutual exclusion against each other across all threads in the contention group, regardless of which team the threads belong to.\n\n### **Options**\n\n- **name**\n  : Optional identifier for the critical region. Names are global entities of the program in Fortran. Critical regions with the same name share mutual exclusion. If omitted, the critical section shares an implicit common name with all other unnamed critical sections.\n\n- **hint(hint-expression)**\n  : Optional clause providing implementation hints about expected runtime properties. Valid hint values (from `omp_lib` module):\n  - `omp_sync_hint_none` (default) - No hint specified\n  - `omp_sync_hint_uncontended` - Low contention expected\n  - `omp_sync_hint_contended` - High contention expected\n  - `omp_sync_hint_nonspeculative` - Use non-speculative locking\n  - `omp_sync_hint_speculative` - Use speculative locking (hardware transactional memory)\n  \n  Hints do not affect isolation guarantees and may be ignored by the implementation. A hint clause requires a named construct.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_omp_critical\n  use omp_lib\n  implicit none\n  integer :: total, thread_id\n  integer :: i\n  integer, parameter :: n = 100\n\n  total = 0\n\n  !$omp parallel private(thread_id, i)\n    thread_id = omp_get_thread_num()\n\n    ! Named critical section for safe accumulation\n    do i = 1, n\n      !$omp critical (accumulate)\n        total = total + 1\n      !$omp end critical (accumulate)\n    end do\n\n    ! Unnamed critical for I/O\n    !$omp critical\n      print '(A,I2,A,I6)', 'Thread ', thread_id, ' sees total = ', total\n    !$omp end critical\n\n  !$omp end parallel\n\n  print '(A,I6)', 'Final total = ', total\n\nend program demo_omp_critical\n```\n\nSample program with hint clause:\n\n```fortran\nprogram demo_omp_critical_hint\n  use omp_lib\n  implicit none\n  real(8) :: sum_val\n  integer :: i\n  integer, parameter :: n = 1000000\n\n  sum_val = 0.0d0\n\n  !$omp parallel do private(i)\n  do i = 1, n\n    ! Hint that contention is expected (many threads updating)\n    !$omp critical (sum_region, hint(omp_sync_hint_contended))\n      sum_val = sum_val + 1.0d0 / real(i, 8)\n    !$omp end critical (sum_region)\n  end do\n  !$omp end parallel do\n\n  print '(A,F12.6)', 'Harmonic sum approximation = ', sum_val\n\nend program demo_omp_critical_hint\n```\n\nResults:\n```text\nThread  0 sees total =    127\nThread  2 sees total =    298\nThread  1 sees total =    364\nThread  3 sees total =    400\nFinal total =    400\n\nHarmonic sum approximation =    14.392727\n```\n\n### **Standard**\n\nOpenMP 1.0 (critical construct), OpenMP 4.5 (hint clause)\n\n### **See Also**\n\n[**atomic**(3)](#atomic),\n[**barrier**(3)](#barrier),\n[**omp_set_lock**(3)](#omp_set_lock),\n[**omp_init_lock_with_hint**(3)](#omp_init_lock_with_hint)\n\n### **Resources**\n\n- [OpenMP 5.0 Critical Construct Specification](https://www.openmp.org/spec-html/5.0/openmpsu89.html)\n- [OpenMP 5.0 Synchronization Hints](https://www.openmp.org/spec-html/5.0/openmpsu100.html)\n- [LLNL HPC Tutorials - Critical Directive](https://hpc-tutorials.llnl.gov/openmp/critical_directive/)"
  },
  "OpenMP Parallel Do": {
    "prefix": [
      "ompdo",
      "OMPDO",
      "paralleldo",
      "PARALLELDO",
      "omp_parallel_do"
    ],
    "body": [
      "!$omp parallel do private(${1:i}) shared(${2:arr})${3: schedule(${4|static,dynamic,guided,runtime,auto|}${5:, ${6:chunk_size}})}${7: reduction(${8|+,-,*,max,min,iand,ior,ieor,.and.,.or.,.eqv.,.neqv.|}:${9:var})}",
      "do ${1:i} = ${10:1}, ${11:n}",
      "\t${0}",
      "end do",
      "!$omp end parallel do"
    ],
    "description": "!$OMP PARALLEL DO [clauses] creates a parallel region containing a single worksharing DO loop, distributing iterations across threads."
  },
  "OpenMP Parallel Do Simd": {
    "prefix": [
      "ompdosimd",
      "OMPDOSIMD",
      "paralleldosimd",
      "PARALLELDOSIMD",
      "omp_parallel_do_simd"
    ],
    "body": [
      "!$omp parallel do simd private(${1:i}) shared(${2:arr})${3: reduction(${4|+,*,max,min|}:${5:result})}",
      "do ${1:i} = ${6:1}, ${7:n}",
      "\t${0}",
      "end do",
      "!$omp end parallel do simd"
    ],
    "description": "!$OMP PARALLEL DO SIMD(PRIVATE,SHARED,REDUCTION) combines parallel region, worksharing-loop, and SIMD vectorization into a single construct."
  },
  "OpenMP Parallel Region": {
    "prefix": [
      "ompparallel",
      "OMPPARALLEL"
    ],
    "body": [
      "!$omp parallel${1: private(${2:private_vars})}${3: shared(${4:shared_vars})}${5: default(${6|none,shared,private,firstprivate|})}",
      "\t${0}",
      "!$omp end parallel"
    ],
    "description": "## omp_parallel\n\n### **Name**\n\n**omp parallel** - \\[PARALLEL:OPENMP\\] Creates a team of threads to execute a parallel region\n\n### **Synopsis**\n\n```fortran\n    !$omp parallel [clause [[,] clause] ...]\n       structured-block\n    !$omp end parallel\n```\n\n```fortran\n    !$omp parallel private(list) shared(list) default(none|shared|private|firstprivate)\n    !$omp& firstprivate(list) copyin(list) reduction(operator:list)\n    !$omp& if(scalar-logical-expr) num_threads(scalar-integer-expr)\n    !$omp& proc_bind(master|close|spread) allocate([allocator:]list)\n       structured-block\n    !$omp end parallel\n```\n\n### **Characteristics**\n\n - **private(list)** specifies variables that are private to each thread.\n - **shared(list)** specifies variables that are shared among all threads.\n - **default(none|shared|private|firstprivate)** sets the default data-sharing attribute.\n - **firstprivate(list)** specifies private variables initialized from the original.\n - **copyin(list)** copies master thread's THREADPRIVATE data to all threads.\n - **reduction(operator:list)** performs a reduction operation across threads.\n - **if(expr)** conditionally executes in parallel; serial if false.\n - **num_threads(expr)** specifies the number of threads to use.\n - **proc_bind(policy)** specifies thread-to-place binding policy.\n - An implicit barrier exists at the end of the parallel region.\n\n### **Description**\n\n **!$omp parallel** creates a team of threads that execute the enclosed\n structured block in parallel. When a thread encounters a parallel construct,\n a team of threads is created. The thread that encountered the construct\n becomes the master thread (thread number 0) of the new team. All threads\n in the team, including the master thread, execute the parallel region.\n Once the team is created, the number of threads remains constant for\n the duration of that parallel region. At the end of the parallel region,\n an implicit barrier synchronizes all threads before only the master\n thread continues execution.\n\n### **Options**\n\n- **private(list)**\n  : Creates a new instance of each listed variable for each thread. The\n  initial value is undefined. Variables must be definable.\n\n- **shared(list)**\n  : Specifies that listed variables are shared among all threads in the\n  team. All threads access the same storage location.\n\n- **default(none|shared|private|firstprivate)**\n  : Sets the default data-sharing attribute for variables referenced in\n  the parallel region. Using `none` requires explicit specification of\n  all variables. Only one DEFAULT clause is allowed per directive.\n\n- **firstprivate(list)**\n  : Like private, but each thread's copy is initialized from the original\n  variable's value before the parallel region.\n\n- **copyin(list)**\n  : Copies the master thread's THREADPRIVATE common block data to the\n  thread-private copies at the start of the parallel region.\n\n- **reduction([modifier,]operator:list)**\n  : Performs a reduction operation. Each thread has a private copy\n  initialized appropriately. At region end, values are combined using\n  the specified operator (+, *, -, .and., .or., .eqv., .neqv., max, min,\n  iand, ior, ieor).\n\n- **if([parallel:]scalar-logical-expression)**\n  : If the expression evaluates to .false., the region executes serially\n  with a single thread.\n\n- **num_threads(scalar-integer-expression)**\n  : Specifies the number of threads in the team. Must evaluate to a\n  positive integer. Overrides OMP_NUM_THREADS environment variable.\n\n- **proc_bind(master|close|spread)**\n  : Specifies the mapping of threads to places. `master` binds threads\n  to the master's place, `close` binds to places close to the master,\n  `spread` distributes threads across available places.\n\n- **allocate([allocator:]list)**\n  : Specifies the memory allocator for private variables.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_omp_parallel\n  use omp_lib\n  implicit none\n  integer :: thread_id, num_threads\n  integer :: i, n\n  real :: sum_val, local_sum\n  real, allocatable :: array(:)\n\n  n = 1000\n  allocate(array(n))\n  array = [(real(i), i=1,n)]\n  sum_val = 0.0\n\n  ! Basic parallel region\n  !$omp parallel private(thread_id) shared(num_threads)\n    thread_id = omp_get_thread_num()\n    if (thread_id == 0) then\n      num_threads = omp_get_num_threads()\n      print *, 'Number of threads:', num_threads\n    end if\n    print *, 'Hello from thread', thread_id\n  !$omp end parallel\n\n  ! Parallel region with reduction\n  !$omp parallel default(none) shared(array, n) &\n  !$omp& private(i, local_sum) reduction(+:sum_val)\n    local_sum = 0.0\n    !$omp do\n    do i = 1, n\n      local_sum = local_sum + array(i)\n    end do\n    !$omp end do\n    sum_val = sum_val + local_sum\n  !$omp end parallel\n\n  print *, 'Sum of array:', sum_val\n\n  ! Parallel region with conditional execution\n  !$omp parallel if(n > 100) num_threads(4)\n    print *, 'Executing with specified thread count'\n  !$omp end parallel\n\n  deallocate(array)\nend program demo_omp_parallel\n```\n\nCompile with:\n```text\n    gfortran -fopenmp demo_omp_parallel.f90 -o demo_omp_parallel\n    ifort -qopenmp demo_omp_parallel.f90 -o demo_omp_parallel\n```\n\nResults:\n```text\n    Number of threads: 4\n    Hello from thread 0\n    Hello from thread 1\n    Hello from thread 2\n    Hello from thread 3\n    Sum of array: 500500.0\n    Executing with specified thread count\n```\n\n### **Standard**\n\nOpenMP 1.0 (October 1997), with enhancements in subsequent versions:\n - OpenMP 2.5: Added copyin clause\n - OpenMP 3.0: Added IF clause with directive-name-modifier\n - OpenMP 4.0: Added proc_bind clause\n - OpenMP 5.0: Added allocate clause, default(firstprivate) for Fortran\n\n### **See Also**\n\n[**omp_parallel_do**(3)](#omp_parallel_do),\n[**omp_critical**(3)](#omp_critical),\n[**omp_barrier**(3)](#omp_barrier),\n[**omp_single**(3)](#omp_single),\n[**omp_master**(3)](#omp_master),\n[**omp_sections**(3)](#omp_sections)"
  },
  "OpenMP Reduction": {
    "prefix": [
      "ompreduce",
      "OMPREDUCE",
      "reduction",
      "omp_reduction"
    ],
    "body": [
      "!$omp parallel do reduction(${1|+,*,max,min,iand,ior,ieor,.and.,.or.|}:${2:sum}) private(${3:i})",
      "do ${3:i} = ${4:1}, ${5:n}",
      "\t${2:sum} = ${6:${2:sum} ${1:+} ${0:arr(i)}}",
      "end do",
      "!$omp end parallel do"
    ],
    "description": "!$OMP PARALLEL DO REDUCTION(op:var) creates a parallel reduction loop with thread-private copies combined at end."
  },
  "Optional Argument": {
    "prefix": [
      "optional",
      "OPTIONAL"
    ],
    "body": [
      "${1:type}, intent(${2:in}), optional :: ${3:arg}",
      "if (present(${3:arg})) then",
      "\t${0}",
      "end if"
    ],
    "description": "OPTIONAL(ARG) declares an optional dummy argument with presence check."
  },
  "_optional_argument_documentation": {
    "markdown": [
      "## optional_argument",
      "",
      "### **Name**",
      "",
      "**optional_argument** - \\[STRUCTURE:PROCEDURE\\] Declare an optional dummy argument with presence check",
      "",
      "### **Synopsis**",
      "",
      "```fortran",
      "    type, intent(inout), optional :: arg",
      "    if (present(arg)) then",
      "      ! use arg",
      "    end if",
      "```",
      "",
      "```fortran",
      "     subroutine example_procedure(required_arg, optional_arg)",
      "",
      "      type(TYPE(kind=**)), intent(in)           :: required_arg",
      "      type(TYPE(kind=**)), intent(in), optional :: optional_arg",
      "```",
      "",
      "### **Characteristics**",
      "",
      " - **type** is any valid Fortran data type (integer, real, character, logical, or derived type).",
      " - **intent** specifies the data flow direction (in, out, or inout).",
      " - **arg** is the dummy argument name that becomes optional.",
      " - The **present** intrinsic must be used to check if an optional argument was provided before accessing it.",
      "",
      "### **Description**",
      "",
      " **optional_argument** is a pattern for declaring optional dummy arguments in",
      " Fortran procedures. The OPTIONAL attribute allows callers to omit the argument,",
      " and the PRESENT intrinsic function is used to determine at runtime whether the",
      " argument was provided. This enables flexible procedure interfaces without requiring",
      " multiple procedure overloads.",
      "",
      "### **Options**",
      "",
      "- **type**",
      "  : Any valid Fortran type declaration including intrinsic types (integer, real,",
      "  complex, logical, character) or derived types. May include kind specifiers.",
      "",
      "- **intent**",
      "  : Data flow specification for the dummy argument:",
      "  - `in` - argument is read-only (default for optional args)",
      "  - `out` - argument is write-only, undefined on entry",
      "  - `inout` - argument may be read and modified",
      "",
      "- **arg**",
      "  : The name of the optional dummy argument. Must be a valid Fortran identifier.",
      "  Cannot be accessed unless PRESENT(arg) returns .true.",
      "",
      "### **Examples**",
      "",
      "Sample program:",
      "",
      "```fortran",
      "program demo_optional_argument",
      "implicit none",
      "  real :: result",
      "",
      "  ! Call without optional argument (uses default)",
      "  call compute_value(10.0, result)",
      "  print *, 'Without optional: ', result",
      "",
      "  ! Call with optional argument",
      "  call compute_value(10.0, result, scale=2.0)",
      "  print *, 'With optional:    ', result",
      "",
      "contains",
      "",
      "  subroutine compute_value(input, output, scale)",
      "    real, intent(in)           :: input",
      "    real, intent(out)          :: output",
      "    real, intent(in), optional :: scale",
      "",
      "    if (present(scale)) then",
      "      output = input * scale",
      "    else",
      "      output = input  ! Default behavior when scale not provided",
      "    end if",
      "  end subroutine compute_value",
      "",
      "end program demo_optional_argument",
      "```",
      "",
      "Results:",
      "",
      "```text",
      " Without optional:    10.0000000",
      " With optional:       20.0000000",
      "```",
      "",
      "### **Standard**",
      "",
      "Fortran 90",
      "",
      "### **See Also**",
      "",
      "[**present**(3)](#present),",
      "[**intent**(3)](#intent),",
      "[**subroutine**(3)](#subroutine),",
      "[**function**(3)](#function)"
    ]
  },
  "Optional with Default": {
    "prefix": [
      "optdefault",
      "OPTDEFAULT",
      "optionaldefault",
      "OPTIONALDEFAULT"
    ],
    "body": [
      "${1:type} :: ${2:local_var}",
      "if (present(${3:optional_arg})) then",
      "\t${2:local_var} = ${3:optional_arg}",
      "else",
      "\t${2:local_var} = ${0:default_value}",
      "end if"
    ],
    "description": "## optional_with_default\n\n### **Name**\n\n**optional_with_default** - \\[STRUCTURE:PROCEDURE\\] Handle optional argument with default value assignment\n\n### **Synopsis**\n```fortran\n    type :: local_var\n    if (present(optional_arg)) then\n        local_var = optional_arg\n    else\n        local_var = default_value\n    end if\n```\n```fortran\n     ! Pattern for handling optional arguments in procedures\n\n      type, intent(in), optional :: optional_arg\n      type                       :: local_var\n```\n\n### **Characteristics**\n\n - **local_var** is a local variable of any valid Fortran type.\n - **optional_arg** is an optional dummy argument passed to the procedure.\n - **default_value** is the fallback value when optional_arg is not present.\n - The type of local_var, optional_arg, and default_value must be compatible.\n - This pattern creates a local copy to avoid repeated present() checks.\n\n### **Description**\n\n **optional_with_default** is a common Fortran idiom for handling optional\n arguments with default values. It uses the intrinsic PRESENT function to\n test whether an optional argument was provided by the caller, then assigns\n either the provided value or a default to a local variable. This approach\n avoids repeated PRESENT checks throughout the procedure body.\n\n### **Options**\n\n- **type**\n  : The Fortran type declaration for the local variable (e.g., integer,\n  real, character(len=*), type(mytype)). Must match the optional argument type.\n\n- **local_var**\n  : Name of the local variable that will hold the effective value.\n  By convention, often named with a trailing underscore or prefix like\n  'local_' to distinguish from the optional argument.\n\n- **optional_arg**\n  : Name of the optional dummy argument being tested. This must be\n  declared with the OPTIONAL attribute in the procedure interface.\n\n- **default_value**\n  : The value to use when the optional argument is not present.\n  Must be type-compatible with local_var.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_optional_with_default\nimplicit none\n\n  ! Demonstrate optional argument handling\n  call greet(\"Alice\")\n  call greet(\"Bob\", greeting=\"Good morning\")\n  \n  print *, \"Factorial with default: \", factorial(5)\n  print *, \"Factorial with base 0:  \", factorial(5, base=0)\n\ncontains\n\n  subroutine greet(name, greeting)\n    character(len=*), intent(in) :: name\n    character(len=*), intent(in), optional :: greeting\n    \n    ! Handle optional with default\n    character(len=64) :: greeting_local\n    if (present(greeting)) then\n        greeting_local = greeting\n    else\n        greeting_local = \"Hello\"\n    end if\n    \n    print *, trim(greeting_local), \", \", trim(name), \"!\"\n  end subroutine greet\n\n  function factorial(n, base) result(res)\n    integer, intent(in) :: n\n    integer, intent(in), optional :: base\n    integer :: res\n    integer :: i\n    \n    ! Handle optional with default\n    integer :: base_local\n    if (present(base)) then\n        base_local = base\n    else\n        base_local = 1\n    end if\n    \n    res = base_local\n    do i = 2, n\n      res = res * i\n    end do\n  end function factorial\n\nend program demo_optional_with_default\n```\nResults:\n```text\n Hello, Alice!\n Good morning, Bob!\n Factorial with default:          120\n Factorial with base 0:             0\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**present**(3)](#present),\n[**optional**(3)](#optional),\n[**intent**(3)](#intent)"
  },
  "Parameter Constant": {
    "prefix": [
      "parameter",
      "PARAMETER",
      "param",
      "PARAM"
    ],
    "body": [
      "${1:type}, parameter :: ${2:name} = ${0:value}"
    ],
    "description": "## parameter\n\n### **Name**\n\n**parameter** - \\[STRUCTURE:DECLARATION\\] Declare a named constant with a fixed value\n\n### **Synopsis**\n```fortran\n    type, parameter :: name = value\n```\n```fortran\n     type, parameter :: constant_name = literal_value\n\n      integer, parameter          :: constant_name\n      real, parameter             :: constant_name\n      character(*), parameter     :: constant_name\n      logical, parameter          :: constant_name\n```\n\n### **Characteristics**\n\n - **type** is any intrinsic type (integer, real, complex, logical, character) or derived type.\n - **name** is a valid Fortran identifier for the constant.\n - **value** must be a constant expression determinable at compile time.\n - The constant cannot be modified after declaration.\n - Multiple constants can be declared in a single statement.\n\n### **Description**\n\n **parameter** declares a named constant whose value is fixed at compile time\n and cannot be changed during program execution. Named constants improve code\n readability, maintainability, and allow the compiler to perform optimizations.\n\n### **Options**\n\n- **type**\n  : The data type of the constant. Can be any intrinsic type (integer, real,\n  double precision, complex, logical, character) or a derived type. Kind\n  specifiers may be included (e.g., integer(kind=8), real(kind=dp)).\n\n- **name**\n  : A valid Fortran identifier that will be used to reference the constant\n  throughout the program. By convention, parameter names are often written\n  in UPPERCASE to distinguish them from variables.\n\n- **value**\n  : A constant expression that can be evaluated at compile time. May include\n  literal values, other named constants, and intrinsic functions with\n  constant arguments.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_parameter\nimplicit none\n  ! Mathematical constants\n  real, parameter :: PI = 3.14159265358979323846\n  real, parameter :: E = 2.71828182845904523536\n  real, parameter :: TWO_PI = 2.0 * PI\n\n  ! Physical constants (SI units)\n  double precision, parameter :: SPEED_OF_LIGHT = 299792458.0d0  ! m/s\n  double precision, parameter :: PLANCK = 6.62607015d-34        ! J*s\n\n  ! Array dimensions\n  integer, parameter :: MAX_SIZE = 100\n  integer, parameter :: NUM_DIMS = 3\n\n  ! Character constants\n  character(*), parameter :: VERSION = '1.0.0'\n  character(*), parameter :: AUTHOR = 'Fortran Developer'\n\n  ! Logical constants\n  logical, parameter :: DEBUG_MODE = .true.\n\n  ! Multiple declarations in one statement\n  integer, parameter :: ROWS = 10, COLS = 20, LAYERS = 5\n\n  ! Using parameters\n  real :: circle_area, radius\n  real :: data(MAX_SIZE)\n  integer :: matrix(ROWS, COLS)\n\n  radius = 5.0\n  circle_area = PI * radius**2\n\n  print *, 'Program version: ', VERSION\n  print *, 'Pi value: ', PI\n  print *, 'Circle area (r=5): ', circle_area\n  print *, 'Max array size: ', MAX_SIZE\n  print *, 'Matrix dimensions: ', ROWS, 'x', COLS\n\nend program demo_parameter\n```\nResults:\n```text\n Program version: 1.0.0\n Pi value:    3.14159274\n Circle area (r=5):    78.5398178\n Max array size:          100\n Matrix dimensions:           10 x          20\n```\n\n### **Standard**\n\nFortran 77\n\n### **See Also**\n\n[**integer**(3)](#integer),\n[**real**(3)](#real),\n[**character**(3)](#character),\n[**implicit**(3)](#implicit)"
  },
  "Pi Constant": {
    "prefix": [
      "pi",
      "PI"
    ],
    "body": [
      "real(${1:dp}), parameter :: ${2:pi} = 4.0_${1:dp} * atan(1.0_${1:dp})"
    ],
    "description": "PI = 4*atan(1) defines the mathematical constant pi using the arctangent identity."
  },
  "_pi_constant_documentation": {
    "Name": "**pi** - \\[NUMERIC:CONSTANT\\] Define mathematical constant pi using arctangent identity",
    "Synopsis": {
      "usage": "real(KIND), parameter :: pi = 4.0_KIND * atan(1.0_KIND)",
      "interface": "     real(KIND), parameter :: pi = 4.0_KIND * atan(1.0_KIND)\n\n      integer, parameter :: KIND  ! Kind parameter (e.g., dp for double precision)\n      real(KIND)         :: pi    ! Mathematical constant pi (3.14159265...)"
    },
    "Characteristics": [
      "**KIND** is an integer constant specifying the precision (e.g., selected_real_kind(15,307) for double precision).",
      "**pi** is a named constant (parameter) of type real with the specified kind.",
      "The value is computed at compile time using the intrinsic function atan.",
      "The result has full precision for the specified kind parameter."
    ],
    "Description": "**pi** defines the mathematical constant pi (approximately 3.14159265358979...) using the trigonometric identity that atan(1) = pi/4. This is the standard portable method in Fortran to obtain pi to full machine precision for any real kind. The identity works because the arctangent of 1 (i.e., tan(45 degrees)) equals pi/4 radians. Multiplying by 4 yields pi. This approach is preferred over hardcoding decimal digits because: (1) it automatically provides the correct precision for any kind parameter, (2) the compiler evaluates it at compile time with no runtime cost, and (3) it avoids transcription errors from typing many digits.",
    "Options": [
      {
        "name": "KIND",
        "description": "The kind parameter specifying the precision of the real constant. Common choices include: sp (single precision, typically 6-7 significant digits), dp (double precision, typically 15-16 significant digits), or qp (quad precision, typically 33-34 significant digits). The kind should be defined elsewhere in the program using selected_real_kind or iso_fortran_env constants."
      },
      {
        "name": "pi",
        "description": "The name of the parameter constant. While 'pi' is conventional, any valid Fortran identifier can be used. The parameter attribute ensures the value cannot be modified during program execution."
      }
    ],
    "Examples": {
      "code": "program demo_pi_constant\n  use, intrinsic :: iso_fortran_env, only: sp=>real32, dp=>real64\n  implicit none\n\n  ! Define pi for different precisions using 4*atan(1) identity\n  real(sp), parameter :: pi_sp = 4.0_sp * atan(1.0_sp)\n  real(dp), parameter :: pi_dp = 4.0_dp * atan(1.0_dp)\n\n  real(dp) :: radius, area, circumference\n\n  ! Display pi values at different precisions\n  print '(a)',        'Pi constant demonstration'\n  print '(a)',        '========================'\n  print '(a,f12.7)',  'Single precision pi: ', pi_sp\n  print '(a,f22.16)', 'Double precision pi: ', pi_dp\n\n  ! Example: Calculate circle properties\n  radius = 2.5_dp\n  area = pi_dp * radius**2\n  circumference = 2.0_dp * pi_dp * radius\n\n  print '(a)',           ''\n  print '(a)',           'Circle with radius 2.5:'\n  print '(a,f12.6)',     '  Area:          ', area\n  print '(a,f12.6)',     '  Circumference: ', circumference\n\n  ! Verify the identity: atan(1) = pi/4\n  print '(a)',           ''\n  print '(a)',           'Verification:'\n  print '(a,f22.16)',    '  atan(1.0_dp):    ', atan(1.0_dp)\n  print '(a,f22.16)',    '  pi_dp / 4:       ', pi_dp / 4.0_dp\n\nend program demo_pi_constant",
      "results": "Pi constant demonstration\n========================\nSingle precision pi:    3.1415927\nDouble precision pi:    3.1415926535897931\n\nCircle with radius 2.5:\n  Area:            19.634954\n  Circumference:   15.707963\n\nVerification:\n  atan(1.0_dp):      0.7853981633974483\n  pi_dp / 4:         0.7853981633974483"
    },
    "Standard": "Fortran 90",
    "See_Also": [
      "**atan**(3) - Arctangent function",
      "**selected_real_kind**(3) - Select real kind by precision",
      "**iso_fortran_env**(3) - Intrinsic module with real32, real64, real128 kind constants",
      "**acos**(3) - Alternative: pi = acos(-1.0)"
    ]
  },
  "Pointer Assignment": {
    "prefix": [
      "ptrassign",
      "PTRASSIGN",
      "=>"
    ],
    "body": [
      "${1:pointer} => ${0:target}"
    ],
    "description": "pointer => target associates a pointer with a target variable or expression.",
    "documentation": {
      "name": "**=>** - \\[MEMORY:POINTER\\] Associate a pointer with a target",
      "synopsis": {
        "usage": "```fortran\n    pointer => target\n```",
        "interface": "```fortran\n     pointer => target\n\n      type(TYPE(kind=**)), pointer     :: pointer\n      type(TYPE(kind=**)), target      :: target\n```"
      },
      "characteristics": [
        "**pointer** is a variable with the POINTER attribute of any type.",
        "**target** is a variable with the TARGET attribute, another pointer, or a valid pointer target expression.",
        "**pointer** and **target** must have the same type, kind, and rank.",
        "After association, **pointer** references the same storage as **target**."
      ],
      "description": "**=>** is the pointer assignment operator. It associates a pointer variable with a target, causing the pointer to reference the same data as the target. Unlike ordinary assignment (=) which copies values, pointer assignment establishes an alias relationship where both the pointer and target refer to the same memory location. The pointer can subsequently be used to access or modify the target's data.",
      "options": {
        "pointer": "A variable declared with the POINTER attribute. Must be of compatible type, kind, and rank with the target. Can be a scalar, array, or derived type pointer.",
        "target": "A variable declared with the TARGET attribute, another pointer that is currently associated, or a valid pointer target expression (such as an array section or structure component with the TARGET attribute). Must have the same type, kind, and rank as the pointer."
      },
      "examples": {
        "code": "program demo_pointer_assignment\nimplicit none\n  ! Declarations\n  integer, target  :: x = 10\n  integer, pointer :: p\n  real, dimension(5), target  :: arr = [1.0, 2.0, 3.0, 4.0, 5.0]\n  real, dimension(:), pointer :: arr_ptr\n  type :: node\n    integer :: value\n    type(node), pointer :: next => null()\n  end type node\n  type(node), target  :: first\n  type(node), pointer :: current\n\n  ! Basic scalar pointer assignment\n  p => x\n  print *, 'x =', x\n  print *, 'p =>', p\n\n  ! Modify target through pointer\n  p = 20\n  print *, 'After p = 20:'\n  print *, 'x =', x\n  print *, 'p =>', p\n\n  ! Array pointer assignment\n  arr_ptr => arr\n  print *, 'arr_ptr =>', arr_ptr\n\n  ! Pointer to array section\n  arr_ptr => arr(2:4)\n  print *, 'arr(2:4) =>', arr_ptr\n\n  ! Derived type pointer (linked list node)\n  first%value = 100\n  current => first\n  print *, 'current%value =>', current%value\n\n  ! Disassociate pointer\n  nullify(p)\n  print *, 'p associated?', associated(p)\n\nend program demo_pointer_assignment",
        "results": "```text\n x =          10\n p =>          10\n After p = 20:\n x =          20\n p =>          20\n arr_ptr =>   1.00000000       2.00000000       3.00000000       4.00000000       5.00000000\n arr(2:4) =>   2.00000000       3.00000000       4.00000000\n current%value =>         100\n p associated? F\n```"
      },
      "standard": "Fortran 90",
      "see_also": [
        "[**associated**(3)](#associated) - Test pointer association status",
        "[**null**(3)](#null) - Return a disassociated pointer",
        "[**nullify**(3)](#nullify) - Disassociate a pointer",
        "[**allocate**(3)](#allocate) - Allocate memory for a pointer target",
        "[**deallocate**(3)](#deallocate) - Free pointer-allocated memory"
      ]
    }
  },
  "Procedure Argument": {
    "prefix": [
      "procarg",
      "PROCARG",
      "callback",
      "CALLBACK"
    ],
    "body": [
      "subroutine ${1:subroutine_name}(${2:callback})",
      "  implicit none",
      "  interface",
      "    ${3:subroutine} ${2:callback}(${4:arg})",
      "      ${5:real}, intent(${6:in}) :: ${4:arg}",
      "    end ${3:subroutine} ${2:callback}",
      "  end interface",
      "",
      "  ${0:! Use callback here}",
      "end subroutine ${1:subroutine_name}"
    ],
    "description": "PROCEDURE_ARGUMENT(CALLBACK) defines a subroutine with an explicit interface block for passing procedures as arguments."
  },
  "Procedure Pointer": {
    "prefix": [
      "procptr",
      "PROCPTR",
      "procedurepointer",
      "PROCEDUREPOINTER"
    ],
    "body": "procedure(${1:interface}), pointer :: ${2:ptr} => null()",
    "description": "procedure(interface), pointer :: ptr => null() declares a procedure pointer with an explicit interface."
  },
  "_procedure_pointer_documentation": {
    "markdown": "## procedure_pointer\n\n### **Name**\n\n**procedure_pointer** - \\[MEMORY:POINTER\\] Declare a procedure pointer with an explicit interface\n\n### **Synopsis**\n```fortran\n    procedure(interface), pointer :: ptr => null()\n```\n```fortran\n     procedure(interface_name), pointer :: procedure_pointer_name\n\n      abstract interface\n        function interface_name(arg) result(res)\n          type(TYPE), intent(in) :: arg\n          type(TYPE)             :: res\n        end function\n      end interface\n```\n\n### **Characteristics**\n\n - **interface** is the name of an abstract interface, a procedure, or a procedure type that defines the signature of procedures this pointer can reference.\n - **ptr** is the name of the procedure pointer variable being declared.\n - The pointer is initialized to **null()** to ensure a known initial state.\n - Procedure pointers can point to external procedures, module procedures, or internal procedures.\n - The target procedure must have the same characteristics (arguments, result type) as the interface.\n\n### **Description**\n\n **procedure_pointer** declares a pointer variable that can reference procedures\n (functions or subroutines) rather than data. The procedure pointer must be\n associated with a target procedure that has matching characteristics defined\n by the specified interface. Procedure pointers enable runtime polymorphism,\n callback mechanisms, and dynamic procedure selection patterns.\n\n### **Options**\n\n- **interface**\n  : The name of an abstract interface block, an existing procedure, or a\n  procedure type that specifies the signature (argument types, return type,\n  and attributes) of procedures that can be assigned to this pointer.\n\n- **ptr**\n  : The name of the procedure pointer being declared. Must be a valid Fortran\n  identifier. The pointer can be reassigned to different target procedures\n  during program execution.\n\n- **null()**\n  : Initial value indicating the pointer is not associated with any target.\n  This initialization is optional but recommended to ensure a defined initial\n  state. Use **associated(ptr)** to check if the pointer is associated.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_procedure_pointer\nimplicit none\n\n  ! Define an abstract interface for mathematical operations\n  abstract interface\n    function math_op(x, y) result(res)\n      real, intent(in) :: x, y\n      real             :: res\n    end function math_op\n  end interface\n\n  ! Declare a procedure pointer with the math_op interface\n  procedure(math_op), pointer :: operation => null()\n\n  real :: a, b, result\n\n  a = 10.0\n  b = 3.0\n\n  ! Check initial association status\n  print *, 'Pointer associated initially:', associated(operation)\n\n  ! Point to the add function\n  operation => add\n  result = operation(a, b)\n  print *, 'add(10, 3) =', result\n\n  ! Point to the multiply function\n  operation => multiply\n  result = operation(a, b)\n  print *, 'multiply(10, 3) =', result\n\n  ! Point to the subtract function\n  operation => subtract\n  result = operation(a, b)\n  print *, 'subtract(10, 3) =', result\n\n  ! Nullify the pointer\n  operation => null()\n  print *, 'Pointer associated after nullify:', associated(operation)\n\ncontains\n\n  function add(x, y) result(res)\n    real, intent(in) :: x, y\n    real             :: res\n    res = x + y\n  end function add\n\n  function multiply(x, y) result(res)\n    real, intent(in) :: x, y\n    real             :: res\n    res = x * y\n  end function multiply\n\n  function subtract(x, y) result(res)\n    real, intent(in) :: x, y\n    real             :: res\n    res = x - y\n  end function subtract\n\nend program demo_procedure_pointer\n```\nResults:\n```text\n Pointer associated initially: F\n add(10, 3) =   13.0000000\n multiply(10, 3) =   30.0000000\n subtract(10, 3) =   7.00000000\n Pointer associated after nullify: F\n```\n\n### **Standard**\n\nFortran 2003\n\n### **See Also**\n\n[**associated**(3)](#associated),\n[**null**(3)](#null),\n[**abstract_interface**](#abstract_interface),\n[**pointer_assignment**](#pointer_assignment)"
  },
  "Random Number": {
    "prefix": [
      "random_number",
      "RANDOM_NUMBER"
    ],
    "body": "call random_number(${1:harvest})",
    "description": "RANDOM_NUMBER(HARVEST) returns pseudorandom numbers from the uniform distribution in the range 0 <= x < 1.",
    "documentation": {
      "name": "**random_number** - \\[NUMERIC:ELEMENTAL\\] Returns pseudorandom numbers from a uniform distribution",
      "synopsis": {
        "usage": "call random_number(harvest)",
        "interface": [
          "subroutine random_number(harvest)",
          "",
          "  real(kind=**), intent(out) :: harvest(..)",
          "end subroutine random_number"
        ]
      },
      "characteristics": [
        "**harvest** is a real variable of any kind.",
        "**harvest** may be a scalar or an array of any rank.",
        "The result values are in the range 0 <= x < 1."
      ],
      "description": "**random_number** returns pseudorandom numbers from the uniform distribution over the range 0 <= x < 1. The runtime library implementation determines the quality and period of the random sequence. For reproducible sequences, use **random_seed** to initialize the generator.",
      "options": {
        "harvest": "A real scalar or array that will be filled with pseudorandom values. Each element receives an independent sample from the uniform distribution in the range [0, 1). The kind of real determines the precision of the values."
      },
      "examples": {
        "description": "Sample program demonstrating random_number usage:",
        "code": [
          "program demo_random_number",
          "implicit none",
          "  real :: r",
          "  real :: array(5)",
          "  real :: matrix(3, 3)",
          "  integer :: i",
          "",
          "  ! Generate a single random number",
          "  call random_number(r)",
          "  print '(A,F10.6)', 'Single random value: ', r",
          "",
          "  ! Fill an array with random numbers",
          "  call random_number(array)",
          "  print '(A)', 'Random array:'",
          "  do i = 1, 5",
          "    print '(A,I1,A,F10.6)', '  array(', i, ') = ', array(i)",
          "  end do",
          "",
          "  ! Fill a matrix with random numbers",
          "  call random_number(matrix)",
          "  print '(A)', 'Random 3x3 matrix:'",
          "  do i = 1, 3",
          "    print '(3F10.6)', matrix(i, :)",
          "  end do",
          "",
          "  ! Generate random integers in a range [1, 6] (dice roll)",
          "  call random_number(r)",
          "  print '(A,I1)', 'Dice roll: ', int(r * 6.0) + 1",
          "",
          "end program demo_random_number"
        ],
        "results": [
          "Single random value:   0.372845",
          "Random array:",
          "  array(1) =   0.891234",
          "  array(2) =   0.123456",
          "  array(3) =   0.567890",
          "  array(4) =   0.234567",
          "  array(5) =   0.789012",
          "Random 3x3 matrix:",
          "  0.345678  0.456789  0.567890",
          "  0.678901  0.789012  0.890123",
          "  0.901234  0.012345  0.123456",
          "Dice roll: 3"
        ]
      },
      "standard": "Fortran 95",
      "see_also": [
        "**random_seed**(3) - Initialize the pseudorandom number generator",
        "**random_init**(3) - Initialize the pseudorandom number generator (Fortran 2018)"
      ]
    }
  },
  "tier1_signature": {
    "RANDOM_SEED": {
      "args": "SIZE=size,PUT=put,GET=get",
      "doc": "RANDOM_SEED(SIZE=size,PUT=put,GET=get) initializes or retrieves the state of the pseudorandom number generator.",
      "type": 2
    }
  },
  "tier2_documentation": {
    "RANDOM_SEED": "## random_seed\n\n### **Name**\n\n**random_seed** - \\[NUMERIC:SUBROUTINE\\] Initialize or query the pseudorandom number generator seed\n\n### **Synopsis**\n```fortran\n    call random_seed([size] [,put] [,get])\n```\n```fortran\n     subroutine random_seed(size, put, get)\n\n      integer, intent(out), optional :: size\n      integer, intent(in),  optional :: put(:)\n      integer, intent(out), optional :: get(:)\n```\n\n### **Characteristics**\n\n - **size** is an optional scalar _integer_ with intent(out).\n - **put** is an optional rank-one _integer_ array with intent(in).\n - **get** is an optional rank-one _integer_ array with intent(out).\n - All arguments are optional, but at most one may be specified per call.\n - The array arguments **put** and **get** must have at least **size** elements.\n\n### **Description**\n\n **random_seed** initializes, retrieves, or queries the state of the\n pseudorandom number generator used by **random_number**.\n\n When called with no arguments, **random_seed** initializes the generator\n to a processor-dependent state (which may be the same on each program\n execution unless a system-specific seed is used).\n\n The size of the seed array is processor-dependent and can be queried\n using the **size** argument.\n\n### **Options**\n\n- **size**\n  : Returns the size of the integer array needed to hold the seed value.\n  This is processor-dependent and must be queried before using **put**\n  or **get**.\n\n- **put**\n  : Sets the seed of the random number generator. The array must have\n  at least **size** elements. The values determine the sequence of\n  pseudorandom numbers that will be generated.\n\n- **get**\n  : Retrieves the current seed of the random number generator. The array\n  must have at least **size** elements. This allows saving and restoring\n  the generator state for reproducibility.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_random_seed\nimplicit none\n  integer :: n\n  integer, allocatable :: seed(:)\n  real :: x\n\n  ! Query the size of the seed array\n  call random_seed(size=n)\n  print '(a,i0)', 'Seed array size: ', n\n\n  ! Allocate seed array\n  allocate(seed(n))\n\n  ! Get current seed\n  call random_seed(get=seed)\n  print '(a,*(i0,:,\",\"))', 'Current seed: ', seed\n\n  ! Generate a random number\n  call random_number(x)\n  print '(a,f10.6)', 'Random number 1: ', x\n\n  ! Restore the seed to reproduce the same sequence\n  call random_seed(put=seed)\n  call random_number(x)\n  print '(a,f10.6)', 'Random number 2 (same seed): ', x\n\n  ! Initialize with a specific seed for reproducibility\n  seed = 12345\n  call random_seed(put=seed)\n  call random_number(x)\n  print '(a,f10.6)', 'Random with fixed seed: ', x\n\n  ! Re-initialize to get the same result\n  seed = 12345\n  call random_seed(put=seed)\n  call random_number(x)\n  print '(a,f10.6)', 'Same fixed seed again: ', x\n\n  deallocate(seed)\nend program demo_random_seed\n```\nResults:\n```text\n    Seed array size: 8\n    Current seed: 123456789,987654321,111111111,222222222,333333333,444444444,555555555,666666666\n    Random number 1:   0.347826\n    Random number 2 (same seed):   0.347826\n    Random with fixed seed:   0.218419\n    Same fixed seed again:   0.218419\n```\n\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**random_number**(3)](#random_number)"
  },
  "vscode_snippet": {
    "Random Number Seed": {
      "prefix": [
        "random_seed",
        "RANDOM_SEED"
      ],
      "body": [
        "! Initialize random number generator",
        "integer :: seed_size",
        "integer, allocatable :: seed(:)",
        "",
        "call random_seed(size=seed_size)",
        "allocate(seed(seed_size))",
        "",
        "! Option 1: Use system-dependent initialization",
        "call random_seed()",
        "",
        "! Option 2: Set reproducible seed",
        "seed = ${1:12345}",
        "call random_seed(put=seed)"
      ],
      "description": "RANDOM_SEED(SIZE=size,PUT=put,GET=get) initializes or retrieves the state of the pseudorandom number generator."
    }
  },
  "Read Formatted": {
    "prefix": [
      "readfmt",
      "READFMT"
    ],
    "body": [
      "read(${1:unit}, '(${2:format})') ${0:var}"
    ],
    "description": "READ(UNIT,'(FORMAT)') VAR reads formatted data from a file or standard input.",
    "documentation": {
      "name": "**read** - \\[IO:INPUT\\] Read formatted data from a file or standard input",
      "synopsis": {
        "usage": "read(unit, '(format)') var1, var2, ...",
        "interface": "     read(unit_number, format_specifier) variable_list\n\n      integer, intent(in)           :: unit_number\n      character(len=*), intent(in)  :: format_specifier\n      type(*), intent(out)          :: variable_list"
      },
      "characteristics": [
        "**unit** is an integer representing the file unit number, or * for standard input",
        "**format** is a character string specifying the format descriptor (e.g., I5, F10.3, A20)",
        "**var** is one or more variables to receive the input data",
        "The types of variables must match the format descriptors provided",
        "Unit 5 is typically standard input; * can also be used for keyboard input"
      ],
      "description": "**read** transfers formatted data from an external file or standard input into program variables. The format specifier controls how characters in the input record are interpreted and converted to internal representation. Format descriptors like I (integer), F (real), E (exponential), A (character), and L (logical) define the conversion rules.",
      "options": {
        "unit": "An integer expression specifying the unit number connected to the input file. Use * or 5 for standard input. The unit must be connected to a file opened for formatted sequential or direct access reading.",
        "format": "A character expression containing format edit descriptors enclosed in parentheses. Common descriptors include: Iw (integer width w), Fw.d (real width w with d decimal places), Ew.d (exponential notation), Aw (character width w), Lw (logical), nX (skip n positions), / (new record).",
        "var": "One or more variables to receive the input values. The number and types of variables must correspond to the format descriptors. Arrays can be read element by element or using implied do loops."
      },
      "examples": {
        "code": "program demo_read_formatted\nimplicit none\n  integer :: unit_num, ios\n  integer :: id\n  real :: temperature, pressure\n  character(len=20) :: name\n  \n  ! Example 1: Read from standard input with format\n  print *, 'Enter an integer and a real (I5,F10.2 format):'\n  read(*, '(I5,F10.2)') id, temperature\n  print *, 'Read id:', id, ' temperature:', temperature\n  \n  ! Example 2: Read from a file with format\n  unit_num = 10\n  open(unit=unit_num, file='data.txt', status='old', &\n       action='read', iostat=ios)\n  if (ios == 0) then\n    read(unit_num, '(A20,I5,F10.3)') name, id, pressure\n    print *, 'Name:', trim(name)\n    print *, 'ID:', id\n    print *, 'Pressure:', pressure\n    close(unit_num)\n  else\n    print *, 'Error opening file'\n  end if\n  \n  ! Example 3: Read multiple values with repeated format\n  ! Input line: \"  123  456  789\"\n  ! read(*, '(3I5)') i1, i2, i3\n\nend program demo_read_formatted",
        "results": "Enter an integer and a real (I5,F10.2 format):\n  100     25.50\n Read id: 100  temperature: 25.50\n Name: Sample Data         \n ID: 42\n Pressure: 101.325"
      },
      "standard": "Fortran 77 (enhanced in Fortran 90/95/2003 with additional features)",
      "see_also": [
        "**write**(3) - Write formatted data to a file or standard output",
        "**open**(3) - Connect a file to a unit number",
        "**close**(3) - Disconnect a file from a unit number",
        "**read_unformatted**(3) - Read unformatted (binary) data",
        "**read_list_directed**(3) - Read with list-directed (free format) input"
      ]
    }
  },
  "Read Formatted Multiple": {
    "prefix": [
      "readfmtmulti",
      "READFMTMULTI"
    ],
    "body": "read(${1:unit}, '(${2:I5}, ${3:F10.3}, ${4:A20})') ${5:int_var}, ${6:real_var}, ${7:char_var}",
    "description": "READ(UNIT,FMT) reads multiple values with explicit format descriptors from a unit."
  },
  "Read from String": {
    "prefix": [
      "readstr",
      "READSTR",
      "readstring",
      "READSTRING",
      "internalread",
      "INTERNALREAD"
    ],
    "body": [
      "read(${1:string}, ${2:*}) ${0:var}"
    ],
    "description": "READ(STRING,FMT) reads formatted data from an internal character variable instead of an external file.\n\n### **Name**\n\n**read** - \\[IO:INPUT\\] Read formatted data from an internal character variable (internal read)\n\n### **Synopsis**\n```fortran\n    read(string, fmt) var1, var2, ...\n```\n```fortran\n     read(unit=string, fmt=format_spec, iostat=ios, iomsg=msg) var_list\n\n      character(len=*), intent(in)  :: string\n      character(len=*), intent(in)  :: format_spec  ! or *\n      integer, intent(out), optional :: ios\n      character(len=*), intent(inout), optional :: msg\n```\n\n### **Characteristics**\n\n - **string** is a character variable or array containing the data to be read.\n - **fmt** is a format specification (character expression, label, or * for list-directed).\n - **var** is the variable(s) to receive the parsed data.\n - The internal file must contain valid formatted data matching the format specification.\n - No file unit number is used; the character variable serves as the \"file\".\n\n### **Description**\n\n **read** with an internal file (character variable) parses formatted data from a string into program variables. This is commonly used for:\n - Converting strings to numeric values\n - Parsing user input that was read as a character string\n - Processing data from non-file sources\n - Extracting values from formatted text buffers\n\n The character variable acts as an internal file, with each element of a character array treated as a separate record.\n\n### **Options**\n\n- **string**\n  : A character variable, substring, or array containing formatted data to be parsed. For arrays, each element is treated as a separate record (line).\n\n- **fmt**\n  : Format specification controlling how data is interpreted. Can be:\n  - `*` for list-directed (free-format) reading\n  - A character expression containing format descriptors\n  - A statement label referencing a FORMAT statement\n  - `'(format-descriptors)'` as a literal string\n\n- **var**\n  : One or more variables to receive the parsed values. Types must match the format specification.\n\n- **iostat=** (optional)\n  : Integer variable set to zero on success, positive on error, negative on end-of-record/file.\n\n- **iomsg=** (optional)\n  : Character variable that receives an error message if an error occurs.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_internal_read\nimplicit none\n  character(len=50) :: input_string\n  character(len=20) :: name\n  integer :: age, ios\n  real :: temperature, value\n  character(len=100) :: errmsg\n\n  ! Example 1: Simple numeric conversion from string\n  input_string = '42'\n  read(input_string, *) age\n  print *, 'Age:', age\n\n  ! Example 2: Reading multiple values\n  input_string = '98.6  37.0'\n  read(input_string, *) temperature, value\n  print *, 'Temperature F:', temperature, ' C:', value\n\n  ! Example 3: Using explicit format\n  input_string = 'John                  25'\n  read(input_string, '(A20, I5)') name, age\n  print *, 'Name:', trim(name), ' Age:', age\n\n  ! Example 4: Error handling with iostat\n  input_string = 'not_a_number'\n  read(input_string, *, iostat=ios, iomsg=errmsg) value\n  if (ios /= 0) then\n    print *, 'Read error:', trim(errmsg)\n  else\n    print *, 'Value:', value\n  end if\n\n  ! Example 5: Reading from string with complex format\n  input_string = '2024-01-15'\n  block\n    integer :: year, month, day\n    read(input_string, '(I4, 1X, I2, 1X, I2)') year, month, day\n    print *, 'Date: Year=', year, ' Month=', month, ' Day=', day\n  end block\n\nend program demo_internal_read\n```\nResults:\n```text\n Age:          42\n Temperature F:   98.5999985      C:   37.0000000\n Name:John                  Age:          25\n Read error: Invalid argument\n Date: Year=        2024  Month=           1  Day=          15\n```\n\n### **Standard**\n\nFortran 77 (internal files introduced in F77; IOMSG added in Fortran 2003)\n\n### **See Also**\n\n[**write**(3)](#write) (internal write for converting values to strings),\n[**read**(3)](#read) (external file read),\n[**open**(3)](#open),\n[**format**(3)](#format)"
  },
  "Read With Error Check": {
    "prefix": [
      "readcheck",
      "READCHECK"
    ],
    "body": [
      "read(${1:unit}, ${2:*}, iostat=${3:ierr}) ${4:var}",
      "if (${3:ierr} /= 0) error stop '${5:Read error}'"
    ],
    "description": "READ(UNIT,FMT,IOSTAT=ierr) reads data with error checking via iostat and error stop."
  },
  "Real Kind real64": {
    "prefix": [
      "real64",
      "REAL64"
    ],
    "body": [
      "real(real64) :: ${0:var}"
    ],
    "description": "REAL(real64) [NUMERIC:DECLARATION] Declares a 64-bit (double precision) real variable.\n\n### **Synopsis**\n\n```fortran\nuse, intrinsic :: iso_fortran_env, only: real64\nreal(real64) :: variable_name\n```\n\n```fortran\n     real(kind=real64) :: variable_name\n\n      integer, parameter :: real64 = selected_real_kind(15, 307)\n```\n\n### **Characteristics**\n\n - **real64** is a named constant from the `iso_fortran_env` intrinsic module.\n - The kind value represents a real type with at least 15 decimal digits of precision and an exponent range of at least 307.\n - Equivalent to `double precision` on most systems (IEEE 754 binary64 format).\n - Storage size is typically 64 bits (8 bytes).\n\n### **Description**\n\n **real(real64)** declares a variable of 64-bit floating-point type using the portable `real64` kind parameter from the `iso_fortran_env` module. This provides a standardized way to declare double-precision real variables across different compilers and platforms, avoiding the non-portable `double precision` keyword or magic kind numbers.\n\n### **Options**\n\n- **var**\n  : The name of the variable being declared. Can be a scalar or array with any valid Fortran array specification.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_real64\n  use, intrinsic :: iso_fortran_env, only: real64\n  implicit none\n\n  real(real64) :: x\n  real(real64) :: pi\n  real(real64), dimension(3) :: coords\n  real(real64), parameter :: tolerance = 1.0e-12_real64\n\n  ! Assign values with appropriate literal suffix\n  pi = 3.141592653589793_real64\n  x = 1.0_real64 / 3.0_real64\n\n  ! Array assignment\n  coords = [1.5_real64, 2.5_real64, 3.5_real64]\n\n  print '(A,I0)', 'Kind of real64: ', real64\n  print '(A,I0)', 'Storage size (bits): ', storage_size(x)\n  print '(A,I0)', 'Precision (digits): ', precision(x)\n  print '(A,I0)', 'Exponent range: ', range(x)\n  print '(A,ES23.16)', 'Value of pi: ', pi\n  print '(A,ES23.16)', 'Value of 1/3: ', x\n  print '(A,3ES12.4)', 'Coordinates: ', coords\n\nend program demo_real64\n```\n\nResults:\n\n```text\nKind of real64: 8\nStorage size (bits): 64\nPrecision (digits): 15\nExponent range: 307\nValue of pi:  3.1415926535897931E+00\nValue of 1/3:  3.3333333333333331E-01\nCoordinates:   1.5000E+00  2.5000E+00  3.5000E+00\n```\n\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\n[**real32**(3)](#real32), [**real128**(3)](#real128), [**selected_real_kind**(3)](#selected_real_kind), [**precision**(3)](#precision), [**range**(3)](#range), [**iso_fortran_env**(3)](#iso_fortran_env)"
  },
  "Reshape with Order": {
    "prefix": [
      "reshapeorder",
      "RESHAPEORDER"
    ],
    "body": "reshape(${1:source}, [${2:m}, ${3:n}], order=[${4:2}, ${5:1}])",
    "description": "RESHAPE(SOURCE,SHAPE,PAD=pad,ORDER=order) constructs an array with a specified shape from the elements of a given array."
  },
  "Select Rank": {
    "prefix": [
      "selectrank",
      "SELECTRANK",
      "select rank",
      "SELECT RANK"
    ],
    "body": [
      "select rank (${1:arr})",
      "\trank (0)",
      "\t\t${2:! scalar case}",
      "\trank (1)",
      "\t\t${3:! rank-1 array}",
      "\trank (2)",
      "\t\t${4:! rank-2 array}",
      "\trank default",
      "\t\t${0:! handle other ranks}",
      "end select"
    ],
    "description": "## select_rank\n\n### **Name**\n\n**select_rank** - \\[CONTROL:CONDITIONAL\\] Select code block based on the rank of an assumed-rank array\n\n### **Synopsis**\n```fortran\n    select rank (array-name)\n      rank (0)\n        ! scalar case\n      rank (n)\n        ! rank-n array handling\n      rank default\n        ! handle other ranks\n    end select\n```\n```fortran\n     select rank (selector)\n\n      type(*), dimension(..) :: selector  ! assumed-rank array\n      ! Inside rank(n) block, selector has rank n\n      ! Inside rank(*), selector is assumed-size\n      ! Inside rank default, selector is assumed-rank\n```\n\n### **Characteristics**\n\n - **selector** is an assumed-rank variable (declared with `dimension(..)`).\n - Each **rank (n)** block receives the variable with the specified rank.\n - **rank (*)** handles assumed-size arrays passed from older code.\n - **rank default** catches all unspecified ranks; selector remains assumed-rank.\n - Only one rank block executes based on the actual rank at runtime.\n\n### **Description**\n\n **select_rank** provides a mechanism to handle assumed-rank dummy arguments\n by selecting code blocks based on the actual rank of the array at runtime.\n This construct is essential for writing generic procedures that accept\n arrays of any rank while providing type-safe, rank-specific implementations.\n Within each rank block, the assumed-rank variable becomes a regular array\n with the specified rank, enabling standard array operations.\n\n### **Options**\n\n- **selector**\n  : The assumed-rank dummy argument to inspect. Must be declared with\n  `dimension(..)`. Can optionally include an associate-name using\n  `select rank (name => selector)` syntax.\n\n- **rank (n)**\n  : Executes when selector has rank n (0 for scalar, 1-15 for arrays).\n  Inside this block, the selector has the specified fixed rank.\n\n- **rank (*)**\n  : Executes when an assumed-size array is passed. The selector becomes\n  assumed-size `dimension(*)` inside this block.\n\n- **rank default**\n  : Executes when no other rank case matches. The selector remains\n  assumed-rank inside this block (limited operations available).\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_select_rank\nimplicit none\n  real :: scalar_val = 3.14\n  real :: array_1d(5) = [1.0, 2.0, 3.0, 4.0, 5.0]\n  real :: array_2d(2,3) = reshape([1.0,2.0,3.0,4.0,5.0,6.0], [2,3])\n  real :: array_3d(2,2,2) = 1.0\n\n  print '(a)', 'Testing scalar:'\n  call print_rank(scalar_val)\n\n  print '(a)', 'Testing rank-1 array:'\n  call print_rank(array_1d)\n\n  print '(a)', 'Testing rank-2 array:'\n  call print_rank(array_2d)\n\n  print '(a)', 'Testing rank-3 array:'\n  call print_rank(array_3d)\n\ncontains\n\n  subroutine print_rank(arr)\n    real, dimension(..), intent(in) :: arr\n\n    select rank (arr)\n      rank (0)\n        print '(a,f6.2)', '  Scalar value: ', arr\n      rank (1)\n        print '(a,i0)', '  Rank-1 array, size: ', size(arr)\n        print '(a,*(f6.2,1x))', '  Elements: ', arr\n      rank (2)\n        print '(a,i0,a,i0)', '  Rank-2 array, shape: ', &\n              size(arr,1), ' x ', size(arr,2)\n        print '(a,f6.2)', '  First element: ', arr(1,1)\n      rank default\n        print '(a,i0)', '  Higher rank array, rank: ', rank(arr)\n    end select\n  end subroutine print_rank\n\nend program demo_select_rank\n```\nResults:\n```text\nTesting scalar:\n  Scalar value:   3.14\nTesting rank-1 array:\n  Rank-1 array, size: 5\n  Elements:   1.00   2.00   3.00   4.00   5.00\nTesting rank-2 array:\n  Rank-2 array, shape: 2 x 3\n  First element:   1.00\nTesting rank-3 array:\n  Higher rank array, rank: 3\n```\n\n### **Standard**\n\nFortran 2018\n\n### **See Also**\n\n[**select_type**(3)](#select_type),\n[**select_case**(3)](#select_case),\n[**rank**(3)](#rank),\n[**assumed_rank**(3)](#assumed_rank)"
  },
  "Stream I/O Open": {
    "prefix": [
      "streamopen",
      "STREAMOPEN",
      "binaryopen",
      "BINARYOPEN"
    ],
    "body": [
      "open(newunit=${1:unit}, file='${2:filename}', access='stream', &",
      "     form='unformatted', status='${3|unknown,old,new,replace|}', iostat=${4:ierr})",
      "if (${4:ierr} /= 0) error stop 'Failed to open stream file: ${2:filename}'"
    ],
    "description": "OPEN(NEWUNIT,FILE,ACCESS='stream',FORM,STATUS,IOSTAT) opens a file for stream (binary) I/O with error handling.",
    "documentation": {
      "name": "**stream_io_open** - [IO:FILE] Open a file for stream (binary) I/O access",
      "synopsis": {
        "usage": "open(newunit=unit, file='filename', access='stream', form='unformatted', status='unknown', iostat=ierr)",
        "interface": [
          "open(newunit=unit, file=filename, access=access_mode, &",
          "     form=form_mode, status=status_mode, iostat=iostat_var)",
          "",
          "integer, intent(out)          :: unit        ! Unit number assigned",
          "character(len=*), intent(in)  :: filename    ! File path to open",
          "character(len=*), intent(in)  :: access_mode ! 'stream' for binary access",
          "character(len=*), intent(in)  :: form_mode   ! 'unformatted' for binary",
          "character(len=*), intent(in)  :: status_mode ! 'unknown', 'old', 'new', 'replace'",
          "integer, intent(out)          :: iostat_var  ! Error status (0 = success)"
        ]
      },
      "characteristics": [
        "**unit** is an integer variable that receives the automatically assigned unit number (newunit)",
        "**filename** is a character expression specifying the file path",
        "**access** is set to 'stream' for byte-addressable I/O without record structure",
        "**form** is set to 'unformatted' for binary (non-text) data transfer",
        "**status** determines file creation behavior: 'unknown' (open or create), 'old' (must exist), 'new' (must not exist), 'replace' (overwrite if exists)",
        "**iostat** receives 0 on success, a positive error code on failure"
      ],
      "description": "**stream_io_open** opens a file for stream I/O, which provides direct byte-addressable access without the record structure of traditional Fortran sequential or direct-access files. Stream I/O is ideal for reading/writing binary files in formats compatible with C programs or other languages, as it does not add record markers. The newunit specifier automatically assigns an available unit number, avoiding conflicts with hardcoded unit numbers.",
      "options": {
        "newunit": "Automatically assigns an available unit number to the specified integer variable. This is preferred over hardcoded unit numbers to avoid conflicts.",
        "file": "The path to the file to open. Can be an absolute or relative path.",
        "access='stream'": "Enables stream I/O mode where the file is treated as a sequence of bytes without record structure. Positions are measured in file storage units (typically bytes).",
        "form='unformatted'": "Specifies binary (unformatted) data transfer. Combined with stream access, this allows reading/writing raw binary data.",
        "status": "'unknown' - open existing or create new; 'old' - file must exist; 'new' - file must not exist; 'replace' - delete existing and create new.",
        "iostat": "Integer variable receiving the I/O status. Zero indicates success; positive values indicate errors. Always check this value for robust code."
      },
      "examples": {
        "code": [
          "program demo_stream_io_open",
          "implicit none",
          "  integer :: unit, ierr",
          "  real(8) :: data_out(100), data_in(100)",
          "  integer :: i",
          "",
          "  ! Initialize test data",
          "  data_out = [(real(i, 8), i = 1, 100)]",
          "",
          "  ! Write binary data to file",
          "  open(newunit=unit, file='test_stream.bin', access='stream', &",
          "       form='unformatted', status='replace', iostat=ierr)",
          "  if (ierr /= 0) error stop 'Failed to open file for writing'",
          "",
          "  write(unit) data_out",
          "  close(unit)",
          "",
          "  ! Read binary data back from file",
          "  open(newunit=unit, file='test_stream.bin', access='stream', &",
          "       form='unformatted', status='old', iostat=ierr)",
          "  if (ierr /= 0) error stop 'Failed to open file for reading'",
          "",
          "  read(unit) data_in",
          "  close(unit)",
          "",
          "  ! Verify data integrity",
          "  if (all(data_in == data_out)) then",
          "    print *, 'SUCCESS: Data read matches data written'",
          "    print *, 'First 5 values:', data_in(1:5)",
          "    print *, 'Last 5 values:', data_in(96:100)",
          "  else",
          "    print *, 'ERROR: Data mismatch'",
          "  end if",
          "",
          "end program demo_stream_io_open"
        ],
        "result": [
          " SUCCESS: Data read matches data written",
          " First 5 values:   1.0000000000000000   2.0000000000000000   3.0000000000000000   4.0000000000000000   5.0000000000000000",
          " Last 5 values:   96.000000000000000   97.000000000000000   98.000000000000000   99.000000000000000   100.00000000000000"
        ]
      },
      "standard": "Fortran 2003",
      "see_also": [
        "**close**(3)",
        "**read**(3)",
        "**write**(3)",
        "**inquire**(3)",
        "**flush**(3)"
      ]
    }
  },
  "Stream Read": {
    "prefix": [
      "streamread",
      "STREAMREAD",
      "stream_read"
    ],
    "body": "read(${1:unit}) ${0:var}",
    "description": "READ(UNIT) VAR reads data from a file connected for stream access."
  },
  "Stream Write": {
    "prefix": [
      "streamwrite",
      "STREAMWRITE"
    ],
    "body": "write(${1:unit}) ${2:var}",
    "description": "WRITE(UNIT) VAR writes data to a file connected for stream access without record delimiters.",
    "documentation": "## stream_write\n\n### **Name**\n\n**stream_write** - \\[IO:OUTPUT\\] Write data to a stream-access file\n\n### **Synopsis**\n```fortran\n    write(unit) var\n```\n```fortran\n     write(unit, iostat=ios, iomsg=msg) var1, var2, ...\n\n      integer, intent(in)              :: unit\n      integer, intent(out), optional   :: ios\n      character(*), intent(inout), optional :: msg\n      type(*)                          :: var1, var2, ...\n```\n\n### **Characteristics**\n\n - **unit** is a scalar integer expression representing a connected file unit.\n - **var** can be any intrinsic or derived type that is permitted for unformatted I/O.\n - The file must be connected for stream access (ACCESS='STREAM').\n - Data is written without record delimiters at the current file position.\n - The file position advances by the number of file storage units written.\n\n### **Description**\n\n **stream_write** writes data to a file that has been opened with stream access. Unlike sequential or direct access, stream access treats the file as a continuous sequence of file storage units (typically bytes) without any record structure. Data is written starting at the current file position, which can be queried or set using the POS= specifier in the INQUIRE or READ/WRITE statements.\n\n Stream access is particularly useful for:\n - Binary file I/O where exact byte-level control is needed\n - Interfacing with files created by C programs or other languages\n - Reading/writing files without Fortran record markers\n - Random access to arbitrary positions within a file\n\n### **Options**\n\n- **unit**\n  : An integer expression specifying the logical unit number. The unit must be connected to a file opened with ACCESS='STREAM'. Valid unit numbers are processor-dependent but typically range from 0 to a large positive integer.\n\n- **var**\n  : The variable or expression to be written. Can be a scalar, array, or derived type. For derived types, all components must be permitted for unformatted I/O (no pointer or allocatable components unless using Fortran 2003+ features).\n\n- **iostat** (optional)\n  : An integer variable that receives a status value. Zero indicates success, a positive value indicates an error, and a negative value indicates an end-of-file condition.\n\n- **iomsg** (optional)\n  : A character variable that receives an explanatory message if an error occurs.\n\n- **pos** (optional)\n  : An integer expression specifying the file position (in file storage units) at which to write. Position 1 is the beginning of the file.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_stream_write\nimplicit none\n  integer :: unit_num, ios, i\n  real    :: data(5) = [1.0, 2.0, 3.0, 4.0, 5.0]\n  integer :: header = 12345\n  character(len=100) :: msg\n\n  ! Open a file for stream access\n  open(newunit=unit_num, file='stream_data.bin', &\n       access='stream', form='unformatted', &\n       status='replace', iostat=ios, iomsg=msg)\n\n  if (ios /= 0) then\n    print *, 'Error opening file: ', trim(msg)\n    stop 1\n  end if\n\n  ! Write a header value\n  write(unit_num) header\n  print *, 'Wrote header:', header\n\n  ! Write array data\n  write(unit_num) data\n  print *, 'Wrote data array:', data\n\n  ! Write individual values with error checking\n  do i = 1, 3\n    write(unit_num, iostat=ios, iomsg=msg) real(i * 10)\n    if (ios /= 0) then\n      print *, 'Write error: ', trim(msg)\n      exit\n    end if\n  end do\n  print *, 'Wrote 3 additional values'\n\n  ! Close the file\n  close(unit_num)\n  print *, 'File closed successfully'\n\n  ! Verify by reading back\n  call verify_file()\n\ncontains\n\n  subroutine verify_file()\n    integer :: u, h, stat\n    real    :: d(5), extra(3)\n\n    open(newunit=u, file='stream_data.bin', &\n         access='stream', form='unformatted', &\n         status='old')\n\n    read(u) h\n    read(u) d\n    read(u) extra\n\n    print *, 'Verification - Header:', h\n    print *, 'Verification - Data:', d\n    print *, 'Verification - Extra:', extra\n\n    close(u, status='delete')\n  end subroutine verify_file\n\nend program demo_stream_write\n```\nResults:\n```text\n Wrote header:       12345\n Wrote data array:   1.00000000       2.00000000       3.00000000       4.00000000       5.00000000\n Wrote 3 additional values\n File closed successfully\n Verification - Header:       12345\n Verification - Data:   1.00000000       2.00000000       3.00000000       4.00000000       5.00000000\n Verification - Extra:   10.0000000       20.0000000       30.0000000\n```\n\n### **Standard**\n\nFortran 2003\n\n### **See Also**\n\n[**stream_read**(3)](#stream_read),\n[**open**(3)](#open),\n[**write**(3)](#write),\n[**inquire**(3)](#inquire)"
  },
  "Sync All": {
    "prefix": [
      "sync all",
      "SYNC ALL",
      "syncall",
      "SYNCALL"
    ],
    "body": "sync all",
    "description": "SYNC ALL synchronizes all images in the current team, providing a global barrier for coarray programs.\n\n## sync_all\n\n### **Name**\n\n**sync_all** - \\[PARALLEL:COARRAY\\] Synchronize all images in the current team\n\n### **Synopsis**\n```fortran\n    sync all [stat=stat_variable] [errmsg=errmsg_variable]\n```\n```fortran\n     sync all [sync-stat-list]\n\n      integer, intent(out), optional :: stat_variable\n      character(*), intent(inout), optional :: errmsg_variable\n```\n\n### **Characteristics**\n\n - **stat_variable** is a scalar integer variable that receives the synchronization status.\n - **errmsg_variable** is a scalar default character variable that receives an error message if an error occurs.\n - This is an image control statement that affects execution ordering.\n - All images in the current team participate in the synchronization.\n\n### **Description**\n\n **sync all** provides a global synchronization barrier for all images in the\n current team. When an image executes SYNC ALL, it waits until all other\n images in the team have also reached a SYNC ALL statement. This ensures\n that all images have completed their preceding operations before any\n image proceeds past the barrier.\n\n The synchronization establishes a segment boundary. All operations that\n precede SYNC ALL on any image are ordered before all operations that\n follow SYNC ALL on any image in the team.\n\n### **Options**\n\n- **stat=stat_variable**\n  : Optional. If present, receives a status value upon completion.\n  A value of zero indicates successful synchronization. A nonzero value\n  indicates an error occurred, such as a stopped or failed image.\n  The constant STAT_STOPPED_IMAGE or STAT_FAILED_IMAGE from ISO_FORTRAN_ENV\n  may be returned.\n\n- **errmsg=errmsg_variable**\n  : Optional. If present and an error occurs, receives an explanatory\n  message describing the error condition. The variable is assigned only\n  if stat_variable is also present and receives a nonzero value.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_sync_all\n  use iso_fortran_env, only: int64\n  implicit none\n  integer :: me, num_images\n  real, allocatable :: local_data(:)[:]  ! Coarray\n  real :: global_sum\n  integer :: i, stat\n  character(len=100) :: errmsg\n\n  me = this_image()\n  num_images = num_images()\n\n  ! Allocate coarray on all images\n  allocate(local_data(100)[*])\n\n  ! Each image initializes its own data\n  local_data = real(me)\n\n  ! Synchronize to ensure all images have initialized their data\n  sync all\n\n  ! Now safe to access data from other images\n  if (me == 1) then\n    global_sum = 0.0\n    do i = 1, num_images\n      global_sum = global_sum + local_data(1)[i]\n    end do\n    print '(A,F10.2)', 'Sum of first elements from all images: ', global_sum\n  end if\n\n  ! Synchronize before cleanup\n  sync all\n\n  ! Example with error handling\n  sync all (stat=stat, errmsg=errmsg)\n  if (stat /= 0) then\n    print '(A,I0,A,A)', 'Image ', me, ' sync error: ', trim(errmsg)\n  end if\n\n  deallocate(local_data)\n\nend program demo_sync_all\n```\nResults (with 4 images):\n```text\n    Sum of first elements from all images:      10.00\n```\n\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\n[**sync_images**(3)](#sync_images),\n[**sync_memory**(3)](#sync_memory),\n[**sync_team**(3)](#sync_team),\n[**this_image**(3)](#this_image),\n[**num_images**(3)](#num_images),\n[**co_sum**(3)](#co_sum),\n[**co_broadcast**(3)](#co_broadcast)"
  },
  "System Clock": {
    "prefix": [
      "sysclock",
      "SYSCLOCK",
      "systemclock",
      "SYSTEMCLOCK",
      "system_clock",
      "SYSTEM_CLOCK",
      "walltime"
    ],
    "body": [
      "call system_clock(count=${1:count}, count_rate=${2:rate}, count_max=${3:max})"
    ],
    "description": "SYSTEM_CLOCK(COUNT=count,COUNT_RATE=count_rate,COUNT_MAX=count_max) returns processor clock information for wall clock timing."
  },
  "Type Constructor": {
    "prefix": [
      "constructor",
      "CONSTRUCTOR",
      "typeconstructor",
      "TYPECONSTRUCTOR"
    ],
    "body": [
      "type :: ${1:type_name}",
      "\t${2:! Type components}",
      "\t${3:integer} :: ${4:component}",
      "contains",
      "\tprocedure :: ${5:init} => ${1}_init",
      "end type ${1}",
      "",
      "interface ${1}",
      "\tmodule procedure ${1}_constructor",
      "end interface ${1}",
      "",
      "contains",
      "",
      "function ${1}_constructor(${6:args}) result(self)",
      "\t${7:integer}, intent(in) :: ${6}",
      "\ttype(${1}) :: self",
      "\tself%${4} = ${6}",
      "end function ${1}_constructor"
    ],
    "description": "TYPE_CONSTRUCTOR(ARGS) creates a generic interface that overloads the type name to act as a constructor function."
  },
  "Type Destructor": {
    "prefix": [
      "destructor",
      "DESTRUCTOR",
      "typedestructor",
      "TYPEDESTRUCTOR",
      "finalize"
    ],
    "body": [
      "subroutine ${1:type_name}_destructor(self)",
      "\ttype(${1:type_name}), intent(inout) :: self",
      "\t",
      "\tif (allocated(self%${2:component})) then",
      "\t\tdeallocate(self%${2:component})",
      "\tend if",
      "\t$0",
      "end subroutine ${1:type_name}_destructor"
    ],
    "description": "## type_destructor\n\n### **Name**\n\n**type_destructor** - \\[STRUCTURE:TYPE\\] Subroutine for derived type cleanup and resource deallocation\n\n### **Synopsis**\n```fortran\n    call type_name_destructor(self)\n```\n```fortran\n     subroutine type_name_destructor(self)\n\n      type(type_name), intent(inout) :: self\n```\n\n### **Characteristics**\n\n - **self** is a derived type instance to be cleaned up.\n - The subroutine deallocates allocatable components to prevent memory leaks.\n - Can be bound to the type as a FINAL procedure for automatic cleanup.\n - Intent(inout) allows modification of the object during cleanup.\n\n### **Description**\n\n **type_destructor** performs cleanup operations on a derived type instance,\n deallocating any allocatable components and releasing resources. When bound\n as a FINAL procedure, it is automatically called when the object goes out\n of scope or is explicitly deallocated.\n\n### **Options**\n\n- **self**\n  : The derived type instance to be destroyed. All allocatable components\n  will be deallocated. The object should not be used after destruction\n  unless reinitialized.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_type_destructor\nimplicit none\n\n  type :: container\n    integer, allocatable :: data(:)\n    character(len=:), allocatable :: name\n  contains\n    final :: container_destructor\n  end type container\n\n  type(container) :: obj\n\n  ! Allocate components\n  allocate(obj%data(100))\n  obj%data = 42\n  obj%name = 'test_container'\n\n  print *, 'Data allocated:', allocated(obj%data)\n  print *, 'Name allocated:', allocated(obj%name)\n\n  ! Manual cleanup (or automatic when obj goes out of scope)\n  call container_destructor(obj)\n\n  print *, 'After destructor:'\n  print *, 'Data allocated:', allocated(obj%data)\n  print *, 'Name allocated:', allocated(obj%name)\n\ncontains\n\n  subroutine container_destructor(self)\n    type(container), intent(inout) :: self\n\n    if (allocated(self%data)) then\n      deallocate(self%data)\n    end if\n\n    if (allocated(self%name)) then\n      deallocate(self%name)\n    end if\n\n  end subroutine container_destructor\n\nend program demo_type_destructor\n```\nResults:\n```text\n Data allocated: T\n Name allocated: T\n After destructor:\n Data allocated: F\n Name allocated: F\n```\n\n### **Standard**\n\nFortran 90 (FINAL procedures: Fortran 2003)\n\n### **See Also**\n\n[**type_constructor**(3)](#type_constructor),\n[**allocate**(3)](#allocate),\n[**deallocate**(3)](#deallocate),\n[**derived_type**(3)](#derived_type)"
  },
  "Where Elsewhere": {
    "prefix": [
      "whereelse",
      "WHEREELSE",
      "where_elsewhere"
    ],
    "body": [
      "where (${1:mask})",
      "\t${2:arr} = ${3:value1}",
      "elsewhere",
      "\t${2:arr} = ${4:value2}",
      "end where"
    ],
    "description": "WHERE(MASK)...ELSEWHERE...END WHERE performs masked array assignment with alternative for non-matching elements."
  },
  "Where Elsewhere If": {
    "prefix": [
      "whereelseif",
      "WHEREELSEIF"
    ],
    "body": [
      "where (${1:mask1})",
      "\t${2:arr} = ${3:value1}",
      "elsewhere (${4:mask2})",
      "\t${2:arr} = ${5:value2}",
      "elsewhere",
      "\t${2:arr} = ${6:value3}",
      "end where"
    ],
    "description": "WHERE-ELSEWHERE(mask)-ELSEWHERE - \\[ARRAY:CONSTRUCTION\\] Masked array assignment with multiple conditions.\n\n### **Synopsis**\n```fortran\n    where (mask1)\n      array = value1\n    elsewhere (mask2)\n      array = value2\n    elsewhere\n      array = value3\n    end where\n```\n```fortran\n     where (logical(kind=**), dimension(..))  ! primary mask\n       array = expression1\n     elsewhere (logical(kind=**), dimension(..))  ! secondary mask\n       array = expression2\n     elsewhere  ! default case\n       array = expression3\n     end where\n```\n\n### **Characteristics**\n\n - **mask1** is a logical array expression defining the primary condition.\n - **mask2** is a logical array expression defining the secondary condition.\n - **array** is an array variable that will be assigned values.\n - All masks must be conformable (same shape) with the array.\n - Masks are evaluated in order; each element is assigned by the first matching condition.\n - The final ELSEWHERE without a mask catches all remaining elements.\n\n### **Description**\n\n **where-elsewhere** provides conditional array assignment with multiple masks. Elements of the array are assigned based on the first mask condition that evaluates to .TRUE. for that element. The ELSEWHERE(mask2) clause handles elements where mask1 is .FALSE. but mask2 is .TRUE. The final ELSEWHERE without a mask handles all remaining elements where all previous masks were .FALSE.\n\n### **Options**\n\n- **mask1**\n  : Logical array expression. Elements where mask1 is .TRUE. receive value1.\n\n- **mask2**\n  : Logical array expression. Elements where mask1 is .FALSE. and mask2 is .TRUE. receive value2.\n\n- **array**\n  : The target array variable being assigned. Must be conformable with all masks.\n\n- **value1, value2, value3**\n  : Expressions conformable with array. Assigned to elements based on mask conditions.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_where_elsewhere_if\nimplicit none\n  integer :: i\n  real :: scores(10)\n  character(len=1) :: grades(10)\n  \n  ! Sample test scores\n  scores = [95.0, 82.0, 67.0, 91.0, 55.0, 78.0, 88.0, 42.0, 73.0, 99.0]\n  \n  ! Assign letter grades based on score ranges\n  where (scores >= 90.0)\n    grades = 'A'\n  elsewhere (scores >= 70.0)\n    grades = 'B'\n  elsewhere (scores >= 60.0)\n    grades = 'C'\n  elsewhere\n    grades = 'F'\n  end where\n  \n  ! Display results\n  print '(a)', 'Score  Grade'\n  print '(a)', '-----  -----'\n  do i = 1, 10\n    print '(f5.1, 4x, a1)', scores(i), grades(i)\n  end do\n  \nend program demo_where_elsewhere_if\n```\nResults:\n```text\nScore  Grade\n-----  -----\n 95.0    A\n 82.0    B\n 67.0    C\n 91.0    A\n 55.0    F\n 78.0    B\n 88.0    B\n 42.0    F\n 73.0    B\n 99.0    A\n```\n\n### **Standard**\n\nFortran 90\n\n### **See Also**\n\n[**where**(3)](#where), [**elsewhere**(3)](#elsewhere), [**merge**(3)](#merge), [**pack**(3)](#pack), [**unpack**(3)](#unpack)"
  },
  "Write Formatted": {
    "prefix": [
      "writefmt",
      "WRITEFMT",
      "writef",
      "WRITEF"
    ],
    "body": [
      "write(${1:*}, '(${2:A})') ${0:var}"
    ],
    "description": "WRITE(UNIT,FMT) VAR outputs data to a file or device using formatted output with a format specification."
  },
  "Write Formatted Multiple": {
    "prefix": [
      "writefmtmulti",
      "WRITEFMTMULTI"
    ],
    "body": [
      "write(${1:*}, '(${2:A, I5, F10.3})') ${3:str}, ${4:ivar}, ${0:rvar}"
    ],
    "description": "WRITE(UNIT,'(format)') performs formatted output of multiple variables with mixed types to a specified unit.",
    "documentation": {
      "name": "**write** (formatted multiple) - \\[IO:OUTPUT\\] Write multiple variables with format descriptors",
      "synopsis": {
        "usage": "write(unit, '(format_descriptors)') var1, var2, var3",
        "interface": [
          "write(unit, '(fmt)') output_list",
          "",
          "integer, intent(in)            :: unit    ! Output unit (* for stdout)",
          "character(len=*), intent(in)   :: fmt     ! Format specification",
          "type(*), intent(in)            :: output_list  ! Variables to output"
        ]
      },
      "characteristics": [
        "**unit** is an integer unit number or * for standard output",
        "**format** is a character string containing format descriptors",
        "**output_list** contains one or more variables of any intrinsic type",
        "Format descriptors must match the types of variables in order"
      ],
      "description": "**write** with a format specification outputs multiple variables according to format descriptors. Each variable in the output list is formatted according to the corresponding descriptor in the format string. Common format descriptors include:\n\n- **A** or **Aw** - Character data (w = width)\n- **Iw** or **Iw.m** - Integer (w = width, m = minimum digits)\n- **Fw.d** - Fixed-point real (w = width, d = decimal places)\n- **Ew.d** - Exponential notation real\n- **ESw.d** - Scientific notation real\n- **Gw.d** - General format (auto-selects F or E)\n- **Lw** - Logical values\n- **nX** - Skip n spaces\n- **/** - Start new line\n- **'text'** - Literal text in output",
      "options": [
        {
          "name": "unit",
          "description": "The unit number for output. Use * for standard output (screen), or an integer representing an opened file unit."
        },
        {
          "name": "format",
          "description": "A format specification string enclosed in parentheses within quotes. Contains format descriptors separated by commas that describe how each variable should be formatted."
        },
        {
          "name": "output_list",
          "description": "A comma-separated list of variables, expressions, or array elements to be written. Each item must have a corresponding format descriptor in the format string."
        }
      ],
      "examples": {
        "code": [
          "program demo_write_formatted_multiple",
          "implicit none",
          "  character(len=20) :: name",
          "  integer :: age, year",
          "  real :: salary, bonus",
          "",
          "  ! Initialize variables",
          "  name = 'John Smith'",
          "  age = 35",
          "  year = 2024",
          "  salary = 75000.50",
          "  bonus = 5250.75",
          "",
          "  ! Write string, integer, and real with basic format",
          "  write(*, '(A, I5, F10.2)') 'Age: ', age, salary",
          "",
          "  ! Write with multiple format types and spacing",
          "  write(*, '(A20, I4, 2X, F12.2)') name, age, salary",
          "",
          "  ! Write with descriptive text embedded",
          "  write(*, '(A, A, A, I3, A, F10.2)') 'Employee: ', trim(name), &",
          "          ', Age: ', age, ', Salary: $', salary",
          "",
          "  ! Write multiple reals with same format (repeat count)",
          "  write(*, '(A, 2F12.2)') 'Compensation: ', salary, bonus",
          "",
          "  ! Write integers with minimum digits",
          "  write(*, '(A, I4.4, A, I4)') 'Year: ', year, ' Age: ', age",
          "",
          "end program demo_write_formatted_multiple"
        ],
        "output": [
          "Age:    35  75000.50",
          "          John Smith  35    75000.50",
          "Employee: John Smith, Age:  35, Salary: $  75000.50",
          "Compensation:     75000.50     5250.75",
          "Year: 2024 Age:   35"
        ]
      },
      "standard": "Fortran 77",
      "see_also": [
        "**write**(3) - basic write statement",
        "**print**(3) - formatted print to stdout",
        "**read**(3) - formatted input",
        "**format**(3) - format statement specification"
      ]
    }
  },
  "Write to String": {
    "prefix": [
      "writestr",
      "WRITESTR",
      "writestring",
      "WRITESTRING"
    ],
    "body": [
      "write(${1:str}, '(${2:A,I0})') ${0:values}"
    ],
    "description": "WRITE(unit,format) performs internal write to convert values to a character string."
  }
}